
kernel.elf：     文件格式 elf32-i386


Disassembly of section .text:

c0203000 <get_esp>:
;内核线程模块的汇编函数文件
[bits 32]
[GLOBAL get_esp]
get_esp:
	mov eax,esp
c0203000:	89 e0                	mov    %esp,%eax
	ret
c0203002:	c3                   	ret    

c0203003 <get_eflags>:
[GLOBAL get_eflags]
get_eflags:
	pushf
c0203003:	9c                   	pushf  
	pop eax
c0203004:	58                   	pop    %eax
	ret
c0203005:	c3                   	ret    

c0203006 <switch_to>:
[GLOBAL switch_to]
switch_to:
	;保存上下文
	mov eax,[esp+4]     ;第一个参数 
c0203006:	8b 44 24 04          	mov    0x4(%esp),%eax
	mov [eax],ebp
c020300a:	89 28                	mov    %ebp,(%eax)
	mov [eax+4],ebx
c020300c:	89 58 04             	mov    %ebx,0x4(%eax)
	mov [eax+8],ecx
c020300f:	89 48 08             	mov    %ecx,0x8(%eax)
	mov [eax+12],edx
c0203012:	89 50 0c             	mov    %edx,0xc(%eax)
	mov [eax+16],esi
c0203015:	89 70 10             	mov    %esi,0x10(%eax)
	mov [eax+20],edi
c0203018:	89 78 14             	mov    %edi,0x14(%eax)
	mov [eax+28],esp
c020301b:	89 60 1c             	mov    %esp,0x1c(%eax)
	push ebx
c020301e:	53                   	push   %ebx
	mov ebx,eax
c020301f:	89 c3                	mov    %eax,%ebx
	pushf
c0203021:	9c                   	pushf  
	pop eax
c0203022:	58                   	pop    %eax
	mov [ebx+24],eax
c0203023:	89 43 18             	mov    %eax,0x18(%ebx)
	mov eax,ebx
c0203026:	89 d8                	mov    %ebx,%eax
	pop ebx
c0203028:	5b                   	pop    %ebx

	;加载上下文
	mov eax,[esp+8]      ;第二个参数
c0203029:	8b 44 24 08          	mov    0x8(%esp),%eax
	mov esp,[eax+28]    ;切换了esp    导致ret指令控制流转移
c020302d:	8b 60 1c             	mov    0x1c(%eax),%esp
	mov ebp,[eax]
c0203030:	8b 28                	mov    (%eax),%ebp
	mov ebx,[eax+4]
c0203032:	8b 58 04             	mov    0x4(%eax),%ebx
	mov ecx,[eax+8]
c0203035:	8b 48 08             	mov    0x8(%eax),%ecx
	mov edx,[eax+12]
c0203038:	8b 50 0c             	mov    0xc(%eax),%edx
	mov esi,[eax+16]
c020303b:	8b 70 10             	mov    0x10(%eax),%esi
	mov edi,[eax+20]
c020303e:	8b 78 14             	mov    0x14(%eax),%edi
	add eax,24
c0203041:	83 c0 18             	add    $0x18,%eax
	push dword [eax] ;eflags
c0203044:	ff 30                	pushl  (%eax)
	popf	
c0203046:	9d                   	popf   

	;由于8259a设置的手动模式 所以必须给主片与从片发送信号 否则8259a会暂停
	;这个bug找了一下午才找到 顺便吐槽下 内核级的代码debug太难了(GDB在多线程与汇编级会失效 只有print调试法) 
	mov al,0x20         
c0203047:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c0203049:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c020304b:	e6 20                	out    %al,$0x20
	
c020304d:	c3                   	ret    
c020304e:	66 90                	xchg   %ax,%ax

c0203050 <asm_change_esp>:

[bits 32]
[GLOBAL asm_change_esp]
[GLOBAL asm_active_page_dir_table]
asm_change_esp:
    ret
c0203050:	c3                   	ret    

c0203051 <asm_active_page_dir_table>:
asm_active_page_dir_table:
c0203051:	c3                   	ret    
c0203052:	66 90                	xchg   %ax,%ax
c0203054:	66 90                	xchg   %ax,%ax
c0203056:	66 90                	xchg   %ax,%ax
c0203058:	66 90                	xchg   %ax,%ax
c020305a:	66 90                	xchg   %ax,%ax
c020305c:	66 90                	xchg   %ax,%ax
c020305e:	66 90                	xchg   %ax,%ax

c0203060 <pre_handle>:
%endmacro

;这个中断流程是内核与用户共用的
[EXTERN int_func_route]
pre_handle:
	pushad               ;压入八个32位
c0203060:	60                   	pusha  
	mov ecx,[ss:esp+32]
c0203061:	36 8b 4c 24 20       	mov    %ss:0x20(%esp),%ecx
	;mov ebx,eax
	mov ax,es          ;进入时ss已经被切换了
c0203066:	66 8c c0             	mov    %es,%ax
	and eax,0x0000FFFF
c0203069:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c020306e:	50                   	push   %eax
	mov ax,fs          
c020306f:	66 8c e0             	mov    %fs,%ax
	and eax,0x0000FFFF
c0203072:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c0203077:	50                   	push   %eax
	mov ax,gs
c0203078:	66 8c e8             	mov    %gs,%ax
	and eax,0x0000FFFF
c020307b:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c0203080:	50                   	push   %eax
;切换回内核的中断相关段寄存器  cs与ss不用管 在中断时已经被cpu自动从tss中切换
	mov ax,KERN_DATA_SELECTOR    ;不包含ss
c0203081:	66 b8 10 00          	mov    $0x10,%ax
	mov es,ax
c0203085:	8e c0                	mov    %eax,%es
	mov fs,ax
c0203087:	8e e0                	mov    %eax,%fs
	mov ax,KERN_VGA_SELECTOR
c0203089:	66 b8 18 00          	mov    $0x18,%ax
	mov gs,ax
c020308d:	8e e8                	mov    %eax,%gs
	push ebx     ;传入void *
c020308f:	53                   	push   %ebx
	push ecx     ;传入int类型中断号
c0203090:	51                   	push   %ecx
;                              	es（扩展为32位）
;                               fs（扩展为32位）
;                               gs（扩展为32位）
;                               中断参数
; low addr            中断号
	call int_func_route
c0203091:	e8 d2 31 00 00       	call   c0206268 <int_func_route>
;以下部分为中断退出结构
;C遵循函数调用者处理函数压入参数问题 所以使用add esp,8去除压入的两个参数（intr   AND    args）
;使用函数handle_int_exit_stack的开始位置
	add esp,8
c0203096:	83 c4 08             	add    $0x8,%esp
	pop eax
c0203099:	58                   	pop    %eax
	mov gs,ax
c020309a:	8e e8                	mov    %eax,%gs
	pop eax
c020309c:	58                   	pop    %eax
	mov fs,ax
c020309d:	8e e0                	mov    %eax,%fs
	pop eax
c020309f:	58                   	pop    %eax
	mov es,ax
c02030a0:	8e c0                	mov    %eax,%es
	popad
c02030a2:	61                   	popa   
	add esp,8
c02030a3:	83 c4 08             	add    $0x8,%esp
	mov al,0x20
c02030a6:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02030a8:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02030aa:	e6 20                	out    %al,$0x20
;此处的al是否需要保存？
	iret
c02030ac:	cf                   	iret   

c02030ad <isr0>:


NO_ERROCODE 0
c02030ad:	6a 00                	push   $0x0
c02030af:	6a 00                	push   $0x0
c02030b1:	eb ad                	jmp    c0203060 <pre_handle>

c02030b3 <isr1>:
NO_ERROCODE 1
c02030b3:	6a 00                	push   $0x0
c02030b5:	6a 01                	push   $0x1
c02030b7:	eb a7                	jmp    c0203060 <pre_handle>

c02030b9 <isr2>:
NO_ERROCODE 2
c02030b9:	6a 00                	push   $0x0
c02030bb:	6a 02                	push   $0x2
c02030bd:	eb a1                	jmp    c0203060 <pre_handle>

c02030bf <isr3>:
NO_ERROCODE 3
c02030bf:	6a 00                	push   $0x0
c02030c1:	6a 03                	push   $0x3
c02030c3:	eb 9b                	jmp    c0203060 <pre_handle>

c02030c5 <isr4>:
NO_ERROCODE 4
c02030c5:	6a 00                	push   $0x0
c02030c7:	6a 04                	push   $0x4
c02030c9:	eb 95                	jmp    c0203060 <pre_handle>

c02030cb <isr5>:
NO_ERROCODE 5
c02030cb:	6a 00                	push   $0x0
c02030cd:	6a 05                	push   $0x5
c02030cf:	eb 8f                	jmp    c0203060 <pre_handle>

c02030d1 <isr6>:
NO_ERROCODE 6
c02030d1:	6a 00                	push   $0x0
c02030d3:	6a 06                	push   $0x6
c02030d5:	eb 89                	jmp    c0203060 <pre_handle>

c02030d7 <isr7>:
NO_ERROCODE 7
c02030d7:	6a 00                	push   $0x0
c02030d9:	6a 07                	push   $0x7
c02030db:	eb 83                	jmp    c0203060 <pre_handle>

c02030dd <isr8>:
HAVE_ERROCODE 8
c02030dd:	90                   	nop
c02030de:	6a 08                	push   $0x8
c02030e0:	e9 7b ff ff ff       	jmp    c0203060 <pre_handle>

c02030e5 <isr9>:
NO_ERROCODE 9
c02030e5:	6a 00                	push   $0x0
c02030e7:	6a 09                	push   $0x9
c02030e9:	e9 72 ff ff ff       	jmp    c0203060 <pre_handle>

c02030ee <isr10>:
HAVE_ERROCODE 10
c02030ee:	90                   	nop
c02030ef:	6a 0a                	push   $0xa
c02030f1:	e9 6a ff ff ff       	jmp    c0203060 <pre_handle>

c02030f6 <isr11>:
HAVE_ERROCODE 11
c02030f6:	90                   	nop
c02030f7:	6a 0b                	push   $0xb
c02030f9:	e9 62 ff ff ff       	jmp    c0203060 <pre_handle>

c02030fe <isr12>:
HAVE_ERROCODE 12 
c02030fe:	90                   	nop
c02030ff:	6a 0c                	push   $0xc
c0203101:	e9 5a ff ff ff       	jmp    c0203060 <pre_handle>

c0203106 <isr13>:
HAVE_ERROCODE 13 
c0203106:	90                   	nop
c0203107:	6a 0d                	push   $0xd
c0203109:	e9 52 ff ff ff       	jmp    c0203060 <pre_handle>

c020310e <isr14>:
HAVE_ERROCODE 14
c020310e:	90                   	nop
c020310f:	6a 0e                	push   $0xe
c0203111:	e9 4a ff ff ff       	jmp    c0203060 <pre_handle>

c0203116 <isr15>:
NO_ERROCODE 15
c0203116:	6a 00                	push   $0x0
c0203118:	6a 0f                	push   $0xf
c020311a:	e9 41 ff ff ff       	jmp    c0203060 <pre_handle>

c020311f <isr16>:
NO_ERROCODE 16
c020311f:	6a 00                	push   $0x0
c0203121:	6a 10                	push   $0x10
c0203123:	e9 38 ff ff ff       	jmp    c0203060 <pre_handle>

c0203128 <isr17>:
HAVE_ERROCODE 17
c0203128:	90                   	nop
c0203129:	6a 11                	push   $0x11
c020312b:	e9 30 ff ff ff       	jmp    c0203060 <pre_handle>

c0203130 <isr18>:
NO_ERROCODE 18
c0203130:	6a 00                	push   $0x0
c0203132:	6a 12                	push   $0x12
c0203134:	e9 27 ff ff ff       	jmp    c0203060 <pre_handle>

c0203139 <isr19>:
NO_ERROCODE 19
c0203139:	6a 00                	push   $0x0
c020313b:	6a 13                	push   $0x13
c020313d:	e9 1e ff ff ff       	jmp    c0203060 <pre_handle>

c0203142 <isr20>:

NO_ERROCODE 20
c0203142:	6a 00                	push   $0x0
c0203144:	6a 14                	push   $0x14
c0203146:	e9 15 ff ff ff       	jmp    c0203060 <pre_handle>

c020314b <isr21>:
NO_ERROCODE 21
c020314b:	6a 00                	push   $0x0
c020314d:	6a 15                	push   $0x15
c020314f:	e9 0c ff ff ff       	jmp    c0203060 <pre_handle>

c0203154 <isr22>:
NO_ERROCODE 22
c0203154:	6a 00                	push   $0x0
c0203156:	6a 16                	push   $0x16
c0203158:	e9 03 ff ff ff       	jmp    c0203060 <pre_handle>

c020315d <isr23>:
NO_ERROCODE 23
c020315d:	6a 00                	push   $0x0
c020315f:	6a 17                	push   $0x17
c0203161:	e9 fa fe ff ff       	jmp    c0203060 <pre_handle>

c0203166 <isr24>:
NO_ERROCODE 24
c0203166:	6a 00                	push   $0x0
c0203168:	6a 18                	push   $0x18
c020316a:	e9 f1 fe ff ff       	jmp    c0203060 <pre_handle>

c020316f <isr25>:
NO_ERROCODE 25
c020316f:	6a 00                	push   $0x0
c0203171:	6a 19                	push   $0x19
c0203173:	e9 e8 fe ff ff       	jmp    c0203060 <pre_handle>

c0203178 <isr26>:
NO_ERROCODE 26
c0203178:	6a 00                	push   $0x0
c020317a:	6a 1a                	push   $0x1a
c020317c:	e9 df fe ff ff       	jmp    c0203060 <pre_handle>

c0203181 <isr27>:
NO_ERROCODE 27
c0203181:	6a 00                	push   $0x0
c0203183:	6a 1b                	push   $0x1b
c0203185:	e9 d6 fe ff ff       	jmp    c0203060 <pre_handle>

c020318a <isr28>:
NO_ERROCODE 28
c020318a:	6a 00                	push   $0x0
c020318c:	6a 1c                	push   $0x1c
c020318e:	e9 cd fe ff ff       	jmp    c0203060 <pre_handle>

c0203193 <isr29>:
NO_ERROCODE 29
c0203193:	6a 00                	push   $0x0
c0203195:	6a 1d                	push   $0x1d
c0203197:	e9 c4 fe ff ff       	jmp    c0203060 <pre_handle>

c020319c <isr30>:
NO_ERROCODE 30
c020319c:	6a 00                	push   $0x0
c020319e:	6a 1e                	push   $0x1e
c02031a0:	e9 bb fe ff ff       	jmp    c0203060 <pre_handle>

c02031a5 <isr31>:
NO_ERROCODE 31
c02031a5:	6a 00                	push   $0x0
c02031a7:	6a 1f                	push   $0x1f
c02031a9:	e9 b2 fe ff ff       	jmp    c0203060 <pre_handle>

c02031ae <isr32>:
NO_ERROCODE 32
c02031ae:	6a 00                	push   $0x0
c02031b0:	6a 20                	push   $0x20
c02031b2:	e9 a9 fe ff ff       	jmp    c0203060 <pre_handle>

c02031b7 <load_idt>:


[GLOBAL load_idt]
load_idt:
	mov eax, [esp+4]  ; 参数存入 eax 寄存器
c02031b7:	8b 44 24 04          	mov    0x4(%esp),%eax
    lidt [eax]        ; 加载到 IDTR
c02031bb:	0f 01 18             	lidtl  (%eax)
    ret
c02031be:	c3                   	ret    

c02031bf <get_cr2>:

[GLOBAL get_cr2]
[GLOBAL _CR2]
get_cr2:
	mov eax,cr2
c02031bf:	0f 20 d0             	mov    %cr2,%eax
	mov [_CR2],eax
c02031c2:	a3 c8 31 20 c0       	mov    %eax,0xc02031c8
	ret
c02031c7:	c3                   	ret    

c02031c8 <_CR2>:
_CR2:
c02031c8:	00 00                	add    %al,(%eax)
c02031ca:	00 00                	add    %al,(%eax)
c02031cc:	66 90                	xchg   %ax,%ax
c02031ce:	66 90                	xchg   %ax,%ax

c02031d0 <reload_gdt>:
[GLOBAL exit_int]
[GLOBAL reload_kern_page_table]
;------------------------------------------------

reload_gdt:
    lgdt [gdt_ptr]
c02031d0:	0f 01 15 48 32 20 c0 	lgdtl  0xc0203248
    ret
c02031d7:	c3                   	ret    

c02031d8 <reload_kern_page_table>:

;parame1   pdt_paddr
;origin format:    void reload_kern_page_table(uint32_t pdt_paddr)
reload_kern_page_table:
    ;get parame 1 from [esp+4]
    mov eax,[esp+4]
c02031d8:	8b 44 24 04          	mov    0x4(%esp),%eax
    and eax,0xFFFFF000
c02031dc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    ;relaod cr3
    mov cr3,eax
c02031e1:	0f 22 d8             	mov    %eax,%cr3
    ret
c02031e4:	c3                   	ret    

c02031e5 <exit_int>:

;参数1   esp的值
;C语言原型     void *  exit_int(void* esp)     esp必须是栈指针（地址）
exit_int:
    mov eax,[esp+4]
c02031e5:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov esp,eax       ;修改栈位置
c02031e9:	89 c4                	mov    %eax,%esp
    ;以下部分是模拟中断中的执行返回(见interrupt_asm.s)

    add esp,8
c02031eb:	83 c4 08             	add    $0x8,%esp
	pop eax
c02031ee:	58                   	pop    %eax
	mov gs,ax
c02031ef:	8e e8                	mov    %eax,%gs
	pop eax
c02031f1:	58                   	pop    %eax
	mov fs,ax
c02031f2:	8e e0                	mov    %eax,%fs
	pop eax
c02031f4:	58                   	pop    %eax
	mov es,ax
c02031f5:	8e c0                	mov    %eax,%es
	popad
c02031f7:	61                   	popa   
	add esp,8
c02031f8:	83 c4 08             	add    $0x8,%esp
;由于start_user_task函数执行时一定是因为时钟中断的线程调度  调度完成以后就已经打开了中断并且设置了8259A   
;执行到此步时无需再次打开8259A   
	;mov al,0x20
	;out 0xA0,al
	;out 0x20,al
	iret
c02031fb:	cf                   	iret   
c02031fc:	66 90                	xchg   %ax,%ax
c02031fe:	66 90                	xchg   %ax,%ax

c0203200 <GDT_BASE>:
	...

c0203208 <CODE_DESC>:
[GLOBAL gdt_ptr]
; GDT安装位置
   GDT_BASE:   dd    0x00000000 
           	   dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
c0203208:	ff ff 00 00 00 98 cf 00                             ........

c0203210 <DATA_STACK_DESC>:
               dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
c0203210:	ff ff 00 00 00 92 cf 00                             ........

c0203218 <VIDEO_DESC>:
                     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007        ; limit=(0xbffff-0xb8000)/4k=0x7
c0203218:	07 00 00 80 0b 92 c0 00                             ........

c0203220 <USER_CODE_DESC>:
               dd    DESC_VIDEO_HIGH4  ; 此时dpl为0

    ;---------新增段描述符-----------
    ;用户代码段与数据段
    USER_CODE_DESC: dd 0x0000FFFF
c0203220:	ff ff 00 00 00 f8 cf 00                             ........

c0203228 <USER_DATA_DESC>:
                dd   DESC_USER_CODE_HIGH4

    USER_DATA_DESC: dd 0x0000FFFF
c0203228:	ff ff 00 00 00 f2 cf 00                             ........

c0203230 <TSS_CPU0>:
	...

c0203238 <SELECTOR_CODE_MEM>:
   SELECTOR_USER_CODE equ (0x0004<<3) + TI_GDT + RPL3
   SELECTOR_USER_DATA equ (0x0005<<3) + TI_GDT + RPL3
   SELECTOR_TSS_CPU0 equ (0x0006<<3) + TI_GDT +RPL0
   

   SELECTOR_CODE_MEM dw SELECTOR_CODE
c0203238:	08 00                	or     %al,(%eax)

c020323a <SELECTOR_DATA_MEM>:
   SELECTOR_DATA_MEM dw SELECTOR_DATA
c020323a:	10 00                	adc    %al,(%eax)

c020323c <SELECTOR_VIDEO_MEM>:
   SELECTOR_VIDEO_MEM dw SELECTOR_VIDEO
c020323c:	18 00                	sbb    %al,(%eax)

c020323e <SELECTOR_USER_CODE_MEM>:
   SELECTOR_USER_CODE_MEM dw SELECTOR_USER_CODE
c020323e:	23 00                	and    (%eax),%eax

c0203240 <SELECTOR_USER_DATA_MEM>:
   SELECTOR_USER_DATA_MEM dw SELECTOR_USER_DATA
c0203240:	2b 00                	sub    (%eax),%eax

c0203242 <SELECTOR_TSS_CPU0_MEM>:
   SELECTOR_TSS_CPU0_MEM dw SELECTOR_TSS_CPU0
c0203242:	30 00                	xor    %al,(%eax)

c0203244 <total_mem_bytes>:
   


   total_mem_bytes dd 0                  
c0203244:	00 00 00 00                                         ....

c0203248 <gdt_ptr>:
   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址
   gdt_ptr  dw  GDT_LIMIT 
c0203248:	37                   	aaa    
c0203249:	00 00                	add    %al,(%eax)
        	dd  GDT_BASE
c020324b:	32 20                	xor    (%eax),%ah
c020324d:	c0                   	.byte 0xc0

c020324e <boot_start_after_set_paging>:
;boot开始！
boot_start_after_set_paging:        ;此处修改了函数名     在设置好页表后调用此函数
    mov ebx,[temp_mboot_ptr]     ;此处将暂存的mboot信息取出    但是一定要注意：必须要前4MB的物理-虚拟内存映射才能够使用
c020324e:	8b 1d 0c 00 10 00    	mov    0x10000c,%ebx
    mov [mboot_ptr], ebx ; GRUB加载内核后会将mutiboot信息地址存放在ebx中
c0203254:	89 1d 10 80 20 c0    	mov    %ebx,0xc0208010
    ;-----------------   准备进入保护模式   -------------------
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1
   ;-----------------  打开A20  ----------------
    in al,0x92
c020325a:	e4 92                	in     $0x92,%al
    or al,0000_0010B
c020325c:	0c 02                	or     $0x2,%al
    out 0x92,al
c020325e:	e6 92                	out    %al,$0x92
   ;-----------------  加载GDT  ----------------
   ; 注意：lgdt装载的低32位是线性地址（逻辑地址----》线性地址------》物理地址）
   ; 所有的段的实际偏移都是0    故线性地址等效于逻辑地址   即虚拟地址    所以此处gdt_ptr内容中低32位实际上是GDT的虚拟地址   
    lgdt [gdt_ptr]
c0203260:	0f 01 15 48 32 20 c0 	lgdtl  0xc0203248
   ;-----------------  cr0第0位置1  ----------------
    mov eax, cr0
c0203267:	0f 20 c0             	mov    %cr0,%eax
    or eax, 0x00000001
c020326a:	83 c8 01             	or     $0x1,%eax
    mov cr0, eax
c020326d:	0f 22 c0             	mov    %eax,%cr0
    jmp dword SELECTOR_CODE:far_jmp_target      ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
c0203270:	ea 77 32 20 c0 08 00 	ljmp   $0x8,$0xc0203277

c0203277 <far_jmp_target>:

;初始化段寄存器以及栈结构
    far_jmp_target:
    mov ax,SELECTOR_DATA
c0203277:	66 b8 10 00          	mov    $0x10,%ax
    mov ss,ax
c020327b:	8e d0                	mov    %eax,%ss
    mov ds,ax
c020327d:	8e d8                	mov    %eax,%ds
  	mov ax,SELECTOR_VIDEO
c020327f:	66 b8 18 00          	mov    $0x18,%ax
  	mov gs,ax
c0203283:	8e e8                	mov    %eax,%gs
    mov esp, STACK_TOP      
c0203285:	bc 03 20 29 c0       	mov    $0xc0292003,%esp
    and esp, 0xFFFFFFF0  ;16字节对齐
c020328a:	83 e4 f0             	and    $0xfffffff0,%esp
    mov ebp, 0         
c020328d:	bd 00 00 00 00       	mov    $0x0,%ebp
    mov eax,kern_bitmap_block
c0203292:	b8 00 a0 20 c0       	mov    $0xc020a000,%eax
    mov [kern_bitmap],eax
c0203297:	a3 0c 80 20 c0       	mov    %eax,0xc020800c
    mov eax,kern_dir_table
c020329c:	b8 00 10 10 00       	mov    $0x101000,%eax
    mov [kern_dir_table_paddr],eax
c02032a1:	a3 14 80 20 c0       	mov    %eax,0xc0208014
    mov eax,kern_page_table
c02032a6:	b8 00 20 10 00       	mov    $0x102000,%eax
    mov [kern_page_table_paddr],eax
c02032ab:	a3 18 80 20 c0       	mov    %eax,0xc0208018
;进入内核主函数    
    cli
c02032b0:	fa                   	cli    
    call kern_entry                    
c02032b1:	e8 ec 38 00 00       	call   c0206ba2 <kern_entry>
    jmp dword $          ;防止意外退出内核
c02032b6:	e9 fb ff ff ff       	jmp    c02032b6 <far_jmp_target+0x3f>

c02032bb <bitmap_init_mem>:
#include "string.h"
#include "printk.h"
//4KB为一个页来管理

//初始化目标bitmap的内存区域
void bitmap_init_mem(bitmap bm){
c02032bb:	55                   	push   %ebp
c02032bc:	89 e5                	mov    %esp,%ebp
c02032be:	53                   	push   %ebx
c02032bf:	83 ec 14             	sub    $0x14,%esp
c02032c2:	e8 3d 4d 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02032c7:	81 c3 39 5d 00 00    	add    $0x5d39,%ebx
    printk("bitmap init mem=%h,%h,%h\n",bm.target_addr_header,bm.vaddr_header,bm.length);
c02032cd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c02032d0:	8b 55 08             	mov    0x8(%ebp),%edx
c02032d3:	8b 45 10             	mov    0x10(%ebp),%eax
c02032d6:	51                   	push   %ecx
c02032d7:	52                   	push   %edx
c02032d8:	50                   	push   %eax
c02032d9:	8d 83 18 00 00 00    	lea    0x18(%ebx),%eax
c02032df:	50                   	push   %eax
c02032e0:	e8 4f 40 00 00       	call   c0207334 <printk>
c02032e5:	83 c4 10             	add    $0x10,%esp
    uint32_t length = bm.length;
c02032e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c02032eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02032ee:	8b 45 08             	mov    0x8(%ebp),%eax
c02032f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
//    for(uint32_t i = 0;i<length;i++){
//        *((byte*)(vaddr_header+i)) = 255;   //11111111b
//    }
    memset(vaddr_header,255,length);
c02032f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02032f7:	83 ec 04             	sub    $0x4,%esp
c02032fa:	ff 75 f4             	pushl  -0xc(%ebp)
c02032fd:	68 ff 00 00 00       	push   $0xff
c0203302:	50                   	push   %eax
c0203303:	e8 ef 46 00 00       	call   c02079f7 <memset>
c0203308:	83 c4 10             	add    $0x10,%esp
}
c020330b:	90                   	nop
c020330c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020330f:	c9                   	leave  
c0203310:	c3                   	ret    

c0203311 <bitmap_alloc_one_page>:


//指定分配目标页  0xc0293ca0
//分配成功：返回目标页起始地址
//分配失败：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc_one_page(bitmap bm,uint32_t target){
c0203311:	55                   	push   %ebp
c0203312:	89 e5                	mov    %esp,%ebp
c0203314:	83 ec 20             	sub    $0x20,%esp
c0203317:	e8 e4 4c 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020331c:	05 e4 5c 00 00       	add    $0x5ce4,%eax
    uint32_t lenght = bm.length;
c0203321:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203324:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0203327:	8b 45 08             	mov    0x8(%ebp),%eax
c020332a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c020332d:	8b 45 10             	mov    0x10(%ebp),%eax
c0203330:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0203333:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;   //必须要-1 否则可能造成max_addr溢出为0
c020333a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020333d:	c1 e0 0f             	shl    $0xf,%eax
c0203340:	89 c2                	mov    %eax,%edx
c0203342:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203345:	01 d0                	add    %edx,%eax
c0203347:	83 e8 01             	sub    $0x1,%eax
c020334a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c020334d:	8b 45 14             	mov    0x14(%ebp),%eax
c0203350:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0203353:	0f 82 8e 00 00 00    	jb     c02033e7 <bitmap_alloc_one_page+0xd6>
c0203359:	8b 45 14             	mov    0x14(%ebp),%eax
c020335c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c020335f:	0f 83 82 00 00 00    	jae    c02033e7 <bitmap_alloc_one_page+0xd6>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c0203365:	8b 45 14             	mov    0x14(%ebp),%eax
c0203368:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020336b:	c1 e8 0c             	shr    $0xc,%eax
c020336e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c0203371:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203374:	8d 50 07             	lea    0x7(%eax),%edx
c0203377:	85 c0                	test   %eax,%eax
c0203379:	0f 48 c2             	cmovs  %edx,%eax
c020337c:	c1 f8 03             	sar    $0x3,%eax
c020337f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c0203382:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203385:	99                   	cltd   
c0203386:	c1 ea 1d             	shr    $0x1d,%edx
c0203389:	01 d0                	add    %edx,%eax
c020338b:	83 e0 07             	and    $0x7,%eax
c020338e:	29 d0                	sub    %edx,%eax
c0203390:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c0203393:	b8 07 00 00 00       	mov    $0x7,%eax
c0203398:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c020339b:	ba 01 00 00 00       	mov    $0x1,%edx
c02033a0:	89 c1                	mov    %eax,%ecx
c02033a2:	d3 e2                	shl    %cl,%edx
c02033a4:	89 d0                	mov    %edx,%eax
c02033a6:	88 45 e3             	mov    %al,-0x1d(%ebp)
        byte target_byte = *((byte*)(vaddr_header+i));
c02033a9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02033ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02033af:	01 d0                	add    %edx,%eax
c02033b1:	0f b6 00             	movzbl (%eax),%eax
c02033b4:	88 45 e2             	mov    %al,-0x1e(%ebp)
        if(target_byte== (target_byte| byte_mask)){
c02033b7:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
c02033bb:	0a 45 e3             	or     -0x1d(%ebp),%al
c02033be:	38 45 e2             	cmp    %al,-0x1e(%ebp)
c02033c1:	75 1d                	jne    c02033e0 <bitmap_alloc_one_page+0xcf>
            //此时目标bit为1 空闲状态
            *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) - byte_mask;
c02033c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02033c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02033c9:	01 d0                	add    %edx,%eax
c02033cb:	0f b6 00             	movzbl (%eax),%eax
c02033ce:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c02033d1:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02033d4:	01 ca                	add    %ecx,%edx
c02033d6:	2a 45 e3             	sub    -0x1d(%ebp),%al
c02033d9:	88 02                	mov    %al,(%edx)
            return target;    
c02033db:	8b 45 14             	mov    0x14(%ebp),%eax
c02033de:	eb 0c                	jmp    c02033ec <bitmap_alloc_one_page+0xdb>
        }
        else{
            //此时目标bit为0     忙碌状态
            return BITMAP_RETURN_ERRO;
c02033e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02033e5:	eb 05                	jmp    c02033ec <bitmap_alloc_one_page+0xdb>
        }   
    }
    else{
        return BITMAP_RETURN_ERRO;
c02033e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c02033ec:	c9                   	leave  
c02033ed:	c3                   	ret    

c02033ee <bitmap_release_one_page>:

//BUG!!!!!!!!
//释放指定的目标页
//释放成功或者失败都不会返回信息
void bitmap_release_one_page(bitmap bm,uint32_t target){
c02033ee:	55                   	push   %ebp
c02033ef:	89 e5                	mov    %esp,%ebp
c02033f1:	83 ec 20             	sub    $0x20,%esp
c02033f4:	e8 07 4c 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02033f9:	05 07 5c 00 00       	add    $0x5c07,%eax
    uint32_t lenght = bm.length;
c02033fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203401:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0203404:	8b 45 08             	mov    0x8(%ebp),%eax
c0203407:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c020340a:	8b 45 10             	mov    0x10(%ebp),%eax
c020340d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0203410:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;
c0203417:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020341a:	c1 e0 0f             	shl    $0xf,%eax
c020341d:	89 c2                	mov    %eax,%edx
c020341f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203422:	01 d0                	add    %edx,%eax
c0203424:	83 e8 01             	sub    $0x1,%eax
c0203427:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c020342a:	8b 45 14             	mov    0x14(%ebp),%eax
c020342d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0203430:	72 64                	jb     c0203496 <bitmap_release_one_page+0xa8>
c0203432:	8b 45 14             	mov    0x14(%ebp),%eax
c0203435:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0203438:	73 5c                	jae    c0203496 <bitmap_release_one_page+0xa8>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c020343a:	8b 45 14             	mov    0x14(%ebp),%eax
c020343d:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0203440:	c1 e8 0c             	shr    $0xc,%eax
c0203443:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c0203446:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203449:	8d 50 07             	lea    0x7(%eax),%edx
c020344c:	85 c0                	test   %eax,%eax
c020344e:	0f 48 c2             	cmovs  %edx,%eax
c0203451:	c1 f8 03             	sar    $0x3,%eax
c0203454:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c0203457:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020345a:	99                   	cltd   
c020345b:	c1 ea 1d             	shr    $0x1d,%edx
c020345e:	01 d0                	add    %edx,%eax
c0203460:	83 e0 07             	and    $0x7,%eax
c0203463:	29 d0                	sub    %edx,%eax
c0203465:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c0203468:	b8 07 00 00 00       	mov    $0x7,%eax
c020346d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0203470:	ba 01 00 00 00       	mov    $0x1,%edx
c0203475:	89 c1                	mov    %eax,%ecx
c0203477:	d3 e2                	shl    %cl,%edx
c0203479:	89 d0                	mov    %edx,%eax
c020347b:	88 45 e3             	mov    %al,-0x1d(%ebp)
        *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) | byte_mask;
c020347e:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0203481:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203484:	01 d0                	add    %edx,%eax
c0203486:	0f b6 00             	movzbl (%eax),%eax
c0203489:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c020348c:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020348f:	01 ca                	add    %ecx,%edx
c0203491:	0a 45 e3             	or     -0x1d(%ebp),%al
c0203494:	88 02                	mov    %al,(%edx)
    }
}
c0203496:	90                   	nop
c0203497:	c9                   	leave  
c0203498:	c3                   	ret    

c0203499 <bitmap_alloc>:

//任意分配 未指定分配的目标
//分配成功：返回目标页起始地址
//没有可用页：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc(bitmap bm){
c0203499:	55                   	push   %ebp
c020349a:	89 e5                	mov    %esp,%ebp
c020349c:	83 ec 30             	sub    $0x30,%esp
c020349f:	e8 5c 4b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02034a4:	05 5c 5b 00 00       	add    $0x5b5c,%eax
    uint32_t lenght = bm.length;
c02034a9:	8b 45 0c             	mov    0xc(%ebp),%eax
c02034ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02034af:	8b 45 08             	mov    0x8(%ebp),%eax
c02034b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c02034b5:	8b 45 10             	mov    0x10(%ebp),%eax
c02034b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(uint32_t i =0;i<lenght;i++){
c02034bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c02034c2:	e9 96 00 00 00       	jmp    c020355d <bitmap_alloc+0xc4>
        byte * byte_ptr = (byte*)(vaddr_header+i);
c02034c7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02034ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02034cd:	01 d0                	add    %edx,%eax
c02034cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
        byte byte_now = *byte_ptr ;
c02034d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c02034d5:	0f b6 00             	movzbl (%eax),%eax
c02034d8:	88 45 fb             	mov    %al,-0x5(%ebp)
        if(byte_now != 0x00){
c02034db:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c02034df:	74 78                	je     c0203559 <bitmap_alloc+0xc0>
            int pos;     //在本字节中目标bit所在位置（从左往右 从0开始）
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c02034e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c02034e8:	eb 22                	jmp    c020350c <bitmap_alloc+0x73>
                byte temp_byte = (byte_now)&(0x7F);    // 01111-1111b
c02034ea:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c02034ee:	83 e0 7f             	and    $0x7f,%eax
c02034f1:	88 45 df             	mov    %al,-0x21(%ebp)
                if(byte_now!=temp_byte){
c02034f4:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c02034f8:	3a 45 df             	cmp    -0x21(%ebp),%al
c02034fb:	74 08                	je     c0203505 <bitmap_alloc+0x6c>
                    pos = j;
c02034fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203500:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    break;
c0203503:	eb 0d                	jmp    c0203512 <bitmap_alloc+0x79>
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0203505:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0203509:	d0 65 fb             	shlb   -0x5(%ebp)
c020350c:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c0203510:	7e d8                	jle    c02034ea <bitmap_alloc+0x51>
                }
            }
            byte byte_sub = 0x01<<(7-pos);     //1=00000001b
c0203512:	b8 07 00 00 00       	mov    $0x7,%eax
c0203517:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020351a:	ba 01 00 00 00       	mov    $0x1,%edx
c020351f:	89 c1                	mov    %eax,%ecx
c0203521:	d3 e2                	shl    %cl,%edx
c0203523:	89 d0                	mov    %edx,%eax
c0203525:	88 45 de             	mov    %al,-0x22(%ebp)
            *byte_ptr = *byte_ptr-byte_sub;
c0203528:	8b 45 e0             	mov    -0x20(%ebp),%eax
c020352b:	0f b6 00             	movzbl (%eax),%eax
c020352e:	2a 45 de             	sub    -0x22(%ebp),%al
c0203531:	89 c2                	mov    %eax,%edx
c0203533:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0203536:	88 10                	mov    %dl,(%eax)
            int page_no = i*8+pos;
c0203538:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020353b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0203542:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203545:	01 d0                	add    %edx,%eax
c0203547:	89 45 d8             	mov    %eax,-0x28(%ebp)
            return page_no*PAGE_SIZE+target_addr_header;
c020354a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020354d:	c1 e0 0c             	shl    $0xc,%eax
c0203550:	89 c2                	mov    %eax,%edx
c0203552:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0203555:	01 d0                	add    %edx,%eax
c0203557:	eb 15                	jmp    c020356e <bitmap_alloc+0xd5>
    for(uint32_t i =0;i<lenght;i++){
c0203559:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c020355d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203560:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0203563:	0f 82 5e ff ff ff    	jb     c02034c7 <bitmap_alloc+0x2e>
        }
    }
    return BITMAP_RETURN_ERRO;
c0203569:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c020356e:	c9                   	leave  
c020356f:	c3                   	ret    

c0203570 <print_mem>:

void print_mem(bitmap bm){
c0203570:	55                   	push   %ebp
c0203571:	89 e5                	mov    %esp,%ebp
c0203573:	53                   	push   %ebx
c0203574:	83 ec 14             	sub    $0x14,%esp
c0203577:	e8 84 4a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020357c:	05 84 5a 00 00       	add    $0x5a84,%eax
    uint32_t addr = bm.vaddr_header;
c0203581:	8b 55 08             	mov    0x8(%ebp),%edx
c0203584:	89 55 f4             	mov    %edx,-0xc(%ebp)
    printk("4BYTES:%h\n",*(uint32_t*)addr);
c0203587:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020358a:	8b 12                	mov    (%edx),%edx
c020358c:	83 ec 08             	sub    $0x8,%esp
c020358f:	52                   	push   %edx
c0203590:	8d 90 32 00 00 00    	lea    0x32(%eax),%edx
c0203596:	52                   	push   %edx
c0203597:	89 c3                	mov    %eax,%ebx
c0203599:	e8 96 3d 00 00       	call   c0207334 <printk>
c020359e:	83 c4 10             	add    $0x10,%esp
}
c02035a1:	90                   	nop
c02035a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02035a5:	c9                   	leave  
c02035a6:	c3                   	ret    

c02035a7 <bitmap_test>:

void bitmap_test(){
c02035a7:	55                   	push   %ebp
c02035a8:	89 e5                	mov    %esp,%ebp
c02035aa:	53                   	push   %ebx
c02035ab:	83 ec 24             	sub    $0x24,%esp
c02035ae:	e8 51 4a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02035b3:	81 c3 4d 5a 00 00    	add    $0x5a4d,%ebx
    void clear_screen();
    clear_screen();
c02035b9:	e8 1d 38 00 00       	call   c0206ddb <clear_screen>
    extern uint32_t kern_bitmap;
    bitmap bm;
    bm.vaddr_header = kern_bitmap;
c02035be:	c7 c0 0c 80 20 c0    	mov    $0xc020800c,%eax
c02035c4:	8b 00                	mov    (%eax),%eax
c02035c6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bm.length=4;
c02035c9:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
    bm.target_addr_header = 0x1000;
c02035d0:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
    bitmap_init_mem(bm);
c02035d7:	83 ec 04             	sub    $0x4,%esp
c02035da:	ff 75 e0             	pushl  -0x20(%ebp)
c02035dd:	ff 75 dc             	pushl  -0x24(%ebp)
c02035e0:	ff 75 d8             	pushl  -0x28(%ebp)
c02035e3:	e8 d3 fc ff ff       	call   c02032bb <bitmap_init_mem>
c02035e8:	83 c4 10             	add    $0x10,%esp
    print_mem(bm);
c02035eb:	83 ec 04             	sub    $0x4,%esp
c02035ee:	ff 75 e0             	pushl  -0x20(%ebp)
c02035f1:	ff 75 dc             	pushl  -0x24(%ebp)
c02035f4:	ff 75 d8             	pushl  -0x28(%ebp)
c02035f7:	e8 74 ff ff ff       	call   c0203570 <print_mem>
c02035fc:	83 c4 10             	add    $0x10,%esp
    while(1){
        uint32_t addr_head = bitmap_alloc(bm);
c02035ff:	83 ec 04             	sub    $0x4,%esp
c0203602:	ff 75 e0             	pushl  -0x20(%ebp)
c0203605:	ff 75 dc             	pushl  -0x24(%ebp)
c0203608:	ff 75 d8             	pushl  -0x28(%ebp)
c020360b:	e8 89 fe ff ff       	call   c0203499 <bitmap_alloc>
c0203610:	83 c4 10             	add    $0x10,%esp
c0203613:	89 45 e8             	mov    %eax,-0x18(%ebp)
        printk("addr:0x%h\n",addr_head);
c0203616:	83 ec 08             	sub    $0x8,%esp
c0203619:	ff 75 e8             	pushl  -0x18(%ebp)
c020361c:	8d 83 3d 00 00 00    	lea    0x3d(%ebx),%eax
c0203622:	50                   	push   %eax
c0203623:	e8 0c 3d 00 00       	call   c0207334 <printk>
c0203628:	83 c4 10             	add    $0x10,%esp
        uint32_t addr_probe=addr_head;
c020362b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020362e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        print_mem(bm);
c0203631:	83 ec 04             	sub    $0x4,%esp
c0203634:	ff 75 e0             	pushl  -0x20(%ebp)
c0203637:	ff 75 dc             	pushl  -0x24(%ebp)
c020363a:	ff 75 d8             	pushl  -0x28(%ebp)
c020363d:	e8 2e ff ff ff       	call   c0203570 <print_mem>
c0203642:	83 c4 10             	add    $0x10,%esp
        for(int i = 0; i<23;i++){
c0203645:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020364c:	eb 50                	jmp    c020369e <bitmap_test+0xf7>
            addr_probe +=0x1000;
c020364e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
            uint32_t alloc_addr=bitmap_alloc_one_page(bm,addr_probe);
c0203655:	ff 75 f4             	pushl  -0xc(%ebp)
c0203658:	ff 75 e0             	pushl  -0x20(%ebp)
c020365b:	ff 75 dc             	pushl  -0x24(%ebp)
c020365e:	ff 75 d8             	pushl  -0x28(%ebp)
c0203661:	e8 ab fc ff ff       	call   c0203311 <bitmap_alloc_one_page>
c0203666:	83 c4 10             	add    $0x10,%esp
c0203669:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            print_mem(bm);
c020366c:	83 ec 04             	sub    $0x4,%esp
c020366f:	ff 75 e0             	pushl  -0x20(%ebp)
c0203672:	ff 75 dc             	pushl  -0x24(%ebp)
c0203675:	ff 75 d8             	pushl  -0x28(%ebp)
c0203678:	e8 f3 fe ff ff       	call   c0203570 <print_mem>
c020367d:	83 c4 10             	add    $0x10,%esp
            if(alloc_addr==BITMAP_RETURN_ERRO){
c0203680:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c0203684:	75 14                	jne    c020369a <bitmap_test+0xf3>
                printk("ERRO");
c0203686:	83 ec 0c             	sub    $0xc,%esp
c0203689:	8d 83 48 00 00 00    	lea    0x48(%ebx),%eax
c020368f:	50                   	push   %eax
c0203690:	e8 9f 3c 00 00       	call   c0207334 <printk>
c0203695:	83 c4 10             	add    $0x10,%esp
                while (1);
c0203698:	eb fe                	jmp    c0203698 <bitmap_test+0xf1>
        for(int i = 0; i<23;i++){
c020369a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020369e:	83 7d f0 16          	cmpl   $0x16,-0x10(%ebp)
c02036a2:	7e aa                	jle    c020364e <bitmap_test+0xa7>
            }
        }
        printk("bit map alloc all:");
c02036a4:	83 ec 0c             	sub    $0xc,%esp
c02036a7:	8d 83 4d 00 00 00    	lea    0x4d(%ebx),%eax
c02036ad:	50                   	push   %eax
c02036ae:	e8 81 3c 00 00       	call   c0207334 <printk>
c02036b3:	83 c4 10             	add    $0x10,%esp
        print_mem(bm);
c02036b6:	83 ec 04             	sub    $0x4,%esp
c02036b9:	ff 75 e0             	pushl  -0x20(%ebp)
c02036bc:	ff 75 dc             	pushl  -0x24(%ebp)
c02036bf:	ff 75 d8             	pushl  -0x28(%ebp)
c02036c2:	e8 a9 fe ff ff       	call   c0203570 <print_mem>
c02036c7:	83 c4 10             	add    $0x10,%esp
        printk("start release");
c02036ca:	83 ec 0c             	sub    $0xc,%esp
c02036cd:	8d 83 60 00 00 00    	lea    0x60(%ebx),%eax
c02036d3:	50                   	push   %eax
c02036d4:	e8 5b 3c 00 00       	call   c0207334 <printk>
c02036d9:	83 c4 10             	add    $0x10,%esp
        addr_probe = addr_head;
c02036dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c02036df:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(int i = 0;i<24;i++){
c02036e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c02036e9:	eb 33                	jmp    c020371e <bitmap_test+0x177>
            bitmap_release_one_page(bm,addr_probe);
c02036eb:	ff 75 f4             	pushl  -0xc(%ebp)
c02036ee:	ff 75 e0             	pushl  -0x20(%ebp)
c02036f1:	ff 75 dc             	pushl  -0x24(%ebp)
c02036f4:	ff 75 d8             	pushl  -0x28(%ebp)
c02036f7:	e8 f2 fc ff ff       	call   c02033ee <bitmap_release_one_page>
c02036fc:	83 c4 10             	add    $0x10,%esp
            print_mem(bm);
c02036ff:	83 ec 04             	sub    $0x4,%esp
c0203702:	ff 75 e0             	pushl  -0x20(%ebp)
c0203705:	ff 75 dc             	pushl  -0x24(%ebp)
c0203708:	ff 75 d8             	pushl  -0x28(%ebp)
c020370b:	e8 60 fe ff ff       	call   c0203570 <print_mem>
c0203710:	83 c4 10             	add    $0x10,%esp
            addr_probe+=0x1000;
c0203713:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
        for(int i = 0;i<24;i++){
c020371a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c020371e:	83 7d ec 17          	cmpl   $0x17,-0x14(%ebp)
c0203722:	7e c7                	jle    c02036eb <bitmap_test+0x144>
    while(1){
c0203724:	e9 d6 fe ff ff       	jmp    c02035ff <bitmap_test+0x58>

c0203729 <get_running_progress>:
TCB_t main_TCB;    //内核主线程TCB
TCB_t* cur_tcb;
static char* LOG_SRC_THREADS = "THREADS";


TCB_t* get_running_progress(){
c0203729:	55                   	push   %ebp
c020372a:	89 e5                	mov    %esp,%ebp
c020372c:	e8 cf 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203731:	05 cf 58 00 00       	add    $0x58cf,%eax
	return cur_tcb;
c0203736:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c020373c:	8b 00                	mov    (%eax),%eax
}
c020373e:	5d                   	pop    %ebp
c020373f:	c3                   	ret    

c0203740 <check_kern_stack_overflow>:

bool check_kern_stack_overflow(TCB_t* tcb_ptr){
c0203740:	55                   	push   %ebp
c0203741:	89 e5                	mov    %esp,%ebp
c0203743:	e8 b8 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203748:	05 b8 58 00 00       	add    $0x58b8,%eax
	if(tcb_ptr->tcb_magic_number==TCB_MAGIC_NUMBER){
c020374d:	8b 45 08             	mov    0x8(%ebp),%eax
c0203750:	8b 40 54             	mov    0x54(%eax),%eax
c0203753:	3d ab 21 0d fc       	cmp    $0xfc0d21ab,%eax
c0203758:	75 07                	jne    c0203761 <check_kern_stack_overflow+0x21>
		return True;
c020375a:	b8 01 00 00 00       	mov    $0x1,%eax
c020375f:	eb 05                	jmp    c0203766 <check_kern_stack_overflow+0x26>
	}
	else{
		return False;
c0203761:	b8 00 00 00 00       	mov    $0x0,%eax
	}	
}
c0203766:	5d                   	pop    %ebp
c0203767:	c3                   	ret    

c0203768 <kern_overflow_handler>:

static void kern_overflow_handler(TCB_t * tcb_ptr){
c0203768:	55                   	push   %ebp
c0203769:	89 e5                	mov    %esp,%ebp
c020376b:	53                   	push   %ebx
c020376c:	83 ec 14             	sub    $0x14,%esp
c020376f:	e8 8c 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203774:	05 8c 58 00 00       	add    $0x588c,%eax
	uint32_t tid = tcb_ptr->tid;
c0203779:	8b 55 08             	mov    0x8(%ebp),%edx
c020377c:	8b 52 14             	mov    0x14(%edx),%edx
c020377f:	89 55 f4             	mov    %edx,-0xc(%ebp)
	STOP(LOG_SRC_THREADS,"Thread Kern Stack Overflow!STOP!");
c0203782:	8b 90 0c 00 00 00    	mov    0xc(%eax),%edx
c0203788:	83 ec 08             	sub    $0x8,%esp
c020378b:	8d 88 78 00 00 00    	lea    0x78(%eax),%ecx
c0203791:	51                   	push   %ecx
c0203792:	52                   	push   %edx
c0203793:	89 c3                	mov    %eax,%ebx
c0203795:	e8 ae 20 00 00       	call   c0205848 <stop_kern>
c020379a:	83 c4 10             	add    $0x10,%esp
}
c020379d:	90                   	nop
c020379e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02037a1:	c9                   	leave  
c02037a2:	c3                   	ret    

c02037a3 <_init_main_thread>:
//主要功能： 1 页表切换   2  tss栈修改    
// static void active_task(TCB_t * next){
	
// }

static void  _init_main_thread(TCB_t * main_tcb){
c02037a3:	55                   	push   %ebp
c02037a4:	89 e5                	mov    %esp,%ebp
c02037a6:	83 ec 10             	sub    $0x10,%esp
c02037a9:	e8 52 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02037ae:	05 52 58 00 00       	add    $0x5852,%eax
	TCB_t *tcb_buffer_addr = main_tcb;
c02037b3:	8b 45 08             	mov    0x8(%ebp),%eax
c02037b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = 0;        //主线程的编号为0  
c02037b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037bc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c02037c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037c6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c02037cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037d0:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c02037d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037da:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=0;   //主线程不会被回收内存 所以可以任意赋值
c02037e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037e4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	tcb_buffer_addr->page_addr=0;
c02037eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037ee:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	tcb_buffer_addr->next = tcb_buffer_addr;
c02037f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037f8:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02037fb:	89 50 10             	mov    %edx,0x10(%eax)
	tcb_buffer_addr->kern_stack_top=0;
c02037fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203801:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	tcb_buffer_addr->is_kern_thread = True;
c0203807:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020380a:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%eax)
	tcb_buffer_addr->tcb_magic_number = TCB_MAGIC_NUMBER;
c0203811:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203814:	c7 40 54 ab 21 0d fc 	movl   $0xfc0d21ab,0x54(%eax)
}
c020381b:	90                   	nop
c020381c:	c9                   	leave  
c020381d:	c3                   	ret    

c020381e <threads_init>:

void threads_init(){
c020381e:	55                   	push   %ebp
c020381f:	89 e5                	mov    %esp,%ebp
c0203821:	53                   	push   %ebx
c0203822:	83 ec 10             	sub    $0x10,%esp
c0203825:	e8 da 47 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020382a:	81 c3 d6 57 00 00    	add    $0x57d6,%ebx
	TCB_t *tcb_buffer_addr = &main_TCB;
c0203830:	c7 c0 20 30 29 c0    	mov    $0xc0293020,%eax
c0203836:	89 45 f8             	mov    %eax,-0x8(%ebp)
	_init_main_thread(&main_TCB);
c0203839:	c7 c0 20 30 29 c0    	mov    $0xc0293020,%eax
c020383f:	50                   	push   %eax
c0203840:	e8 5e ff ff ff       	call   c02037a3 <_init_main_thread>
c0203845:	83 c4 04             	add    $0x4,%esp
	cur_tcb = &main_TCB;
c0203848:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c020384e:	c7 c2 20 30 29 c0    	mov    $0xc0293020,%edx
c0203854:	89 10                	mov    %edx,(%eax)
}
c0203856:	90                   	nop
c0203857:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020385a:	c9                   	leave  
c020385b:	c3                   	ret    

c020385c <create_TCB>:

//用于创建线程的PCB
TCB_t* create_TCB(uint32_t tid,uint32_t page_addr,uint32_t page_counte){
c020385c:	55                   	push   %ebp
c020385d:	89 e5                	mov    %esp,%ebp
c020385f:	83 ec 10             	sub    $0x10,%esp
c0203862:	e8 99 47 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203867:	05 99 57 00 00       	add    $0x5799,%eax
	TCB_t * tcb_buffer_addr = (TCB_t*)page_addr;
c020386c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020386f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = tid;         
c0203872:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203875:	8b 55 08             	mov    0x8(%ebp),%edx
c0203878:	89 50 14             	mov    %edx,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c020387b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020387e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c0203885:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203888:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c020388f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203892:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=page_counte; 
c0203899:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020389c:	8b 55 10             	mov    0x10(%ebp),%edx
c020389f:	89 50 18             	mov    %edx,0x18(%eax)
	tcb_buffer_addr->page_addr=page_addr;
c02038a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038a5:	8b 55 0c             	mov    0xc(%ebp),%edx
c02038a8:	89 50 1c             	mov    %edx,0x1c(%eax)
	tcb_buffer_addr->kern_stack_top=page_addr+page_counte*PAGE_SIZE;    
c02038ab:	8b 45 10             	mov    0x10(%ebp),%eax
c02038ae:	c1 e0 0c             	shl    $0xc,%eax
c02038b1:	89 c2                	mov    %eax,%edx
c02038b3:	8b 45 0c             	mov    0xc(%ebp),%eax
c02038b6:	01 d0                	add    %edx,%eax
c02038b8:	89 c2                	mov    %eax,%edx
c02038ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038bd:	89 10                	mov    %edx,(%eax)
	tcb_buffer_addr->tcb_magic_number = TCB_MAGIC_NUMBER;
c02038bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038c2:	c7 40 54 ab 21 0d fc 	movl   $0xfc0d21ab,0x54(%eax)
	return (TCB_t*)page_addr;
c02038c9:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c02038cc:	c9                   	leave  
c02038cd:	c3                   	ret    

c02038ce <create_thread>:

//创建最终线程的核心函数     创建用户进程以及创建内核线程的函数都是对这个函数的封装
//会操作TCB链表 需要加锁
void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte,bool is_kern_thread,bitmap user_vmm_pool,uint32_t pdt_vaddr){	
c02038ce:	55                   	push   %ebp
c02038cf:	89 e5                	mov    %esp,%ebp
c02038d1:	53                   	push   %ebx
c02038d2:	83 ec 10             	sub    $0x10,%esp
c02038d5:	e8 2a 47 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02038da:	81 c3 26 57 00 00    	add    $0x5726,%ebx
	asm volatile("cli");  //由于创建过程会使用到共享的数据 不使用锁的话会造成临界区错误 所以我们在此处关闭中断
c02038e0:	fa                   	cli    
	TCB_t * new_tcb = create_TCB(tid,addr,page_counte);
c02038e1:	ff 75 18             	pushl  0x18(%ebp)
c02038e4:	ff 75 14             	pushl  0x14(%ebp)
c02038e7:	ff 75 08             	pushl  0x8(%ebp)
c02038ea:	e8 6d ff ff ff       	call   c020385c <create_TCB>
c02038ef:	83 c4 0c             	add    $0xc,%esp
c02038f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
	TCB_t * temp_next = cur_tcb->next;
c02038f5:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c02038fb:	8b 00                	mov    (%eax),%eax
c02038fd:	8b 40 10             	mov    0x10(%eax),%eax
c0203900:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cur_tcb->next = new_tcb;
c0203903:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203909:	8b 00                	mov    (%eax),%eax
c020390b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020390e:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->next = temp_next;
c0203911:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203914:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203917:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->is_kern_thread = is_kern_thread;
c020391a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020391d:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0203920:	89 50 20             	mov    %edx,0x20(%eax)
	if(!is_kern_thread){
c0203923:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c0203927:	75 1e                	jne    c0203947 <create_thread+0x79>
		//用户进程需要填充页表等
		new_tcb->user_vmm_pool = user_vmm_pool;
c0203929:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020392c:	8b 55 20             	mov    0x20(%ebp),%edx
c020392f:	89 50 24             	mov    %edx,0x24(%eax)
c0203932:	8b 55 24             	mov    0x24(%ebp),%edx
c0203935:	89 50 28             	mov    %edx,0x28(%eax)
c0203938:	8b 55 28             	mov    0x28(%ebp),%edx
c020393b:	89 50 2c             	mov    %edx,0x2c(%eax)
		new_tcb->pdt_vaddr = pdt_vaddr;
c020393e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203941:	8b 55 2c             	mov    0x2c(%ebp),%edx
c0203944:	89 50 30             	mov    %edx,0x30(%eax)
	}
	*(--new_tcb->kern_stack_top)=args;     //压入初始化的参数与线程执行函数
c0203947:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020394a:	8b 00                	mov    (%eax),%eax
c020394c:	8d 50 fc             	lea    -0x4(%eax),%edx
c020394f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203952:	89 10                	mov    %edx,(%eax)
c0203954:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203957:	8b 00                	mov    (%eax),%eax
c0203959:	8b 55 10             	mov    0x10(%ebp),%edx
c020395c:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=exit;
c020395e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203961:	8b 00                	mov    (%eax),%eax
c0203963:	8d 50 fc             	lea    -0x4(%eax),%edx
c0203966:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203969:	89 10                	mov    %edx,(%eax)
c020396b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020396e:	8b 00                	mov    (%eax),%eax
c0203970:	8d 93 5d ab ff ff    	lea    -0x54a3(%ebx),%edx
c0203976:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=func;
c0203978:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020397b:	8b 00                	mov    (%eax),%eax
c020397d:	8d 50 fc             	lea    -0x4(%eax),%edx
c0203980:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203983:	89 10                	mov    %edx,(%eax)
c0203985:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203988:	8b 00                	mov    (%eax),%eax
c020398a:	8b 55 0c             	mov    0xc(%ebp),%edx
c020398d:	89 10                	mov    %edx,(%eax)
	//此处存在修改！    0x200 ------->0x202    IF为1（打开硬中断）   IOPL为0（只允许内核访问IO）   1号位为1（eflags格式默认）
	new_tcb->context.eflags = 0x202; 
c020398f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203992:	c7 40 4c 02 02 00 00 	movl   $0x202,0x4c(%eax)
	new_tcb->context.esp =new_tcb->kern_stack_top;
c0203999:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020399c:	8b 00                	mov    (%eax),%eax
c020399e:	89 c2                	mov    %eax,%edx
c02039a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039a3:	89 50 50             	mov    %edx,0x50(%eax)
	asm volatile("sti");	
c02039a6:	fb                   	sti    
}
c02039a7:	90                   	nop
c02039a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02039ab:	c9                   	leave  
c02039ac:	c3                   	ret    

c02039ad <create_kern_thread>:
//                                            1.func必须保证存在，不会被内存回收
//                                            2.args必须保证存在， 不会被内存回收
//内核线程的func与args都是内核内存空间中的     func通过函数定义的方式保存在os内核的程序段中 ，args保存在调用者函数的定义中，一旦调用者函数退出，args就会被回收
//如何解决这个问题？  线程的创建者函数不能退出！！！使用特定指令阻塞对应的函数（join）
//使用detach，在detach中实现线程将参数复制
void create_kern_thread(uint32_t tid,thread_function *func,void *args){
c02039ad:	55                   	push   %ebp
c02039ae:	89 e5                	mov    %esp,%ebp
c02039b0:	53                   	push   %ebx
c02039b1:	83 ec 24             	sub    $0x24,%esp
c02039b4:	e8 4b 46 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02039b9:	81 c3 47 56 00 00    	add    $0x5647,%ebx
	bitmap default_bitmap;
	uint32_t page_counte = 1;
c02039bf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	uint32_t TCB_page = vmm_kern_alloc();
c02039c6:	e8 20 2c 00 00       	call   c02065eb <vmm_kern_alloc>
c02039cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t default_pdt_vaddr = 0x0;
c02039ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	bool is_kern_thread = True;
c02039d5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    if(TCB_page==KERN_VMM_ALLOC_ERRO){
c02039dc:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c02039e0:	75 19                	jne    c02039fb <create_kern_thread+0x4e>
        STOP(LOG_SRC_THREADS,"Can`t Create New User Task Because Of Error When Alloc TCB Page From Kernel VMM!STOP!");
c02039e2:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
c02039e8:	83 ec 08             	sub    $0x8,%esp
c02039eb:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx
c02039f1:	52                   	push   %edx
c02039f2:	50                   	push   %eax
c02039f3:	e8 50 1e 00 00       	call   c0205848 <stop_kern>
c02039f8:	83 c4 10             	add    $0x10,%esp
    }
	create_thread(tid,func,args,TCB_page,page_counte,is_kern_thread,default_bitmap,default_pdt_vaddr);
c02039fb:	83 ec 08             	sub    $0x8,%esp
c02039fe:	ff 75 ec             	pushl  -0x14(%ebp)
c0203a01:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a04:	ff 75 e0             	pushl  -0x20(%ebp)
c0203a07:	ff 75 dc             	pushl  -0x24(%ebp)
c0203a0a:	ff 75 e8             	pushl  -0x18(%ebp)
c0203a0d:	ff 75 f4             	pushl  -0xc(%ebp)
c0203a10:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a13:	ff 75 10             	pushl  0x10(%ebp)
c0203a16:	ff 75 0c             	pushl  0xc(%ebp)
c0203a19:	ff 75 08             	pushl  0x8(%ebp)
c0203a1c:	e8 ad fe ff ff       	call   c02038ce <create_thread>
c0203a21:	83 c4 30             	add    $0x30,%esp
}
c0203a24:	90                   	nop
c0203a25:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203a28:	c9                   	leave  
c0203a29:	c3                   	ret    

c0203a2a <schedule>:

void schedule(){      //调度函数  检测时间片为0时调用此函数
c0203a2a:	55                   	push   %ebp
c0203a2b:	89 e5                	mov    %esp,%ebp
c0203a2d:	53                   	push   %ebx
c0203a2e:	83 ec 14             	sub    $0x14,%esp
c0203a31:	e8 ce 45 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203a36:	81 c3 ca 55 00 00    	add    $0x55ca,%ebx
	//首先判定现在的线程内核栈是否溢出
	if(!check_kern_stack_overflow(get_running_progress())){
c0203a3c:	e8 e8 fc ff ff       	call   c0203729 <get_running_progress>
c0203a41:	50                   	push   %eax
c0203a42:	e8 f9 fc ff ff       	call   c0203740 <check_kern_stack_overflow>
c0203a47:	83 c4 04             	add    $0x4,%esp
c0203a4a:	85 c0                	test   %eax,%eax
c0203a4c:	75 11                	jne    c0203a5f <schedule+0x35>
		//溢出处理！！！
		kern_overflow_handler(get_running_progress());
c0203a4e:	e8 d6 fc ff ff       	call   c0203729 <get_running_progress>
c0203a53:	83 ec 0c             	sub    $0xc,%esp
c0203a56:	50                   	push   %eax
c0203a57:	e8 0c fd ff ff       	call   c0203768 <kern_overflow_handler>
c0203a5c:	83 c4 10             	add    $0x10,%esp
	}
	if(cur_tcb->next==cur_tcb){
c0203a5f:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203a65:	8b 00                	mov    (%eax),%eax
c0203a67:	8b 50 10             	mov    0x10(%eax),%edx
c0203a6a:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203a70:	8b 00                	mov    (%eax),%eax
c0203a72:	39 c2                	cmp    %eax,%edx
c0203a74:	75 11                	jne    c0203a87 <schedule+0x5d>
		cur_tcb->time_left = TIME_CONT;    //如果只有一个线程 就再次给此线程添加时间片
c0203a76:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203a7c:	8b 00                	mov    (%eax),%eax
c0203a7e:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
		return ;
c0203a85:	eb 5b                	jmp    c0203ae2 <schedule+0xb8>
	}
	//进行调度
	TCB_t *now = cur_tcb;
c0203a87:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203a8d:	8b 00                	mov    (%eax),%eax
c0203a8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0203a92:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203a98:	8b 00                	mov    (%eax),%eax
c0203a9a:	8b 40 10             	mov    0x10(%eax),%eax
c0203a9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0203aa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203aa3:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	cur_tcb = next_tcb;
c0203aaa:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203ab0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0203ab3:	89 10                	mov    %edx,(%eax)
	active_task(cur_tcb);
c0203ab5:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203abb:	8b 00                	mov    (%eax),%eax
c0203abd:	83 ec 0c             	sub    $0xc,%esp
c0203ac0:	50                   	push   %eax
c0203ac1:	e8 ac 03 00 00       	call   c0203e72 <active_task>
c0203ac6:	83 c4 10             	add    $0x10,%esp
	//get_esp();      //有一个隐藏bug 需要call刷新寄存器
	switch_to(&(now->context),&(next_tcb->context));      
c0203ac9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203acc:	8d 50 34             	lea    0x34(%eax),%edx
c0203acf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203ad2:	83 c0 34             	add    $0x34,%eax
c0203ad5:	83 ec 08             	sub    $0x8,%esp
c0203ad8:	52                   	push   %edx
c0203ad9:	50                   	push   %eax
c0203ada:	e8 27 f5 ff ff       	call   c0203006 <switch_to>
c0203adf:	83 c4 10             	add    $0x10,%esp
}
c0203ae2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ae5:	c9                   	leave  
c0203ae6:	c3                   	ret    

c0203ae7 <remove_thread>:

void remove_thread(){
c0203ae7:	55                   	push   %ebp
c0203ae8:	89 e5                	mov    %esp,%ebp
c0203aea:	53                   	push   %ebx
c0203aeb:	83 ec 14             	sub    $0x14,%esp
c0203aee:	e8 0d 45 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203af3:	05 0d 55 00 00       	add    $0x550d,%eax
	asm volatile("cli");
c0203af8:	fa                   	cli    
	if(cur_tcb->tid==0)
c0203af9:	c7 c2 00 30 29 c0    	mov    $0xc0293000,%edx
c0203aff:	8b 12                	mov    (%edx),%edx
c0203b01:	8b 52 14             	mov    0x14(%edx),%edx
c0203b04:	85 d2                	test   %edx,%edx
c0203b06:	75 16                	jne    c0203b1e <remove_thread+0x37>
		printk("ERRO:main thread can`t use function exit\n");
c0203b08:	83 ec 0c             	sub    $0xc,%esp
c0203b0b:	8d 90 f4 00 00 00    	lea    0xf4(%eax),%edx
c0203b11:	52                   	push   %edx
c0203b12:	89 c3                	mov    %eax,%ebx
c0203b14:	e8 1b 38 00 00       	call   c0207334 <printk>
c0203b19:	83 c4 10             	add    $0x10,%esp
		TCB_t *temp = cur_tcb;
		for(;temp->next!=cur_tcb;temp=temp->next)
			;
		temp->next = cur_tcb->next;
	}
}
c0203b1c:	eb 39                	jmp    c0203b57 <remove_thread+0x70>
		TCB_t *temp = cur_tcb;
c0203b1e:	c7 c2 00 30 29 c0    	mov    $0xc0293000,%edx
c0203b24:	8b 12                	mov    (%edx),%edx
c0203b26:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;temp->next!=cur_tcb;temp=temp->next)
c0203b29:	eb 09                	jmp    c0203b34 <remove_thread+0x4d>
c0203b2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b2e:	8b 52 10             	mov    0x10(%edx),%edx
c0203b31:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0203b34:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b37:	8b 4a 10             	mov    0x10(%edx),%ecx
c0203b3a:	c7 c2 00 30 29 c0    	mov    $0xc0293000,%edx
c0203b40:	8b 12                	mov    (%edx),%edx
c0203b42:	39 d1                	cmp    %edx,%ecx
c0203b44:	75 e5                	jne    c0203b2b <remove_thread+0x44>
		temp->next = cur_tcb->next;
c0203b46:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203b4c:	8b 00                	mov    (%eax),%eax
c0203b4e:	8b 50 10             	mov    0x10(%eax),%edx
c0203b51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b54:	89 50 10             	mov    %edx,0x10(%eax)
}
c0203b57:	90                   	nop
c0203b58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203b5b:	c9                   	leave  
c0203b5c:	c3                   	ret    

c0203b5d <exit>:


//本exit函数暂时只能被内核线程使用 作为自动退出
void exit(){
c0203b5d:	55                   	push   %ebp
c0203b5e:	89 e5                	mov    %esp,%ebp
c0203b60:	53                   	push   %ebx
c0203b61:	83 ec 14             	sub    $0x14,%esp
c0203b64:	e8 9b 44 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203b69:	81 c3 97 54 00 00    	add    $0x5497,%ebx
	remove_thread();
c0203b6f:	e8 73 ff ff ff       	call   c0203ae7 <remove_thread>
	TCB_t *now = cur_tcb;
c0203b74:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203b7a:	8b 00                	mov    (%eax),%eax
c0203b7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0203b7f:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203b85:	8b 00                	mov    (%eax),%eax
c0203b87:	8b 40 10             	mov    0x10(%eax),%eax
c0203b8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0203b8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203b90:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	cur_tcb = cur_tcb->next;
c0203b97:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203b9d:	8b 00                	mov    (%eax),%eax
c0203b9f:	8b 50 10             	mov    0x10(%eax),%edx
c0203ba2:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203ba8:	89 10                	mov    %edx,(%eax)
	switch_to(&(now->context),&(next_tcb->context));
c0203baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203bad:	8d 50 34             	lea    0x34(%eax),%edx
c0203bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203bb3:	83 c0 34             	add    $0x34,%eax
c0203bb6:	83 ec 08             	sub    $0x8,%esp
c0203bb9:	52                   	push   %edx
c0203bba:	50                   	push   %eax
c0203bbb:	e8 46 f4 ff ff       	call   c0203006 <switch_to>
c0203bc0:	83 c4 10             	add    $0x10,%esp
	//注意 暂时没有回收此线程页
}
c0203bc3:	90                   	nop
c0203bc4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203bc7:	c9                   	leave  
c0203bc8:	c3                   	ret    

c0203bc9 <create_user_task_bitmap>:
extern uint16_t SELECTOR_USER_DATA_MEM;       //用户级数据段选择子
//创建用户专用bitmap
//用户的bitmap会占用内核虚拟空间 要在内核空间池中分配 
//注意 进程结束时一定要回收这部分空间
//the bitmap have been init before return;
bitmap create_user_task_bitmap(){
c0203bc9:	55                   	push   %ebp
c0203bca:	89 e5                	mov    %esp,%ebp
c0203bcc:	53                   	push   %ebx
c0203bcd:	83 ec 24             	sub    $0x24,%esp
c0203bd0:	e8 2f 44 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203bd5:	81 c3 2b 54 00 00    	add    $0x542b,%ebx
    //ask <96KB> for Bitmap!!!
    //alloc kern vm for bitmap
    //get the first 4KB
    uint32_t val_4KB = 0x1000;
c0203bdb:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
    uint32_t vm_head = vmm_kern_alloc();
c0203be2:	e8 04 2a 00 00       	call   c02065eb <vmm_kern_alloc>
c0203be7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(vm_head==KERN_VMM_ALLOC_ERRO){
c0203bea:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c0203bee:	75 14                	jne    c0203c04 <create_user_task_bitmap+0x3b>
        printk("[ERRO]:user_task.c/0");
c0203bf0:	83 ec 0c             	sub    $0xc,%esp
c0203bf3:	8d 83 2a 01 00 00    	lea    0x12a(%ebx),%eax
c0203bf9:	50                   	push   %eax
c0203bfa:	e8 35 37 00 00       	call   c0207334 <printk>
c0203bff:	83 c4 10             	add    $0x10,%esp
        while(True);
c0203c02:	eb fe                	jmp    c0203c02 <create_user_task_bitmap+0x39>
    }
// for 96KB/4KB-1=23 times
    bool alloc_flag = True;
c0203c04:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    uint32_t addr_for = vm_head+val_4KB;
c0203c0b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0203c0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203c11:	01 d0                	add    %edx,%eax
c0203c13:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int item=0;item<23;item++){
c0203c16:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0203c1d:	eb 26                	jmp    c0203c45 <create_user_task_bitmap+0x7c>
        if(vmm_kern_alloc_one_page(addr_for)==KERN_VMM_ALLOC_ERRO){
c0203c1f:	83 ec 0c             	sub    $0xc,%esp
c0203c22:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c25:	e8 fe 28 00 00       	call   c0206528 <vmm_kern_alloc_one_page>
c0203c2a:	83 c4 10             	add    $0x10,%esp
c0203c2d:	83 f8 ff             	cmp    $0xffffffff,%eax
c0203c30:	75 09                	jne    c0203c3b <create_user_task_bitmap+0x72>
            alloc_flag = False;
c0203c32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            break;
c0203c39:	eb 10                	jmp    c0203c4b <create_user_task_bitmap+0x82>
        }
        addr_for += val_4KB;
c0203c3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203c3e:	01 45 f0             	add    %eax,-0x10(%ebp)
    for(int item=0;item<23;item++){
c0203c41:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0203c45:	83 7d ec 16          	cmpl   $0x16,-0x14(%ebp)
c0203c49:	7e d4                	jle    c0203c1f <create_user_task_bitmap+0x56>
    }
    if(!alloc_flag){
c0203c4b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0203c4f:	75 14                	jne    c0203c65 <create_user_task_bitmap+0x9c>
        printk("[ERRO]:user_task.c/1");
c0203c51:	83 ec 0c             	sub    $0xc,%esp
c0203c54:	8d 83 3f 01 00 00    	lea    0x13f(%ebx),%eax
c0203c5a:	50                   	push   %eax
c0203c5b:	e8 d4 36 00 00       	call   c0207334 <printk>
c0203c60:	83 c4 10             	add    $0x10,%esp
        while (True);
c0203c63:	eb fe                	jmp    c0203c63 <create_user_task_bitmap+0x9a>
    }
    bitmap re_bitmap;
    //从0~3GB虚拟地址来映射
    re_bitmap.vaddr_header = vm_head;
c0203c65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0203c68:	89 45 d8             	mov    %eax,-0x28(%ebp)
    re_bitmap.target_addr_header = 0x00000000;
c0203c6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    //需要3GB空间映射
    re_bitmap.length = 0x00018000;  //需要96KB的存储空间存放
c0203c72:	c7 45 dc 00 80 01 00 	movl   $0x18000,-0x24(%ebp)
    bitmap_init_mem(re_bitmap);
c0203c79:	83 ec 04             	sub    $0x4,%esp
c0203c7c:	ff 75 e0             	pushl  -0x20(%ebp)
c0203c7f:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c82:	ff 75 d8             	pushl  -0x28(%ebp)
c0203c85:	e8 31 f6 ff ff       	call   c02032bb <bitmap_init_mem>
c0203c8a:	83 c4 10             	add    $0x10,%esp
    return re_bitmap;
c0203c8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0203c90:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0203c93:	89 10                	mov    %edx,(%eax)
c0203c95:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0203c98:	89 50 04             	mov    %edx,0x4(%eax)
c0203c9b:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0203c9e:	89 50 08             	mov    %edx,0x8(%eax)
}
c0203ca1:	8b 45 08             	mov    0x8(%ebp),%eax
c0203ca4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ca7:	c9                   	leave  
c0203ca8:	c2 04 00             	ret    $0x4

c0203cab <release_user_task_bitmap>:

//release all 96KB to kern vm
//need release 96/4 = 24 times;
void release_user_task_bitmap(bitmap bm){
c0203cab:	55                   	push   %ebp
c0203cac:	89 e5                	mov    %esp,%ebp
c0203cae:	53                   	push   %ebx
c0203caf:	83 ec 14             	sub    $0x14,%esp
c0203cb2:	e8 4d 43 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203cb7:	81 c3 49 53 00 00    	add    $0x5349,%ebx
    uint32_t val_4KB = 0x1000;
c0203cbd:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
    uint32_t vm = bm.vaddr_header;
c0203cc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0203cc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (int i = 0; i < 24; i++) {
c0203cca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0203cd1:	eb 18                	jmp    c0203ceb <release_user_task_bitmap+0x40>
        vmm_kern_release_one_page(vm);
c0203cd3:	83 ec 0c             	sub    $0xc,%esp
c0203cd6:	ff 75 f4             	pushl  -0xc(%ebp)
c0203cd9:	e8 d0 29 00 00       	call   c02066ae <vmm_kern_release_one_page>
c0203cde:	83 c4 10             	add    $0x10,%esp
        vm += val_4KB;
c0203ce1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203ce4:	01 45 f4             	add    %eax,-0xc(%ebp)
    for (int i = 0; i < 24; i++) {
c0203ce7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0203ceb:	83 7d f0 17          	cmpl   $0x17,-0x10(%ebp)
c0203cef:	7e e2                	jle    c0203cd3 <release_user_task_bitmap+0x28>
    }
}
c0203cf1:	90                   	nop
c0203cf2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203cf5:	c9                   	leave  
c0203cf6:	c3                   	ret    

c0203cf7 <pdt_mapping_helper>:

static void pdt_mapping_helper(uint32_t pdt_vaddr){
c0203cf7:	55                   	push   %ebp
c0203cf8:	89 e5                	mov    %esp,%ebp
c0203cfa:	53                   	push   %ebx
c0203cfb:	83 ec 04             	sub    $0x4,%esp
c0203cfe:	e8 01 43 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203d03:	81 c3 fd 52 00 00    	add    $0x52fd,%ebx
    //copy length is 1024B
    //只映射后256项（共1024项 ，每项4B，共映射1024B）
    memcpy(pdt_vaddr+0xC00,get_pde(0xC0000000),1024);
c0203d09:	83 ec 0c             	sub    $0xc,%esp
c0203d0c:	68 00 00 00 c0       	push   $0xc0000000
c0203d11:	e8 d1 27 00 00       	call   c02064e7 <get_pde>
c0203d16:	83 c4 10             	add    $0x10,%esp
c0203d19:	89 c2                	mov    %eax,%edx
c0203d1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0203d1e:	05 00 0c 00 00       	add    $0xc00,%eax
c0203d23:	83 ec 04             	sub    $0x4,%esp
c0203d26:	68 00 04 00 00       	push   $0x400
c0203d2b:	52                   	push   %edx
c0203d2c:	50                   	push   %eax
c0203d2d:	e8 96 3c 00 00       	call   c02079c8 <memcpy>
c0203d32:	83 c4 10             	add    $0x10,%esp

    //memcpy(pdt_vaddr,get_pde(0x0),4);
}
c0203d35:	90                   	nop
c0203d36:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203d39:	c9                   	leave  
c0203d3a:	c3                   	ret    

c0203d3b <mapping_last_pde>:

static void mapping_last_pde(uint32_t  last_pte_vaddr,uint32_t pdt_paddr){
c0203d3b:	55                   	push   %ebp
c0203d3c:	89 e5                	mov    %esp,%ebp
c0203d3e:	83 ec 10             	sub    $0x10,%esp
c0203d41:	e8 ba 42 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203d46:	05 ba 52 00 00       	add    $0x52ba,%eax
    uint32_t* ptr = (uint32_t*)last_pte_vaddr;
c0203d4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0203d4e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    *ptr = (pdt_paddr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c0203d51:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203d54:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0203d59:	8d 90 03 01 00 00    	lea    0x103(%eax),%edx
c0203d5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203d62:	89 10                	mov    %edx,(%eax)
}
c0203d64:	90                   	nop
c0203d65:	c9                   	leave  
c0203d66:	c3                   	ret    

c0203d67 <pt_release_helper>:

static void pt_release_helper(uint32_t pdt_vaddr){
c0203d67:	55                   	push   %ebp
c0203d68:	89 e5                	mov    %esp,%ebp
c0203d6a:	e8 91 42 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203d6f:	05 91 52 00 00       	add    $0x5291,%eax
    //PAGE DIRECTORY DESC
}
c0203d74:	90                   	nop
c0203d75:	5d                   	pop    %ebp
c0203d76:	c3                   	ret    

c0203d77 <create_user_task_pdt>:

//create pdt for user_task
//do two things: 1.alloc virtual memory from kern vm pool
//               2.mapping 3-4GB to kern page table (by using pointer)
uint32_t create_user_task_pdt(){
c0203d77:	55                   	push   %ebp
c0203d78:	89 e5                	mov    %esp,%ebp
c0203d7a:	53                   	push   %ebx
c0203d7b:	83 ec 14             	sub    $0x14,%esp
c0203d7e:	e8 81 42 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203d83:	81 c3 7d 52 00 00    	add    $0x527d,%ebx
    uint32_t pdt_vaddr = vmm_kern_alloc();
c0203d89:	e8 5d 28 00 00       	call   c02065eb <vmm_kern_alloc>
c0203d8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pdt_vaddr==KERN_VMM_ALLOC_ERRO){
c0203d91:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0203d95:	75 07                	jne    c0203d9e <create_user_task_pdt+0x27>
        return USER_TASK_INIT_ERRO;
c0203d97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0203d9c:	eb 4c                	jmp    c0203dea <create_user_task_pdt+0x73>
    }   
    else{
        //clear mem
        memset((void *) pdt_vaddr, 0, 0x1000);
c0203d9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203da1:	83 ec 04             	sub    $0x4,%esp
c0203da4:	68 00 10 00 00       	push   $0x1000
c0203da9:	6a 00                	push   $0x0
c0203dab:	50                   	push   %eax
c0203dac:	e8 46 3c 00 00       	call   c02079f7 <memset>
c0203db1:	83 c4 10             	add    $0x10,%esp
        //mapping......
        pdt_mapping_helper(pdt_vaddr);
c0203db4:	83 ec 0c             	sub    $0xc,%esp
c0203db7:	ff 75 f4             	pushl  -0xc(%ebp)
c0203dba:	e8 38 ff ff ff       	call   c0203cf7 <pdt_mapping_helper>
c0203dbf:	83 c4 10             	add    $0x10,%esp
        //must mapping last page!
        mapping_last_pde(pdt_vaddr+0x1000-4,vmm_v2p(pdt_vaddr));
c0203dc2:	83 ec 0c             	sub    $0xc,%esp
c0203dc5:	ff 75 f4             	pushl  -0xc(%ebp)
c0203dc8:	e8 9d 29 00 00       	call   c020676a <vmm_v2p>
c0203dcd:	83 c4 10             	add    $0x10,%esp
c0203dd0:	89 c2                	mov    %eax,%edx
c0203dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203dd5:	05 fc 0f 00 00       	add    $0xffc,%eax
c0203dda:	83 ec 08             	sub    $0x8,%esp
c0203ddd:	52                   	push   %edx
c0203dde:	50                   	push   %eax
c0203ddf:	e8 57 ff ff ff       	call   c0203d3b <mapping_last_pde>
c0203de4:	83 c4 10             	add    $0x10,%esp
    }
    return pdt_vaddr;
c0203de7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0203dea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ded:	c9                   	leave  
c0203dee:	c3                   	ret    

c0203def <release_user_task_pdt>:

//release the mem when release user task
//do two things:  1.release the kern mem of page table
//                2.release the kern mem of page dir table(this is alloc when the task creates)
void release_user_task_pdt(uint32_t pdt_vaddr){
c0203def:	55                   	push   %ebp
c0203df0:	89 e5                	mov    %esp,%ebp
c0203df2:	53                   	push   %ebx
c0203df3:	83 ec 04             	sub    $0x4,%esp
c0203df6:	e8 09 42 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203dfb:	81 c3 05 52 00 00    	add    $0x5205,%ebx
    pt_release_helper(pdt_vaddr);
c0203e01:	ff 75 08             	pushl  0x8(%ebp)
c0203e04:	e8 5e ff ff ff       	call   c0203d67 <pt_release_helper>
c0203e09:	83 c4 04             	add    $0x4,%esp
    vmm_kern_release_one_page(pdt_vaddr);
c0203e0c:	83 ec 0c             	sub    $0xc,%esp
c0203e0f:	ff 75 08             	pushl  0x8(%ebp)
c0203e12:	e8 97 28 00 00       	call   c02066ae <vmm_kern_release_one_page>
c0203e17:	83 c4 10             	add    $0x10,%esp
}
c0203e1a:	90                   	nop
c0203e1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203e1e:	c9                   	leave  
c0203e1f:	c3                   	ret    

c0203e20 <_active_pdt>:

//页表装载------------------------------
static void _active_pdt(uint32_t pdt_paddr){
c0203e20:	55                   	push   %ebp
c0203e21:	89 e5                	mov    %esp,%ebp
c0203e23:	e8 d8 41 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203e28:	05 d8 51 00 00       	add    $0x51d8,%eax
    //内联汇编   修改cr3
    asm volatile("movl %0, %%cr3" : : "r" (pdt_paddr) : "memory");
c0203e2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0203e30:	0f 22 d8             	mov    %eax,%cr3
}
c0203e33:	90                   	nop
c0203e34:	5d                   	pop    %ebp
c0203e35:	c3                   	ret    

c0203e36 <_active_kern_pdt>:

static void _active_kern_pdt(){
c0203e36:	55                   	push   %ebp
c0203e37:	89 e5                	mov    %esp,%ebp
c0203e39:	e8 c2 41 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203e3e:	05 c2 51 00 00       	add    $0x51c2,%eax
    _active_pdt(kern_dir_table_paddr);
c0203e43:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0203e49:	8b 00                	mov    (%eax),%eax
c0203e4b:	50                   	push   %eax
c0203e4c:	e8 cf ff ff ff       	call   c0203e20 <_active_pdt>
c0203e51:	83 c4 04             	add    $0x4,%esp
}
c0203e54:	90                   	nop
c0203e55:	c9                   	leave  
c0203e56:	c3                   	ret    

c0203e57 <_active_user_pdt>:

static void _active_user_pdt(uint32_t pdt_paddr){
c0203e57:	55                   	push   %ebp
c0203e58:	89 e5                	mov    %esp,%ebp
c0203e5a:	e8 a1 41 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203e5f:	05 a1 51 00 00       	add    $0x51a1,%eax
    //printk("\n0x%h",pdt_paddr);
    //STOP(LOG_SRC_USER_TASK,"STOP POINT1");
    _active_pdt(pdt_paddr);
c0203e64:	ff 75 08             	pushl  0x8(%ebp)
c0203e67:	e8 b4 ff ff ff       	call   c0203e20 <_active_pdt>
c0203e6c:	83 c4 04             	add    $0x4,%esp
}
c0203e6f:	90                   	nop
c0203e70:	c9                   	leave  
c0203e71:	c3                   	ret    

c0203e72 <active_task>:
//页表装载------------------------------

//在调度task之前需要执行此函数激活task的页表以及进程的tss
void active_task(TCB_t* tcb_ptr){
c0203e72:	55                   	push   %ebp
c0203e73:	89 e5                	mov    %esp,%ebp
c0203e75:	53                   	push   %ebx
c0203e76:	83 ec 14             	sub    $0x14,%esp
c0203e79:	e8 86 41 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203e7e:	81 c3 82 51 00 00    	add    $0x5182,%ebx
    if(tcb_ptr->is_kern_thread){
c0203e84:	8b 45 08             	mov    0x8(%ebp),%eax
c0203e87:	8b 40 20             	mov    0x20(%eax),%eax
c0203e8a:	85 c0                	test   %eax,%eax
c0203e8c:	74 07                	je     c0203e95 <active_task+0x23>
        //内核线程同样需要重新装载页表      否者可能会访问到上一个用户进程的用户虚拟空间（0-3GB）
        _active_kern_pdt();
c0203e8e:	e8 a3 ff ff ff       	call   c0203e36 <_active_kern_pdt>
        }
        _active_user_pdt(user_task_pdt_paddr);
        //对于用户进程 需要更新tss的0特权级栈地址
        tss_update(tcb_ptr);
    }
}
c0203e93:	eb 50                	jmp    c0203ee5 <active_task+0x73>
        uint32_t user_task_pdt_paddr = vmm_v2p(tcb_ptr->pdt_vaddr);
c0203e95:	8b 45 08             	mov    0x8(%ebp),%eax
c0203e98:	8b 40 30             	mov    0x30(%eax),%eax
c0203e9b:	83 ec 0c             	sub    $0xc,%esp
c0203e9e:	50                   	push   %eax
c0203e9f:	e8 c6 28 00 00       	call   c020676a <vmm_v2p>
c0203ea4:	83 c4 10             	add    $0x10,%esp
c0203ea7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(user_task_pdt_paddr==V2P_ERROR){
c0203eaa:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0203eae:	75 19                	jne    c0203ec9 <active_task+0x57>
            STOP(LOG_SRC_USER_TASK,"V2P Error!STOP!");
c0203eb0:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0203eb6:	83 ec 08             	sub    $0x8,%esp
c0203eb9:	8d 93 54 01 00 00    	lea    0x154(%ebx),%edx
c0203ebf:	52                   	push   %edx
c0203ec0:	50                   	push   %eax
c0203ec1:	e8 82 19 00 00       	call   c0205848 <stop_kern>
c0203ec6:	83 c4 10             	add    $0x10,%esp
        _active_user_pdt(user_task_pdt_paddr);
c0203ec9:	83 ec 0c             	sub    $0xc,%esp
c0203ecc:	ff 75 f4             	pushl  -0xc(%ebp)
c0203ecf:	e8 83 ff ff ff       	call   c0203e57 <_active_user_pdt>
c0203ed4:	83 c4 10             	add    $0x10,%esp
        tss_update(tcb_ptr);
c0203ed7:	83 ec 0c             	sub    $0xc,%esp
c0203eda:	ff 75 08             	pushl  0x8(%ebp)
c0203edd:	e8 69 18 00 00       	call   c020574b <tss_update>
c0203ee2:	83 c4 10             	add    $0x10,%esp
}
c0203ee5:	90                   	nop
c0203ee6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ee9:	c9                   	leave  
c0203eea:	c3                   	ret    

c0203eeb <start_user_task>:


//这个函数作为进程创建以后的线程执行的第一个函数   在这个函数中 会根据输入的目标function或者filename名字加载相应的用户进程，执行进程的初始化，最后执行伪中断退出到达3特权级
void start_user_task(start_user_task_params_t* params_ptr){
c0203eeb:	55                   	push   %ebp
c0203eec:	89 e5                	mov    %esp,%ebp
c0203eee:	53                   	push   %ebx
c0203eef:	83 ec 64             	sub    $0x64,%esp
c0203ef2:	e8 0d 41 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203ef7:	81 c3 09 51 00 00    	add    $0x5109,%ebx
    if(params_ptr->is_from_file){
c0203efd:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f00:	8b 00                	mov    (%eax),%eax
c0203f02:	85 c0                	test   %eax,%eax
c0203f04:	74 1e                	je     c0203f24 <start_user_task+0x39>
        STOP(LOG_SRC_USER_TASK,"File System is not exits!STOP!");
c0203f06:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0203f0c:	83 ec 08             	sub    $0x8,%esp
c0203f0f:	8d 93 64 01 00 00    	lea    0x164(%ebx),%edx
c0203f15:	52                   	push   %edx
c0203f16:	50                   	push   %eax
c0203f17:	e8 2c 19 00 00       	call   c0205848 <stop_kern>
c0203f1c:	83 c4 10             	add    $0x10,%esp
c0203f1f:	e9 45 01 00 00       	jmp    c0204069 <start_user_task+0x17e>
    }
    else{
        //检查function是否为NULL
        if(params_ptr->function == NULL){
c0203f24:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f27:	8b 40 04             	mov    0x4(%eax),%eax
c0203f2a:	85 c0                	test   %eax,%eax
c0203f2c:	0f 84 36 01 00 00    	je     c0204068 <start_user_task+0x17d>
            goto error_out;
        }
        else{
            //进行jmp 3级特权中断栈填充
            TCB_t * cur_tcb = get_running_progress();
c0203f32:	e8 f2 f7 ff ff       	call   c0203729 <get_running_progress>
c0203f37:	89 45 f4             	mov    %eax,-0xc(%ebp)
            uint32_t kern_stack_max_addr = cur_tcb->page_addr + cur_tcb->page_counte*PAGE_SIZE;
c0203f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203f3d:	8b 50 1c             	mov    0x1c(%eax),%edx
c0203f40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203f43:	8b 40 18             	mov    0x18(%eax),%eax
c0203f46:	c1 e0 0c             	shl    $0xc,%eax
c0203f49:	01 d0                	add    %edx,%eax
c0203f4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
//            interrupt_stack_t  * int_stack = (interrupt_stack_t*)(kern_stack_max_addr - sizeof(interrupt_stack_t));
            interrupt_stack_t int_stack_temp;
            int_stack_temp.int_no_1 = 1;
c0203f4e:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
            int_stack_temp.args = (void * )0;
c0203f55:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
            int_stack_temp.gs=0;
c0203f5c:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
            int_stack_temp.fs=0;
c0203f63:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
            int_stack_temp.es=0;
c0203f6a:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
            int_stack_temp.edi = 0;
c0203f71:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
            int_stack_temp.esi = 0;
c0203f78:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
            int_stack_temp.ebp =0;
c0203f7f:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
            int_stack_temp.esp_duplicate = 0;
c0203f86:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
            int_stack_temp.ebx=0;
c0203f8d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
            int_stack_temp.edx=0;
c0203f94:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
            int_stack_temp.ecx=0;
c0203f9b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
            int_stack_temp.eax=0;
c0203fa2:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
            int_stack_temp.int_no_2=0;
c0203fa9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	        int_stack_temp.error_no=0;
c0203fb0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	        int_stack_temp.eip=params_ptr->function;
c0203fb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0203fba:	8b 40 04             	mov    0x4(%eax),%eax
c0203fbd:	89 45 d8             	mov    %eax,-0x28(%ebp)
	        int_stack_temp.cs=SELECTOR_USER_CODE_MEM&0x0000FFFF;      //填充为用户级别
c0203fc0:	c7 c0 3e 32 20 c0    	mov    $0xc020323e,%eax
c0203fc6:	0f b7 00             	movzwl (%eax),%eax
c0203fc9:	0f b7 c0             	movzwl %ax,%eax
c0203fcc:	89 45 dc             	mov    %eax,-0x24(%ebp)
	        int_stack_temp.eflags =INTR_TO_LEVEL3_EFLAGS;
c0203fcf:	c7 45 e0 02 02 00 00 	movl   $0x202,-0x20(%ebp)
            //分配一页用于命令行参数以及function执行参数
            if(vmm_user_alloc_one_page(cur_tcb,0xC0000000-PAGE_SIZE)==USER_VMM_ALLOC_ERRO){
c0203fd6:	83 ec 08             	sub    $0x8,%esp
c0203fd9:	68 00 f0 ff bf       	push   $0xbffff000
c0203fde:	ff 75 f4             	pushl  -0xc(%ebp)
c0203fe1:	e8 e2 28 00 00       	call   c02068c8 <vmm_user_alloc_one_page>
c0203fe6:	83 c4 10             	add    $0x10,%esp
c0203fe9:	83 f8 ff             	cmp    $0xffffffff,%eax
c0203fec:	75 19                	jne    c0204007 <start_user_task+0x11c>
                STOP(LOG_SRC_USER_TASK,"Can`t Create User Task Args Page!STOP!");
c0203fee:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0203ff4:	83 ec 08             	sub    $0x8,%esp
c0203ff7:	8d 93 84 01 00 00    	lea    0x184(%ebx),%edx
c0203ffd:	52                   	push   %edx
c0203ffe:	50                   	push   %eax
c0203fff:	e8 44 18 00 00       	call   c0205848 <stop_kern>
c0204004:	83 c4 10             	add    $0x10,%esp
            }

            //分配一张用户页用于用户栈
            uint32_t user_stack_page = vmm_user_alloc_one_page(cur_tcb,0xC0000000-2*PAGE_SIZE);
c0204007:	83 ec 08             	sub    $0x8,%esp
c020400a:	68 00 e0 ff bf       	push   $0xbfffe000
c020400f:	ff 75 f4             	pushl  -0xc(%ebp)
c0204012:	e8 b1 28 00 00       	call   c02068c8 <vmm_user_alloc_one_page>
c0204017:	83 c4 10             	add    $0x10,%esp
c020401a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	        if(user_stack_page==USER_VMM_ALLOC_ERRO){
c020401d:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0204021:	75 19                	jne    c020403c <start_user_task+0x151>
                STOP(LOG_SRC_USER_TASK,"Can`t Create User Task Stack Page!STOP!");
c0204023:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0204029:	83 ec 08             	sub    $0x8,%esp
c020402c:	8d 93 ac 01 00 00    	lea    0x1ac(%ebx),%edx
c0204032:	52                   	push   %edx
c0204033:	50                   	push   %eax
c0204034:	e8 0f 18 00 00       	call   c0205848 <stop_kern>
c0204039:	83 c4 10             	add    $0x10,%esp
            }
            int_stack_temp.esp = user_stack_page+PAGE_SIZE;
c020403c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020403f:	05 00 10 00 00       	add    $0x1000,%eax
c0204044:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	        int_stack_temp.ss=SELECTOR_USER_DATA_MEM&0x0000FFFF;
c0204047:	c7 c0 40 32 20 c0    	mov    $0xc0203240,%eax
c020404d:	0f b7 00             	movzwl (%eax),%eax
c0204050:	0f b7 c0             	movzwl %ax,%eax
c0204053:	89 45 e8             	mov    %eax,-0x18(%ebp)
	        //执行iret伪装中断返回
            //执行了jmp3之后 内核栈会被重置回收 之后本进程使用内核栈都是从栈最大处开始使用
            exit_int((void*)&int_stack_temp);
c0204056:	83 ec 0c             	sub    $0xc,%esp
c0204059:	8d 45 9c             	lea    -0x64(%ebp),%eax
c020405c:	50                   	push   %eax
c020405d:	e8 83 f1 ff ff       	call   c02031e5 <exit_int>
c0204062:	83 c4 10             	add    $0x10,%esp
            return;
c0204065:	90                   	nop
c0204066:	eb 1a                	jmp    c0204082 <start_user_task+0x197>
            goto error_out;
c0204068:	90                   	nop
        }       
    }

    error_out:
        STOP(LOG_SRC_USER_TASK,"Main Function is NULL when create user task by function input!STOP!");
c0204069:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c020406f:	83 ec 08             	sub    $0x8,%esp
c0204072:	8d 93 d4 01 00 00    	lea    0x1d4(%ebx),%edx
c0204078:	52                   	push   %edx
c0204079:	50                   	push   %eax
c020407a:	e8 c9 17 00 00       	call   c0205848 <stop_kern>
c020407f:	83 c4 10             	add    $0x10,%esp
}
c0204082:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0204085:	c9                   	leave  
c0204086:	c3                   	ret    

c0204087 <create_user_task>:

// 用于创建用户进程对应的线程   并且分配相应的用户进程资源
//args是start_user_task_params_t*类型的！！！
//注意：args中的内容不能被回收！！！也就是说调用create_user_task的函数不能退出，只能等待
void create_user_task(uint32_t tid,start_user_task_params_t*args){
c0204087:	55                   	push   %ebp
c0204088:	89 e5                	mov    %esp,%ebp
c020408a:	53                   	push   %ebx
c020408b:	83 ec 24             	sub    $0x24,%esp
c020408e:	e8 71 3f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0204093:	81 c3 6d 4f 00 00    	add    $0x4f6d,%ebx
	bool is_kern_thread =False;
c0204099:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bitmap user_vmm_pool = create_user_task_bitmap();
c02040a0:	8d 45 dc             	lea    -0x24(%ebp),%eax
c02040a3:	83 ec 0c             	sub    $0xc,%esp
c02040a6:	50                   	push   %eax
c02040a7:	e8 1d fb ff ff       	call   c0203bc9 <create_user_task_bitmap>
c02040ac:	83 c4 0c             	add    $0xc,%esp
	uint32_t pdt_vaddr = create_user_task_pdt();
c02040af:	e8 c3 fc ff ff       	call   c0203d77 <create_user_task_pdt>
c02040b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pdt_vaddr==USER_TASK_INIT_ERRO){
c02040b7:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c02040bb:	75 19                	jne    c02040d6 <create_user_task+0x4f>
        STOP(LOG_SRC_USER_TASK,"Can`t Create New User Task Because Of Error When Alloc User Pdt!STOP!");
c02040bd:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c02040c3:	83 ec 08             	sub    $0x8,%esp
c02040c6:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
c02040cc:	52                   	push   %edx
c02040cd:	50                   	push   %eax
c02040ce:	e8 75 17 00 00       	call   c0205848 <stop_kern>
c02040d3:	83 c4 10             	add    $0x10,%esp
    }
	uint32_t page_counte = 1;
c02040d6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	uint32_t TCB_page = vmm_kern_alloc();
c02040dd:	e8 09 25 00 00       	call   c02065eb <vmm_kern_alloc>
c02040e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(TCB_page==KERN_VMM_ALLOC_ERRO){
c02040e5:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
c02040e9:	75 19                	jne    c0204104 <create_user_task+0x7d>
        STOP(LOG_SRC_USER_TASK,"Can`t Create New User Task Because Of Error When Alloc TCB Page From Kernel VMM!STOP!");
c02040eb:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c02040f1:	83 ec 08             	sub    $0x8,%esp
c02040f4:	8d 93 60 02 00 00    	lea    0x260(%ebx),%edx
c02040fa:	52                   	push   %edx
c02040fb:	50                   	push   %eax
c02040fc:	e8 47 17 00 00       	call   c0205848 <stop_kern>
c0204101:	83 c4 10             	add    $0x10,%esp
    }
	create_thread(tid,start_user_task,(void*)args,TCB_page,page_counte,is_kern_thread,user_vmm_pool,pdt_vaddr);
c0204104:	83 ec 08             	sub    $0x8,%esp
c0204107:	ff 75 f0             	pushl  -0x10(%ebp)
c020410a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020410d:	ff 75 e0             	pushl  -0x20(%ebp)
c0204110:	ff 75 dc             	pushl  -0x24(%ebp)
c0204113:	ff 75 f4             	pushl  -0xc(%ebp)
c0204116:	ff 75 ec             	pushl  -0x14(%ebp)
c0204119:	ff 75 e8             	pushl  -0x18(%ebp)
c020411c:	ff 75 0c             	pushl  0xc(%ebp)
c020411f:	8d 83 eb ae ff ff    	lea    -0x5115(%ebx),%eax
c0204125:	50                   	push   %eax
c0204126:	ff 75 08             	pushl  0x8(%ebp)
c0204129:	e8 a0 f7 ff ff       	call   c02038ce <create_thread>
c020412e:	83 c4 30             	add    $0x30,%esp
}
c0204131:	90                   	nop
c0204132:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0204135:	c9                   	leave  
c0204136:	c3                   	ret    

c0204137 <change_esp>:
void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte,bool is_kern_thread,bitmap user_vmm_pool,uint32_t pdt_vaddr);


void change_esp(uint32_t stack_top_addr){
c0204137:	55                   	push   %ebp
c0204138:	89 e5                	mov    %esp,%ebp
c020413a:	e8 c1 3e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020413f:	05 c1 4e 00 00       	add    $0x4ec1,%eax

}
c0204144:	90                   	nop
c0204145:	5d                   	pop    %ebp
c0204146:	c3                   	ret    

c0204147 <handle_int_exit_stack>:

//用于清理中断栈 并且实现中断返回
//这个函数是创建user_task时跳转3特权级时调用 在interrupt中的清理中断栈实际上是在interrupt中实现的
//调用此函数之前需要把栈顶指针置于user_task中interrupt_stack顶
void handle_int_exit_stack(interrupt_stack_t * stack_top_ptr){
c0204147:	55                   	push   %ebp
c0204148:	89 e5                	mov    %esp,%ebp
c020414a:	e8 b1 3e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020414f:	05 b1 4e 00 00       	add    $0x4eb1,%eax

}
c0204154:	90                   	nop
c0204155:	5d                   	pop    %ebp
c0204156:	c3                   	ret    

c0204157 <user_task_test>:



void user_task_test(){
c0204157:	55                   	push   %ebp
c0204158:	89 e5                	mov    %esp,%ebp
c020415a:	53                   	push   %ebx
c020415b:	83 ec 14             	sub    $0x14,%esp
c020415e:	e8 a1 3e 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0204163:	81 c3 9d 4e 00 00    	add    $0x4e9d,%ebx
    for(int i=0;i<1000;i++){
c0204169:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0204170:	eb 3c                	jmp    c02041ae <user_task_test+0x57>
        printk("running!%d",i);
c0204172:	83 ec 08             	sub    $0x8,%esp
c0204175:	ff 75 f4             	pushl  -0xc(%ebp)
c0204178:	8d 83 b6 02 00 00    	lea    0x2b6(%ebx),%eax
c020417e:	50                   	push   %eax
c020417f:	e8 b0 31 00 00       	call   c0207334 <printk>
c0204184:	83 c4 10             	add    $0x10,%esp
        bitmap bm = create_user_task_bitmap();
c0204187:	8d 45 e8             	lea    -0x18(%ebp),%eax
c020418a:	83 ec 0c             	sub    $0xc,%esp
c020418d:	50                   	push   %eax
c020418e:	e8 36 fa ff ff       	call   c0203bc9 <create_user_task_bitmap>
c0204193:	83 c4 0c             	add    $0xc,%esp
        release_user_task_bitmap(bm);
c0204196:	83 ec 04             	sub    $0x4,%esp
c0204199:	ff 75 f0             	pushl  -0x10(%ebp)
c020419c:	ff 75 ec             	pushl  -0x14(%ebp)
c020419f:	ff 75 e8             	pushl  -0x18(%ebp)
c02041a2:	e8 04 fb ff ff       	call   c0203cab <release_user_task_bitmap>
c02041a7:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<1000;i++){
c02041aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02041ae:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c02041b5:	7e bb                	jle    c0204172 <user_task_test+0x1b>
        //uint32_t addr =create_user_task_pdt();
        //release_user_task_pdt(addr);
    }
c02041b7:	90                   	nop
c02041b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02041bb:	c9                   	leave  
c02041bc:	c3                   	ret    

c02041bd <pmm_page_no_to_addr>:
pm_page_t *page_array = (pm_page_t*)0xC0000100;       
pm_multi_link_t * MULTI_LINK;   //用大写来表示很重要 并且定义为结构体指针，用->更加美观了～
pm_multi_link_t multi_link_struct={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
pm_page_t * SINGLE_LINK = NULL ;
//获取page编号对应的addr
static uint32_t pmm_page_no_to_addr(uint32_t page_no){
c02041bd:	55                   	push   %ebp
c02041be:	89 e5                	mov    %esp,%ebp
c02041c0:	e8 3b 3e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02041c5:	05 3b 4e 00 00       	add    $0x4e3b,%eax
	return (page_no<<12)+pmm_page_start;
c02041ca:	8b 55 08             	mov    0x8(%ebp),%edx
c02041cd:	c1 e2 0c             	shl    $0xc,%edx
c02041d0:	8b 80 90 90 08 00    	mov    0x89090(%eax),%eax
c02041d6:	01 d0                	add    %edx,%eax
}
c02041d8:	5d                   	pop    %ebp
c02041d9:	c3                   	ret    

c02041da <addr_to_pmm_page_no>:

//addr转为page_no
static uint32_t addr_to_pmm_page_no(uint32_t addr){
c02041da:	55                   	push   %ebp
c02041db:	89 e5                	mov    %esp,%ebp
c02041dd:	e8 1e 3e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02041e2:	05 1e 4e 00 00       	add    $0x4e1e,%eax
	return (addr-pmm_page_start)>>12;
c02041e7:	8b 80 90 90 08 00    	mov    0x89090(%eax),%eax
c02041ed:	8b 55 08             	mov    0x8(%ebp),%edx
c02041f0:	29 c2                	sub    %eax,%edx
c02041f2:	89 d0                	mov    %edx,%eax
c02041f4:	c1 e8 0c             	shr    $0xc,%eax
}
c02041f7:	5d                   	pop    %ebp
c02041f8:	c3                   	ret    

c02041f9 <c_to_uint32>:

//将 page_c_t枚举类型转化为对应的块大小 如 (page_c_t)_256——> (uint32_t)256
static uint32_t c_to_uint32(page_c_t ph){
c02041f9:	55                   	push   %ebp
c02041fa:	89 e5                	mov    %esp,%ebp
c02041fc:	83 ec 10             	sub    $0x10,%esp
c02041ff:	e8 fc 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204204:	05 fc 4d 00 00       	add    $0x4dfc,%eax
	uint32_t re = 1;
c0204209:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
	re = re<<ph;
c0204210:	8b 45 08             	mov    0x8(%ebp),%eax
c0204213:	89 c1                	mov    %eax,%ecx
c0204215:	d3 65 fc             	shll   %cl,-0x4(%ebp)
	return re;
c0204218:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c020421b:	c9                   	leave  
c020421c:	c3                   	ret    

c020421d <get_partner_page_no>:

static uint32_t get_partner_page_no(uint32_t page_no,page_c_t type){
c020421d:	55                   	push   %ebp
c020421e:	89 e5                	mov    %esp,%ebp
c0204220:	83 ec 10             	sub    $0x10,%esp
c0204223:	e8 d8 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204228:	05 d8 4d 00 00       	add    $0x4dd8,%eax
	//--|--|--|--|--|--| 如图 必须整数倍或者0
	uint32_t v1 = c_to_uint32(type);
c020422d:	ff 75 0c             	pushl  0xc(%ebp)
c0204230:	e8 c4 ff ff ff       	call   c02041f9 <c_to_uint32>
c0204235:	83 c4 04             	add    $0x4,%esp
c0204238:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t v2 = 2*v1;
c020423b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020423e:	01 c0                	add    %eax,%eax
c0204240:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if((page_no - v1)%v2 == 0)
c0204243:	8b 45 08             	mov    0x8(%ebp),%eax
c0204246:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0204249:	ba 00 00 00 00       	mov    $0x0,%edx
c020424e:	f7 75 f8             	divl   -0x8(%ebp)
c0204251:	89 d0                	mov    %edx,%eax
c0204253:	85 c0                	test   %eax,%eax
c0204255:	75 08                	jne    c020425f <get_partner_page_no+0x42>
		return page_no-v1;
c0204257:	8b 45 08             	mov    0x8(%ebp),%eax
c020425a:	2b 45 fc             	sub    -0x4(%ebp),%eax
c020425d:	eb 08                	jmp    c0204267 <get_partner_page_no+0x4a>
	else
		return page_no+v1;
c020425f:	8b 55 08             	mov    0x8(%ebp),%edx
c0204262:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204265:	01 d0                	add    %edx,%eax
}
c0204267:	c9                   	leave  
c0204268:	c3                   	ret    

c0204269 <append_block>:


//向链表添加块（用于初始化链表以及free后添加块）
//此处可以使用##连接宏（但是我偏不）
static void append_block(int page_no,page_c_t c){
c0204269:	55                   	push   %ebp
c020426a:	89 e5                	mov    %esp,%ebp
c020426c:	53                   	push   %ebx
c020426d:	83 ec 10             	sub    $0x10,%esp
c0204270:	e8 8b 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204275:	05 8b 4d 00 00       	add    $0x4d8b,%eax
	page_array[page_no].next = NULL ;     //一定要设置 新加入块的下个指针为NULL
c020427a:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204280:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204283:	89 ca                	mov    %ecx,%edx
c0204285:	01 d2                	add    %edx,%edx
c0204287:	01 ca                	add    %ecx,%edx
c0204289:	c1 e2 02             	shl    $0x2,%edx
c020428c:	01 da                	add    %ebx,%edx
c020428e:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	pm_page_t * header;
	switch(c){
c0204295:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204299:	0f 87 cd 02 00 00    	ja     c020456c <.L39+0x22>
c020429f:	8b 55 0c             	mov    0xc(%ebp),%edx
c02042a2:	c1 e2 02             	shl    $0x2,%edx
c02042a5:	8b 94 02 c4 02 00 00 	mov    0x2c4(%edx,%eax,1),%edx
c02042ac:	01 c2                	add    %eax,%edx
c02042ae:	ff e2                	jmp    *%edx

c02042b0 <.L12>:
		case _1:
			header = MULTI_LINK ->_1;
c02042b0:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02042b6:	8b 12                	mov    (%edx),%edx
c02042b8:	8b 12                	mov    (%edx),%edx
c02042ba:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02042bd:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02042c1:	0f 85 86 02 00 00    	jne    c020454d <.L39+0x3>
				MULTI_LINK ->_1 = &(page_array[page_no]);
c02042c7:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02042cd:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02042d0:	89 ca                	mov    %ecx,%edx
c02042d2:	01 d2                	add    %edx,%edx
c02042d4:	01 ca                	add    %ecx,%edx
c02042d6:	c1 e2 02             	shl    $0x2,%edx
c02042d9:	89 d1                	mov    %edx,%ecx
c02042db:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02042e1:	8b 12                	mov    (%edx),%edx
c02042e3:	01 d9                	add    %ebx,%ecx
c02042e5:	89 0a                	mov    %ecx,(%edx)
			break;
c02042e7:	e9 61 02 00 00       	jmp    c020454d <.L39+0x3>

c02042ec <.L14>:
		case _2:
			header = MULTI_LINK ->_2;
c02042ec:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02042f2:	8b 12                	mov    (%edx),%edx
c02042f4:	8b 52 04             	mov    0x4(%edx),%edx
c02042f7:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02042fa:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02042fe:	0f 85 4c 02 00 00    	jne    c0204550 <.L39+0x6>
				MULTI_LINK ->_2 = &(page_array[page_no]);
c0204304:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c020430a:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020430d:	89 ca                	mov    %ecx,%edx
c020430f:	01 d2                	add    %edx,%edx
c0204311:	01 ca                	add    %ecx,%edx
c0204313:	c1 e2 02             	shl    $0x2,%edx
c0204316:	89 d1                	mov    %edx,%ecx
c0204318:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020431e:	8b 12                	mov    (%edx),%edx
c0204320:	01 d9                	add    %ebx,%ecx
c0204322:	89 4a 04             	mov    %ecx,0x4(%edx)
			break;
c0204325:	e9 26 02 00 00       	jmp    c0204550 <.L39+0x6>

c020432a <.L15>:
		case _4:
			header = MULTI_LINK ->_4;
c020432a:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204330:	8b 12                	mov    (%edx),%edx
c0204332:	8b 52 08             	mov    0x8(%edx),%edx
c0204335:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204338:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020433c:	0f 85 11 02 00 00    	jne    c0204553 <.L39+0x9>
				MULTI_LINK ->_4 = &(page_array[page_no]);
c0204342:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204348:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020434b:	89 ca                	mov    %ecx,%edx
c020434d:	01 d2                	add    %edx,%edx
c020434f:	01 ca                	add    %ecx,%edx
c0204351:	c1 e2 02             	shl    $0x2,%edx
c0204354:	89 d1                	mov    %edx,%ecx
c0204356:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020435c:	8b 12                	mov    (%edx),%edx
c020435e:	01 d9                	add    %ebx,%ecx
c0204360:	89 4a 08             	mov    %ecx,0x8(%edx)
			break;
c0204363:	e9 eb 01 00 00       	jmp    c0204553 <.L39+0x9>

c0204368 <.L16>:
		case _8:
			header = MULTI_LINK ->_8;
c0204368:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020436e:	8b 12                	mov    (%edx),%edx
c0204370:	8b 52 0c             	mov    0xc(%edx),%edx
c0204373:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204376:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020437a:	0f 85 d6 01 00 00    	jne    c0204556 <.L39+0xc>
				MULTI_LINK ->_8 = &(page_array[page_no]);
c0204380:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204386:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204389:	89 ca                	mov    %ecx,%edx
c020438b:	01 d2                	add    %edx,%edx
c020438d:	01 ca                	add    %ecx,%edx
c020438f:	c1 e2 02             	shl    $0x2,%edx
c0204392:	89 d1                	mov    %edx,%ecx
c0204394:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020439a:	8b 12                	mov    (%edx),%edx
c020439c:	01 d9                	add    %ebx,%ecx
c020439e:	89 4a 0c             	mov    %ecx,0xc(%edx)
			break;
c02043a1:	e9 b0 01 00 00       	jmp    c0204556 <.L39+0xc>

c02043a6 <.L17>:
		case _16:
			header = MULTI_LINK ->_16;
c02043a6:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043ac:	8b 12                	mov    (%edx),%edx
c02043ae:	8b 52 10             	mov    0x10(%edx),%edx
c02043b1:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02043b4:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02043b8:	0f 85 9b 01 00 00    	jne    c0204559 <.L39+0xf>
				MULTI_LINK ->_16 = &(page_array[page_no]);
c02043be:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02043c4:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02043c7:	89 ca                	mov    %ecx,%edx
c02043c9:	01 d2                	add    %edx,%edx
c02043cb:	01 ca                	add    %ecx,%edx
c02043cd:	c1 e2 02             	shl    $0x2,%edx
c02043d0:	89 d1                	mov    %edx,%ecx
c02043d2:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043d8:	8b 12                	mov    (%edx),%edx
c02043da:	01 d9                	add    %ebx,%ecx
c02043dc:	89 4a 10             	mov    %ecx,0x10(%edx)
			break;
c02043df:	e9 75 01 00 00       	jmp    c0204559 <.L39+0xf>

c02043e4 <.L18>:
		case _32:
			header = MULTI_LINK ->_32;
c02043e4:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043ea:	8b 12                	mov    (%edx),%edx
c02043ec:	8b 52 14             	mov    0x14(%edx),%edx
c02043ef:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02043f2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02043f6:	0f 85 60 01 00 00    	jne    c020455c <.L39+0x12>
				MULTI_LINK ->_32 = &(page_array[page_no]);
c02043fc:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204402:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204405:	89 ca                	mov    %ecx,%edx
c0204407:	01 d2                	add    %edx,%edx
c0204409:	01 ca                	add    %ecx,%edx
c020440b:	c1 e2 02             	shl    $0x2,%edx
c020440e:	89 d1                	mov    %edx,%ecx
c0204410:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204416:	8b 12                	mov    (%edx),%edx
c0204418:	01 d9                	add    %ebx,%ecx
c020441a:	89 4a 14             	mov    %ecx,0x14(%edx)
			break;
c020441d:	e9 3a 01 00 00       	jmp    c020455c <.L39+0x12>

c0204422 <.L19>:
		case _64:
			header = MULTI_LINK ->_64;
c0204422:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204428:	8b 12                	mov    (%edx),%edx
c020442a:	8b 52 18             	mov    0x18(%edx),%edx
c020442d:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204430:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204434:	0f 85 25 01 00 00    	jne    c020455f <.L39+0x15>
				MULTI_LINK ->_64 = &(page_array[page_no]);
c020443a:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204440:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204443:	89 ca                	mov    %ecx,%edx
c0204445:	01 d2                	add    %edx,%edx
c0204447:	01 ca                	add    %ecx,%edx
c0204449:	c1 e2 02             	shl    $0x2,%edx
c020444c:	89 d1                	mov    %edx,%ecx
c020444e:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204454:	8b 12                	mov    (%edx),%edx
c0204456:	01 d9                	add    %ebx,%ecx
c0204458:	89 4a 18             	mov    %ecx,0x18(%edx)
			break;
c020445b:	e9 ff 00 00 00       	jmp    c020455f <.L39+0x15>

c0204460 <.L20>:
		case _128:
			header = MULTI_LINK ->_128;
c0204460:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204466:	8b 12                	mov    (%edx),%edx
c0204468:	8b 52 1c             	mov    0x1c(%edx),%edx
c020446b:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020446e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204472:	0f 85 ea 00 00 00    	jne    c0204562 <.L39+0x18>
				MULTI_LINK ->_128 = &(page_array[page_no]);
c0204478:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c020447e:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204481:	89 ca                	mov    %ecx,%edx
c0204483:	01 d2                	add    %edx,%edx
c0204485:	01 ca                	add    %ecx,%edx
c0204487:	c1 e2 02             	shl    $0x2,%edx
c020448a:	89 d1                	mov    %edx,%ecx
c020448c:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204492:	8b 12                	mov    (%edx),%edx
c0204494:	01 d9                	add    %ebx,%ecx
c0204496:	89 4a 1c             	mov    %ecx,0x1c(%edx)
			break;
c0204499:	e9 c4 00 00 00       	jmp    c0204562 <.L39+0x18>

c020449e <.L21>:
		case _256:
			header = MULTI_LINK ->_256;
c020449e:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02044a4:	8b 12                	mov    (%edx),%edx
c02044a6:	8b 52 20             	mov    0x20(%edx),%edx
c02044a9:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02044ac:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02044b0:	0f 85 af 00 00 00    	jne    c0204565 <.L39+0x1b>
				MULTI_LINK ->_256 = &(page_array[page_no]);
c02044b6:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02044bc:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02044bf:	89 ca                	mov    %ecx,%edx
c02044c1:	01 d2                	add    %edx,%edx
c02044c3:	01 ca                	add    %ecx,%edx
c02044c5:	c1 e2 02             	shl    $0x2,%edx
c02044c8:	89 d1                	mov    %edx,%ecx
c02044ca:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02044d0:	8b 12                	mov    (%edx),%edx
c02044d2:	01 d9                	add    %ebx,%ecx
c02044d4:	89 4a 20             	mov    %ecx,0x20(%edx)
			break;
c02044d7:	e9 89 00 00 00       	jmp    c0204565 <.L39+0x1b>

c02044dc <.L22>:
		case _512:
			header = MULTI_LINK ->_512;
c02044dc:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02044e2:	8b 12                	mov    (%edx),%edx
c02044e4:	8b 52 24             	mov    0x24(%edx),%edx
c02044e7:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02044ea:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02044ee:	75 78                	jne    c0204568 <.L39+0x1e>
				MULTI_LINK ->_512 = &(page_array[page_no]);
c02044f0:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02044f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02044f9:	89 ca                	mov    %ecx,%edx
c02044fb:	01 d2                	add    %edx,%edx
c02044fd:	01 ca                	add    %ecx,%edx
c02044ff:	c1 e2 02             	shl    $0x2,%edx
c0204502:	89 d1                	mov    %edx,%ecx
c0204504:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020450a:	8b 12                	mov    (%edx),%edx
c020450c:	01 d9                	add    %ebx,%ecx
c020450e:	89 4a 24             	mov    %ecx,0x24(%edx)
			break;
c0204511:	eb 55                	jmp    c0204568 <.L39+0x1e>

c0204513 <.L23>:
		case _1024:
			header = MULTI_LINK ->_1024;
c0204513:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204519:	8b 12                	mov    (%edx),%edx
c020451b:	8b 52 28             	mov    0x28(%edx),%edx
c020451e:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204521:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204525:	75 44                	jne    c020456b <.L39+0x21>
				MULTI_LINK ->_1024 = &(page_array[page_no]);
c0204527:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c020452d:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204530:	89 ca                	mov    %ecx,%edx
c0204532:	01 d2                	add    %edx,%edx
c0204534:	01 ca                	add    %ecx,%edx
c0204536:	c1 e2 02             	shl    $0x2,%edx
c0204539:	89 d1                	mov    %edx,%ecx
c020453b:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204541:	8b 12                	mov    (%edx),%edx
c0204543:	01 d9                	add    %ebx,%ecx
c0204545:	89 4a 28             	mov    %ecx,0x28(%edx)
			break;
c0204548:	eb 21                	jmp    c020456b <.L39+0x21>

c020454a <.L39>:
		case _erro:
			break;
c020454a:	90                   	nop
c020454b:	eb 1f                	jmp    c020456c <.L39+0x22>
			break;
c020454d:	90                   	nop
c020454e:	eb 1c                	jmp    c020456c <.L39+0x22>
			break;
c0204550:	90                   	nop
c0204551:	eb 19                	jmp    c020456c <.L39+0x22>
			break;
c0204553:	90                   	nop
c0204554:	eb 16                	jmp    c020456c <.L39+0x22>
			break;
c0204556:	90                   	nop
c0204557:	eb 13                	jmp    c020456c <.L39+0x22>
			break;
c0204559:	90                   	nop
c020455a:	eb 10                	jmp    c020456c <.L39+0x22>
			break;
c020455c:	90                   	nop
c020455d:	eb 0d                	jmp    c020456c <.L39+0x22>
			break;
c020455f:	90                   	nop
c0204560:	eb 0a                	jmp    c020456c <.L39+0x22>
			break;
c0204562:	90                   	nop
c0204563:	eb 07                	jmp    c020456c <.L39+0x22>
			break;
c0204565:	90                   	nop
c0204566:	eb 04                	jmp    c020456c <.L39+0x22>
			break;
c0204568:	90                   	nop
c0204569:	eb 01                	jmp    c020456c <.L39+0x22>
			break;
c020456b:	90                   	nop
	}
	if(header!=NULL){
c020456c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204570:	74 36                	je     c02045a8 <.L39+0x5e>
		pm_page_t * probe = header;
c0204572:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204575:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;(probe->next)!=NULL;probe = probe->next)
c0204578:	eb 09                	jmp    c0204583 <.L39+0x39>
c020457a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020457d:	8b 52 04             	mov    0x4(%edx),%edx
c0204580:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0204583:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204586:	8b 52 04             	mov    0x4(%edx),%edx
c0204589:	85 d2                	test   %edx,%edx
c020458b:	75 ed                	jne    c020457a <.L39+0x30>
			;
		(probe -> next)=&(page_array[page_no]);
c020458d:	8b 88 1c f0 ff ff    	mov    -0xfe4(%eax),%ecx
c0204593:	8b 55 08             	mov    0x8(%ebp),%edx
c0204596:	89 d0                	mov    %edx,%eax
c0204598:	01 c0                	add    %eax,%eax
c020459a:	01 d0                	add    %edx,%eax
c020459c:	c1 e0 02             	shl    $0x2,%eax
c020459f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c02045a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02045a5:	89 50 04             	mov    %edx,0x4(%eax)
	}
}
c02045a8:	90                   	nop
c02045a9:	83 c4 10             	add    $0x10,%esp
c02045ac:	5b                   	pop    %ebx
c02045ad:	5d                   	pop    %ebp
c02045ae:	c3                   	ret    

c02045af <pop_block>:

//从链表中取出一个块 链表为空返回ERRO_POP_BLOCK
static uint32_t pop_block(page_c_t c){
c02045af:	55                   	push   %ebp
c02045b0:	89 e5                	mov    %esp,%ebp
c02045b2:	83 ec 10             	sub    $0x10,%esp
c02045b5:	e8 46 3a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02045ba:	05 46 4a 00 00       	add    $0x4a46,%eax
	pm_page_t * header;
	switch(c){
c02045bf:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c02045c3:	0f 87 1e 03 00 00    	ja     c02048e7 <.L66+0x26>
c02045c9:	8b 55 08             	mov    0x8(%ebp),%edx
c02045cc:	c1 e2 02             	shl    $0x2,%edx
c02045cf:	8b 94 02 f4 02 00 00 	mov    0x2f4(%edx,%eax,1),%edx
c02045d6:	01 c2                	add    %eax,%edx
c02045d8:	ff e2                	jmp    *%edx

c02045da <.L54>:
		case _1:
			header = MULTI_LINK ->_1;
c02045da:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02045e0:	8b 12                	mov    (%edx),%edx
c02045e2:	8b 12                	mov    (%edx),%edx
c02045e4:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02045e7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02045eb:	75 0a                	jne    c02045f7 <.L54+0x1d>
				return ERRO_POP_BLOCK;
c02045ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02045f2:	e9 26 03 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c02045f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02045fa:	8b 52 04             	mov    0x4(%edx),%edx
c02045fd:	85 d2                	test   %edx,%edx
c02045ff:	0f 85 c3 02 00 00    	jne    c02048c8 <.L66+0x7>
				MULTI_LINK ->_1 =NULL;
c0204605:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020460b:	8b 00                	mov    (%eax),%eax
c020460d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				return header->page_no;
c0204613:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204616:	8b 00                	mov    (%eax),%eax
c0204618:	e9 00 03 00 00       	jmp    c020491d <.L66+0x5c>

c020461d <.L56>:
			}
			break;
		case _2:
			header = MULTI_LINK ->_2;
c020461d:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204623:	8b 12                	mov    (%edx),%edx
c0204625:	8b 52 04             	mov    0x4(%edx),%edx
c0204628:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c020462b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020462f:	75 0a                	jne    c020463b <.L56+0x1e>
				return ERRO_POP_BLOCK;
c0204631:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204636:	e9 e2 02 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c020463b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020463e:	8b 52 04             	mov    0x4(%edx),%edx
c0204641:	85 d2                	test   %edx,%edx
c0204643:	0f 85 82 02 00 00    	jne    c02048cb <.L66+0xa>
				MULTI_LINK ->_2 = NULL;
c0204649:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020464f:	8b 00                	mov    (%eax),%eax
c0204651:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
				return header->page_no;
c0204658:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020465b:	8b 00                	mov    (%eax),%eax
c020465d:	e9 bb 02 00 00       	jmp    c020491d <.L66+0x5c>

c0204662 <.L57>:
			}
			break;
		case _4:
			header = MULTI_LINK ->_4;
c0204662:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204668:	8b 12                	mov    (%edx),%edx
c020466a:	8b 52 08             	mov    0x8(%edx),%edx
c020466d:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204670:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204674:	75 0a                	jne    c0204680 <.L57+0x1e>
				return ERRO_POP_BLOCK;
c0204676:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020467b:	e9 9d 02 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c0204680:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204683:	8b 52 04             	mov    0x4(%edx),%edx
c0204686:	85 d2                	test   %edx,%edx
c0204688:	0f 85 40 02 00 00    	jne    c02048ce <.L66+0xd>
				MULTI_LINK ->_4 = NULL;
c020468e:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204694:	8b 00                	mov    (%eax),%eax
c0204696:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				return header->page_no;
c020469d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02046a0:	8b 00                	mov    (%eax),%eax
c02046a2:	e9 76 02 00 00       	jmp    c020491d <.L66+0x5c>

c02046a7 <.L58>:
			}
			break;
		case _8:
			header = MULTI_LINK ->_8;
c02046a7:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02046ad:	8b 12                	mov    (%edx),%edx
c02046af:	8b 52 0c             	mov    0xc(%edx),%edx
c02046b2:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02046b5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02046b9:	75 0a                	jne    c02046c5 <.L58+0x1e>
				return ERRO_POP_BLOCK;
c02046bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02046c0:	e9 58 02 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c02046c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02046c8:	8b 52 04             	mov    0x4(%edx),%edx
c02046cb:	85 d2                	test   %edx,%edx
c02046cd:	0f 85 fe 01 00 00    	jne    c02048d1 <.L66+0x10>
				MULTI_LINK ->_8 = NULL;
c02046d3:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02046d9:	8b 00                	mov    (%eax),%eax
c02046db:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				return header->page_no;
c02046e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02046e5:	8b 00                	mov    (%eax),%eax
c02046e7:	e9 31 02 00 00       	jmp    c020491d <.L66+0x5c>

c02046ec <.L59>:
			}
			break;
		case _16:
			header = MULTI_LINK ->_16;
c02046ec:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02046f2:	8b 12                	mov    (%edx),%edx
c02046f4:	8b 52 10             	mov    0x10(%edx),%edx
c02046f7:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02046fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02046fe:	75 0a                	jne    c020470a <.L59+0x1e>
				return ERRO_POP_BLOCK;
c0204700:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204705:	e9 13 02 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c020470a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020470d:	8b 52 04             	mov    0x4(%edx),%edx
c0204710:	85 d2                	test   %edx,%edx
c0204712:	0f 85 bc 01 00 00    	jne    c02048d4 <.L66+0x13>
				MULTI_LINK ->_16 = NULL;
c0204718:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020471e:	8b 00                	mov    (%eax),%eax
c0204720:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
				return header->page_no;
c0204727:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020472a:	8b 00                	mov    (%eax),%eax
c020472c:	e9 ec 01 00 00       	jmp    c020491d <.L66+0x5c>

c0204731 <.L60>:
			}
			break;
		case _32:
			header = MULTI_LINK ->_32;
c0204731:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204737:	8b 12                	mov    (%edx),%edx
c0204739:	8b 52 14             	mov    0x14(%edx),%edx
c020473c:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c020473f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204743:	75 0a                	jne    c020474f <.L60+0x1e>
				return ERRO_POP_BLOCK;
c0204745:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020474a:	e9 ce 01 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c020474f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204752:	8b 52 04             	mov    0x4(%edx),%edx
c0204755:	85 d2                	test   %edx,%edx
c0204757:	0f 85 7a 01 00 00    	jne    c02048d7 <.L66+0x16>
				MULTI_LINK ->_32 = NULL;
c020475d:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204763:	8b 00                	mov    (%eax),%eax
c0204765:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
				return header->page_no;
c020476c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020476f:	8b 00                	mov    (%eax),%eax
c0204771:	e9 a7 01 00 00       	jmp    c020491d <.L66+0x5c>

c0204776 <.L61>:
			}
			break;
		case _64:
			header = MULTI_LINK ->_64;
c0204776:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020477c:	8b 12                	mov    (%edx),%edx
c020477e:	8b 52 18             	mov    0x18(%edx),%edx
c0204781:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204784:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204788:	75 0a                	jne    c0204794 <.L61+0x1e>
				return ERRO_POP_BLOCK;
c020478a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020478f:	e9 89 01 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c0204794:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204797:	8b 52 04             	mov    0x4(%edx),%edx
c020479a:	85 d2                	test   %edx,%edx
c020479c:	0f 85 38 01 00 00    	jne    c02048da <.L66+0x19>
				MULTI_LINK ->_64 = NULL;
c02047a2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02047a8:	8b 00                	mov    (%eax),%eax
c02047aa:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
				return header->page_no;
c02047b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02047b4:	8b 00                	mov    (%eax),%eax
c02047b6:	e9 62 01 00 00       	jmp    c020491d <.L66+0x5c>

c02047bb <.L62>:
			}
			break;
		case _128:
			header = MULTI_LINK ->_128;
c02047bb:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02047c1:	8b 12                	mov    (%edx),%edx
c02047c3:	8b 52 1c             	mov    0x1c(%edx),%edx
c02047c6:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02047c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02047cd:	75 0a                	jne    c02047d9 <.L62+0x1e>
				return ERRO_POP_BLOCK;
c02047cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02047d4:	e9 44 01 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c02047d9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02047dc:	8b 52 04             	mov    0x4(%edx),%edx
c02047df:	85 d2                	test   %edx,%edx
c02047e1:	0f 85 f6 00 00 00    	jne    c02048dd <.L66+0x1c>
				MULTI_LINK ->_128 = NULL;
c02047e7:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02047ed:	8b 00                	mov    (%eax),%eax
c02047ef:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
				return header->page_no;
c02047f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02047f9:	8b 00                	mov    (%eax),%eax
c02047fb:	e9 1d 01 00 00       	jmp    c020491d <.L66+0x5c>

c0204800 <.L63>:
			}
			break;
		case _256:
			header = MULTI_LINK ->_256;
c0204800:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204806:	8b 12                	mov    (%edx),%edx
c0204808:	8b 52 20             	mov    0x20(%edx),%edx
c020480b:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c020480e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204812:	75 0a                	jne    c020481e <.L63+0x1e>
				return ERRO_POP_BLOCK;
c0204814:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204819:	e9 ff 00 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c020481e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204821:	8b 52 04             	mov    0x4(%edx),%edx
c0204824:	85 d2                	test   %edx,%edx
c0204826:	0f 85 b4 00 00 00    	jne    c02048e0 <.L66+0x1f>
				MULTI_LINK ->_256 = NULL;
c020482c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204832:	8b 00                	mov    (%eax),%eax
c0204834:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				return header->page_no;
c020483b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020483e:	8b 00                	mov    (%eax),%eax
c0204840:	e9 d8 00 00 00       	jmp    c020491d <.L66+0x5c>

c0204845 <.L64>:
			}
			break;
		case _512:
			header = MULTI_LINK ->_512;
c0204845:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020484b:	8b 12                	mov    (%edx),%edx
c020484d:	8b 52 24             	mov    0x24(%edx),%edx
c0204850:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204853:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204857:	75 0a                	jne    c0204863 <.L64+0x1e>
				return ERRO_POP_BLOCK;
c0204859:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020485e:	e9 ba 00 00 00       	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c0204863:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204866:	8b 52 04             	mov    0x4(%edx),%edx
c0204869:	85 d2                	test   %edx,%edx
c020486b:	75 76                	jne    c02048e3 <.L66+0x22>
				MULTI_LINK ->_512 = NULL;
c020486d:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204873:	8b 00                	mov    (%eax),%eax
c0204875:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
				return header->page_no;
c020487c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020487f:	8b 00                	mov    (%eax),%eax
c0204881:	e9 97 00 00 00       	jmp    c020491d <.L66+0x5c>

c0204886 <.L65>:
			}
			break;
		case _1024:
			header = MULTI_LINK ->_1024;
c0204886:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020488c:	8b 12                	mov    (%edx),%edx
c020488e:	8b 52 28             	mov    0x28(%edx),%edx
c0204891:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204894:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204898:	75 07                	jne    c02048a1 <.L65+0x1b>
				return ERRO_POP_BLOCK;
c020489a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020489f:	eb 7c                	jmp    c020491d <.L66+0x5c>
			if(header->next==NULL){
c02048a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02048a4:	8b 52 04             	mov    0x4(%edx),%edx
c02048a7:	85 d2                	test   %edx,%edx
c02048a9:	75 3b                	jne    c02048e6 <.L66+0x25>
				MULTI_LINK ->_1024 = NULL;
c02048ab:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02048b1:	8b 00                	mov    (%eax),%eax
c02048b3:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
				return header->page_no;
c02048ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02048bd:	8b 00                	mov    (%eax),%eax
c02048bf:	eb 5c                	jmp    c020491d <.L66+0x5c>

c02048c1 <.L66>:
			}
			break;
		case _erro:
			return ERRO_POP_BLOCK; 
c02048c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02048c6:	eb 55                	jmp    c020491d <.L66+0x5c>
			break;
c02048c8:	90                   	nop
c02048c9:	eb 1c                	jmp    c02048e7 <.L66+0x26>
			break;
c02048cb:	90                   	nop
c02048cc:	eb 19                	jmp    c02048e7 <.L66+0x26>
			break;
c02048ce:	90                   	nop
c02048cf:	eb 16                	jmp    c02048e7 <.L66+0x26>
			break;
c02048d1:	90                   	nop
c02048d2:	eb 13                	jmp    c02048e7 <.L66+0x26>
			break;
c02048d4:	90                   	nop
c02048d5:	eb 10                	jmp    c02048e7 <.L66+0x26>
			break;
c02048d7:	90                   	nop
c02048d8:	eb 0d                	jmp    c02048e7 <.L66+0x26>
			break;
c02048da:	90                   	nop
c02048db:	eb 0a                	jmp    c02048e7 <.L66+0x26>
			break;
c02048dd:	90                   	nop
c02048de:	eb 07                	jmp    c02048e7 <.L66+0x26>
			break;
c02048e0:	90                   	nop
c02048e1:	eb 04                	jmp    c02048e7 <.L66+0x26>
			break;
c02048e3:	90                   	nop
c02048e4:	eb 01                	jmp    c02048e7 <.L66+0x26>
			break;
c02048e6:	90                   	nop
			break;
	}
	pm_page_t * probe = header;
c02048e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02048ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;probe->next->next!=NULL;probe = probe->next)
c02048ed:	eb 09                	jmp    c02048f8 <.L66+0x37>
c02048ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02048f2:	8b 40 04             	mov    0x4(%eax),%eax
c02048f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
c02048f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02048fb:	8b 40 04             	mov    0x4(%eax),%eax
c02048fe:	8b 40 04             	mov    0x4(%eax),%eax
c0204901:	85 c0                	test   %eax,%eax
c0204903:	75 ea                	jne    c02048ef <.L66+0x2e>
		;
	uint32_t return_page_no = probe->next->page_no;
c0204905:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204908:	8b 40 04             	mov    0x4(%eax),%eax
c020490b:	8b 00                	mov    (%eax),%eax
c020490d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	probe->next=NULL;
c0204910:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204913:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	return return_page_no;
c020491a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c020491d:	c9                   	leave  
c020491e:	c3                   	ret    

c020491f <find_and_pop_block>:
 
//free合并块使用函数
//如果链表中没有 返回ERRO_POP_BLOCK 否则返回对应page_no
static uint32_t find_and_pop_block(uint32_t target_page_no,page_c_t ph){
c020491f:	55                   	push   %ebp
c0204920:	89 e5                	mov    %esp,%ebp
c0204922:	83 ec 10             	sub    $0x10,%esp
c0204925:	e8 d6 36 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020492a:	05 d6 46 00 00       	add    $0x46d6,%eax
	pm_page_t * header;
	switch(ph){
c020492f:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204933:	0f 87 d3 00 00 00    	ja     c0204a0c <.L117+0xa>
c0204939:	8b 55 0c             	mov    0xc(%ebp),%edx
c020493c:	c1 e2 02             	shl    $0x2,%edx
c020493f:	8b 94 02 24 03 00 00 	mov    0x324(%edx,%eax,1),%edx
c0204946:	01 c2                	add    %eax,%edx
c0204948:	ff e2                	jmp    *%edx

c020494a <.L105>:
		case _1:
			header = MULTI_LINK -> _1;
c020494a:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204950:	8b 00                	mov    (%eax),%eax
c0204952:	8b 00                	mov    (%eax),%eax
c0204954:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204957:	e9 b0 00 00 00       	jmp    c0204a0c <.L117+0xa>

c020495c <.L107>:
		case _2:
			header = MULTI_LINK -> _2;
c020495c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204962:	8b 00                	mov    (%eax),%eax
c0204964:	8b 40 04             	mov    0x4(%eax),%eax
c0204967:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c020496a:	e9 9d 00 00 00       	jmp    c0204a0c <.L117+0xa>

c020496f <.L108>:
		case _4:
			header = MULTI_LINK -> _4;
c020496f:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204975:	8b 00                	mov    (%eax),%eax
c0204977:	8b 40 08             	mov    0x8(%eax),%eax
c020497a:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c020497d:	e9 8a 00 00 00       	jmp    c0204a0c <.L117+0xa>

c0204982 <.L109>:
		case _8:
			header = MULTI_LINK -> _8;
c0204982:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204988:	8b 00                	mov    (%eax),%eax
c020498a:	8b 40 0c             	mov    0xc(%eax),%eax
c020498d:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204990:	eb 7a                	jmp    c0204a0c <.L117+0xa>

c0204992 <.L110>:
		case _16:
			header = MULTI_LINK -> _16;
c0204992:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204998:	8b 00                	mov    (%eax),%eax
c020499a:	8b 40 10             	mov    0x10(%eax),%eax
c020499d:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049a0:	eb 6a                	jmp    c0204a0c <.L117+0xa>

c02049a2 <.L111>:
		case _32:
			header = MULTI_LINK -> _32;
c02049a2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049a8:	8b 00                	mov    (%eax),%eax
c02049aa:	8b 40 14             	mov    0x14(%eax),%eax
c02049ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049b0:	eb 5a                	jmp    c0204a0c <.L117+0xa>

c02049b2 <.L112>:
		case _64:
			header = MULTI_LINK -> _64;
c02049b2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049b8:	8b 00                	mov    (%eax),%eax
c02049ba:	8b 40 18             	mov    0x18(%eax),%eax
c02049bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049c0:	eb 4a                	jmp    c0204a0c <.L117+0xa>

c02049c2 <.L113>:
		case _128:
			header = MULTI_LINK -> _128;
c02049c2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049c8:	8b 00                	mov    (%eax),%eax
c02049ca:	8b 40 1c             	mov    0x1c(%eax),%eax
c02049cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049d0:	eb 3a                	jmp    c0204a0c <.L117+0xa>

c02049d2 <.L114>:
		case _256:
			header = MULTI_LINK -> _256;
c02049d2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049d8:	8b 00                	mov    (%eax),%eax
c02049da:	8b 40 20             	mov    0x20(%eax),%eax
c02049dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049e0:	eb 2a                	jmp    c0204a0c <.L117+0xa>

c02049e2 <.L115>:
		case _512:
			header = MULTI_LINK -> _512;
c02049e2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049e8:	8b 00                	mov    (%eax),%eax
c02049ea:	8b 40 24             	mov    0x24(%eax),%eax
c02049ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049f0:	eb 1a                	jmp    c0204a0c <.L117+0xa>

c02049f2 <.L116>:
		case _1024:
			header = MULTI_LINK -> _1024;
c02049f2:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049f8:	8b 00                	mov    (%eax),%eax
c02049fa:	8b 40 28             	mov    0x28(%eax),%eax
c02049fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204a00:	eb 0a                	jmp    c0204a0c <.L117+0xa>

c0204a02 <.L117>:
		case _erro:
			return ERRO_POP_BLOCK;
c0204a02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204a07:	e9 8c 00 00 00       	jmp    c0204a98 <.L117+0x96>
	}
	if(header == NULL)
c0204a0c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204a10:	75 07                	jne    c0204a19 <.L117+0x17>
		return ERRO_POP_BLOCK;
c0204a12:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204a17:	eb 7f                	jmp    c0204a98 <.L117+0x96>
	if(header->next==NULL){
c0204a19:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204a1c:	8b 40 04             	mov    0x4(%eax),%eax
c0204a1f:	85 c0                	test   %eax,%eax
c0204a21:	75 1a                	jne    c0204a3d <.L117+0x3b>
		if(header->page_no==target_page_no){
c0204a23:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204a26:	8b 00                	mov    (%eax),%eax
c0204a28:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204a2b:	75 10                	jne    c0204a3d <.L117+0x3b>
			pop_block(ph);
c0204a2d:	ff 75 0c             	pushl  0xc(%ebp)
c0204a30:	e8 7a fb ff ff       	call   c02045af <pop_block>
c0204a35:	83 c4 04             	add    $0x4,%esp
			return target_page_no;
c0204a38:	8b 45 08             	mov    0x8(%ebp),%eax
c0204a3b:	eb 5b                	jmp    c0204a98 <.L117+0x96>
		}
	}
	pm_page_t * probe = header ;
c0204a3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204a40:	89 45 f8             	mov    %eax,-0x8(%ebp)
	//
	//
	//
	//
	//
	for(; probe->next!=NULL;probe=probe->next){
c0204a43:	eb 2a                	jmp    c0204a6f <.L117+0x6d>
		if(probe->next->page_no == target_page_no){
c0204a45:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a48:	8b 40 04             	mov    0x4(%eax),%eax
c0204a4b:	8b 00                	mov    (%eax),%eax
c0204a4d:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204a50:	75 14                	jne    c0204a66 <.L117+0x64>
			probe->next = probe->next->next;
c0204a52:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a55:	8b 40 04             	mov    0x4(%eax),%eax
c0204a58:	8b 50 04             	mov    0x4(%eax),%edx
c0204a5b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a5e:	89 50 04             	mov    %edx,0x4(%eax)
			return target_page_no;
c0204a61:	8b 45 08             	mov    0x8(%ebp),%eax
c0204a64:	eb 32                	jmp    c0204a98 <.L117+0x96>
	for(; probe->next!=NULL;probe=probe->next){
c0204a66:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a69:	8b 40 04             	mov    0x4(%eax),%eax
c0204a6c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204a6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a72:	8b 40 04             	mov    0x4(%eax),%eax
c0204a75:	85 c0                	test   %eax,%eax
c0204a77:	75 cc                	jne    c0204a45 <.L117+0x43>
		}
	}
	if(probe->page_no == target_page_no){
c0204a79:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a7c:	8b 00                	mov    (%eax),%eax
c0204a7e:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204a81:	75 10                	jne    c0204a93 <.L117+0x91>
		pop_block(ph);
c0204a83:	ff 75 0c             	pushl  0xc(%ebp)
c0204a86:	e8 24 fb ff ff       	call   c02045af <pop_block>
c0204a8b:	83 c4 04             	add    $0x4,%esp
		return target_page_no;
c0204a8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0204a91:	eb 05                	jmp    c0204a98 <.L117+0x96>
	}
	return ERRO_POP_BLOCK;
c0204a93:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0204a98:	c9                   	leave  
c0204a99:	c3                   	ret    

c0204a9a <get_max_pm_addr>:

//从multi_boot结构体中取出需要管理的地址空间大小 
static uint32_t get_max_pm_addr(){          //qemu默认为128M
c0204a9a:	55                   	push   %ebp
c0204a9b:	89 e5                	mov    %esp,%ebp
c0204a9d:	56                   	push   %esi
c0204a9e:	53                   	push   %ebx
c0204a9f:	83 ec 10             	sub    $0x10,%esp
c0204aa2:	e8 5d 35 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0204aa7:	81 c3 59 45 00 00    	add    $0x4559,%ebx
	uint32_t max_addr=0;
c0204aad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32_t p = (uint32_t)mboot_ptr;
c0204ab4:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204aba:	8b 00                	mov    (%eax),%eax
c0204abc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204abf:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204ac5:	8b 00                	mov    (%eax),%eax
c0204ac7:	8b 40 30             	mov    0x30(%eax),%eax
c0204aca:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0204acd:	eb 6a                	jmp    c0204b39 <get_max_pm_addr+0x9f>
		printk("[INFO][PMM]physic_mem_block:0x%h-0x%h-0x%h-%d\n",pm_entry_cur->base_addr_low,pm_entry_cur->length_low,pm_entry_cur->base_addr_low+pm_entry_cur->length_low,pm_entry_cur->type);
c0204acf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ad2:	8b 48 14             	mov    0x14(%eax),%ecx
c0204ad5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ad8:	8b 50 04             	mov    0x4(%eax),%edx
c0204adb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ade:	8b 40 0c             	mov    0xc(%eax),%eax
c0204ae1:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0204ae4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ae7:	8b 50 0c             	mov    0xc(%eax),%edx
c0204aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204aed:	8b 40 04             	mov    0x4(%eax),%eax
c0204af0:	83 ec 0c             	sub    $0xc,%esp
c0204af3:	51                   	push   %ecx
c0204af4:	56                   	push   %esi
c0204af5:	52                   	push   %edx
c0204af6:	50                   	push   %eax
c0204af7:	8d 83 54 03 00 00    	lea    0x354(%ebx),%eax
c0204afd:	50                   	push   %eax
c0204afe:	e8 31 28 00 00       	call   c0207334 <printk>
c0204b03:	83 c4 20             	add    $0x20,%esp
		if(pm_entry_cur->type==1&&max_addr<pm_entry_cur->base_addr_low+pm_entry_cur->length_low)
c0204b06:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b09:	8b 40 14             	mov    0x14(%eax),%eax
c0204b0c:	83 f8 01             	cmp    $0x1,%eax
c0204b0f:	75 24                	jne    c0204b35 <get_max_pm_addr+0x9b>
c0204b11:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b14:	8b 50 04             	mov    0x4(%eax),%edx
c0204b17:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b1a:	8b 40 0c             	mov    0xc(%eax),%eax
c0204b1d:	01 d0                	add    %edx,%eax
c0204b1f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0204b22:	73 11                	jae    c0204b35 <get_max_pm_addr+0x9b>
			max_addr=pm_entry_cur->base_addr_low+pm_entry_cur->length_low;		
c0204b24:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b27:	8b 50 04             	mov    0x4(%eax),%edx
c0204b2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b2d:	8b 40 0c             	mov    0xc(%eax),%eax
c0204b30:	01 d0                	add    %edx,%eax
c0204b32:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204b35:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
c0204b39:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204b3f:	8b 00                	mov    (%eax),%eax
c0204b41:	8b 50 30             	mov    0x30(%eax),%edx
c0204b44:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204b4a:	8b 00                	mov    (%eax),%eax
c0204b4c:	8b 40 2c             	mov    0x2c(%eax),%eax
c0204b4f:	01 d0                	add    %edx,%eax
c0204b51:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0204b54:	0f 82 75 ff ff ff    	jb     c0204acf <get_max_pm_addr+0x35>
	}
	return max_addr;
c0204b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204b5d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0204b60:	5b                   	pop    %ebx
c0204b61:	5e                   	pop    %esi
c0204b62:	5d                   	pop    %ebp
c0204b63:	c3                   	ret    

c0204b64 <pmm_page_init>:

//初始化页描述结构体以及装载链表
static void pmm_page_init(){  //初始化链表结构体并且填充链表
c0204b64:	55                   	push   %ebp
c0204b65:	89 e5                	mov    %esp,%ebp
c0204b67:	53                   	push   %ebx
c0204b68:	83 ec 14             	sub    $0x14,%esp
c0204b6b:	e8 94 34 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0204b70:	81 c3 90 44 00 00    	add    $0x4490,%ebx
	MULTI_LINK=&multi_link_struct;
c0204b76:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204b7c:	8d 93 60 90 08 00    	lea    0x89060(%ebx),%edx
c0204b82:	89 10                	mov    %edx,(%eax)
	MULTI_LINK->_1=NULL;
c0204b84:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204b8a:	8b 00                	mov    (%eax),%eax
c0204b8c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	MULTI_LINK->_2=NULL;
c0204b92:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204b98:	8b 00                	mov    (%eax),%eax
c0204b9a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	MULTI_LINK->_4=NULL;
c0204ba1:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204ba7:	8b 00                	mov    (%eax),%eax
c0204ba9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	MULTI_LINK->_8=NULL;
c0204bb0:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bb6:	8b 00                	mov    (%eax),%eax
c0204bb8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	MULTI_LINK->_16=NULL;
c0204bbf:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bc5:	8b 00                	mov    (%eax),%eax
c0204bc7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	MULTI_LINK->_32=NULL;
c0204bce:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bd4:	8b 00                	mov    (%eax),%eax
c0204bd6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	MULTI_LINK->_64=NULL;
c0204bdd:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204be3:	8b 00                	mov    (%eax),%eax
c0204be5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	MULTI_LINK->_128=NULL;
c0204bec:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bf2:	8b 00                	mov    (%eax),%eax
c0204bf4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	MULTI_LINK->_256=NULL;
c0204bfb:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c01:	8b 00                	mov    (%eax),%eax
c0204c03:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	MULTI_LINK->_512=NULL;
c0204c0a:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c10:	8b 00                	mov    (%eax),%eax
c0204c12:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	MULTI_LINK->_1024=NULL;
c0204c19:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c1f:	8b 00                	mov    (%eax),%eax
c0204c21:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	//我们将要余出至多1023页来作为单页分配的一个缓冲区 这个缓冲区是与伙伴算法独立的 便于快速分配单页
	for(int i=0;i<pmm_max_page_no;i++){
c0204c28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0204c2f:	eb 51                	jmp    c0204c82 <pmm_page_init+0x11e>
		page_array[i].page_no = i;
c0204c31:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204c37:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204c3a:	89 d0                	mov    %edx,%eax
c0204c3c:	01 c0                	add    %eax,%eax
c0204c3e:	01 d0                	add    %edx,%eax
c0204c40:	c1 e0 02             	shl    $0x2,%eax
c0204c43:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204c49:	89 02                	mov    %eax,(%edx)
		page_array[i].state = 1;
c0204c4b:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204c51:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204c54:	89 d0                	mov    %edx,%eax
c0204c56:	01 c0                	add    %eax,%eax
c0204c58:	01 d0                	add    %edx,%eax
c0204c5a:	c1 e0 02             	shl    $0x2,%eax
c0204c5d:	01 c8                	add    %ecx,%eax
c0204c5f:	c6 40 08 01          	movb   $0x1,0x8(%eax)
		page_array[i].next = NULL;
c0204c63:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204c69:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204c6c:	89 d0                	mov    %edx,%eax
c0204c6e:	01 c0                	add    %eax,%eax
c0204c70:	01 d0                	add    %edx,%eax
c0204c72:	c1 e0 02             	shl    $0x2,%eax
c0204c75:	01 c8                	add    %ecx,%eax
c0204c77:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	for(int i=0;i<pmm_max_page_no;i++){
c0204c7e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0204c82:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204c85:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0204c8b:	39 c2                	cmp    %eax,%edx
c0204c8d:	72 a2                	jb     c0204c31 <pmm_page_init+0xcd>
	}
	//装载链表
	append_block(0,_1);    //1页链表
c0204c8f:	6a 00                	push   $0x0
c0204c91:	6a 00                	push   $0x0
c0204c93:	e8 d1 f5 ff ff       	call   c0204269 <append_block>
c0204c98:	83 c4 08             	add    $0x8,%esp
	append_block(1,_1);
c0204c9b:	6a 00                	push   $0x0
c0204c9d:	6a 01                	push   $0x1
c0204c9f:	e8 c5 f5 ff ff       	call   c0204269 <append_block>
c0204ca4:	83 c4 08             	add    $0x8,%esp

	append_block(2,_2);    //2页链表
c0204ca7:	6a 01                	push   $0x1
c0204ca9:	6a 02                	push   $0x2
c0204cab:	e8 b9 f5 ff ff       	call   c0204269 <append_block>
c0204cb0:	83 c4 08             	add    $0x8,%esp

	append_block(4,_4);
c0204cb3:	6a 02                	push   $0x2
c0204cb5:	6a 04                	push   $0x4
c0204cb7:	e8 ad f5 ff ff       	call   c0204269 <append_block>
c0204cbc:	83 c4 08             	add    $0x8,%esp

	append_block(8,_8);
c0204cbf:	6a 03                	push   $0x3
c0204cc1:	6a 08                	push   $0x8
c0204cc3:	e8 a1 f5 ff ff       	call   c0204269 <append_block>
c0204cc8:	83 c4 08             	add    $0x8,%esp

	append_block(16,_16);
c0204ccb:	6a 04                	push   $0x4
c0204ccd:	6a 10                	push   $0x10
c0204ccf:	e8 95 f5 ff ff       	call   c0204269 <append_block>
c0204cd4:	83 c4 08             	add    $0x8,%esp

	append_block(32,_32);
c0204cd7:	6a 05                	push   $0x5
c0204cd9:	6a 20                	push   $0x20
c0204cdb:	e8 89 f5 ff ff       	call   c0204269 <append_block>
c0204ce0:	83 c4 08             	add    $0x8,%esp

	append_block(64,_64);
c0204ce3:	6a 06                	push   $0x6
c0204ce5:	6a 40                	push   $0x40
c0204ce7:	e8 7d f5 ff ff       	call   c0204269 <append_block>
c0204cec:	83 c4 08             	add    $0x8,%esp

	append_block(128,_128);
c0204cef:	6a 07                	push   $0x7
c0204cf1:	68 80 00 00 00       	push   $0x80
c0204cf6:	e8 6e f5 ff ff       	call   c0204269 <append_block>
c0204cfb:	83 c4 08             	add    $0x8,%esp

	append_block(256,_256);
c0204cfe:	6a 08                	push   $0x8
c0204d00:	68 00 01 00 00       	push   $0x100
c0204d05:	e8 5f f5 ff ff       	call   c0204269 <append_block>
c0204d0a:	83 c4 08             	add    $0x8,%esp

	append_block(512,_512);
c0204d0d:	6a 09                	push   $0x9
c0204d0f:	68 00 02 00 00       	push   $0x200
c0204d14:	e8 50 f5 ff ff       	call   c0204269 <append_block>
c0204d19:	83 c4 08             	add    $0x8,%esp

	append_block(1024,_1024);
c0204d1c:	6a 0a                	push   $0xa
c0204d1e:	68 00 04 00 00       	push   $0x400
c0204d23:	e8 41 f5 ff ff       	call   c0204269 <append_block>
c0204d28:	83 c4 08             	add    $0x8,%esp


	int temp_page_no=2048;
c0204d2b:	c7 45 f0 00 08 00 00 	movl   $0x800,-0x10(%ebp)
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0204d32:	eb 14                	jmp    c0204d48 <pmm_page_init+0x1e4>
		append_block(temp_page_no,_1024);
c0204d34:	6a 0a                	push   $0xa
c0204d36:	ff 75 f0             	pushl  -0x10(%ebp)
c0204d39:	e8 2b f5 ff ff       	call   c0204269 <append_block>
c0204d3e:	83 c4 08             	add    $0x8,%esp
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0204d41:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c0204d48:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0204d4e:	8d 90 00 fc ff ff    	lea    -0x400(%eax),%edx
c0204d54:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204d57:	39 c2                	cmp    %eax,%edx
c0204d59:	77 d9                	ja     c0204d34 <pmm_page_init+0x1d0>
	}
	singel_page_first_no = temp_page_no;   //将第一个单页缓冲区的编号存放好
c0204d5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204d5e:	89 83 9c 90 08 00    	mov    %eax,0x8909c(%ebx)

	printk("[INFO][PMM]single_page_count:%d\n",pmm_max_page_no-temp_page_no);
c0204d64:	8b 93 98 90 08 00    	mov    0x89098(%ebx),%edx
c0204d6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204d6d:	29 c2                	sub    %eax,%edx
c0204d6f:	89 d0                	mov    %edx,%eax
c0204d71:	83 ec 08             	sub    $0x8,%esp
c0204d74:	50                   	push   %eax
c0204d75:	8d 83 84 03 00 00    	lea    0x384(%ebx),%eax
c0204d7b:	50                   	push   %eax
c0204d7c:	e8 b3 25 00 00       	call   c0207334 <printk>
c0204d81:	83 c4 10             	add    $0x10,%esp
	pm_page_t * temp_single_probe = NULL;
c0204d84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c0204d8b:	eb 57                	jmp    c0204de4 <pmm_page_init+0x280>
		if(SINGLE_LINK == NULL){
c0204d8d:	8b 83 8c 90 08 00    	mov    0x8908c(%ebx),%eax
c0204d93:	85 c0                	test   %eax,%eax
c0204d95:	75 25                	jne    c0204dbc <pmm_page_init+0x258>
			SINGLE_LINK=&(page_array[temp_page_no]);
c0204d97:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204d9d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204da0:	89 d0                	mov    %edx,%eax
c0204da2:	01 c0                	add    %eax,%eax
c0204da4:	01 d0                	add    %edx,%eax
c0204da6:	c1 e0 02             	shl    $0x2,%eax
c0204da9:	01 c8                	add    %ecx,%eax
c0204dab:	89 83 8c 90 08 00    	mov    %eax,0x8908c(%ebx)
			temp_single_probe = SINGLE_LINK ;
c0204db1:	8b 83 8c 90 08 00    	mov    0x8908c(%ebx),%eax
c0204db7:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0204dba:	eb 24                	jmp    c0204de0 <pmm_page_init+0x27c>
		}
		else{
			temp_single_probe->next = &(page_array[temp_page_no]);
c0204dbc:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204dc2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204dc5:	89 d0                	mov    %edx,%eax
c0204dc7:	01 c0                	add    %eax,%eax
c0204dc9:	01 d0                	add    %edx,%eax
c0204dcb:	c1 e0 02             	shl    $0x2,%eax
c0204dce:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204dd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204dd4:	89 50 04             	mov    %edx,0x4(%eax)
			temp_single_probe = temp_single_probe -> next;
c0204dd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204dda:	8b 40 04             	mov    0x4(%eax),%eax
c0204ddd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c0204de0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0204de4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204de7:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0204ded:	39 c2                	cmp    %eax,%edx
c0204def:	72 9c                	jb     c0204d8d <pmm_page_init+0x229>
		}
	}
}
c0204df1:	90                   	nop
c0204df2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0204df5:	c9                   	leave  
c0204df6:	c3                   	ret    

c0204df7 <alloc_helper>:





static uint32_t alloc_helper(page_c_t target_ph,page_c_t pop_ph,uint32_t pop_page_no){
c0204df7:	55                   	push   %ebp
c0204df8:	89 e5                	mov    %esp,%ebp
c0204dfa:	83 ec 10             	sub    $0x10,%esp
c0204dfd:	e8 fe 31 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204e02:	05 fe 41 00 00       	add    $0x41fe,%eax
	for(;pop_ph!=target_ph;pop_ph--){
c0204e07:	eb 2e                	jmp    c0204e37 <alloc_helper+0x40>
		uint32_t append_page_no = pop_page_no+(c_to_uint32(pop_ph)/2);
c0204e09:	ff 75 0c             	pushl  0xc(%ebp)
c0204e0c:	e8 e8 f3 ff ff       	call   c02041f9 <c_to_uint32>
c0204e11:	83 c4 04             	add    $0x4,%esp
c0204e14:	d1 e8                	shr    %eax
c0204e16:	89 c2                	mov    %eax,%edx
c0204e18:	8b 45 10             	mov    0x10(%ebp),%eax
c0204e1b:	01 d0                	add    %edx,%eax
c0204e1d:	89 45 fc             	mov    %eax,-0x4(%ebp)
		append_block(append_page_no,pop_page_no-1);
c0204e20:	8b 45 10             	mov    0x10(%ebp),%eax
c0204e23:	8d 50 ff             	lea    -0x1(%eax),%edx
c0204e26:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204e29:	52                   	push   %edx
c0204e2a:	50                   	push   %eax
c0204e2b:	e8 39 f4 ff ff       	call   c0204269 <append_block>
c0204e30:	83 c4 08             	add    $0x8,%esp
	for(;pop_ph!=target_ph;pop_ph--){
c0204e33:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0204e37:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204e3a:	3b 45 08             	cmp    0x8(%ebp),%eax
c0204e3d:	75 ca                	jne    c0204e09 <alloc_helper+0x12>
	}
	return pop_page_no;
c0204e3f:	8b 45 10             	mov    0x10(%ebp),%eax
}
c0204e42:	c9                   	leave  
c0204e43:	c3                   	ret    

c0204e44 <pmm_alloc_pages>:



//伙伴算法多页分配
pm_alloc_t pmm_alloc_pages(uint32_t page_count){
c0204e44:	55                   	push   %ebp
c0204e45:	89 e5                	mov    %esp,%ebp
c0204e47:	83 ec 30             	sub    $0x30,%esp
c0204e4a:	e8 b1 31 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204e4f:	05 b1 41 00 00       	add    $0x41b1,%eax
	pm_alloc_t return_struct = {0,_erro,0}; 
c0204e54:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c0204e5b:	c7 45 dc 0b 00 00 00 	movl   $0xb,-0x24(%ebp)
c0204e62:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
	if (page_count>1024||page_count==0)
c0204e66:	81 7d 0c 00 04 00 00 	cmpl   $0x400,0xc(%ebp)
c0204e6d:	77 06                	ja     c0204e75 <pmm_alloc_pages+0x31>
c0204e6f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0204e73:	75 19                	jne    c0204e8e <pmm_alloc_pages+0x4a>
		return return_struct;    //分配失败
c0204e75:	8b 45 08             	mov    0x8(%ebp),%eax
c0204e78:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0204e7b:	89 10                	mov    %edx,(%eax)
c0204e7d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0204e80:	89 50 04             	mov    %edx,0x4(%eax)
c0204e83:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0204e86:	89 50 08             	mov    %edx,0x8(%eax)
c0204e89:	e9 ce 00 00 00       	jmp    c0204f5c <pmm_alloc_pages+0x118>
	//来点骚操作
	//获取需要分配的页数
	uint32_t page_count_probe=page_count;
c0204e8e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204e91:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter1 = 0;
c0204e94:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;page_count_probe!=0 ;counter1++,page_count_probe=page_count_probe>>1)
c0204e9b:	eb 07                	jmp    c0204ea4 <pmm_alloc_pages+0x60>
c0204e9d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0204ea1:	d1 6d fc             	shrl   -0x4(%ebp)
c0204ea4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ea8:	75 f3                	jne    c0204e9d <pmm_alloc_pages+0x59>
		;
	uint32_t counter2= counter1-1;
c0204eaa:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ead:	83 e8 01             	sub    $0x1,%eax
c0204eb0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(page_count==(1<<counter2))
c0204eb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204eb6:	ba 01 00 00 00       	mov    $0x1,%edx
c0204ebb:	89 c1                	mov    %eax,%ecx
c0204ebd:	d3 e2                	shl    %cl,%edx
c0204ebf:	89 d0                	mov    %edx,%eax
c0204ec1:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0204ec4:	75 04                	jne    c0204eca <pmm_alloc_pages+0x86>
		counter1--;
c0204ec6:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	//此时的counter1即为pm_c_t枚举的对应值
	page_c_t ph = counter1;
c0204eca:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ecd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	page_c_t origin_ph = ph;    //存放原始ph
c0204ed0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204ed3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pop_page_no = ERRO_POP_BLOCK;
c0204ed6:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	for(;ph<_erro;ph++){
c0204edd:	eb 18                	jmp    c0204ef7 <pmm_alloc_pages+0xb3>
		pop_page_no = pop_block(ph);
c0204edf:	ff 75 f4             	pushl  -0xc(%ebp)
c0204ee2:	e8 c8 f6 ff ff       	call   c02045af <pop_block>
c0204ee7:	83 c4 04             	add    $0x4,%esp
c0204eea:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(pop_page_no!=ERRO_POP_BLOCK)
c0204eed:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0204ef1:	75 0c                	jne    c0204eff <pmm_alloc_pages+0xbb>
	for(;ph<_erro;ph++){
c0204ef3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0204ef7:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
c0204efb:	76 e2                	jbe    c0204edf <pmm_alloc_pages+0x9b>
c0204efd:	eb 01                	jmp    c0204f00 <pmm_alloc_pages+0xbc>
			break;
c0204eff:	90                   	nop
	}
	if(pop_page_no==ERRO_POP_BLOCK){
c0204f00:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0204f04:	75 16                	jne    c0204f1c <pmm_alloc_pages+0xd8>
		return return_struct;    //分配失败
c0204f06:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f09:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0204f0c:	89 10                	mov    %edx,(%eax)
c0204f0e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0204f11:	89 50 04             	mov    %edx,0x4(%eax)
c0204f14:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0204f17:	89 50 08             	mov    %edx,0x8(%eax)
c0204f1a:	eb 40                	jmp    c0204f5c <pmm_alloc_pages+0x118>
	}
	else{
		uint32_t target_page_no = alloc_helper(origin_ph,ph,pop_page_no);
c0204f1c:	ff 75 f0             	pushl  -0x10(%ebp)
c0204f1f:	ff 75 f4             	pushl  -0xc(%ebp)
c0204f22:	ff 75 e8             	pushl  -0x18(%ebp)
c0204f25:	e8 cd fe ff ff       	call   c0204df7 <alloc_helper>
c0204f2a:	83 c4 0c             	add    $0xc,%esp
c0204f2d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return_struct.addr = pmm_page_no_to_addr(target_page_no);
c0204f30:	ff 75 e4             	pushl  -0x1c(%ebp)
c0204f33:	e8 85 f2 ff ff       	call   c02041bd <pmm_page_no_to_addr>
c0204f38:	83 c4 04             	add    $0x4,%esp
c0204f3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		return_struct.state = 1;
c0204f3e:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
		return_struct.size = origin_ph;
c0204f42:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0204f45:	89 45 dc             	mov    %eax,-0x24(%ebp)
		return return_struct;
c0204f48:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f4b:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0204f4e:	89 10                	mov    %edx,(%eax)
c0204f50:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0204f53:	89 50 04             	mov    %edx,0x4(%eax)
c0204f56:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0204f59:	89 50 08             	mov    %edx,0x8(%eax)
	}
}
c0204f5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f5f:	c9                   	leave  
c0204f60:	c2 04 00             	ret    $0x4

c0204f63 <pmm_alloc_one_page>:

//缓冲区及伙伴算法单页分配
//当缓冲区没有页的时候会调用伙伴算法分配一页
pm_alloc_t pmm_alloc_one_page(){
c0204f63:	55                   	push   %ebp
c0204f64:	89 e5                	mov    %esp,%ebp
c0204f66:	83 ec 20             	sub    $0x20,%esp
c0204f69:	e8 92 30 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204f6e:	05 92 40 00 00       	add    $0x4092,%eax
	pm_alloc_t return_struct = {0,_erro,0};
c0204f73:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0204f7a:	c7 45 f0 0b 00 00 00 	movl   $0xb,-0x10(%ebp)
c0204f81:	c6 45 f4 00          	movb   $0x0,-0xc(%ebp)
	if(SINGLE_LINK!=NULL){
c0204f85:	8b 90 8c 90 08 00    	mov    0x8908c(%eax),%edx
c0204f8b:	85 d2                	test   %edx,%edx
c0204f8d:	0f 84 ac 00 00 00    	je     c020503f <pmm_alloc_one_page+0xdc>
		pm_page_t * header = SINGLE_LINK;
c0204f93:	8b 90 8c 90 08 00    	mov    0x8908c(%eax),%edx
c0204f99:	89 55 f8             	mov    %edx,-0x8(%ebp)
		if(header->next==NULL){
c0204f9c:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204f9f:	8b 52 04             	mov    0x4(%edx),%edx
c0204fa2:	85 d2                	test   %edx,%edx
c0204fa4:	75 3c                	jne    c0204fe2 <pmm_alloc_one_page+0x7f>
			SINGLE_LINK = NULL;
c0204fa6:	c7 80 8c 90 08 00 00 	movl   $0x0,0x8908c(%eax)
c0204fad:	00 00 00 
			return_struct.state = 1;
c0204fb0:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c0204fb4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(header->page_no);
c0204fbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204fbe:	8b 00                	mov    (%eax),%eax
c0204fc0:	50                   	push   %eax
c0204fc1:	e8 f7 f1 ff ff       	call   c02041bd <pmm_page_no_to_addr>
c0204fc6:	83 c4 04             	add    $0x4,%esp
c0204fc9:	89 45 ec             	mov    %eax,-0x14(%ebp)
			return return_struct;
c0204fcc:	8b 45 08             	mov    0x8(%ebp),%eax
c0204fcf:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0204fd2:	89 10                	mov    %edx,(%eax)
c0204fd4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204fd7:	89 50 04             	mov    %edx,0x4(%eax)
c0204fda:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204fdd:	89 50 08             	mov    %edx,0x8(%eax)
c0204fe0:	eb 6b                	jmp    c020504d <pmm_alloc_one_page+0xea>
		}
		else{
			pm_page_t * probe = header;
c0204fe2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204fe5:	89 45 fc             	mov    %eax,-0x4(%ebp)
			for(;probe->next->next!=NULL;probe=probe->next){
c0204fe8:	eb 09                	jmp    c0204ff3 <pmm_alloc_one_page+0x90>
c0204fea:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204fed:	8b 40 04             	mov    0x4(%eax),%eax
c0204ff0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0204ff3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204ff6:	8b 40 04             	mov    0x4(%eax),%eax
c0204ff9:	8b 40 04             	mov    0x4(%eax),%eax
c0204ffc:	85 c0                	test   %eax,%eax
c0204ffe:	75 ea                	jne    c0204fea <pmm_alloc_one_page+0x87>
				//printk("%d\n",probe->page_no);
				//if(probe->page_no==0){
				//	while(1);
				//}
			}
			return_struct.state = 1;
c0205000:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c0205004:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(probe->next->page_no);
c020500b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020500e:	8b 40 04             	mov    0x4(%eax),%eax
c0205011:	8b 00                	mov    (%eax),%eax
c0205013:	50                   	push   %eax
c0205014:	e8 a4 f1 ff ff       	call   c02041bd <pmm_page_no_to_addr>
c0205019:	83 c4 04             	add    $0x4,%esp
c020501c:	89 45 ec             	mov    %eax,-0x14(%ebp)
			probe->next = NULL;
c020501f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205022:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		}
		return return_struct;
c0205029:	8b 45 08             	mov    0x8(%ebp),%eax
c020502c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c020502f:	89 10                	mov    %edx,(%eax)
c0205031:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205034:	89 50 04             	mov    %edx,0x4(%eax)
c0205037:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020503a:	89 50 08             	mov    %edx,0x8(%eax)
c020503d:	eb 0e                	jmp    c020504d <pmm_alloc_one_page+0xea>
	}
	else{
		return pmm_alloc_pages(1);
c020503f:	8b 45 08             	mov    0x8(%ebp),%eax
c0205042:	6a 01                	push   $0x1
c0205044:	50                   	push   %eax
c0205045:	e8 fa fd ff ff       	call   c0204e44 <pmm_alloc_pages>
c020504a:	83 c4 04             	add    $0x4,%esp
	}
}
c020504d:	8b 45 08             	mov    0x8(%ebp),%eax
c0205050:	c9                   	leave  
c0205051:	c2 04 00             	ret    $0x4

c0205054 <free_helper>:

static void free_helper(uint32_t page_no,page_c_t size){
c0205054:	55                   	push   %ebp
c0205055:	89 e5                	mov    %esp,%ebp
c0205057:	53                   	push   %ebx
c0205058:	83 ec 14             	sub    $0x14,%esp
c020505b:	e8 a4 2f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205060:	81 c3 a0 3f 00 00    	add    $0x3fa0,%ebx
	printk("free size : %d\n",c_to_uint32(size));
c0205066:	ff 75 0c             	pushl  0xc(%ebp)
c0205069:	e8 8b f1 ff ff       	call   c02041f9 <c_to_uint32>
c020506e:	83 c4 04             	add    $0x4,%esp
c0205071:	83 ec 08             	sub    $0x8,%esp
c0205074:	50                   	push   %eax
c0205075:	8d 83 a5 03 00 00    	lea    0x3a5(%ebx),%eax
c020507b:	50                   	push   %eax
c020507c:	e8 b3 22 00 00       	call   c0207334 <printk>
c0205081:	83 c4 10             	add    $0x10,%esp
	uint32_t partner_page_no = get_partner_page_no(page_no,size);
c0205084:	83 ec 08             	sub    $0x8,%esp
c0205087:	ff 75 0c             	pushl  0xc(%ebp)
c020508a:	ff 75 08             	pushl  0x8(%ebp)
c020508d:	e8 8b f1 ff ff       	call   c020421d <get_partner_page_no>
c0205092:	83 c4 10             	add    $0x10,%esp
c0205095:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(find_and_pop_block(partner_page_no,size)!=ERRO_POP_BLOCK){
c0205098:	83 ec 08             	sub    $0x8,%esp
c020509b:	ff 75 0c             	pushl  0xc(%ebp)
c020509e:	ff 75 f4             	pushl  -0xc(%ebp)
c02050a1:	e8 79 f8 ff ff       	call   c020491f <find_and_pop_block>
c02050a6:	83 c4 10             	add    $0x10,%esp
c02050a9:	83 f8 ff             	cmp    $0xffffffff,%eax
c02050ac:	74 1f                	je     c02050cd <free_helper+0x79>
		//合并
		free_helper(partner_page_no<page_no?partner_page_no:page_no,size+1);
c02050ae:	8b 45 0c             	mov    0xc(%ebp),%eax
c02050b1:	8d 50 01             	lea    0x1(%eax),%edx
c02050b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02050b7:	39 45 08             	cmp    %eax,0x8(%ebp)
c02050ba:	0f 46 45 08          	cmovbe 0x8(%ebp),%eax
c02050be:	83 ec 08             	sub    $0x8,%esp
c02050c1:	52                   	push   %edx
c02050c2:	50                   	push   %eax
c02050c3:	e8 8c ff ff ff       	call   c0205054 <free_helper>
c02050c8:	83 c4 10             	add    $0x10,%esp
	}
	else{
		append_block(page_no,size);
	}
}
c02050cb:	eb 12                	jmp    c02050df <free_helper+0x8b>
		append_block(page_no,size);
c02050cd:	8b 45 08             	mov    0x8(%ebp),%eax
c02050d0:	83 ec 08             	sub    $0x8,%esp
c02050d3:	ff 75 0c             	pushl  0xc(%ebp)
c02050d6:	50                   	push   %eax
c02050d7:	e8 8d f1 ff ff       	call   c0204269 <append_block>
c02050dc:	83 c4 10             	add    $0x10,%esp
}
c02050df:	90                   	nop
c02050e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02050e3:	c9                   	leave  
c02050e4:	c3                   	ret    

c02050e5 <pmm_free_page>:

//free页 返回bool型（定义在typs.h中） True-成功free False-失败
bool pmm_free_page(pm_alloc_t block_disc){
c02050e5:	55                   	push   %ebp
c02050e6:	89 e5                	mov    %esp,%ebp
c02050e8:	53                   	push   %ebx
c02050e9:	83 ec 14             	sub    $0x14,%esp
c02050ec:	e8 13 2f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02050f1:	81 c3 0f 3f 00 00    	add    $0x3f0f,%ebx
	//检查页是否在页编号范围内
	uint32_t page_no = addr_to_pmm_page_no(block_disc.addr);
c02050f7:	8b 45 08             	mov    0x8(%ebp),%eax
c02050fa:	50                   	push   %eax
c02050fb:	e8 da f0 ff ff       	call   c02041da <addr_to_pmm_page_no>
c0205100:	83 c4 04             	add    $0x4,%esp
c0205103:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(page_no<pmm_max_page_no){
c0205106:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c020510c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c020510f:	73 7f                	jae    c0205190 <pmm_free_page+0xab>
		if(page_no<singel_page_first_no)
c0205111:	8b 83 9c 90 08 00    	mov    0x8909c(%ebx),%eax
c0205117:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c020511a:	73 14                	jae    c0205130 <pmm_free_page+0x4b>
			free_helper(page_no,block_disc.size);
c020511c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020511f:	83 ec 08             	sub    $0x8,%esp
c0205122:	50                   	push   %eax
c0205123:	ff 75 f0             	pushl  -0x10(%ebp)
c0205126:	e8 29 ff ff ff       	call   c0205054 <free_helper>
c020512b:	83 c4 10             	add    $0x10,%esp
c020512e:	eb 59                	jmp    c0205189 <pmm_free_page+0xa4>
		else{
			pm_page_t *probe = SINGLE_LINK;
c0205130:	8b 83 8c 90 08 00    	mov    0x8908c(%ebx),%eax
c0205136:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if(probe==NULL){
c0205139:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c020513d:	75 25                	jne    c0205164 <pmm_free_page+0x7f>
				SINGLE_LINK=&page_array[page_no];
c020513f:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0205145:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205148:	89 d0                	mov    %edx,%eax
c020514a:	01 c0                	add    %eax,%eax
c020514c:	01 d0                	add    %edx,%eax
c020514e:	c1 e0 02             	shl    $0x2,%eax
c0205151:	01 c8                	add    %ecx,%eax
c0205153:	89 83 8c 90 08 00    	mov    %eax,0x8908c(%ebx)
c0205159:	eb 2e                	jmp    c0205189 <pmm_free_page+0xa4>
			}
			else{
				for(;probe->next!=NULL;probe=probe->next)
c020515b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020515e:	8b 40 04             	mov    0x4(%eax),%eax
c0205161:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0205164:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205167:	8b 40 04             	mov    0x4(%eax),%eax
c020516a:	85 c0                	test   %eax,%eax
c020516c:	75 ed                	jne    c020515b <pmm_free_page+0x76>
					;
				probe->next = &page_array[page_no];
c020516e:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0205174:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205177:	89 d0                	mov    %edx,%eax
c0205179:	01 c0                	add    %eax,%eax
c020517b:	01 d0                	add    %edx,%eax
c020517d:	c1 e0 02             	shl    $0x2,%eax
c0205180:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0205183:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205186:	89 50 04             	mov    %edx,0x4(%eax)
			}
		}
		return True;
c0205189:	b8 01 00 00 00       	mov    $0x1,%eax
c020518e:	eb 05                	jmp    c0205195 <pmm_free_page+0xb0>
	}
	else
		return False;
c0205190:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0205195:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205198:	c9                   	leave  
c0205199:	c3                   	ret    

c020519a <counte_helper>:

static uint32_t counte_helper(pm_page_t * probe){
c020519a:	55                   	push   %ebp
c020519b:	89 e5                	mov    %esp,%ebp
c020519d:	83 ec 10             	sub    $0x10,%esp
c02051a0:	e8 5b 2e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02051a5:	05 5b 3e 00 00       	add    $0x3e5b,%eax
	uint32_t counter = 0;
c02051aa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02051b1:	eb 0d                	jmp    c02051c0 <counte_helper+0x26>
		counter++;
c02051b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02051b7:	8b 45 08             	mov    0x8(%ebp),%eax
c02051ba:	8b 40 04             	mov    0x4(%eax),%eax
c02051bd:	89 45 08             	mov    %eax,0x8(%ebp)
c02051c0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c02051c4:	75 ed                	jne    c02051b3 <counte_helper+0x19>
	return counter;
c02051c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c02051c9:	c9                   	leave  
c02051ca:	c3                   	ret    

c02051cb <get_block_count>:

uint32_t * get_block_count(){
c02051cb:	55                   	push   %ebp
c02051cc:	89 e5                	mov    %esp,%ebp
c02051ce:	53                   	push   %ebx
c02051cf:	e8 30 2e 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02051d4:	81 c3 2c 3e 00 00    	add    $0x3e2c,%ebx
	block_count_array[_1]=counte_helper(MULTI_LINK->_1);
c02051da:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02051e0:	8b 00                	mov    (%eax),%eax
c02051e2:	8b 00                	mov    (%eax),%eax
c02051e4:	50                   	push   %eax
c02051e5:	e8 b0 ff ff ff       	call   c020519a <counte_helper>
c02051ea:	83 c4 04             	add    $0x4,%esp
c02051ed:	89 83 20 90 08 00    	mov    %eax,0x89020(%ebx)
	block_count_array[_2]=counte_helper(MULTI_LINK->_2);
c02051f3:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02051f9:	8b 00                	mov    (%eax),%eax
c02051fb:	8b 40 04             	mov    0x4(%eax),%eax
c02051fe:	50                   	push   %eax
c02051ff:	e8 96 ff ff ff       	call   c020519a <counte_helper>
c0205204:	83 c4 04             	add    $0x4,%esp
c0205207:	89 83 24 90 08 00    	mov    %eax,0x89024(%ebx)
	block_count_array[_4]=counte_helper(MULTI_LINK->_4);
c020520d:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205213:	8b 00                	mov    (%eax),%eax
c0205215:	8b 40 08             	mov    0x8(%eax),%eax
c0205218:	50                   	push   %eax
c0205219:	e8 7c ff ff ff       	call   c020519a <counte_helper>
c020521e:	83 c4 04             	add    $0x4,%esp
c0205221:	89 83 28 90 08 00    	mov    %eax,0x89028(%ebx)
	block_count_array[_8]=counte_helper(MULTI_LINK->_8);
c0205227:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020522d:	8b 00                	mov    (%eax),%eax
c020522f:	8b 40 0c             	mov    0xc(%eax),%eax
c0205232:	50                   	push   %eax
c0205233:	e8 62 ff ff ff       	call   c020519a <counte_helper>
c0205238:	83 c4 04             	add    $0x4,%esp
c020523b:	89 83 2c 90 08 00    	mov    %eax,0x8902c(%ebx)
	block_count_array[_16]=counte_helper(MULTI_LINK->_16);
c0205241:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205247:	8b 00                	mov    (%eax),%eax
c0205249:	8b 40 10             	mov    0x10(%eax),%eax
c020524c:	50                   	push   %eax
c020524d:	e8 48 ff ff ff       	call   c020519a <counte_helper>
c0205252:	83 c4 04             	add    $0x4,%esp
c0205255:	89 83 30 90 08 00    	mov    %eax,0x89030(%ebx)
	block_count_array[_32]=counte_helper(MULTI_LINK->_32);
c020525b:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205261:	8b 00                	mov    (%eax),%eax
c0205263:	8b 40 14             	mov    0x14(%eax),%eax
c0205266:	50                   	push   %eax
c0205267:	e8 2e ff ff ff       	call   c020519a <counte_helper>
c020526c:	83 c4 04             	add    $0x4,%esp
c020526f:	89 83 34 90 08 00    	mov    %eax,0x89034(%ebx)
	block_count_array[_64]=counte_helper(MULTI_LINK->_64);
c0205275:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020527b:	8b 00                	mov    (%eax),%eax
c020527d:	8b 40 18             	mov    0x18(%eax),%eax
c0205280:	50                   	push   %eax
c0205281:	e8 14 ff ff ff       	call   c020519a <counte_helper>
c0205286:	83 c4 04             	add    $0x4,%esp
c0205289:	89 83 38 90 08 00    	mov    %eax,0x89038(%ebx)
	block_count_array[_128]=counte_helper(MULTI_LINK->_128);
c020528f:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205295:	8b 00                	mov    (%eax),%eax
c0205297:	8b 40 1c             	mov    0x1c(%eax),%eax
c020529a:	50                   	push   %eax
c020529b:	e8 fa fe ff ff       	call   c020519a <counte_helper>
c02052a0:	83 c4 04             	add    $0x4,%esp
c02052a3:	89 83 3c 90 08 00    	mov    %eax,0x8903c(%ebx)
	block_count_array[_256]=counte_helper(MULTI_LINK->_256);
c02052a9:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052af:	8b 00                	mov    (%eax),%eax
c02052b1:	8b 40 20             	mov    0x20(%eax),%eax
c02052b4:	50                   	push   %eax
c02052b5:	e8 e0 fe ff ff       	call   c020519a <counte_helper>
c02052ba:	83 c4 04             	add    $0x4,%esp
c02052bd:	89 83 40 90 08 00    	mov    %eax,0x89040(%ebx)
	block_count_array[_512]=counte_helper(MULTI_LINK->_512);
c02052c3:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052c9:	8b 00                	mov    (%eax),%eax
c02052cb:	8b 40 24             	mov    0x24(%eax),%eax
c02052ce:	50                   	push   %eax
c02052cf:	e8 c6 fe ff ff       	call   c020519a <counte_helper>
c02052d4:	83 c4 04             	add    $0x4,%esp
c02052d7:	89 83 44 90 08 00    	mov    %eax,0x89044(%ebx)
	block_count_array[_1024]=counte_helper(MULTI_LINK->_1024);
c02052dd:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052e3:	8b 00                	mov    (%eax),%eax
c02052e5:	8b 40 28             	mov    0x28(%eax),%eax
c02052e8:	50                   	push   %eax
c02052e9:	e8 ac fe ff ff       	call   c020519a <counte_helper>
c02052ee:	83 c4 04             	add    $0x4,%esp
c02052f1:	89 83 48 90 08 00    	mov    %eax,0x89048(%ebx)
	block_count_array[_erro]=0;
c02052f7:	c7 83 4c 90 08 00 00 	movl   $0x0,0x8904c(%ebx)
c02052fe:	00 00 00 
	return block_count_array;
c0205301:	8d 83 20 90 08 00    	lea    0x89020(%ebx),%eax
}
c0205307:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020530a:	c9                   	leave  
c020530b:	c3                   	ret    

c020530c <get_single_count>:

uint32_t get_single_count(){
c020530c:	55                   	push   %ebp
c020530d:	89 e5                	mov    %esp,%ebp
c020530f:	83 ec 10             	sub    $0x10,%esp
c0205312:	e8 e9 2c 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205317:	05 e9 3c 00 00       	add    $0x3ce9,%eax
	pm_page_t * probe =SINGLE_LINK;
c020531c:	8b 80 8c 90 08 00    	mov    0x8908c(%eax),%eax
c0205322:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter = 0;
c0205325:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c020532c:	eb 0d                	jmp    c020533b <get_single_count+0x2f>
		counter++;
c020532e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205332:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205335:	8b 40 04             	mov    0x4(%eax),%eax
c0205338:	89 45 fc             	mov    %eax,-0x4(%ebp)
c020533b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020533f:	75 ed                	jne    c020532e <get_single_count+0x22>
	return counter;	
c0205341:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0205344:	c9                   	leave  
c0205345:	c3                   	ret    

c0205346 <pmm_show_page_count>:

//打印块使用情况的函数 
//懒得挨个写 用宏来解决
// #表示字符串化 ##表示连接生成符号操作
#define MACRO_PMM_1(number) printk("_"#number":%d blocks\n",block_count_array[_##number])
void pmm_show_page_count(){
c0205346:	55                   	push   %ebp
c0205347:	89 e5                	mov    %esp,%ebp
c0205349:	53                   	push   %ebx
c020534a:	83 ec 04             	sub    $0x4,%esp
c020534d:	e8 b2 2c 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205352:	81 c3 ae 3c 00 00    	add    $0x3cae,%ebx
	get_block_count();
c0205358:	e8 6e fe ff ff       	call   c02051cb <get_block_count>
	printk("Partner:\n");
c020535d:	83 ec 0c             	sub    $0xc,%esp
c0205360:	8d 83 b5 03 00 00    	lea    0x3b5(%ebx),%eax
c0205366:	50                   	push   %eax
c0205367:	e8 c8 1f 00 00       	call   c0207334 <printk>
c020536c:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1);
c020536f:	8b 83 20 90 08 00    	mov    0x89020(%ebx),%eax
c0205375:	83 ec 08             	sub    $0x8,%esp
c0205378:	50                   	push   %eax
c0205379:	8d 83 bf 03 00 00    	lea    0x3bf(%ebx),%eax
c020537f:	50                   	push   %eax
c0205380:	e8 af 1f 00 00       	call   c0207334 <printk>
c0205385:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(2);
c0205388:	8b 83 24 90 08 00    	mov    0x89024(%ebx),%eax
c020538e:	83 ec 08             	sub    $0x8,%esp
c0205391:	50                   	push   %eax
c0205392:	8d 83 cd 03 00 00    	lea    0x3cd(%ebx),%eax
c0205398:	50                   	push   %eax
c0205399:	e8 96 1f 00 00       	call   c0207334 <printk>
c020539e:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(4);
c02053a1:	8b 83 28 90 08 00    	mov    0x89028(%ebx),%eax
c02053a7:	83 ec 08             	sub    $0x8,%esp
c02053aa:	50                   	push   %eax
c02053ab:	8d 83 db 03 00 00    	lea    0x3db(%ebx),%eax
c02053b1:	50                   	push   %eax
c02053b2:	e8 7d 1f 00 00       	call   c0207334 <printk>
c02053b7:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(8);
c02053ba:	8b 83 2c 90 08 00    	mov    0x8902c(%ebx),%eax
c02053c0:	83 ec 08             	sub    $0x8,%esp
c02053c3:	50                   	push   %eax
c02053c4:	8d 83 e9 03 00 00    	lea    0x3e9(%ebx),%eax
c02053ca:	50                   	push   %eax
c02053cb:	e8 64 1f 00 00       	call   c0207334 <printk>
c02053d0:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(16);
c02053d3:	8b 83 30 90 08 00    	mov    0x89030(%ebx),%eax
c02053d9:	83 ec 08             	sub    $0x8,%esp
c02053dc:	50                   	push   %eax
c02053dd:	8d 83 f7 03 00 00    	lea    0x3f7(%ebx),%eax
c02053e3:	50                   	push   %eax
c02053e4:	e8 4b 1f 00 00       	call   c0207334 <printk>
c02053e9:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(32);
c02053ec:	8b 83 34 90 08 00    	mov    0x89034(%ebx),%eax
c02053f2:	83 ec 08             	sub    $0x8,%esp
c02053f5:	50                   	push   %eax
c02053f6:	8d 83 06 04 00 00    	lea    0x406(%ebx),%eax
c02053fc:	50                   	push   %eax
c02053fd:	e8 32 1f 00 00       	call   c0207334 <printk>
c0205402:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(64);
c0205405:	8b 83 38 90 08 00    	mov    0x89038(%ebx),%eax
c020540b:	83 ec 08             	sub    $0x8,%esp
c020540e:	50                   	push   %eax
c020540f:	8d 83 15 04 00 00    	lea    0x415(%ebx),%eax
c0205415:	50                   	push   %eax
c0205416:	e8 19 1f 00 00       	call   c0207334 <printk>
c020541b:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(128);
c020541e:	8b 83 3c 90 08 00    	mov    0x8903c(%ebx),%eax
c0205424:	83 ec 08             	sub    $0x8,%esp
c0205427:	50                   	push   %eax
c0205428:	8d 83 24 04 00 00    	lea    0x424(%ebx),%eax
c020542e:	50                   	push   %eax
c020542f:	e8 00 1f 00 00       	call   c0207334 <printk>
c0205434:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(256);
c0205437:	8b 83 40 90 08 00    	mov    0x89040(%ebx),%eax
c020543d:	83 ec 08             	sub    $0x8,%esp
c0205440:	50                   	push   %eax
c0205441:	8d 83 34 04 00 00    	lea    0x434(%ebx),%eax
c0205447:	50                   	push   %eax
c0205448:	e8 e7 1e 00 00       	call   c0207334 <printk>
c020544d:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(512);
c0205450:	8b 83 44 90 08 00    	mov    0x89044(%ebx),%eax
c0205456:	83 ec 08             	sub    $0x8,%esp
c0205459:	50                   	push   %eax
c020545a:	8d 83 44 04 00 00    	lea    0x444(%ebx),%eax
c0205460:	50                   	push   %eax
c0205461:	e8 ce 1e 00 00       	call   c0207334 <printk>
c0205466:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1024);
c0205469:	8b 83 48 90 08 00    	mov    0x89048(%ebx),%eax
c020546f:	83 ec 08             	sub    $0x8,%esp
c0205472:	50                   	push   %eax
c0205473:	8d 83 54 04 00 00    	lea    0x454(%ebx),%eax
c0205479:	50                   	push   %eax
c020547a:	e8 b5 1e 00 00       	call   c0207334 <printk>
c020547f:	83 c4 10             	add    $0x10,%esp
	printk("singel buffer have:%d pages!\n",get_single_count());
c0205482:	e8 85 fe ff ff       	call   c020530c <get_single_count>
c0205487:	83 ec 08             	sub    $0x8,%esp
c020548a:	50                   	push   %eax
c020548b:	8d 83 65 04 00 00    	lea    0x465(%ebx),%eax
c0205491:	50                   	push   %eax
c0205492:	e8 9d 1e 00 00       	call   c0207334 <printk>
c0205497:	83 c4 10             	add    $0x10,%esp
}
c020549a:	90                   	nop
c020549b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020549e:	c9                   	leave  
c020549f:	c3                   	ret    

c02054a0 <pmm_init>:
//取消此宏定义 将宏定义范围限制在此函数中
#undef MACRO_PMM_1(number)

//为内核entry使用的pmm管理模块初始化函数
void pmm_init(){
c02054a0:	55                   	push   %ebp
c02054a1:	89 e5                	mov    %esp,%ebp
c02054a3:	53                   	push   %ebx
c02054a4:	83 ec 04             	sub    $0x4,%esp
c02054a7:	e8 58 2b 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02054ac:	81 c3 54 3b 00 00    	add    $0x3b54,%ebx
	printk("[INFO][PMM]kern_physic_start:0x%h\n",kern_start);
c02054b2:	83 ec 08             	sub    $0x8,%esp
c02054b5:	c7 c0 00 00 10 00    	mov    $0x100000,%eax
c02054bb:	50                   	push   %eax
c02054bc:	8d 83 84 04 00 00    	lea    0x484(%ebx),%eax
c02054c2:	50                   	push   %eax
c02054c3:	e8 6c 1e 00 00       	call   c0207334 <printk>
c02054c8:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]kern_physic_end:0x%h\n",kern_end);
c02054cb:	83 ec 08             	sub    $0x8,%esp
c02054ce:	c7 c0 00 30 2a 00    	mov    $0x2a3000,%eax
c02054d4:	50                   	push   %eax
c02054d5:	8d 83 a8 04 00 00    	lea    0x4a8(%ebx),%eax
c02054db:	50                   	push   %eax
c02054dc:	e8 53 1e 00 00       	call   c0207334 <printk>
c02054e1:	83 c4 10             	add    $0x10,%esp
	//一定要注意 由于分页必须4k对齐 所以此处的物理页管理必须与虚拟页相同 都要4K对齐
	pmm_page_start = ((((uint32_t)kern_end >> 12))+1)<<12;
c02054e4:	c7 c0 00 30 2a 00    	mov    $0x2a3000,%eax
c02054ea:	c1 e8 0c             	shr    $0xc,%eax
c02054ed:	83 c0 01             	add    $0x1,%eax
c02054f0:	c1 e0 0c             	shl    $0xc,%eax
c02054f3:	89 83 90 90 08 00    	mov    %eax,0x89090(%ebx)
	pmm_page_end = (((get_max_pm_addr() >> 12)))<<12;
c02054f9:	e8 9c f5 ff ff       	call   c0204a9a <get_max_pm_addr>
c02054fe:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0205503:	89 83 94 90 08 00    	mov    %eax,0x89094(%ebx)
	pmm_max_page_no = ((pmm_page_end - pmm_page_start)>>12);
c0205509:	8b 93 94 90 08 00    	mov    0x89094(%ebx),%edx
c020550f:	8b 83 90 90 08 00    	mov    0x89090(%ebx),%eax
c0205515:	29 c2                	sub    %eax,%edx
c0205517:	89 d0                	mov    %edx,%eax
c0205519:	c1 e8 0c             	shr    $0xc,%eax
c020551c:	89 83 98 90 08 00    	mov    %eax,0x89098(%ebx)
	printk("[INFO][PMM]pmm_start:0x%h\n",pmm_page_start);
c0205522:	8b 83 90 90 08 00    	mov    0x89090(%ebx),%eax
c0205528:	83 ec 08             	sub    $0x8,%esp
c020552b:	50                   	push   %eax
c020552c:	8d 83 c9 04 00 00    	lea    0x4c9(%ebx),%eax
c0205532:	50                   	push   %eax
c0205533:	e8 fc 1d 00 00       	call   c0207334 <printk>
c0205538:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]pmm_end:0x%h\n",pmm_page_end);
c020553b:	8b 83 94 90 08 00    	mov    0x89094(%ebx),%eax
c0205541:	83 ec 08             	sub    $0x8,%esp
c0205544:	50                   	push   %eax
c0205545:	8d 83 e4 04 00 00    	lea    0x4e4(%ebx),%eax
c020554b:	50                   	push   %eax
c020554c:	e8 e3 1d 00 00       	call   c0207334 <printk>
c0205551:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]physic_page_count:%d\n",pmm_max_page_no+1);
c0205554:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c020555a:	83 c0 01             	add    $0x1,%eax
c020555d:	83 ec 08             	sub    $0x8,%esp
c0205560:	50                   	push   %eax
c0205561:	8d 83 00 05 00 00    	lea    0x500(%ebx),%eax
c0205567:	50                   	push   %eax
c0205568:	e8 c7 1d 00 00       	call   c0207334 <printk>
c020556d:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]first_page_physic_addr:0x%h\n",pmm_page_no_to_addr(32000));
c0205570:	83 ec 0c             	sub    $0xc,%esp
c0205573:	68 00 7d 00 00       	push   $0x7d00
c0205578:	e8 40 ec ff ff       	call   c02041bd <pmm_page_no_to_addr>
c020557d:	83 c4 10             	add    $0x10,%esp
c0205580:	83 ec 08             	sub    $0x8,%esp
c0205583:	50                   	push   %eax
c0205584:	8d 83 24 05 00 00    	lea    0x524(%ebx),%eax
c020558a:	50                   	push   %eax
c020558b:	e8 a4 1d 00 00       	call   c0207334 <printk>
c0205590:	83 c4 10             	add    $0x10,%esp
	pmm_page_init();
c0205593:	e8 cc f5 ff ff       	call   c0204b64 <pmm_page_init>
c0205598:	90                   	nop
c0205599:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020559c:	c9                   	leave  
c020559d:	c3                   	ret    

c020559e <get_tss_desc>:
#define TSS_ATTR_LOW   0x89//10001001//(1<<7)+(0<<5)+(0<<4)+9
#define TSS_ATTR_HIGH  0x80//10000000//(1<<7)+(0<<6)+(0<<5)+(0<<4)+0x0
#define LOG_SRC_TSS "TSS"
tss_t tss_cpu0;      //存放cpu0的tss    全局变量 不会被栈回收

static  tss_desc_t* get_tss_desc(){
c020559e:	55                   	push   %ebp
c020559f:	89 e5                	mov    %esp,%ebp
c02055a1:	83 ec 10             	sub    $0x10,%esp
c02055a4:	e8 57 2a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02055a9:	05 57 3a 00 00       	add    $0x3a57,%eax
    //GDT_BASE的地址是虚拟地址
    uint32_t gdt_head_vaddr = (uint32_t)&GDT_BASE;
c02055ae:	c7 c0 00 32 20 c0    	mov    $0xc0203200,%eax
c02055b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t tss_desc_vaddr = gdt_head_vaddr+GDT_DESC_SIZE*TSS_CPU0_DESC_POS_ON_GDT;
c02055b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02055ba:	83 c0 30             	add    $0x30,%eax
c02055bd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return (tss_desc_t*)tss_desc_vaddr;
c02055c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c02055c3:	c9                   	leave  
c02055c4:	c3                   	ret    

c02055c5 <create_tss_desc>:

static tss_desc_t create_tss_desc(uint32_t desc_base,uint32_t limit,uint8_t attr_low,uint8_t attr_high){
c02055c5:	55                   	push   %ebp
c02055c6:	89 e5                	mov    %esp,%ebp
c02055c8:	83 ec 18             	sub    $0x18,%esp
c02055cb:	e8 30 2a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02055d0:	05 30 3a 00 00       	add    $0x3a30,%eax
c02055d5:	8b 55 14             	mov    0x14(%ebp),%edx
c02055d8:	8b 45 18             	mov    0x18(%ebp),%eax
c02055db:	88 55 ec             	mov    %dl,-0x14(%ebp)
c02055de:	88 45 e8             	mov    %al,-0x18(%ebp)
    tss_desc_t desc;
    desc.limit_low_word = (uint16_t)(limit & 0x0000FFFF);
c02055e1:	8b 45 10             	mov    0x10(%ebp),%eax
c02055e4:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc.base_low_word = (uint16_t)(desc_base&0x0000FFFF);
c02055e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c02055eb:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    desc.base_mid_byte = (uint8_t)((desc_base&0x00FF0000)>>16);
c02055ef:	8b 45 0c             	mov    0xc(%ebp),%eax
c02055f2:	c1 e8 10             	shr    $0x10,%eax
c02055f5:	88 45 fc             	mov    %al,-0x4(%ebp)
    desc.attr_low_byte = (uint8_t)attr_low;
c02055f8:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c02055fc:	88 45 fd             	mov    %al,-0x3(%ebp)
    desc.limit_high_attr_high = ((limit&0x000F0000)>>16)+(uint8_t)(attr_high);
c02055ff:	8b 45 10             	mov    0x10(%ebp),%eax
c0205602:	c1 e8 10             	shr    $0x10,%eax
c0205605:	83 e0 0f             	and    $0xf,%eax
c0205608:	89 c2                	mov    %eax,%edx
c020560a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c020560e:	01 d0                	add    %edx,%eax
c0205610:	88 45 fe             	mov    %al,-0x2(%ebp)
    desc.base_high_byte = (uint8_t)(desc_base>>24);
c0205613:	8b 45 0c             	mov    0xc(%ebp),%eax
c0205616:	c1 e8 18             	shr    $0x18,%eax
c0205619:	88 45 ff             	mov    %al,-0x1(%ebp)
    return desc;
c020561c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020561f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205622:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0205625:	89 01                	mov    %eax,(%ecx)
c0205627:	89 51 04             	mov    %edx,0x4(%ecx)
}
c020562a:	8b 45 08             	mov    0x8(%ebp),%eax
c020562d:	c9                   	leave  
c020562e:	c2 04 00             	ret    $0x4

c0205631 <get_TSS_desc_high_word>:

//这个函数用来验证TSS是否加载成功
//加载成功后TSS描述符的B位会被置为1
static uint32_t get_TSS_desc_high_word(){
c0205631:	55                   	push   %ebp
c0205632:	89 e5                	mov    %esp,%ebp
c0205634:	83 ec 10             	sub    $0x10,%esp
c0205637:	e8 c4 29 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020563c:	05 c4 39 00 00       	add    $0x39c4,%eax
    tss_desc_t * tss_d = get_tss_desc();
c0205641:	e8 58 ff ff ff       	call   c020559e <get_tss_desc>
c0205646:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t * p = (uint32_t*)tss_d;
c0205649:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020564c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return *(p+1);
c020564f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205652:	8b 40 04             	mov    0x4(%eax),%eax
}
c0205655:	c9                   	leave  
c0205656:	c3                   	ret    

c0205657 <tss_init>:

void tss_init(){
c0205657:	55                   	push   %ebp
c0205658:	89 e5                	mov    %esp,%ebp
c020565a:	56                   	push   %esi
c020565b:	53                   	push   %ebx
c020565c:	83 ec 20             	sub    $0x20,%esp
c020565f:	e8 a0 29 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205664:	81 c3 9c 39 00 00    	add    $0x399c,%ebx
    uint32_t tss_size = sizeof(tss_t);
c020566a:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
    tss_desc_t* tss_cpu0_desc_ptr = get_tss_desc();
c0205671:	e8 28 ff ff ff       	call   c020559e <get_tss_desc>
c0205676:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bzero(&tss_cpu0,tss_size);
c0205679:	83 ec 08             	sub    $0x8,%esp
c020567c:	ff 75 f4             	pushl  -0xc(%ebp)
c020567f:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c0205685:	50                   	push   %eax
c0205686:	e8 a6 23 00 00       	call   c0207a31 <bzero>
c020568b:	83 c4 10             	add    $0x10,%esp
    tss_cpu0.io_base =tss_size;
c020568e:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c0205694:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205697:	89 50 68             	mov    %edx,0x68(%eax)
    tss_cpu0.ss0 = SELECTOR_DATA_MEM&0x0000FFFF;    //内核数据段
c020569a:	c7 c0 3a 32 20 c0    	mov    $0xc020323a,%eax
c02056a0:	0f b7 00             	movzwl (%eax),%eax
c02056a3:	0f b7 d0             	movzwl %ax,%edx
c02056a6:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02056ac:	89 50 08             	mov    %edx,0x8(%eax)
    *tss_cpu0_desc_ptr=create_tss_desc(&tss_cpu0,tss_size-1,TSS_ATTR_LOW,TSS_ATTR_HIGH);   
c02056af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02056b2:	8d 50 ff             	lea    -0x1(%eax),%edx
c02056b5:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02056bb:	89 c1                	mov    %eax,%ecx
c02056bd:	8b 75 f0             	mov    -0x10(%ebp),%esi
c02056c0:	8d 45 e0             	lea    -0x20(%ebp),%eax
c02056c3:	83 ec 0c             	sub    $0xc,%esp
c02056c6:	68 80 00 00 00       	push   $0x80
c02056cb:	68 89 00 00 00       	push   $0x89
c02056d0:	52                   	push   %edx
c02056d1:	51                   	push   %ecx
c02056d2:	50                   	push   %eax
c02056d3:	e8 ed fe ff ff       	call   c02055c5 <create_tss_desc>
c02056d8:	83 c4 1c             	add    $0x1c,%esp
c02056db:	8b 45 e0             	mov    -0x20(%ebp),%eax
c02056de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c02056e1:	89 06                	mov    %eax,(%esi)
c02056e3:	89 56 04             	mov    %edx,0x4(%esi)
    //重载GDT
    uint32_t befor_load_val = get_TSS_desc_high_word();
c02056e6:	e8 46 ff ff ff       	call   c0205631 <get_TSS_desc_high_word>
c02056eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    reload_gdt();
c02056ee:	e8 dd da ff ff       	call   c02031d0 <reload_gdt>
    //加载TSS
    asm volatile("ltr %w0" : : "r" (SELECTOR_TSS_CPU0_MEM));
c02056f3:	c7 c0 42 32 20 c0    	mov    $0xc0203242,%eax
c02056f9:	0f b7 00             	movzwl (%eax),%eax
c02056fc:	0f 00 d8             	ltr    %ax
    uint32_t after_load_val = get_TSS_desc_high_word();
c02056ff:	e8 2d ff ff ff       	call   c0205631 <get_TSS_desc_high_word>
c0205704:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //装载tss后 cpu会修改tss描述符B位 所以高32位会变化
    if(after_load_val!=befor_load_val){
c0205707:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020570a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c020570d:	74 1b                	je     c020572a <tss_init+0xd3>
        INFO(LOG_SRC_TSS,"Init TSS Success!");
c020570f:	83 ec 08             	sub    $0x8,%esp
c0205712:	8d 83 4c 05 00 00    	lea    0x54c(%ebx),%eax
c0205718:	50                   	push   %eax
c0205719:	8d 83 5e 05 00 00    	lea    0x55e(%ebx),%eax
c020571f:	50                   	push   %eax
c0205720:	e8 88 00 00 00       	call   c02057ad <info_kern>
c0205725:	83 c4 10             	add    $0x10,%esp
    }
    else{
        STOP(LOG_SRC_TSS,"Fail To Load TSS!STOP!");
    }
}
c0205728:	eb 19                	jmp    c0205743 <tss_init+0xec>
        STOP(LOG_SRC_TSS,"Fail To Load TSS!STOP!");
c020572a:	83 ec 08             	sub    $0x8,%esp
c020572d:	8d 83 62 05 00 00    	lea    0x562(%ebx),%eax
c0205733:	50                   	push   %eax
c0205734:	8d 83 5e 05 00 00    	lea    0x55e(%ebx),%eax
c020573a:	50                   	push   %eax
c020573b:	e8 08 01 00 00       	call   c0205848 <stop_kern>
c0205740:	83 c4 10             	add    $0x10,%esp
}
c0205743:	90                   	nop
c0205744:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0205747:	5b                   	pop    %ebx
c0205748:	5e                   	pop    %esi
c0205749:	5d                   	pop    %ebp
c020574a:	c3                   	ret    

c020574b <tss_update>:

void tss_update(TCB_t* tcb_ptr){
c020574b:	55                   	push   %ebp
c020574c:	89 e5                	mov    %esp,%ebp
c020574e:	e8 ad 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205753:	05 ad 38 00 00       	add    $0x38ad,%eax
    tss_cpu0.esp0 = (uint32_t*)((uint32_t)tcb_ptr+tcb_ptr->page_counte*PAGE_SIZE);
c0205758:	8b 55 08             	mov    0x8(%ebp),%edx
c020575b:	8b 52 18             	mov    0x18(%edx),%edx
c020575e:	89 d1                	mov    %edx,%ecx
c0205760:	c1 e1 0c             	shl    $0xc,%ecx
c0205763:	8b 55 08             	mov    0x8(%ebp),%edx
c0205766:	01 ca                	add    %ecx,%edx
c0205768:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c020576e:	89 50 04             	mov    %edx,0x4(%eax)
}
c0205771:	90                   	nop
c0205772:	5d                   	pop    %ebp
c0205773:	c3                   	ret    

c0205774 <tss_test>:

void tss_test(){
c0205774:	55                   	push   %ebp
c0205775:	89 e5                	mov    %esp,%ebp
c0205777:	53                   	push   %ebx
c0205778:	83 ec 04             	sub    $0x4,%esp
c020577b:	e8 80 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205780:	05 80 38 00 00       	add    $0x3880,%eax
    printk("GDT_BASE:%h\nGDT_PTR:0x%h\n",&GDT_BASE,&gdt_ptr);
c0205785:	83 ec 04             	sub    $0x4,%esp
c0205788:	c7 c2 48 32 20 c0    	mov    $0xc0203248,%edx
c020578e:	52                   	push   %edx
c020578f:	c7 c2 00 32 20 c0    	mov    $0xc0203200,%edx
c0205795:	52                   	push   %edx
c0205796:	8d 90 79 05 00 00    	lea    0x579(%eax),%edx
c020579c:	52                   	push   %edx
c020579d:	89 c3                	mov    %eax,%ebx
c020579f:	e8 90 1b 00 00       	call   c0207334 <printk>
c02057a4:	83 c4 10             	add    $0x10,%esp
c02057a7:	90                   	nop
c02057a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02057ab:	c9                   	leave  
c02057ac:	c3                   	ret    

c02057ad <info_kern>:
#include "kern_log.h"
#include "printk.h"
#include "vga_basic.h"
void info_kern(char* src,char* text){
c02057ad:	55                   	push   %ebp
c02057ae:	89 e5                	mov    %esp,%ebp
c02057b0:	53                   	push   %ebx
c02057b1:	83 ec 04             	sub    $0x4,%esp
c02057b4:	e8 47 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02057b9:	05 47 38 00 00       	add    $0x3847,%eax
    printk("[INFO][%s]%s\n",src,text);
c02057be:	83 ec 04             	sub    $0x4,%esp
c02057c1:	ff 75 0c             	pushl  0xc(%ebp)
c02057c4:	ff 75 08             	pushl  0x8(%ebp)
c02057c7:	8d 90 93 05 00 00    	lea    0x593(%eax),%edx
c02057cd:	52                   	push   %edx
c02057ce:	89 c3                	mov    %eax,%ebx
c02057d0:	e8 5f 1b 00 00       	call   c0207334 <printk>
c02057d5:	83 c4 10             	add    $0x10,%esp
}
c02057d8:	90                   	nop
c02057d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02057dc:	c9                   	leave  
c02057dd:	c3                   	ret    

c02057de <error_kern>:

void error_kern(char* src,char* text){
c02057de:	55                   	push   %ebp
c02057df:	89 e5                	mov    %esp,%ebp
c02057e1:	53                   	push   %ebx
c02057e2:	83 ec 04             	sub    $0x4,%esp
c02057e5:	e8 16 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02057ea:	05 16 38 00 00       	add    $0x3816,%eax
    printk_color("[ERROR][%s]%s\n",black,red,src,text);
c02057ef:	83 ec 0c             	sub    $0xc,%esp
c02057f2:	ff 75 0c             	pushl  0xc(%ebp)
c02057f5:	ff 75 08             	pushl  0x8(%ebp)
c02057f8:	6a 04                	push   $0x4
c02057fa:	6a 00                	push   $0x0
c02057fc:	8d 90 a1 05 00 00    	lea    0x5a1(%eax),%edx
c0205802:	52                   	push   %edx
c0205803:	89 c3                	mov    %eax,%ebx
c0205805:	e8 9e 1d 00 00       	call   c02075a8 <printk_color>
c020580a:	83 c4 20             	add    $0x20,%esp
}
c020580d:	90                   	nop
c020580e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205811:	c9                   	leave  
c0205812:	c3                   	ret    

c0205813 <warning_kern>:

void warning_kern(char* src,char* text){
c0205813:	55                   	push   %ebp
c0205814:	89 e5                	mov    %esp,%ebp
c0205816:	53                   	push   %ebx
c0205817:	83 ec 04             	sub    $0x4,%esp
c020581a:	e8 e1 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020581f:	05 e1 37 00 00       	add    $0x37e1,%eax
    printk_color("[WARNING][%s]%s\n",black,yellow,src,text);
c0205824:	83 ec 0c             	sub    $0xc,%esp
c0205827:	ff 75 0c             	pushl  0xc(%ebp)
c020582a:	ff 75 08             	pushl  0x8(%ebp)
c020582d:	6a 0e                	push   $0xe
c020582f:	6a 00                	push   $0x0
c0205831:	8d 90 b0 05 00 00    	lea    0x5b0(%eax),%edx
c0205837:	52                   	push   %edx
c0205838:	89 c3                	mov    %eax,%ebx
c020583a:	e8 69 1d 00 00       	call   c02075a8 <printk_color>
c020583f:	83 c4 20             	add    $0x20,%esp
}
c0205842:	90                   	nop
c0205843:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205846:	c9                   	leave  
c0205847:	c3                   	ret    

c0205848 <stop_kern>:

void stop_kern(char* src,char* text){
c0205848:	55                   	push   %ebp
c0205849:	89 e5                	mov    %esp,%ebp
c020584b:	53                   	push   %ebx
c020584c:	83 ec 04             	sub    $0x4,%esp
c020584f:	e8 ac 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205854:	05 ac 37 00 00       	add    $0x37ac,%eax
    //printk("[STOP][%s]%s\n",src,text);
    printk_color("[STOP][%s]%s\n",white,black,src,text);
c0205859:	83 ec 0c             	sub    $0xc,%esp
c020585c:	ff 75 0c             	pushl  0xc(%ebp)
c020585f:	ff 75 08             	pushl  0x8(%ebp)
c0205862:	6a 00                	push   $0x0
c0205864:	6a 0f                	push   $0xf
c0205866:	8d 90 c1 05 00 00    	lea    0x5c1(%eax),%edx
c020586c:	52                   	push   %edx
c020586d:	89 c3                	mov    %eax,%ebx
c020586f:	e8 34 1d 00 00       	call   c02075a8 <printk_color>
c0205874:	83 c4 20             	add    $0x20,%esp
    while(1){}
c0205877:	eb fe                	jmp    c0205877 <stop_kern+0x2f>

c0205879 <debug>:
}

void debug(function func,char *src,char*text){
c0205879:	55                   	push   %ebp
c020587a:	89 e5                	mov    %esp,%ebp
c020587c:	83 ec 08             	sub    $0x8,%esp
c020587f:	e8 7c 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205884:	05 7c 37 00 00       	add    $0x377c,%eax
    #ifdef DEBUG_FLAGE
    func(src,text);
c0205889:	83 ec 08             	sub    $0x8,%esp
c020588c:	ff 75 10             	pushl  0x10(%ebp)
c020588f:	ff 75 0c             	pushl  0xc(%ebp)
c0205892:	8b 45 08             	mov    0x8(%ebp),%eax
c0205895:	ff d0                	call   *%eax
c0205897:	83 c4 10             	add    $0x10,%esp
    #endif
c020589a:	90                   	nop
c020589b:	c9                   	leave  
c020589c:	c3                   	ret    

c020589d <set_int_disc>:
int_server_func_t int_server_func_list[256];
interrupt_discripter_t idt_entries[256];    //中断描述符表 idt_entries为表首指针
lidt_target_t lidt_target;
static uint8_t default_inf=0x8E;
static uint16_t kern_cs=0x08; 
static void set_int_disc(int int_no, uint32_t offset, uint16_t selector, uint8_t inf){
c020589d:	55                   	push   %ebp
c020589e:	89 e5                	mov    %esp,%ebp
c02058a0:	53                   	push   %ebx
c02058a1:	83 ec 08             	sub    $0x8,%esp
c02058a4:	e8 57 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02058a9:	05 57 37 00 00       	add    $0x3757,%eax
c02058ae:	8b 4d 10             	mov    0x10(%ebp),%ecx
c02058b1:	8b 55 14             	mov    0x14(%ebp),%edx
c02058b4:	66 89 4d f8          	mov    %cx,-0x8(%ebp)
c02058b8:	88 55 f4             	mov    %dl,-0xc(%ebp)
	idt_entries[int_no].offset_low=(uint16_t)offset;
c02058bb:	8b 55 0c             	mov    0xc(%ebp),%edx
c02058be:	89 d3                	mov    %edx,%ebx
c02058c0:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c02058c6:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02058c9:	66 89 1c ca          	mov    %bx,(%edx,%ecx,8)
	idt_entries[int_no].offset_high=(uint16_t)(offset>>16);
c02058cd:	8b 55 0c             	mov    0xc(%ebp),%edx
c02058d0:	c1 ea 10             	shr    $0x10,%edx
c02058d3:	89 d3                	mov    %edx,%ebx
c02058d5:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c02058db:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02058de:	66 89 5c ca 06       	mov    %bx,0x6(%edx,%ecx,8)
	idt_entries[int_no].selector=selector;
c02058e3:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c02058e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02058ec:	0f b7 5d f8          	movzwl -0x8(%ebp),%ebx
c02058f0:	66 89 5c ca 02       	mov    %bx,0x2(%edx,%ecx,8)
	idt_entries[int_no].inf=inf;
c02058f5:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c02058fb:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02058fe:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0205902:	88 5c ca 05          	mov    %bl,0x5(%edx,%ecx,8)
	idt_entries[int_no].default_bit8=0;
c0205906:	c7 c0 20 35 29 c0    	mov    $0xc0293520,%eax
c020590c:	8b 55 08             	mov    0x8(%ebp),%edx
c020590f:	c6 44 d0 04 00       	movb   $0x0,0x4(%eax,%edx,8)
}
c0205914:	90                   	nop
c0205915:	83 c4 08             	add    $0x8,%esp
c0205918:	5b                   	pop    %ebx
c0205919:	5d                   	pop    %ebp
c020591a:	c3                   	ret    

c020591b <timer_init>:
static void timer_init(uint32_t frequency){
c020591b:	55                   	push   %ebp
c020591c:	89 e5                	mov    %esp,%ebp
c020591e:	53                   	push   %ebx
c020591f:	83 ec 14             	sub    $0x14,%esp
c0205922:	e8 dd 26 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205927:	81 c3 d9 36 00 00    	add    $0x36d9,%ebx
	// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h
    // 输入频率为 1193180，frequency 即每秒中断次数
    uint32_t divisor = 1193180 / frequency;
c020592d:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0205932:	ba 00 00 00 00       	mov    $0x0,%edx
c0205937:	f7 75 08             	divl   0x8(%ebp)
c020593a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    // D7 D6 D5 D4 D3 D2 D1 D0
    // 0  0  1  1  0  1  1  0
    // 即就是 36 H
    // 设置 8253/8254 芯片工作在模式 3 下
    outb(0x43, 0x36);
c020593d:	83 ec 08             	sub    $0x8,%esp
c0205940:	6a 36                	push   $0x36
c0205942:	6a 43                	push   $0x43
c0205944:	e8 a2 18 00 00       	call   c02071eb <outb>
c0205949:	83 c4 10             	add    $0x10,%esp

    // 拆分低字节和高字节
    uint8_t low = (uint8_t)(divisor & 0xFF);
c020594c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020594f:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t hign = (uint8_t)((divisor >> 8) & 0xFF);
c0205952:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205955:	c1 e8 08             	shr    $0x8,%eax
c0205958:	88 45 f2             	mov    %al,-0xe(%ebp)
    
    // 分别写入低字节和高字节
    outb(0x40, low);
c020595b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c020595f:	83 ec 08             	sub    $0x8,%esp
c0205962:	50                   	push   %eax
c0205963:	6a 40                	push   $0x40
c0205965:	e8 81 18 00 00       	call   c02071eb <outb>
c020596a:	83 c4 10             	add    $0x10,%esp
    outb(0x40, hign);
c020596d:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
c0205971:	83 ec 08             	sub    $0x8,%esp
c0205974:	50                   	push   %eax
c0205975:	6a 40                	push   $0x40
c0205977:	e8 6f 18 00 00       	call   c02071eb <outb>
c020597c:	83 c4 10             	add    $0x10,%esp
}
c020597f:	90                   	nop
c0205980:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205983:	c9                   	leave  
c0205984:	c3                   	ret    

c0205985 <registe_interrupt>:

static void registe_interrupt(int int_no,int_server_func_t target_func){
c0205985:	55                   	push   %ebp
c0205986:	89 e5                	mov    %esp,%ebp
c0205988:	e8 73 26 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020598d:	05 73 36 00 00       	add    $0x3673,%eax
	int_server_func_list[int_no] = target_func;
c0205992:	c7 c0 00 31 29 c0    	mov    $0xc0293100,%eax
c0205998:	8b 55 08             	mov    0x8(%ebp),%edx
c020599b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c020599e:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
}
c02059a1:	90                   	nop
c02059a2:	5d                   	pop    %ebp
c02059a3:	c3                   	ret    

c02059a4 <default_server_func>:

void default_server_func(void *args){
c02059a4:	55                   	push   %ebp
c02059a5:	89 e5                	mov    %esp,%ebp
c02059a7:	e8 54 26 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02059ac:	05 54 36 00 00       	add    $0x3654,%eax
	//printk("Default Int server function!\n");
}
c02059b1:	90                   	nop
c02059b2:	5d                   	pop    %ebp
c02059b3:	c3                   	ret    

c02059b4 <timer_server_func>:


extern TCB_t * cur_tcb; 

//时钟中断函数 主要用于线程调度
void timer_server_func(void *args){
c02059b4:	55                   	push   %ebp
c02059b5:	89 e5                	mov    %esp,%ebp
c02059b7:	56                   	push   %esi
c02059b8:	53                   	push   %ebx
c02059b9:	e8 46 26 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02059be:	81 c3 42 36 00 00    	add    $0x3642,%ebx
	if(cur_tcb->time_left!=0){
c02059c4:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c02059ca:	8b 00                	mov    (%eax),%eax
c02059cc:	8b 40 0c             	mov    0xc(%eax),%eax
c02059cf:	85 c0                	test   %eax,%eax
c02059d1:	74 24                	je     c02059f7 <timer_server_func+0x43>
		(cur_tcb->time_left)--;
c02059d3:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c02059d9:	8b 00                	mov    (%eax),%eax
c02059db:	8b 50 0c             	mov    0xc(%eax),%edx
c02059de:	83 ea 01             	sub    $0x1,%edx
c02059e1:	89 50 0c             	mov    %edx,0xc(%eax)
		(cur_tcb->time_counter)++;
c02059e4:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c02059ea:	8b 00                	mov    (%eax),%eax
c02059ec:	8b 50 08             	mov    0x8(%eax),%edx
c02059ef:	83 c2 01             	add    $0x1,%edx
c02059f2:	89 50 08             	mov    %edx,0x8(%eax)
	}
	else{
        printk("Schedule!Running Task ID : %d,Kernel Task:%d\n",get_running_progress()->tid,get_running_progress()->is_kern_thread);
		schedule();
	}
}
c02059f5:	eb 29                	jmp    c0205a20 <timer_server_func+0x6c>
        printk("Schedule!Running Task ID : %d,Kernel Task:%d\n",get_running_progress()->tid,get_running_progress()->is_kern_thread);
c02059f7:	e8 2d dd ff ff       	call   c0203729 <get_running_progress>
c02059fc:	8b 70 20             	mov    0x20(%eax),%esi
c02059ff:	e8 25 dd ff ff       	call   c0203729 <get_running_progress>
c0205a04:	8b 40 14             	mov    0x14(%eax),%eax
c0205a07:	83 ec 04             	sub    $0x4,%esp
c0205a0a:	56                   	push   %esi
c0205a0b:	50                   	push   %eax
c0205a0c:	8d 83 d0 05 00 00    	lea    0x5d0(%ebx),%eax
c0205a12:	50                   	push   %eax
c0205a13:	e8 1c 19 00 00       	call   c0207334 <printk>
c0205a18:	83 c4 10             	add    $0x10,%esp
		schedule();
c0205a1b:	e8 0a e0 ff ff       	call   c0203a2a <schedule>
}
c0205a20:	90                   	nop
c0205a21:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0205a24:	5b                   	pop    %ebx
c0205a25:	5e                   	pop    %esi
c0205a26:	5d                   	pop    %ebp
c0205a27:	c3                   	ret    

c0205a28 <page_fault_func>:

//cr2 保存引起缺页的线性地址
void get_cr2();
extern uint32_t _CR2;
void page_fault_func(void * args){
c0205a28:	55                   	push   %ebp
c0205a29:	89 e5                	mov    %esp,%ebp
c0205a2b:	53                   	push   %ebx
c0205a2c:	83 ec 14             	sub    $0x14,%esp
c0205a2f:	e8 d0 25 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205a34:	81 c3 cc 35 00 00    	add    $0x35cc,%ebx
	get_cr2();
c0205a3a:	e8 80 d7 ff ff       	call   c02031bf <get_cr2>
	uint32_t MY_CR2 = _CR2;
c0205a3f:	c7 c0 c8 31 20 c0    	mov    $0xc02031c8,%eax
c0205a45:	8b 00                	mov    (%eax),%eax
c0205a47:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct TCB_t* cur_tcb=get_running_progress();
c0205a4a:	e8 da dc ff ff       	call   c0203729 <get_running_progress>
c0205a4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //printk("INT 14:Page Fault:0x%h IN before init threads\n",_CR2);
    }
	else{
	    //printk("INT 14:Page Fault:0x%h IN TASK:%d\n",_CR2,cur_tcb->tid);
	}
}
c0205a52:	90                   	nop
c0205a53:	83 c4 14             	add    $0x14,%esp
c0205a56:	5b                   	pop    %ebx
c0205a57:	5d                   	pop    %ebp
c0205a58:	c3                   	ret    

c0205a59 <idt_init>:
void isr30();
void isr31();

void isr32();

void idt_init(){
c0205a59:	55                   	push   %ebp
c0205a5a:	89 e5                	mov    %esp,%ebp
c0205a5c:	53                   	push   %ebx
c0205a5d:	83 ec 04             	sub    $0x4,%esp
c0205a60:	e8 9f 25 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205a65:	81 c3 9b 35 00 00    	add    $0x359b,%ebx
	_8259A_init();   //初始化中断控制器
c0205a6b:	e8 b7 11 00 00       	call   c0206c27 <_8259A_init>
	set_int_disc(0,(uint32_t)isr0,kern_cs,default_inf);
c0205a70:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205a77:	0f b6 d0             	movzbl %al,%edx
c0205a7a:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205a81:	0f b7 c0             	movzwl %ax,%eax
c0205a84:	c7 c1 ad 30 20 c0    	mov    $0xc02030ad,%ecx
c0205a8a:	52                   	push   %edx
c0205a8b:	50                   	push   %eax
c0205a8c:	51                   	push   %ecx
c0205a8d:	6a 00                	push   $0x0
c0205a8f:	e8 09 fe ff ff       	call   c020589d <set_int_disc>
c0205a94:	83 c4 10             	add    $0x10,%esp
	set_int_disc(1,(uint32_t)isr1,kern_cs,default_inf);
c0205a97:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205a9e:	0f b6 d0             	movzbl %al,%edx
c0205aa1:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205aa8:	0f b7 c0             	movzwl %ax,%eax
c0205aab:	c7 c1 b3 30 20 c0    	mov    $0xc02030b3,%ecx
c0205ab1:	52                   	push   %edx
c0205ab2:	50                   	push   %eax
c0205ab3:	51                   	push   %ecx
c0205ab4:	6a 01                	push   $0x1
c0205ab6:	e8 e2 fd ff ff       	call   c020589d <set_int_disc>
c0205abb:	83 c4 10             	add    $0x10,%esp
	set_int_disc(2,(uint32_t)isr2,kern_cs,default_inf);
c0205abe:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ac5:	0f b6 d0             	movzbl %al,%edx
c0205ac8:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205acf:	0f b7 c0             	movzwl %ax,%eax
c0205ad2:	c7 c1 b9 30 20 c0    	mov    $0xc02030b9,%ecx
c0205ad8:	52                   	push   %edx
c0205ad9:	50                   	push   %eax
c0205ada:	51                   	push   %ecx
c0205adb:	6a 02                	push   $0x2
c0205add:	e8 bb fd ff ff       	call   c020589d <set_int_disc>
c0205ae2:	83 c4 10             	add    $0x10,%esp
	set_int_disc(3,(uint32_t)isr3,kern_cs,default_inf);
c0205ae5:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205aec:	0f b6 d0             	movzbl %al,%edx
c0205aef:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205af6:	0f b7 c0             	movzwl %ax,%eax
c0205af9:	c7 c1 bf 30 20 c0    	mov    $0xc02030bf,%ecx
c0205aff:	52                   	push   %edx
c0205b00:	50                   	push   %eax
c0205b01:	51                   	push   %ecx
c0205b02:	6a 03                	push   $0x3
c0205b04:	e8 94 fd ff ff       	call   c020589d <set_int_disc>
c0205b09:	83 c4 10             	add    $0x10,%esp
	set_int_disc(4,(uint32_t)isr4,kern_cs,default_inf);
c0205b0c:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b13:	0f b6 d0             	movzbl %al,%edx
c0205b16:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b1d:	0f b7 c0             	movzwl %ax,%eax
c0205b20:	c7 c1 c5 30 20 c0    	mov    $0xc02030c5,%ecx
c0205b26:	52                   	push   %edx
c0205b27:	50                   	push   %eax
c0205b28:	51                   	push   %ecx
c0205b29:	6a 04                	push   $0x4
c0205b2b:	e8 6d fd ff ff       	call   c020589d <set_int_disc>
c0205b30:	83 c4 10             	add    $0x10,%esp
	set_int_disc(5,(uint32_t)isr5,kern_cs,default_inf);
c0205b33:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b3a:	0f b6 d0             	movzbl %al,%edx
c0205b3d:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b44:	0f b7 c0             	movzwl %ax,%eax
c0205b47:	c7 c1 cb 30 20 c0    	mov    $0xc02030cb,%ecx
c0205b4d:	52                   	push   %edx
c0205b4e:	50                   	push   %eax
c0205b4f:	51                   	push   %ecx
c0205b50:	6a 05                	push   $0x5
c0205b52:	e8 46 fd ff ff       	call   c020589d <set_int_disc>
c0205b57:	83 c4 10             	add    $0x10,%esp
	set_int_disc(6,(uint32_t)isr6,kern_cs,default_inf);
c0205b5a:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b61:	0f b6 d0             	movzbl %al,%edx
c0205b64:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b6b:	0f b7 c0             	movzwl %ax,%eax
c0205b6e:	c7 c1 d1 30 20 c0    	mov    $0xc02030d1,%ecx
c0205b74:	52                   	push   %edx
c0205b75:	50                   	push   %eax
c0205b76:	51                   	push   %ecx
c0205b77:	6a 06                	push   $0x6
c0205b79:	e8 1f fd ff ff       	call   c020589d <set_int_disc>
c0205b7e:	83 c4 10             	add    $0x10,%esp
	set_int_disc(7,(uint32_t)isr7,kern_cs,default_inf);
c0205b81:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b88:	0f b6 d0             	movzbl %al,%edx
c0205b8b:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b92:	0f b7 c0             	movzwl %ax,%eax
c0205b95:	c7 c1 d7 30 20 c0    	mov    $0xc02030d7,%ecx
c0205b9b:	52                   	push   %edx
c0205b9c:	50                   	push   %eax
c0205b9d:	51                   	push   %ecx
c0205b9e:	6a 07                	push   $0x7
c0205ba0:	e8 f8 fc ff ff       	call   c020589d <set_int_disc>
c0205ba5:	83 c4 10             	add    $0x10,%esp
	set_int_disc(8,(uint32_t)isr8,kern_cs,default_inf);
c0205ba8:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205baf:	0f b6 d0             	movzbl %al,%edx
c0205bb2:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205bb9:	0f b7 c0             	movzwl %ax,%eax
c0205bbc:	c7 c1 dd 30 20 c0    	mov    $0xc02030dd,%ecx
c0205bc2:	52                   	push   %edx
c0205bc3:	50                   	push   %eax
c0205bc4:	51                   	push   %ecx
c0205bc5:	6a 08                	push   $0x8
c0205bc7:	e8 d1 fc ff ff       	call   c020589d <set_int_disc>
c0205bcc:	83 c4 10             	add    $0x10,%esp
	set_int_disc(9,(uint32_t)isr9,kern_cs,default_inf);
c0205bcf:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205bd6:	0f b6 d0             	movzbl %al,%edx
c0205bd9:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205be0:	0f b7 c0             	movzwl %ax,%eax
c0205be3:	c7 c1 e5 30 20 c0    	mov    $0xc02030e5,%ecx
c0205be9:	52                   	push   %edx
c0205bea:	50                   	push   %eax
c0205beb:	51                   	push   %ecx
c0205bec:	6a 09                	push   $0x9
c0205bee:	e8 aa fc ff ff       	call   c020589d <set_int_disc>
c0205bf3:	83 c4 10             	add    $0x10,%esp
	set_int_disc(10,(uint32_t)isr10,kern_cs,default_inf);
c0205bf6:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205bfd:	0f b6 d0             	movzbl %al,%edx
c0205c00:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c07:	0f b7 c0             	movzwl %ax,%eax
c0205c0a:	c7 c1 ee 30 20 c0    	mov    $0xc02030ee,%ecx
c0205c10:	52                   	push   %edx
c0205c11:	50                   	push   %eax
c0205c12:	51                   	push   %ecx
c0205c13:	6a 0a                	push   $0xa
c0205c15:	e8 83 fc ff ff       	call   c020589d <set_int_disc>
c0205c1a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(11,(uint32_t)isr11,kern_cs,default_inf);
c0205c1d:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c24:	0f b6 d0             	movzbl %al,%edx
c0205c27:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c2e:	0f b7 c0             	movzwl %ax,%eax
c0205c31:	c7 c1 f6 30 20 c0    	mov    $0xc02030f6,%ecx
c0205c37:	52                   	push   %edx
c0205c38:	50                   	push   %eax
c0205c39:	51                   	push   %ecx
c0205c3a:	6a 0b                	push   $0xb
c0205c3c:	e8 5c fc ff ff       	call   c020589d <set_int_disc>
c0205c41:	83 c4 10             	add    $0x10,%esp
	set_int_disc(12,(uint32_t)isr12,kern_cs,default_inf);
c0205c44:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c4b:	0f b6 d0             	movzbl %al,%edx
c0205c4e:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c55:	0f b7 c0             	movzwl %ax,%eax
c0205c58:	c7 c1 fe 30 20 c0    	mov    $0xc02030fe,%ecx
c0205c5e:	52                   	push   %edx
c0205c5f:	50                   	push   %eax
c0205c60:	51                   	push   %ecx
c0205c61:	6a 0c                	push   $0xc
c0205c63:	e8 35 fc ff ff       	call   c020589d <set_int_disc>
c0205c68:	83 c4 10             	add    $0x10,%esp
	set_int_disc(13,(uint32_t)isr13,kern_cs,default_inf);
c0205c6b:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c72:	0f b6 d0             	movzbl %al,%edx
c0205c75:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c7c:	0f b7 c0             	movzwl %ax,%eax
c0205c7f:	c7 c1 06 31 20 c0    	mov    $0xc0203106,%ecx
c0205c85:	52                   	push   %edx
c0205c86:	50                   	push   %eax
c0205c87:	51                   	push   %ecx
c0205c88:	6a 0d                	push   $0xd
c0205c8a:	e8 0e fc ff ff       	call   c020589d <set_int_disc>
c0205c8f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(14,(uint32_t)isr14,kern_cs,default_inf);
c0205c92:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c99:	0f b6 d0             	movzbl %al,%edx
c0205c9c:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205ca3:	0f b7 c0             	movzwl %ax,%eax
c0205ca6:	c7 c1 0e 31 20 c0    	mov    $0xc020310e,%ecx
c0205cac:	52                   	push   %edx
c0205cad:	50                   	push   %eax
c0205cae:	51                   	push   %ecx
c0205caf:	6a 0e                	push   $0xe
c0205cb1:	e8 e7 fb ff ff       	call   c020589d <set_int_disc>
c0205cb6:	83 c4 10             	add    $0x10,%esp
	set_int_disc(15,(uint32_t)isr15,kern_cs,default_inf);
c0205cb9:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205cc0:	0f b6 d0             	movzbl %al,%edx
c0205cc3:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205cca:	0f b7 c0             	movzwl %ax,%eax
c0205ccd:	c7 c1 16 31 20 c0    	mov    $0xc0203116,%ecx
c0205cd3:	52                   	push   %edx
c0205cd4:	50                   	push   %eax
c0205cd5:	51                   	push   %ecx
c0205cd6:	6a 0f                	push   $0xf
c0205cd8:	e8 c0 fb ff ff       	call   c020589d <set_int_disc>
c0205cdd:	83 c4 10             	add    $0x10,%esp
	set_int_disc(16,(uint32_t)isr16,kern_cs,default_inf);
c0205ce0:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ce7:	0f b6 d0             	movzbl %al,%edx
c0205cea:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205cf1:	0f b7 c0             	movzwl %ax,%eax
c0205cf4:	c7 c1 1f 31 20 c0    	mov    $0xc020311f,%ecx
c0205cfa:	52                   	push   %edx
c0205cfb:	50                   	push   %eax
c0205cfc:	51                   	push   %ecx
c0205cfd:	6a 10                	push   $0x10
c0205cff:	e8 99 fb ff ff       	call   c020589d <set_int_disc>
c0205d04:	83 c4 10             	add    $0x10,%esp
	set_int_disc(17,(uint32_t)isr17,kern_cs,default_inf);
c0205d07:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d0e:	0f b6 d0             	movzbl %al,%edx
c0205d11:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d18:	0f b7 c0             	movzwl %ax,%eax
c0205d1b:	c7 c1 28 31 20 c0    	mov    $0xc0203128,%ecx
c0205d21:	52                   	push   %edx
c0205d22:	50                   	push   %eax
c0205d23:	51                   	push   %ecx
c0205d24:	6a 11                	push   $0x11
c0205d26:	e8 72 fb ff ff       	call   c020589d <set_int_disc>
c0205d2b:	83 c4 10             	add    $0x10,%esp
	set_int_disc(18,(uint32_t)isr18,kern_cs,default_inf);
c0205d2e:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d35:	0f b6 d0             	movzbl %al,%edx
c0205d38:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d3f:	0f b7 c0             	movzwl %ax,%eax
c0205d42:	c7 c1 30 31 20 c0    	mov    $0xc0203130,%ecx
c0205d48:	52                   	push   %edx
c0205d49:	50                   	push   %eax
c0205d4a:	51                   	push   %ecx
c0205d4b:	6a 12                	push   $0x12
c0205d4d:	e8 4b fb ff ff       	call   c020589d <set_int_disc>
c0205d52:	83 c4 10             	add    $0x10,%esp
	set_int_disc(19,(uint32_t)isr19,kern_cs,default_inf);
c0205d55:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d5c:	0f b6 d0             	movzbl %al,%edx
c0205d5f:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d66:	0f b7 c0             	movzwl %ax,%eax
c0205d69:	c7 c1 39 31 20 c0    	mov    $0xc0203139,%ecx
c0205d6f:	52                   	push   %edx
c0205d70:	50                   	push   %eax
c0205d71:	51                   	push   %ecx
c0205d72:	6a 13                	push   $0x13
c0205d74:	e8 24 fb ff ff       	call   c020589d <set_int_disc>
c0205d79:	83 c4 10             	add    $0x10,%esp
	set_int_disc(20,(uint32_t)isr20,kern_cs,default_inf);
c0205d7c:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d83:	0f b6 d0             	movzbl %al,%edx
c0205d86:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d8d:	0f b7 c0             	movzwl %ax,%eax
c0205d90:	c7 c1 42 31 20 c0    	mov    $0xc0203142,%ecx
c0205d96:	52                   	push   %edx
c0205d97:	50                   	push   %eax
c0205d98:	51                   	push   %ecx
c0205d99:	6a 14                	push   $0x14
c0205d9b:	e8 fd fa ff ff       	call   c020589d <set_int_disc>
c0205da0:	83 c4 10             	add    $0x10,%esp
	set_int_disc(21,(uint32_t)isr21,kern_cs,default_inf);
c0205da3:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205daa:	0f b6 d0             	movzbl %al,%edx
c0205dad:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205db4:	0f b7 c0             	movzwl %ax,%eax
c0205db7:	c7 c1 4b 31 20 c0    	mov    $0xc020314b,%ecx
c0205dbd:	52                   	push   %edx
c0205dbe:	50                   	push   %eax
c0205dbf:	51                   	push   %ecx
c0205dc0:	6a 15                	push   $0x15
c0205dc2:	e8 d6 fa ff ff       	call   c020589d <set_int_disc>
c0205dc7:	83 c4 10             	add    $0x10,%esp
	set_int_disc(22,(uint32_t)isr22,kern_cs,default_inf);
c0205dca:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205dd1:	0f b6 d0             	movzbl %al,%edx
c0205dd4:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205ddb:	0f b7 c0             	movzwl %ax,%eax
c0205dde:	c7 c1 54 31 20 c0    	mov    $0xc0203154,%ecx
c0205de4:	52                   	push   %edx
c0205de5:	50                   	push   %eax
c0205de6:	51                   	push   %ecx
c0205de7:	6a 16                	push   $0x16
c0205de9:	e8 af fa ff ff       	call   c020589d <set_int_disc>
c0205dee:	83 c4 10             	add    $0x10,%esp
	set_int_disc(23,(uint32_t)isr23,kern_cs,default_inf);
c0205df1:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205df8:	0f b6 d0             	movzbl %al,%edx
c0205dfb:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e02:	0f b7 c0             	movzwl %ax,%eax
c0205e05:	c7 c1 5d 31 20 c0    	mov    $0xc020315d,%ecx
c0205e0b:	52                   	push   %edx
c0205e0c:	50                   	push   %eax
c0205e0d:	51                   	push   %ecx
c0205e0e:	6a 17                	push   $0x17
c0205e10:	e8 88 fa ff ff       	call   c020589d <set_int_disc>
c0205e15:	83 c4 10             	add    $0x10,%esp
	set_int_disc(24,(uint32_t)isr24,kern_cs,default_inf);
c0205e18:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e1f:	0f b6 d0             	movzbl %al,%edx
c0205e22:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e29:	0f b7 c0             	movzwl %ax,%eax
c0205e2c:	c7 c1 66 31 20 c0    	mov    $0xc0203166,%ecx
c0205e32:	52                   	push   %edx
c0205e33:	50                   	push   %eax
c0205e34:	51                   	push   %ecx
c0205e35:	6a 18                	push   $0x18
c0205e37:	e8 61 fa ff ff       	call   c020589d <set_int_disc>
c0205e3c:	83 c4 10             	add    $0x10,%esp
	set_int_disc(25,(uint32_t)isr25,kern_cs,default_inf);
c0205e3f:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e46:	0f b6 d0             	movzbl %al,%edx
c0205e49:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e50:	0f b7 c0             	movzwl %ax,%eax
c0205e53:	c7 c1 6f 31 20 c0    	mov    $0xc020316f,%ecx
c0205e59:	52                   	push   %edx
c0205e5a:	50                   	push   %eax
c0205e5b:	51                   	push   %ecx
c0205e5c:	6a 19                	push   $0x19
c0205e5e:	e8 3a fa ff ff       	call   c020589d <set_int_disc>
c0205e63:	83 c4 10             	add    $0x10,%esp
	set_int_disc(26,(uint32_t)isr26,kern_cs,default_inf);
c0205e66:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e6d:	0f b6 d0             	movzbl %al,%edx
c0205e70:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e77:	0f b7 c0             	movzwl %ax,%eax
c0205e7a:	c7 c1 78 31 20 c0    	mov    $0xc0203178,%ecx
c0205e80:	52                   	push   %edx
c0205e81:	50                   	push   %eax
c0205e82:	51                   	push   %ecx
c0205e83:	6a 1a                	push   $0x1a
c0205e85:	e8 13 fa ff ff       	call   c020589d <set_int_disc>
c0205e8a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(27,(uint32_t)isr27,kern_cs,default_inf);
c0205e8d:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e94:	0f b6 d0             	movzbl %al,%edx
c0205e97:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e9e:	0f b7 c0             	movzwl %ax,%eax
c0205ea1:	c7 c1 81 31 20 c0    	mov    $0xc0203181,%ecx
c0205ea7:	52                   	push   %edx
c0205ea8:	50                   	push   %eax
c0205ea9:	51                   	push   %ecx
c0205eaa:	6a 1b                	push   $0x1b
c0205eac:	e8 ec f9 ff ff       	call   c020589d <set_int_disc>
c0205eb1:	83 c4 10             	add    $0x10,%esp
	set_int_disc(28,(uint32_t)isr28,kern_cs,default_inf);
c0205eb4:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ebb:	0f b6 d0             	movzbl %al,%edx
c0205ebe:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205ec5:	0f b7 c0             	movzwl %ax,%eax
c0205ec8:	c7 c1 8a 31 20 c0    	mov    $0xc020318a,%ecx
c0205ece:	52                   	push   %edx
c0205ecf:	50                   	push   %eax
c0205ed0:	51                   	push   %ecx
c0205ed1:	6a 1c                	push   $0x1c
c0205ed3:	e8 c5 f9 ff ff       	call   c020589d <set_int_disc>
c0205ed8:	83 c4 10             	add    $0x10,%esp
	set_int_disc(29,(uint32_t)isr29,kern_cs,default_inf);
c0205edb:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ee2:	0f b6 d0             	movzbl %al,%edx
c0205ee5:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205eec:	0f b7 c0             	movzwl %ax,%eax
c0205eef:	c7 c1 93 31 20 c0    	mov    $0xc0203193,%ecx
c0205ef5:	52                   	push   %edx
c0205ef6:	50                   	push   %eax
c0205ef7:	51                   	push   %ecx
c0205ef8:	6a 1d                	push   $0x1d
c0205efa:	e8 9e f9 ff ff       	call   c020589d <set_int_disc>
c0205eff:	83 c4 10             	add    $0x10,%esp
	set_int_disc(30,(uint32_t)isr30,kern_cs,default_inf);
c0205f02:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f09:	0f b6 d0             	movzbl %al,%edx
c0205f0c:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f13:	0f b7 c0             	movzwl %ax,%eax
c0205f16:	c7 c1 9c 31 20 c0    	mov    $0xc020319c,%ecx
c0205f1c:	52                   	push   %edx
c0205f1d:	50                   	push   %eax
c0205f1e:	51                   	push   %ecx
c0205f1f:	6a 1e                	push   $0x1e
c0205f21:	e8 77 f9 ff ff       	call   c020589d <set_int_disc>
c0205f26:	83 c4 10             	add    $0x10,%esp
	set_int_disc(31,(uint32_t)isr31,kern_cs,default_inf);
c0205f29:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f30:	0f b6 d0             	movzbl %al,%edx
c0205f33:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f3a:	0f b7 c0             	movzwl %ax,%eax
c0205f3d:	c7 c1 a5 31 20 c0    	mov    $0xc02031a5,%ecx
c0205f43:	52                   	push   %edx
c0205f44:	50                   	push   %eax
c0205f45:	51                   	push   %ecx
c0205f46:	6a 1f                	push   $0x1f
c0205f48:	e8 50 f9 ff ff       	call   c020589d <set_int_disc>
c0205f4d:	83 c4 10             	add    $0x10,%esp
	set_int_disc(32,(uint32_t)isr32,kern_cs,default_inf);
c0205f50:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f57:	0f b6 d0             	movzbl %al,%edx
c0205f5a:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f61:	0f b7 c0             	movzwl %ax,%eax
c0205f64:	c7 c1 ae 31 20 c0    	mov    $0xc02031ae,%ecx
c0205f6a:	52                   	push   %edx
c0205f6b:	50                   	push   %eax
c0205f6c:	51                   	push   %ecx
c0205f6d:	6a 20                	push   $0x20
c0205f6f:	e8 29 f9 ff ff       	call   c020589d <set_int_disc>
c0205f74:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(0,default_server_func);
c0205f77:	83 ec 08             	sub    $0x8,%esp
c0205f7a:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205f80:	50                   	push   %eax
c0205f81:	6a 00                	push   $0x0
c0205f83:	e8 fd f9 ff ff       	call   c0205985 <registe_interrupt>
c0205f88:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(1,default_server_func);
c0205f8b:	83 ec 08             	sub    $0x8,%esp
c0205f8e:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205f94:	50                   	push   %eax
c0205f95:	6a 01                	push   $0x1
c0205f97:	e8 e9 f9 ff ff       	call   c0205985 <registe_interrupt>
c0205f9c:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(2,default_server_func);
c0205f9f:	83 ec 08             	sub    $0x8,%esp
c0205fa2:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205fa8:	50                   	push   %eax
c0205fa9:	6a 02                	push   $0x2
c0205fab:	e8 d5 f9 ff ff       	call   c0205985 <registe_interrupt>
c0205fb0:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(3,default_server_func);
c0205fb3:	83 ec 08             	sub    $0x8,%esp
c0205fb6:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205fbc:	50                   	push   %eax
c0205fbd:	6a 03                	push   $0x3
c0205fbf:	e8 c1 f9 ff ff       	call   c0205985 <registe_interrupt>
c0205fc4:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(4,default_server_func);
c0205fc7:	83 ec 08             	sub    $0x8,%esp
c0205fca:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205fd0:	50                   	push   %eax
c0205fd1:	6a 04                	push   $0x4
c0205fd3:	e8 ad f9 ff ff       	call   c0205985 <registe_interrupt>
c0205fd8:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(5,default_server_func);
c0205fdb:	83 ec 08             	sub    $0x8,%esp
c0205fde:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205fe4:	50                   	push   %eax
c0205fe5:	6a 05                	push   $0x5
c0205fe7:	e8 99 f9 ff ff       	call   c0205985 <registe_interrupt>
c0205fec:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(6,default_server_func);
c0205fef:	83 ec 08             	sub    $0x8,%esp
c0205ff2:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0205ff8:	50                   	push   %eax
c0205ff9:	6a 06                	push   $0x6
c0205ffb:	e8 85 f9 ff ff       	call   c0205985 <registe_interrupt>
c0206000:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(7,default_server_func);
c0206003:	83 ec 08             	sub    $0x8,%esp
c0206006:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c020600c:	50                   	push   %eax
c020600d:	6a 07                	push   $0x7
c020600f:	e8 71 f9 ff ff       	call   c0205985 <registe_interrupt>
c0206014:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(8,default_server_func);
c0206017:	83 ec 08             	sub    $0x8,%esp
c020601a:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206020:	50                   	push   %eax
c0206021:	6a 08                	push   $0x8
c0206023:	e8 5d f9 ff ff       	call   c0205985 <registe_interrupt>
c0206028:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(9,default_server_func);
c020602b:	83 ec 08             	sub    $0x8,%esp
c020602e:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206034:	50                   	push   %eax
c0206035:	6a 09                	push   $0x9
c0206037:	e8 49 f9 ff ff       	call   c0205985 <registe_interrupt>
c020603c:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(10,default_server_func);
c020603f:	83 ec 08             	sub    $0x8,%esp
c0206042:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206048:	50                   	push   %eax
c0206049:	6a 0a                	push   $0xa
c020604b:	e8 35 f9 ff ff       	call   c0205985 <registe_interrupt>
c0206050:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(11,default_server_func);
c0206053:	83 ec 08             	sub    $0x8,%esp
c0206056:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c020605c:	50                   	push   %eax
c020605d:	6a 0b                	push   $0xb
c020605f:	e8 21 f9 ff ff       	call   c0205985 <registe_interrupt>
c0206064:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(12,default_server_func);
c0206067:	83 ec 08             	sub    $0x8,%esp
c020606a:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206070:	50                   	push   %eax
c0206071:	6a 0c                	push   $0xc
c0206073:	e8 0d f9 ff ff       	call   c0205985 <registe_interrupt>
c0206078:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(13,default_server_func);
c020607b:	83 ec 08             	sub    $0x8,%esp
c020607e:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206084:	50                   	push   %eax
c0206085:	6a 0d                	push   $0xd
c0206087:	e8 f9 f8 ff ff       	call   c0205985 <registe_interrupt>
c020608c:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(14,default_server_func);
c020608f:	83 ec 08             	sub    $0x8,%esp
c0206092:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206098:	50                   	push   %eax
c0206099:	6a 0e                	push   $0xe
c020609b:	e8 e5 f8 ff ff       	call   c0205985 <registe_interrupt>
c02060a0:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(15,default_server_func);
c02060a3:	83 ec 08             	sub    $0x8,%esp
c02060a6:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02060ac:	50                   	push   %eax
c02060ad:	6a 0f                	push   $0xf
c02060af:	e8 d1 f8 ff ff       	call   c0205985 <registe_interrupt>
c02060b4:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(16,default_server_func);
c02060b7:	83 ec 08             	sub    $0x8,%esp
c02060ba:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02060c0:	50                   	push   %eax
c02060c1:	6a 10                	push   $0x10
c02060c3:	e8 bd f8 ff ff       	call   c0205985 <registe_interrupt>
c02060c8:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(17,default_server_func);
c02060cb:	83 ec 08             	sub    $0x8,%esp
c02060ce:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02060d4:	50                   	push   %eax
c02060d5:	6a 11                	push   $0x11
c02060d7:	e8 a9 f8 ff ff       	call   c0205985 <registe_interrupt>
c02060dc:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(18,default_server_func);
c02060df:	83 ec 08             	sub    $0x8,%esp
c02060e2:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02060e8:	50                   	push   %eax
c02060e9:	6a 12                	push   $0x12
c02060eb:	e8 95 f8 ff ff       	call   c0205985 <registe_interrupt>
c02060f0:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(19,default_server_func);
c02060f3:	83 ec 08             	sub    $0x8,%esp
c02060f6:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02060fc:	50                   	push   %eax
c02060fd:	6a 13                	push   $0x13
c02060ff:	e8 81 f8 ff ff       	call   c0205985 <registe_interrupt>
c0206104:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(20,default_server_func);
c0206107:	83 ec 08             	sub    $0x8,%esp
c020610a:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206110:	50                   	push   %eax
c0206111:	6a 14                	push   $0x14
c0206113:	e8 6d f8 ff ff       	call   c0205985 <registe_interrupt>
c0206118:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(21,default_server_func);
c020611b:	83 ec 08             	sub    $0x8,%esp
c020611e:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206124:	50                   	push   %eax
c0206125:	6a 15                	push   $0x15
c0206127:	e8 59 f8 ff ff       	call   c0205985 <registe_interrupt>
c020612c:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(22,default_server_func);
c020612f:	83 ec 08             	sub    $0x8,%esp
c0206132:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206138:	50                   	push   %eax
c0206139:	6a 16                	push   $0x16
c020613b:	e8 45 f8 ff ff       	call   c0205985 <registe_interrupt>
c0206140:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(23,default_server_func);
c0206143:	83 ec 08             	sub    $0x8,%esp
c0206146:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c020614c:	50                   	push   %eax
c020614d:	6a 17                	push   $0x17
c020614f:	e8 31 f8 ff ff       	call   c0205985 <registe_interrupt>
c0206154:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(24,default_server_func);
c0206157:	83 ec 08             	sub    $0x8,%esp
c020615a:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206160:	50                   	push   %eax
c0206161:	6a 18                	push   $0x18
c0206163:	e8 1d f8 ff ff       	call   c0205985 <registe_interrupt>
c0206168:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(25,default_server_func);
c020616b:	83 ec 08             	sub    $0x8,%esp
c020616e:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206174:	50                   	push   %eax
c0206175:	6a 19                	push   $0x19
c0206177:	e8 09 f8 ff ff       	call   c0205985 <registe_interrupt>
c020617c:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(26,default_server_func);
c020617f:	83 ec 08             	sub    $0x8,%esp
c0206182:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c0206188:	50                   	push   %eax
c0206189:	6a 1a                	push   $0x1a
c020618b:	e8 f5 f7 ff ff       	call   c0205985 <registe_interrupt>
c0206190:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(27,default_server_func);
c0206193:	83 ec 08             	sub    $0x8,%esp
c0206196:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c020619c:	50                   	push   %eax
c020619d:	6a 1b                	push   $0x1b
c020619f:	e8 e1 f7 ff ff       	call   c0205985 <registe_interrupt>
c02061a4:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(28,default_server_func);
c02061a7:	83 ec 08             	sub    $0x8,%esp
c02061aa:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02061b0:	50                   	push   %eax
c02061b1:	6a 1c                	push   $0x1c
c02061b3:	e8 cd f7 ff ff       	call   c0205985 <registe_interrupt>
c02061b8:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(29,default_server_func);
c02061bb:	83 ec 08             	sub    $0x8,%esp
c02061be:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02061c4:	50                   	push   %eax
c02061c5:	6a 1d                	push   $0x1d
c02061c7:	e8 b9 f7 ff ff       	call   c0205985 <registe_interrupt>
c02061cc:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(30,default_server_func);
c02061cf:	83 ec 08             	sub    $0x8,%esp
c02061d2:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02061d8:	50                   	push   %eax
c02061d9:	6a 1e                	push   $0x1e
c02061db:	e8 a5 f7 ff ff       	call   c0205985 <registe_interrupt>
c02061e0:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(31,default_server_func);
c02061e3:	83 ec 08             	sub    $0x8,%esp
c02061e6:	8d 83 a4 c9 ff ff    	lea    -0x365c(%ebx),%eax
c02061ec:	50                   	push   %eax
c02061ed:	6a 1f                	push   $0x1f
c02061ef:	e8 91 f7 ff ff       	call   c0205985 <registe_interrupt>
c02061f4:	83 c4 10             	add    $0x10,%esp
	//registe_interrupt(32,default_server_func);
	
	registe_interrupt(14,page_fault_func);
c02061f7:	83 ec 08             	sub    $0x8,%esp
c02061fa:	8d 83 28 ca ff ff    	lea    -0x35d8(%ebx),%eax
c0206200:	50                   	push   %eax
c0206201:	6a 0e                	push   $0xe
c0206203:	e8 7d f7 ff ff       	call   c0205985 <registe_interrupt>
c0206208:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(32,timer_server_func);
c020620b:	83 ec 08             	sub    $0x8,%esp
c020620e:	8d 83 b4 c9 ff ff    	lea    -0x364c(%ebx),%eax
c0206214:	50                   	push   %eax
c0206215:	6a 20                	push   $0x20
c0206217:	e8 69 f7 ff ff       	call   c0205985 <registe_interrupt>
c020621c:	83 c4 10             	add    $0x10,%esp
	lidt_target.limit = sizeof(interrupt_discripter_t)*256;
c020621f:	c7 c0 00 35 29 c0    	mov    $0xc0293500,%eax
c0206225:	66 c7 00 00 08       	movw   $0x800,(%eax)
	lidt_target.base = (uint32_t)&idt_entries;
c020622a:	c7 c0 20 35 29 c0    	mov    $0xc0293520,%eax
c0206230:	89 c2                	mov    %eax,%edx
c0206232:	c7 c0 00 35 29 c0    	mov    $0xc0293500,%eax
c0206238:	89 50 02             	mov    %edx,0x2(%eax)
	timer_init(1000);
c020623b:	83 ec 0c             	sub    $0xc,%esp
c020623e:	68 e8 03 00 00       	push   $0x3e8
c0206243:	e8 d3 f6 ff ff       	call   c020591b <timer_init>
c0206248:	83 c4 10             	add    $0x10,%esp
	load_idt((uint32_t)&lidt_target);
c020624b:	c7 c0 00 35 29 c0    	mov    $0xc0293500,%eax
c0206251:	83 ec 0c             	sub    $0xc,%esp
c0206254:	50                   	push   %eax
c0206255:	e8 5d cf ff ff       	call   c02031b7 <load_idt>
c020625a:	83 c4 10             	add    $0x10,%esp
    sti();
c020625d:	e8 41 00 00 00       	call   c02062a3 <sti>
}
c0206262:	90                   	nop
c0206263:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206266:	c9                   	leave  
c0206267:	c3                   	ret    

c0206268 <int_func_route>:

// INT路由函数
void int_func_route(int int_no,void * args){
c0206268:	55                   	push   %ebp
c0206269:	89 e5                	mov    %esp,%ebp
c020626b:	83 ec 08             	sub    $0x8,%esp
c020626e:	e8 8d 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206273:	05 8d 2d 00 00       	add    $0x2d8d,%eax
	int_server_func_list[int_no](args);
c0206278:	c7 c0 00 31 29 c0    	mov    $0xc0293100,%eax
c020627e:	8b 55 08             	mov    0x8(%ebp),%edx
c0206281:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0206284:	83 ec 0c             	sub    $0xc,%esp
c0206287:	ff 75 0c             	pushl  0xc(%ebp)
c020628a:	ff d0                	call   *%eax
c020628c:	83 c4 10             	add    $0x10,%esp
}
c020628f:	90                   	nop
c0206290:	c9                   	leave  
c0206291:	c3                   	ret    

c0206292 <cli>:

void cli(){
c0206292:	55                   	push   %ebp
c0206293:	89 e5                	mov    %esp,%ebp
c0206295:	e8 66 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020629a:	05 66 2d 00 00       	add    $0x2d66,%eax
    asm volatile("cli");
c020629f:	fa                   	cli    
}
c02062a0:	90                   	nop
c02062a1:	5d                   	pop    %ebp
c02062a2:	c3                   	ret    

c02062a3 <sti>:
void sti(){
c02062a3:	55                   	push   %ebp
c02062a4:	89 e5                	mov    %esp,%ebp
c02062a6:	e8 55 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02062ab:	05 55 2d 00 00       	add    $0x2d55,%eax
    asm volatile("sti");
c02062b0:	fb                   	sti    
c02062b1:	90                   	nop
c02062b2:	5d                   	pop    %ebp
c02062b3:	c3                   	ret    

c02062b4 <get_kern_used_page_count>:

bitmap kern_vmm_pool;

static char* LOG_SRC_VMM = "VMM";

static int get_kern_used_page_count(){
c02062b4:	55                   	push   %ebp
c02062b5:	89 e5                	mov    %esp,%ebp
c02062b7:	83 ec 10             	sub    $0x10,%esp
c02062ba:	e8 41 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02062bf:	05 41 2d 00 00       	add    $0x2d41,%eax
    uint32_t size_bytes = kern_end-0;
c02062c4:	c7 c0 00 30 2a 00    	mov    $0x2a3000,%eax
c02062ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (size_bytes+PAGE_SIZE-1)/PAGE_SIZE;     //向上取整
c02062cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062d0:	05 ff 0f 00 00       	add    $0xfff,%eax
c02062d5:	c1 e8 0c             	shr    $0xc,%eax
}
c02062d8:	c9                   	leave  
c02062d9:	c3                   	ret    

c02062da <vmm_kern_init>:

//初始化内核虚拟空间
//预分配已使用内核空间
static void vmm_kern_init(){
c02062da:	55                   	push   %ebp
c02062db:	89 e5                	mov    %esp,%ebp
c02062dd:	53                   	push   %ebx
c02062de:	83 ec 24             	sub    $0x24,%esp
c02062e1:	e8 1e 1d 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02062e6:	81 c3 1a 2d 00 00    	add    $0x2d1a,%ebx
    kern_vmm_pool.target_addr_header = 0xC0000000;   //内核空间起始地址
c02062ec:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02062f2:	c7 40 08 00 00 00 c0 	movl   $0xc0000000,0x8(%eax)
    kern_vmm_pool.length = 0x8000;     //总共1GB空间
c02062f9:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02062ff:	c7 40 04 00 80 00 00 	movl   $0x8000,0x4(%eax)
    kern_vmm_pool.vaddr_header = kern_bitmap;
c0206306:	c7 c0 0c 80 20 c0    	mov    $0xc020800c,%eax
c020630c:	8b 10                	mov    (%eax),%edx
c020630e:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206314:	89 10                	mov    %edx,(%eax)
    bitmap_init_mem(kern_vmm_pool);
c0206316:	83 ec 04             	sub    $0x4,%esp
c0206319:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c020631f:	ff 70 08             	pushl  0x8(%eax)
c0206322:	ff 70 04             	pushl  0x4(%eax)
c0206325:	ff 30                	pushl  (%eax)
c0206327:	e8 8f cf ff ff       	call   c02032bb <bitmap_init_mem>
c020632c:	83 c4 10             	add    $0x10,%esp
    int page_used = get_kern_used_page_count();
c020632f:	e8 80 ff ff ff       	call   c02062b4 <get_kern_used_page_count>
c0206334:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(page_used>1024){
c0206337:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
c020633e:	7e 1b                	jle    c020635b <vmm_kern_init+0x81>
        ERROR(LOG_SRC_VMM,"don`t have enough vm page for kernel when init!");
c0206340:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
c0206346:	83 ec 08             	sub    $0x8,%esp
c0206349:	8d 93 04 06 00 00    	lea    0x604(%ebx),%edx
c020634f:	52                   	push   %edx
c0206350:	50                   	push   %eax
c0206351:	e8 88 f4 ff ff       	call   c02057de <error_kern>
c0206356:	83 c4 10             	add    $0x10,%esp
        while (True){
c0206359:	eb fe                	jmp    c0206359 <vmm_kern_init+0x7f>
            //内核暂停
        }
    }
    for(int i = 0; i<page_used ;i++){
c020635b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0206362:	eb 20                	jmp    c0206384 <vmm_kern_init+0xaa>
        uint32_t rem = bitmap_alloc(kern_vmm_pool); //将内核空间在内存池中置为繁忙   此处可做性能优化
c0206364:	83 ec 04             	sub    $0x4,%esp
c0206367:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c020636d:	ff 70 08             	pushl  0x8(%eax)
c0206370:	ff 70 04             	pushl  0x4(%eax)
c0206373:	ff 30                	pushl  (%eax)
c0206375:	e8 1f d1 ff ff       	call   c0203499 <bitmap_alloc>
c020637a:	83 c4 10             	add    $0x10,%esp
c020637d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(int i = 0; i<page_used ;i++){
c0206380:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206384:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206387:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c020638a:	7c d8                	jl     c0206364 <vmm_kern_init+0x8a>
    }    
    //将内核虚拟内存管理页（最后1024页）在内存池中置为繁忙
    //1024页占用128字节 所以要将bitmap最后128字节清零
    int temp_cnt =0;
c020638c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c0206393:	c7 c0 0c 80 20 c0    	mov    $0xc020800c,%eax
c0206399:	8b 00                	mov    (%eax),%eax
c020639b:	05 ff 7f 00 00       	add    $0x7fff,%eax
c02063a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
c02063a3:	eb 0e                	jmp    c02063b3 <vmm_kern_init+0xd9>
        *((byte*)probe) = 0;
c02063a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02063a8:	c6 00 00             	movb   $0x0,(%eax)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c02063ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02063af:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c02063b3:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
c02063b7:	7e ec                	jle    c02063a5 <vmm_kern_init+0xcb>
    }
}
c02063b9:	90                   	nop
c02063ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02063bd:	c9                   	leave  
c02063be:	c3                   	ret    

c02063bf <create_kern_page_table>:

//create a page table for input pde vaddr
static void create_kern_page_table(uint32_t pde_vaddr){
c02063bf:	55                   	push   %ebp
c02063c0:	89 e5                	mov    %esp,%ebp
c02063c2:	53                   	push   %ebx
c02063c3:	83 ec 24             	sub    $0x24,%esp
c02063c6:	e8 39 1c 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02063cb:	81 c3 35 2c 00 00    	add    $0x2c35,%ebx
    //first:alloc a physic page,don`t alloc from vmm!
    pm_alloc_t pm = pmm_alloc_one_page();
c02063d1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c02063d4:	83 ec 0c             	sub    $0xc,%esp
c02063d7:	50                   	push   %eax
c02063d8:	e8 86 eb ff ff       	call   c0204f63 <pmm_alloc_one_page>
c02063dd:	83 c4 0c             	add    $0xc,%esp
    if(pm.state!=0){
c02063e0:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c02063e4:	84 c0                	test   %al,%al
c02063e6:	74 1b                	je     c0206403 <create_kern_page_table+0x44>
        STOP(LOG_SRC_VMM,"Fail To Create Kernel Page Table!STOP!");
c02063e8:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
c02063ee:	83 ec 08             	sub    $0x8,%esp
c02063f1:	8d 93 34 06 00 00    	lea    0x634(%ebx),%edx
c02063f7:	52                   	push   %edx
c02063f8:	50                   	push   %eax
c02063f9:	e8 4a f4 ff ff       	call   c0205848 <stop_kern>
c02063fe:	83 c4 10             	add    $0x10,%esp
        memset((void *)addr,0x00,PAGE_SIZE);
        //third:change the PDE
        uint32_t* ptr = (uint32_t*) pde_vaddr;
        *ptr = (addr&0xFFFFF000)+PAGE_DESC_P+PAGE_DESC_RW_W+PAGE_DESC_US_S;
    }
}
c0206401:	eb 32                	jmp    c0206435 <create_kern_page_table+0x76>
        uint32_t addr = pm.addr;
c0206403:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0206406:	89 45 f4             	mov    %eax,-0xc(%ebp)
        memset((void *)addr,0x00,PAGE_SIZE);
c0206409:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020640c:	83 ec 04             	sub    $0x4,%esp
c020640f:	68 00 10 00 00       	push   $0x1000
c0206414:	6a 00                	push   $0x0
c0206416:	50                   	push   %eax
c0206417:	e8 db 15 00 00       	call   c02079f7 <memset>
c020641c:	83 c4 10             	add    $0x10,%esp
        uint32_t* ptr = (uint32_t*) pde_vaddr;
c020641f:	8b 45 08             	mov    0x8(%ebp),%eax
c0206422:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *ptr = (addr&0xFFFFF000)+PAGE_DESC_P+PAGE_DESC_RW_W+PAGE_DESC_US_S;
c0206425:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206428:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020642d:	8d 50 03             	lea    0x3(%eax),%edx
c0206430:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206433:	89 10                	mov    %edx,(%eax)
}
c0206435:	90                   	nop
c0206436:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206439:	c9                   	leave  
c020643a:	c3                   	ret    

c020643b <vmm_init>:

void vmm_init(){
c020643b:	55                   	push   %ebp
c020643c:	89 e5                	mov    %esp,%ebp
c020643e:	83 ec 08             	sub    $0x8,%esp
c0206441:	e8 ba 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206446:	05 ba 2b 00 00       	add    $0x2bba,%eax
       vmm_kern_init(); 
c020644b:	e8 8a fe ff ff       	call   c02062da <vmm_kern_init>
}
c0206450:	90                   	nop
c0206451:	c9                   	leave  
c0206452:	c3                   	ret    

c0206453 <vmm_pre_init>:

//cancel first mapping page(from 0x00000000 size 4MB)
void vmm_pre_init(){
c0206453:	55                   	push   %ebp
c0206454:	89 e5                	mov    %esp,%ebp
c0206456:	53                   	push   %ebx
c0206457:	83 ec 14             	sub    $0x14,%esp
c020645a:	e8 a1 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020645f:	05 a1 2b 00 00       	add    $0x2ba1,%eax
    //kern_dir_table_paddr
    uint32_t kern_dir_table_vaddr = kern_dir_table_paddr+0xC0000000;
c0206464:	c7 c2 14 80 20 c0    	mov    $0xc0208014,%edx
c020646a:	8b 12                	mov    (%edx),%edx
c020646c:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
c0206472:	89 55 f4             	mov    %edx,-0xc(%ebp)
    //release first pde
    *((uint32_t *)kern_dir_table_vaddr) = 0x00000000;
c0206475:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206478:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    //reload page table
    reload_kern_page_table(kern_dir_table_paddr);
c020647e:	c7 c2 14 80 20 c0    	mov    $0xc0208014,%edx
c0206484:	8b 12                	mov    (%edx),%edx
c0206486:	83 ec 0c             	sub    $0xc,%esp
c0206489:	52                   	push   %edx
c020648a:	89 c3                	mov    %eax,%ebx
c020648c:	e8 47 cd ff ff       	call   c02031d8 <reload_kern_page_table>
c0206491:	83 c4 10             	add    $0x10,%esp
}
c0206494:	90                   	nop
c0206495:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206498:	c9                   	leave  
c0206499:	c3                   	ret    

c020649a <get_pte>:

//通过虚拟地址 获取对应的页表项虚拟地址
uint32_t get_pte(uint32_t target) {
c020649a:	55                   	push   %ebp
c020649b:	89 e5                	mov    %esp,%ebp
c020649d:	83 ec 10             	sub    $0x10,%esp
c02064a0:	e8 5b 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02064a5:	05 5b 2b 00 00       	add    $0x2b5b,%eax
    target = target&0xFFFFF000;
c02064aa:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = (0x3FF<<22);     //高10位
c02064b1:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = (target>>10) & 0x003FF000;//中间10位为target高10位
c02064b8:	8b 45 08             	mov    0x8(%ebp),%eax
c02064bb:	c1 e8 0a             	shr    $0xa,%eax
c02064be:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c02064c3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t addr_low12 = (((target>>12)&0x3FF)*4)&0x00000FFF;//低12位为target中间10位×4
c02064c6:	8b 45 08             	mov    0x8(%ebp),%eax
c02064c9:	c1 e8 0c             	shr    $0xc,%eax
c02064cc:	25 ff 03 00 00       	and    $0x3ff,%eax
c02064d1:	c1 e0 02             	shl    $0x2,%eax
c02064d4:	25 fc 0f 00 00       	and    $0xffc,%eax
c02064d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c02064dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02064df:	0b 45 f8             	or     -0x8(%ebp),%eax
c02064e2:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c02064e5:	c9                   	leave  
c02064e6:	c3                   	ret    

c02064e7 <get_pde>:

//通过虚拟地址 获取对应的页目录项虚拟地址
uint32_t get_pde(uint32_t target) {
c02064e7:	55                   	push   %ebp
c02064e8:	89 e5                	mov    %esp,%ebp
c02064ea:	83 ec 10             	sub    $0x10,%esp
c02064ed:	e8 0e 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02064f2:	05 0e 2b 00 00       	add    $0x2b0e,%eax
    target = target&0xFFFFF000;
c02064f7:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = (0x3FF<<22);     //高10位
c02064fe:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = 0x003FF000;//中间10位为最后一个页目录项 也就是1023 （1111111111b）
c0206505:	c7 45 f8 00 f0 3f 00 	movl   $0x3ff000,-0x8(%ebp)
    uint32_t addr_low12 = (((target>>22)&0x3FF)*4)&0x00000FFF;//低12位为target中间10位×4
c020650c:	8b 45 08             	mov    0x8(%ebp),%eax
c020650f:	c1 e8 16             	shr    $0x16,%eax
c0206512:	c1 e0 02             	shl    $0x2,%eax
c0206515:	25 fc 0f 00 00       	and    $0xffc,%eax
c020651a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c020651d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206520:	0b 45 f8             	or     -0x8(%ebp),%eax
c0206523:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c0206526:	c9                   	leave  
c0206527:	c3                   	ret    

c0206528 <vmm_kern_alloc_one_page>:
//      1111111111_xxxxxxxxxx_xxxxxxxxxx
//前十位为1表示页目录表最后一项 指向页目录表起始地址
// 中间十位表示在1024项页目录表中的索引
//最后12位表示在页表中的索引（每张页表1024项 共4096B 也就是12位可表达的最大范围）

uint32_t vmm_kern_alloc_one_page(uint32_t target) {
c0206528:	55                   	push   %ebp
c0206529:	89 e5                	mov    %esp,%ebp
c020652b:	53                   	push   %ebx
c020652c:	83 ec 24             	sub    $0x24,%esp
c020652f:	e8 d0 1a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206534:	81 c3 cc 2a 00 00    	add    $0x2acc,%ebx
    uint32_t vaddr_get=bitmap_alloc_one_page(kern_vmm_pool,target);
c020653a:	ff 75 08             	pushl  0x8(%ebp)
c020653d:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206543:	ff 70 08             	pushl  0x8(%eax)
c0206546:	ff 70 04             	pushl  0x4(%eax)
c0206549:	ff 30                	pushl  (%eax)
c020654b:	e8 c1 cd ff ff       	call   c0203311 <bitmap_alloc_one_page>
c0206550:	83 c4 10             	add    $0x10,%esp
c0206553:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c0206556:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c020655a:	0f 84 80 00 00 00    	je     c02065e0 <vmm_kern_alloc_one_page+0xb8>
        goto error_out;
    }
    else{
        //first the check the page table is present~
        uint32_t dir_desc_vaddr = get_pde(target);
c0206560:	83 ec 0c             	sub    $0xc,%esp
c0206563:	ff 75 08             	pushl  0x8(%ebp)
c0206566:	e8 7c ff ff ff       	call   c02064e7 <get_pde>
c020656b:	83 c4 10             	add    $0x10,%esp
c020656e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //the lower is P bit
        uint32_t * ptr = (uint32_t*)dir_desc_vaddr;
c0206571:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206574:	89 45 ec             	mov    %eax,-0x14(%ebp)
            * ptr = *ptr|0x00000001;
            uint32_t page_desc_vaddr = get_pte(target);
            //because we change the PDE,we should flush the TLB to access the target PTE
            asm volatile ("invlpg (%0)" : : "a" (page_desc_vaddr&0xFFFFF000));
        }
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206577:	8d 45 dc             	lea    -0x24(%ebp),%eax
c020657a:	83 ec 0c             	sub    $0xc,%esp
c020657d:	50                   	push   %eax
c020657e:	e8 e0 e9 ff ff       	call   c0204f63 <pmm_alloc_one_page>
c0206583:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c0206586:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c020658a:	84 c0                	test   %al,%al
c020658c:	74 36                	je     c02065c4 <vmm_kern_alloc_one_page+0x9c>
            //没有可用的物理页
            goto clean_bitmap_alloc;
        }
        //修改页表
        uint32_t page_desc_vaddr = get_pte(target);
c020658e:	83 ec 0c             	sub    $0xc,%esp
c0206591:	ff 75 08             	pushl  0x8(%ebp)
c0206594:	e8 01 ff ff ff       	call   c020649a <get_pte>
c0206599:	83 c4 10             	add    $0x10,%esp
c020659c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c020659f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c02065a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02065a7:	89 c2                	mov    %eax,%edx
c02065a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c02065ac:	81 c2 03 01 00 00    	add    $0x103,%edx
c02065b2:	89 10                	mov    %edx,(%eax)
        asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c02065b4:	8b 45 08             	mov    0x8(%ebp),%eax
c02065b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02065bc:	0f 01 38             	invlpg (%eax)
        //reload_kern_page();
        return target;
c02065bf:	8b 45 08             	mov    0x8(%ebp),%eax
c02065c2:	eb 22                	jmp    c02065e6 <vmm_kern_alloc_one_page+0xbe>
            goto clean_bitmap_alloc;
c02065c4:	90                   	nop
    }
    clean_bitmap_alloc:
        bitmap_release_one_page(kern_vmm_pool,target);
c02065c5:	ff 75 08             	pushl  0x8(%ebp)
c02065c8:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02065ce:	ff 70 08             	pushl  0x8(%eax)
c02065d1:	ff 70 04             	pushl  0x4(%eax)
c02065d4:	ff 30                	pushl  (%eax)
c02065d6:	e8 13 ce ff ff       	call   c02033ee <bitmap_release_one_page>
c02065db:	83 c4 10             	add    $0x10,%esp
c02065de:	eb 01                	jmp    c02065e1 <vmm_kern_alloc_one_page+0xb9>
        goto error_out;
c02065e0:	90                   	nop
    error_out:
        return KERN_VMM_ALLOC_ERRO;
c02065e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c02065e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02065e9:	c9                   	leave  
c02065ea:	c3                   	ret    

c02065eb <vmm_kern_alloc>:

uint32_t vmm_kern_alloc(){
c02065eb:	55                   	push   %ebp
c02065ec:	89 e5                	mov    %esp,%ebp
c02065ee:	53                   	push   %ebx
c02065ef:	83 ec 24             	sub    $0x24,%esp
c02065f2:	e8 0d 1a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02065f7:	81 c3 09 2a 00 00    	add    $0x2a09,%ebx
    uint32_t target=bitmap_alloc(kern_vmm_pool);
c02065fd:	83 ec 04             	sub    $0x4,%esp
c0206600:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206606:	ff 70 08             	pushl  0x8(%eax)
c0206609:	ff 70 04             	pushl  0x4(%eax)
c020660c:	ff 30                	pushl  (%eax)
c020660e:	e8 86 ce ff ff       	call   c0203499 <bitmap_alloc>
c0206613:	83 c4 10             	add    $0x10,%esp
c0206616:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(target == BITMAP_RETURN_ERRO){
c0206619:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c020661d:	0f 84 80 00 00 00    	je     c02066a3 <vmm_kern_alloc+0xb8>
        goto error_out;
    }
    else{
        //first the check the page table is present~
        uint32_t dir_desc_vaddr = get_pde(target);
c0206623:	83 ec 0c             	sub    $0xc,%esp
c0206626:	ff 75 f4             	pushl  -0xc(%ebp)
c0206629:	e8 b9 fe ff ff       	call   c02064e7 <get_pde>
c020662e:	83 c4 10             	add    $0x10,%esp
c0206631:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //the lower is P bit
        uint32_t * ptr = (uint32_t*)dir_desc_vaddr;
c0206634:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206637:	89 45 ec             	mov    %eax,-0x14(%ebp)
            * ptr = *ptr|0x00000001;
            uint32_t page_desc_vaddr = get_pte(target);
            //because we change the PDE,we should flush the TLB to access the target PTE
            asm volatile ("invlpg (%0)" : : "a" (page_desc_vaddr&0xFFFFF000));
        }
        pm_alloc_t phy_page = pmm_alloc_one_page();
c020663a:	8d 45 dc             	lea    -0x24(%ebp),%eax
c020663d:	83 ec 0c             	sub    $0xc,%esp
c0206640:	50                   	push   %eax
c0206641:	e8 1d e9 ff ff       	call   c0204f63 <pmm_alloc_one_page>
c0206646:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c0206649:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c020664d:	84 c0                	test   %al,%al
c020664f:	74 36                	je     c0206687 <vmm_kern_alloc+0x9c>
            //没有可用的物理页
            goto clean_bitmap_alloc;
        }
        //修改页表
        uint32_t page_desc_vaddr = get_pte(target);
c0206651:	83 ec 0c             	sub    $0xc,%esp
c0206654:	ff 75 f4             	pushl  -0xc(%ebp)
c0206657:	e8 3e fe ff ff       	call   c020649a <get_pte>
c020665c:	83 c4 10             	add    $0x10,%esp
c020665f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c0206662:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0206665:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020666a:	89 c2                	mov    %eax,%edx
c020666c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020666f:	81 c2 03 01 00 00    	add    $0x103,%edx
c0206675:	89 10                	mov    %edx,(%eax)
        asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c0206677:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020667a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020667f:	0f 01 38             	invlpg (%eax)
        //reload_kern_page();
        return target;
c0206682:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206685:	eb 22                	jmp    c02066a9 <vmm_kern_alloc+0xbe>
            goto clean_bitmap_alloc;
c0206687:	90                   	nop
    }
    clean_bitmap_alloc:
        bitmap_release_one_page(kern_vmm_pool,target);
c0206688:	ff 75 f4             	pushl  -0xc(%ebp)
c020668b:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206691:	ff 70 08             	pushl  0x8(%eax)
c0206694:	ff 70 04             	pushl  0x4(%eax)
c0206697:	ff 30                	pushl  (%eax)
c0206699:	e8 50 cd ff ff       	call   c02033ee <bitmap_release_one_page>
c020669e:	83 c4 10             	add    $0x10,%esp
c02066a1:	eb 01                	jmp    c02066a4 <vmm_kern_alloc+0xb9>
        goto error_out;
c02066a3:	90                   	nop
    error_out:
        return KERN_VMM_ALLOC_ERRO;
c02066a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c02066a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02066ac:	c9                   	leave  
c02066ad:	c3                   	ret    

c02066ae <vmm_kern_release_one_page>:

//释放制定内核虚拟页的空间
//内核的释放与用户的释放要分开 否则用户程序可以使用系统调用指定将内核虚拟页释放掉

void vmm_kern_release_one_page(uint32_t target) {
c02066ae:	55                   	push   %ebp
c02066af:	89 e5                	mov    %esp,%ebp
c02066b1:	53                   	push   %ebx
c02066b2:	83 ec 24             	sub    $0x24,%esp
c02066b5:	e8 4e 19 00 00       	call   c0208008 <__x86.get_pc_thunk.dx>
c02066ba:	81 c2 46 29 00 00    	add    $0x2946,%edx
    //判定是否是内核页
    if(target<0xC0000000){
c02066c0:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c02066c7:	76 68                	jbe    c0206731 <vmm_kern_release_one_page+0x83>
        //不是内核页 直接退出执行
        return ;
    }
    bitmap_release_one_page(kern_vmm_pool,target);
c02066c9:	ff 75 08             	pushl  0x8(%ebp)
c02066cc:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02066d2:	ff 70 08             	pushl  0x8(%eax)
c02066d5:	ff 70 04             	pushl  0x4(%eax)
c02066d8:	ff 30                	pushl  (%eax)
c02066da:	89 d3                	mov    %edx,%ebx
c02066dc:	e8 0d cd ff ff       	call   c02033ee <bitmap_release_one_page>
c02066e1:	83 c4 10             	add    $0x10,%esp
    uint32_t desc_vaddr = get_pte(target);
c02066e4:	83 ec 0c             	sub    $0xc,%esp
c02066e7:	ff 75 08             	pushl  0x8(%ebp)
c02066ea:	e8 ab fd ff ff       	call   c020649a <get_pte>
c02066ef:	83 c4 10             	add    $0x10,%esp
c02066f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t desc_inf = *((uint32_t*)desc_vaddr);
c02066f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02066f8:	8b 00                	mov    (%eax),%eax
c02066fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *((uint32_t*)desc_vaddr) =  desc_inf&0xFFFFFFFE;    //最低位置为0 表示P位为0 不存在(直接访问会造成page_fault中断)
c02066fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206700:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206703:	83 e2 fe             	and    $0xfffffffe,%edx
c0206706:	89 10                	mov    %edx,(%eax)
    uint32_t phy_page_addr = desc_inf&0xFFFFF000;
c0206708:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020670b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206710:	89 45 ec             	mov    %eax,-0x14(%ebp)

    pm_alloc_t release_page;
    release_page.addr = phy_page_addr;
c0206713:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206716:	89 45 e0             	mov    %eax,-0x20(%ebp)
    release_page.size =1;
c0206719:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    release_page.state = 1;
c0206720:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)

    //BUG!!!!!!!!!!!!!!!!!!!!
    //pmm_free_page(release_page);

    /*此处有bug   虽然设置了页不缓存 但是系统还是会自动缓存 所以此处使用嵌入汇编invlpg重载目标页的TLB缓存*/
    asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c0206724:	8b 45 08             	mov    0x8(%ebp),%eax
c0206727:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020672c:	0f 01 38             	invlpg (%eax)
c020672f:	eb 01                	jmp    c0206732 <vmm_kern_release_one_page+0x84>
        return ;
c0206731:	90                   	nop
    //reload_kern_page();
}
c0206732:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206735:	c9                   	leave  
c0206736:	c3                   	ret    

c0206737 <check_vaddr_present>:


//检测vaddr是否可以访问（页表以及页目录项都是P=1）
bool check_vaddr_present(uint32_t vaddr){
c0206737:	55                   	push   %ebp
c0206738:	89 e5                	mov    %esp,%ebp
c020673a:	83 ec 10             	sub    $0x10,%esp
c020673d:	e8 be 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206742:	05 be 28 00 00       	add    $0x28be,%eax
    uint32_t * pde_ptr = get_pde(vaddr);
c0206747:	ff 75 08             	pushl  0x8(%ebp)
c020674a:	e8 98 fd ff ff       	call   c02064e7 <get_pde>
c020674f:	83 c4 04             	add    $0x4,%esp
c0206752:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t * pte_ptr;
    if(*pde_ptr==(*pde_ptr)|0x00000001){
         pte_ptr = get_pte(vaddr);
c0206755:	ff 75 08             	pushl  0x8(%ebp)
c0206758:	e8 3d fd ff ff       	call   c020649a <get_pte>
c020675d:	83 c4 04             	add    $0x4,%esp
c0206760:	89 45 f8             	mov    %eax,-0x8(%ebp)
         if(*pte_ptr==(*pte_ptr)|0x00000001){
            return True;
c0206763:	b8 01 00 00 00       	mov    $0x1,%eax
         }
    }
    else{
        return False;
    }
}
c0206768:	c9                   	leave  
c0206769:	c3                   	ret    

c020676a <vmm_v2p>:

//注意：输入的值结尾为FFF时要防止与错误输出冲突
//本函数不会无视页表的P位
//用于根据已安装的页表进行虚拟地址转换
uint32_t vmm_v2p(uint32_t vaddr){
c020676a:	55                   	push   %ebp
c020676b:	89 e5                	mov    %esp,%ebp
c020676d:	83 ec 10             	sub    $0x10,%esp
c0206770:	e8 8b 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206775:	05 8b 28 00 00       	add    $0x288b,%eax
    uint32_t pte_addr = get_pte(vaddr);
c020677a:	ff 75 08             	pushl  0x8(%ebp)
c020677d:	e8 18 fd ff ff       	call   c020649a <get_pte>
c0206782:	83 c4 04             	add    $0x4,%esp
c0206785:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t * ptr = (uint32_t*)pte_addr;
c0206788:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020678b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(check_vaddr_present(vaddr)){
c020678e:	ff 75 08             	pushl  0x8(%ebp)
c0206791:	e8 a1 ff ff ff       	call   c0206737 <check_vaddr_present>
c0206796:	83 c4 04             	add    $0x4,%esp
c0206799:	85 c0                	test   %eax,%eax
c020679b:	74 18                	je     c02067b5 <vmm_v2p+0x4b>
        //可访问的vaddr
        return (*(ptr)&0xFFFFF000)|(0x00000FFF&vaddr);
c020679d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02067a0:	8b 00                	mov    (%eax),%eax
c02067a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02067a7:	89 c2                	mov    %eax,%edx
c02067a9:	8b 45 08             	mov    0x8(%ebp),%eax
c02067ac:	25 ff 0f 00 00       	and    $0xfff,%eax
c02067b1:	09 d0                	or     %edx,%eax
c02067b3:	eb 05                	jmp    c02067ba <vmm_v2p+0x50>
    }
    else{
        //不可访问的vaddr
        return V2P_ERROR;
c02067b5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c02067ba:	c9                   	leave  
c02067bb:	c3                   	ret    

c02067bc <vmm_user_init>:

static void vmm_user_init(){
c02067bc:	55                   	push   %ebp
c02067bd:	89 e5                	mov    %esp,%ebp
c02067bf:	e8 3c 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02067c4:	05 3c 28 00 00       	add    $0x283c,%eax

}
c02067c9:	90                   	nop
c02067ca:	5d                   	pop    %ebp
c02067cb:	c3                   	ret    

c02067cc <user_get_pde>:
*/


//*************for user vmm****************
#define USER_GET_VMM_ERROR  0xFFFFFFFF
static uint32_t user_get_pde(uint32_t user_pdt_vaddr,uint32_t target_vaddr){
c02067cc:	55                   	push   %ebp
c02067cd:	89 e5                	mov    %esp,%ebp
c02067cf:	83 ec 10             	sub    $0x10,%esp
c02067d2:	e8 29 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02067d7:	05 29 28 00 00       	add    $0x2829,%eax
    uint32_t times = (target_vaddr>>22)&0x000003FF;
c02067dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c02067df:	c1 e8 16             	shr    $0x16,%eax
c02067e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t pde_vaddr = user_pdt_vaddr+times*4;
c02067e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02067e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c02067ef:	8b 45 08             	mov    0x8(%ebp),%eax
c02067f2:	01 d0                	add    %edx,%eax
c02067f4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return pde_vaddr;
c02067f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c02067fa:	c9                   	leave  
c02067fb:	c3                   	ret    

c02067fc <vmm_user_check_pt_present>:


static bool vmm_user_check_pt_present(uint32_t user_pdt_vaddr,uint32_t target_vaddr){
c02067fc:	55                   	push   %ebp
c02067fd:	89 e5                	mov    %esp,%ebp
c02067ff:	83 ec 10             	sub    $0x10,%esp
c0206802:	e8 f9 17 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206807:	05 f9 27 00 00       	add    $0x27f9,%eax
    uint32_t times = (target_vaddr>>22)&0x000003FF;
c020680c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020680f:	c1 e8 16             	shr    $0x16,%eax
c0206812:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t pde_vaddr = user_pdt_vaddr+times*4;     //目标pde虚拟地址
c0206815:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206818:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c020681f:	8b 45 08             	mov    0x8(%ebp),%eax
c0206822:	01 d0                	add    %edx,%eax
c0206824:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t * ptr = (uint32_t*)pde_vaddr;
c0206827:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020682a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //    == 优先级比 |    & 高
    if(*ptr==((*ptr)|0x00000001)){
c020682d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206830:	8b 10                	mov    (%eax),%edx
c0206832:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206835:	8b 00                	mov    (%eax),%eax
c0206837:	83 c8 01             	or     $0x1,%eax
c020683a:	39 c2                	cmp    %eax,%edx
c020683c:	75 07                	jne    c0206845 <vmm_user_check_pt_present+0x49>
        //表示存在present
        return True;
c020683e:	b8 01 00 00 00       	mov    $0x1,%eax
c0206843:	eb 05                	jmp    c020684a <vmm_user_check_pt_present+0x4e>
    }
    else{
        //表示不存在present
        return False;
c0206845:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c020684a:	c9                   	leave  
c020684b:	c3                   	ret    

c020684c <create_user_page_table>:


//创建的页表需要在内核中分配
static bool create_user_page_table(uint32_t pde_vaddr){
c020684c:	55                   	push   %ebp
c020684d:	89 e5                	mov    %esp,%ebp
c020684f:	53                   	push   %ebx
c0206850:	83 ec 14             	sub    $0x14,%esp
c0206853:	e8 ac 17 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206858:	81 c3 a8 27 00 00    	add    $0x27a8,%ebx
    //pde_vaddr 0xC02BABFC
    //首先在内核中获取虚拟页
    uint32_t re_vaddr = vmm_kern_alloc();    
c020685e:	e8 88 fd ff ff       	call   c02065eb <vmm_kern_alloc>
c0206863:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(re_vaddr==KERN_VMM_ALLOC_ERRO){
c0206866:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c020686a:	75 07                	jne    c0206873 <create_user_page_table+0x27>
        return False;
c020686c:	b8 00 00 00 00       	mov    $0x0,%eax
c0206871:	eb 50                	jmp    c02068c3 <create_user_page_table+0x77>
    }
    else{
        //进行单页内存清理
        bzero(re_vaddr,PAGE_SIZE);
c0206873:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206876:	83 ec 08             	sub    $0x8,%esp
c0206879:	68 00 10 00 00       	push   $0x1000
c020687e:	50                   	push   %eax
c020687f:	e8 ad 11 00 00       	call   c0207a31 <bzero>
c0206884:	83 c4 10             	add    $0x10,%esp
        uint32_t page_paddr = vmm_v2p(re_vaddr);
c0206887:	83 ec 0c             	sub    $0xc,%esp
c020688a:	ff 75 f4             	pushl  -0xc(%ebp)
c020688d:	e8 d8 fe ff ff       	call   c020676a <vmm_v2p>
c0206892:	83 c4 10             	add    $0x10,%esp
c0206895:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //获取页表物理地址i
        if(page_paddr == V2P_ERROR){
c0206898:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c020689c:	75 07                	jne    c02068a5 <create_user_page_table+0x59>
            //转换失败！！！
            return False;
c020689e:	b8 00 00 00 00       	mov    $0x0,%eax
c02068a3:	eb 1e                	jmp    c02068c3 <create_user_page_table+0x77>
        }
        else{
        //进行用户页表映射
            uint32_t *ptr = (uint32_t *)pde_vaddr;
c02068a5:	8b 45 08             	mov    0x8(%ebp),%eax
c02068a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *ptr = (page_paddr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_U+PAGE_DESC_G+PAGE_DESC_P;
c02068ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02068ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02068b3:	8d 90 07 01 00 00    	lea    0x107(%eax),%edx
c02068b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02068bc:	89 10                	mov    %edx,(%eax)
        }
        return True;
c02068be:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c02068c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02068c6:	c9                   	leave  
c02068c7:	c3                   	ret    

c02068c8 <vmm_user_alloc_one_page>:

//第一个参数是需要分配的虚拟内存池对应的进程
//第二个参数是需要分配的目标地址
//默认要求此进程已经加载并且正在执行中
uint32_t vmm_user_alloc_one_page(TCB_t * tcb_ptr,uint32_t vaddr){    
c02068c8:	55                   	push   %ebp
c02068c9:	89 e5                	mov    %esp,%ebp
c02068cb:	53                   	push   %ebx
c02068cc:	83 ec 34             	sub    $0x34,%esp
c02068cf:	e8 30 17 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02068d4:	81 c3 2c 27 00 00    	add    $0x272c,%ebx
    if(!USER_PAGE_DIR_IS_LOADED){
c02068da:	8b 83 24 f0 ff ff    	mov    -0xfdc(%ebx),%eax
c02068e0:	85 c0                	test   %eax,%eax
c02068e2:	0f 84 21 01 00 00    	je     c0206a09 <vmm_user_alloc_one_page+0x141>
        goto error_out;
    }

    bool is_kern_thread = tcb_ptr->is_kern_thread;
c02068e8:	8b 45 08             	mov    0x8(%ebp),%eax
c02068eb:	8b 40 20             	mov    0x20(%eax),%eax
c02068ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(is_kern_thread){
c02068f1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c02068f5:	0f 85 11 01 00 00    	jne    c0206a0c <vmm_user_alloc_one_page+0x144>
        goto error_out;
    }
    bitmap user_vmm_pool = tcb_ptr->user_vmm_pool;    //bitmap
c02068fb:	8b 45 08             	mov    0x8(%ebp),%eax
c02068fe:	8b 50 24             	mov    0x24(%eax),%edx
c0206901:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0206904:	8b 50 28             	mov    0x28(%eax),%edx
c0206907:	89 55 d8             	mov    %edx,-0x28(%ebp)
c020690a:	8b 40 2c             	mov    0x2c(%eax),%eax
c020690d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uint32_t user_pdt_vaddr = tcb_ptr->pdt_vaddr;    //pdt
c0206910:	8b 45 08             	mov    0x8(%ebp),%eax
c0206913:	8b 40 30             	mov    0x30(%eax),%eax
c0206916:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t vaddr_get=bitmap_alloc_one_page(user_vmm_pool,vaddr);
c0206919:	ff 75 0c             	pushl  0xc(%ebp)
c020691c:	ff 75 dc             	pushl  -0x24(%ebp)
c020691f:	ff 75 d8             	pushl  -0x28(%ebp)
c0206922:	ff 75 d4             	pushl  -0x2c(%ebp)
c0206925:	e8 e7 c9 ff ff       	call   c0203311 <bitmap_alloc_one_page>
c020692a:	83 c4 10             	add    $0x10,%esp
c020692d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c0206930:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0206934:	0f 84 ad 00 00 00    	je     c02069e7 <vmm_user_alloc_one_page+0x11f>
        goto clean_bitmap_alloc;
    }
    else{
        if(vmm_user_check_pt_present(user_pdt_vaddr,vaddr)){
c020693a:	83 ec 08             	sub    $0x8,%esp
c020693d:	ff 75 0c             	pushl  0xc(%ebp)
c0206940:	ff 75 f0             	pushl  -0x10(%ebp)
c0206943:	e8 b4 fe ff ff       	call   c02067fc <vmm_user_check_pt_present>
c0206948:	83 c4 10             	add    $0x10,%esp
c020694b:	85 c0                	test   %eax,%eax
c020694d:	74 19                	je     c0206968 <vmm_user_alloc_one_page+0xa0>
         asm volatile("cli");
c020694f:	fa                   	cli    
            printk("-0x%h\n",user_pdt_vaddr);
c0206950:	83 ec 08             	sub    $0x8,%esp
c0206953:	ff 75 f0             	pushl  -0x10(%ebp)
c0206956:	8d 83 5b 06 00 00    	lea    0x65b(%ebx),%eax
c020695c:	50                   	push   %eax
c020695d:	e8 d2 09 00 00       	call   c0207334 <printk>
c0206962:	83 c4 10             	add    $0x10,%esp
         asm volatile("sti");
c0206965:	fb                   	sti    
c0206966:	eb 2d                	jmp    c0206995 <vmm_user_alloc_one_page+0xcd>

            // the page table is present,do nothing
        }
        else{
            // the page table is not present,create page table
            uint32_t times = (vaddr>>22)&0x000003FF;
c0206968:	8b 45 0c             	mov    0xc(%ebp),%eax
c020696b:	c1 e8 16             	shr    $0x16,%eax
c020696e:	89 45 e8             	mov    %eax,-0x18(%ebp)
            uint32_t user_dir_desc_vaddr= user_pdt_vaddr+times*4;     //目标pde虚拟地址
c0206971:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0206974:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c020697b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020697e:	01 d0                	add    %edx,%eax
c0206980:	89 45 e4             	mov    %eax,-0x1c(%ebp)
           if(create_user_page_table(user_dir_desc_vaddr)){
c0206983:	83 ec 0c             	sub    $0xc,%esp
c0206986:	ff 75 e4             	pushl  -0x1c(%ebp)
c0206989:	e8 be fe ff ff       	call   c020684c <create_user_page_table>
c020698e:	83 c4 10             	add    $0x10,%esp
c0206991:	85 c0                	test   %eax,%eax
c0206993:	74 55                	je     c02069ea <vmm_user_alloc_one_page+0x122>
           }
           else{
               goto clean_bitmap_alloc;
           }
        }
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206995:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0206998:	83 ec 0c             	sub    $0xc,%esp
c020699b:	50                   	push   %eax
c020699c:	e8 c2 e5 ff ff       	call   c0204f63 <pmm_alloc_one_page>
c02069a1:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c02069a4:	0f b6 45 d0          	movzbl -0x30(%ebp),%eax
c02069a8:	84 c0                	test   %al,%al
c02069aa:	74 41                	je     c02069ed <vmm_user_alloc_one_page+0x125>
            //没有可用的物理页
            goto clean_bitmap_alloc;
        }
        //获取目标页表项在内核空间中的虚拟地址
        uint32_t page_desc_vaddr = get_pte(vaddr);
c02069ac:	83 ec 0c             	sub    $0xc,%esp
c02069af:	ff 75 0c             	pushl  0xc(%ebp)
c02069b2:	e8 e3 fa ff ff       	call   c020649a <get_pte>
c02069b7:	83 c4 10             	add    $0x10,%esp
c02069ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
        //修改页表
        //注意一点：这个page_desc_vaddr只能通过页目录最后一项找到，所以必须要用户页表加载以后才可以寻找到
        //此时会产生page错误？？？？？
        //FFEFFF20
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_U+PAGE_DESC_G+PAGE_DESC_P;
c02069bd:	8b 45 c8             	mov    -0x38(%ebp),%eax
c02069c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069c5:	89 c2                	mov    %eax,%edx
c02069c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c02069ca:	81 c2 07 01 00 00    	add    $0x107,%edx
c02069d0:	89 10                	mov    %edx,(%eax)

        asm volatile ("invlpg (%0)" : : "a" (vaddr&0xFFFFF000));
c02069d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c02069d5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069da:	0f 01 38             	invlpg (%eax)
        return vaddr&0xFFFFF000;
c02069dd:	8b 45 0c             	mov    0xc(%ebp),%eax
c02069e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069e5:	eb 2b                	jmp    c0206a12 <vmm_user_alloc_one_page+0x14a>
        goto clean_bitmap_alloc;
c02069e7:	90                   	nop
c02069e8:	eb 04                	jmp    c02069ee <vmm_user_alloc_one_page+0x126>
               goto clean_bitmap_alloc;
c02069ea:	90                   	nop
c02069eb:	eb 01                	jmp    c02069ee <vmm_user_alloc_one_page+0x126>
            goto clean_bitmap_alloc;
c02069ed:	90                   	nop
    }
    //clean以后会自动执行错误的返回
    clean_bitmap_alloc:
        bitmap_release_one_page(kern_vmm_pool,vaddr);
c02069ee:	ff 75 0c             	pushl  0xc(%ebp)
c02069f1:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02069f7:	ff 70 08             	pushl  0x8(%eax)
c02069fa:	ff 70 04             	pushl  0x4(%eax)
c02069fd:	ff 30                	pushl  (%eax)
c02069ff:	e8 ea c9 ff ff       	call   c02033ee <bitmap_release_one_page>
c0206a04:	83 c4 10             	add    $0x10,%esp
c0206a07:	eb 04                	jmp    c0206a0d <vmm_user_alloc_one_page+0x145>
        goto error_out;
c0206a09:	90                   	nop
c0206a0a:	eb 01                	jmp    c0206a0d <vmm_user_alloc_one_page+0x145>
        goto error_out;
c0206a0c:	90                   	nop
    error_out:
        return USER_VMM_ALLOC_ERRO;
c0206a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0206a12:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206a15:	c9                   	leave  
c0206a16:	c3                   	ret    

c0206a17 <vmm_user_alloc>:

uint32_t vmm_user_alloc(uint32_t user_pdt_vaddr){
c0206a17:	55                   	push   %ebp
c0206a18:	89 e5                	mov    %esp,%ebp
c0206a1a:	e8 e1 15 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206a1f:	05 e1 25 00 00       	add    $0x25e1,%eax

}
c0206a24:	90                   	nop
c0206a25:	5d                   	pop    %ebp
c0206a26:	c3                   	ret    

c0206a27 <vmm_user_release_one_page>:
void vmm_user_release_one_page(uint32_t target){
c0206a27:	55                   	push   %ebp
c0206a28:	89 e5                	mov    %esp,%ebp
c0206a2a:	e8 d1 15 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206a2f:	05 d1 25 00 00       	add    $0x25d1,%eax

}
c0206a34:	90                   	nop
c0206a35:	5d                   	pop    %ebp
c0206a36:	c3                   	ret    

c0206a37 <get_user_used_vmm_info>:

int get_user_used_vmm_info(){
c0206a37:	55                   	push   %ebp
c0206a38:	89 e5                	mov    %esp,%ebp
c0206a3a:	e8 c1 15 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206a3f:	05 c1 25 00 00       	add    $0x25c1,%eax
    return 1;
c0206a44:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0206a49:	5d                   	pop    %ebp
c0206a4a:	c3                   	ret    

c0206a4b <vmm_test>:




//6(0110)3(0011)
void vmm_test(){
c0206a4b:	55                   	push   %ebp
c0206a4c:	89 e5                	mov    %esp,%ebp
c0206a4e:	56                   	push   %esi
c0206a4f:	53                   	push   %ebx
c0206a50:	e8 af 15 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206a55:	81 c3 ab 25 00 00    	add    $0x25ab,%ebx
    //vmm_kern_release_one_page(0xC0000000);
    //*((char*)0xC0000000) = 1;   
    printk("\nkern_dir:0x%h\n",kern_dir_table_paddr);
c0206a5b:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0206a61:	8b 00                	mov    (%eax),%eax
c0206a63:	83 ec 08             	sub    $0x8,%esp
c0206a66:	50                   	push   %eax
c0206a67:	8d 83 62 06 00 00    	lea    0x662(%ebx),%eax
c0206a6d:	50                   	push   %eax
c0206a6e:	e8 c1 08 00 00       	call   c0207334 <printk>
c0206a73:	83 c4 10             	add    $0x10,%esp
    printk("\nkern_page:0x%h\n",kern_page_table_paddr);
c0206a76:	c7 c0 18 80 20 c0    	mov    $0xc0208018,%eax
c0206a7c:	8b 00                	mov    (%eax),%eax
c0206a7e:	83 ec 08             	sub    $0x8,%esp
c0206a81:	50                   	push   %eax
c0206a82:	8d 83 72 06 00 00    	lea    0x672(%ebx),%eax
c0206a88:	50                   	push   %eax
c0206a89:	e8 a6 08 00 00       	call   c0207334 <printk>
c0206a8e:	83 c4 10             	add    $0x10,%esp
    printk("\nlast_pde:0x%h\n",*((uint32_t*)(kern_dir_table_paddr+0xC00+255*4)));
c0206a91:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0206a97:	8b 00                	mov    (%eax),%eax
c0206a99:	05 fc 0f 00 00       	add    $0xffc,%eax
c0206a9e:	8b 00                	mov    (%eax),%eax
c0206aa0:	83 ec 08             	sub    $0x8,%esp
c0206aa3:	50                   	push   %eax
c0206aa4:	8d 83 83 06 00 00    	lea    0x683(%ebx),%eax
c0206aaa:	50                   	push   %eax
c0206aab:	e8 84 08 00 00       	call   c0207334 <printk>
c0206ab0:	83 c4 10             	add    $0x10,%esp
    printk("\nresult:0x%h---%h\n",*((uint32_t*) get_pte(0xC0000000)),*((uint32_t*)kern_page_table_paddr));
c0206ab3:	c7 c0 18 80 20 c0    	mov    $0xc0208018,%eax
c0206ab9:	8b 00                	mov    (%eax),%eax
c0206abb:	8b 30                	mov    (%eax),%esi
c0206abd:	83 ec 0c             	sub    $0xc,%esp
c0206ac0:	68 00 00 00 c0       	push   $0xc0000000
c0206ac5:	e8 d0 f9 ff ff       	call   c020649a <get_pte>
c0206aca:	83 c4 10             	add    $0x10,%esp
c0206acd:	8b 00                	mov    (%eax),%eax
c0206acf:	83 ec 04             	sub    $0x4,%esp
c0206ad2:	56                   	push   %esi
c0206ad3:	50                   	push   %eax
c0206ad4:	8d 83 93 06 00 00    	lea    0x693(%ebx),%eax
c0206ada:	50                   	push   %eax
c0206adb:	e8 54 08 00 00       	call   c0207334 <printk>
c0206ae0:	83 c4 10             	add    $0x10,%esp
//正常分配情况会导致两次page_fault
    *((char*)0xC1000000) = 'a';
c0206ae3:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206ae8:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_alloc_one_page(0xC1000000);
c0206aeb:	83 ec 0c             	sub    $0xc,%esp
c0206aee:	68 00 00 00 c1       	push   $0xc1000000
c0206af3:	e8 30 fa ff ff       	call   c0206528 <vmm_kern_alloc_one_page>
c0206af8:	83 c4 10             	add    $0x10,%esp
    *((char*)0xC1000000) = 'a';
c0206afb:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206b00:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_release_one_page(0xC1000000);
c0206b03:	83 ec 0c             	sub    $0xc,%esp
c0206b06:	68 00 00 00 c1       	push   $0xc1000000
c0206b0b:	e8 9e fb ff ff       	call   c02066ae <vmm_kern_release_one_page>
c0206b10:	83 c4 10             	add    $0x10,%esp
    *((char*)0xC1000000) = 'a';
c0206b13:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206b18:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_alloc_one_page(0xEE000000);
c0206b1b:	83 ec 0c             	sub    $0xc,%esp
c0206b1e:	68 00 00 00 ee       	push   $0xee000000
c0206b23:	e8 00 fa ff ff       	call   c0206528 <vmm_kern_alloc_one_page>
c0206b28:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0000000))));
c0206b2b:	83 ec 0c             	sub    $0xc,%esp
c0206b2e:	68 00 00 00 c0       	push   $0xc0000000
c0206b33:	e8 af f9 ff ff       	call   c02064e7 <get_pde>
c0206b38:	83 c4 10             	add    $0x10,%esp
c0206b3b:	8b 00                	mov    (%eax),%eax
c0206b3d:	83 ec 08             	sub    $0x8,%esp
c0206b40:	50                   	push   %eax
c0206b41:	8d 83 a6 06 00 00    	lea    0x6a6(%ebx),%eax
c0206b47:	50                   	push   %eax
c0206b48:	e8 e7 07 00 00       	call   c0207334 <printk>
c0206b4d:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0400000))));
c0206b50:	83 ec 0c             	sub    $0xc,%esp
c0206b53:	68 00 00 40 c0       	push   $0xc0400000
c0206b58:	e8 8a f9 ff ff       	call   c02064e7 <get_pde>
c0206b5d:	83 c4 10             	add    $0x10,%esp
c0206b60:	8b 00                	mov    (%eax),%eax
c0206b62:	83 ec 08             	sub    $0x8,%esp
c0206b65:	50                   	push   %eax
c0206b66:	8d 83 a6 06 00 00    	lea    0x6a6(%ebx),%eax
c0206b6c:	50                   	push   %eax
c0206b6d:	e8 c2 07 00 00       	call   c0207334 <printk>
c0206b72:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0800000))));
c0206b75:	83 ec 0c             	sub    $0xc,%esp
c0206b78:	68 00 00 80 c0       	push   $0xc0800000
c0206b7d:	e8 65 f9 ff ff       	call   c02064e7 <get_pde>
c0206b82:	83 c4 10             	add    $0x10,%esp
c0206b85:	8b 00                	mov    (%eax),%eax
c0206b87:	83 ec 08             	sub    $0x8,%esp
c0206b8a:	50                   	push   %eax
c0206b8b:	8d 83 a6 06 00 00    	lea    0x6a6(%ebx),%eax
c0206b91:	50                   	push   %eax
c0206b92:	e8 9d 07 00 00       	call   c0207334 <printk>
c0206b97:	83 c4 10             	add    $0x10,%esp
c0206b9a:	90                   	nop
c0206b9b:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0206b9e:	5b                   	pop    %ebx
c0206b9f:	5e                   	pop    %esi
c0206ba0:	5d                   	pop    %ebp
c0206ba1:	c3                   	ret    

c0206ba2 <kern_entry>:
void kputc(char);
void screen_uproll_once();
extern TCB_t * cur_tcb;
extern TCB_t main_TCB;
int entry_test_a;
void kern_entry(){
c0206ba2:	55                   	push   %ebp
c0206ba3:	89 e5                	mov    %esp,%ebp
c0206ba5:	53                   	push   %ebx
c0206ba6:	83 ec 14             	sub    $0x14,%esp
c0206ba9:	e8 56 14 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206bae:	81 c3 52 24 00 00    	add    $0x2452,%ebx
    void func(void* args);
	vga_init();
c0206bb4:	e8 a8 05 00 00       	call   c0207161 <vga_init>
	pmm_init();
c0206bb9:	e8 e2 e8 ff ff       	call   c02054a0 <pmm_init>
    idt_init();
c0206bbe:	e8 96 ee ff ff       	call   c0205a59 <idt_init>
    //vmm_pre_init();
    asm volatile("cli");
c0206bc3:	fa                   	cli    

    //*((char *)0xBFFFF01F) = 'a';

    asm volatile("mov    $0xbffff01f,%eax");
c0206bc4:	b8 1f f0 ff bf       	mov    $0xbffff01f,%eax
    asm volatile("movb   $0x61,(%eax)");
c0206bc9:	c6 00 61             	movb   $0x61,(%eax)

	tss_init();
c0206bcc:	e8 86 ea ff ff       	call   c0205657 <tss_init>
    //must close hardware interrupt because we have just user IRQ0(Number32/clock)
	threads_init();
c0206bd1:	e8 48 cc ff ff       	call   c020381e <threads_init>
    //vga_basic_test();
	vmm_init();
c0206bd6:	e8 60 f8 ff ff       	call   c020643b <vmm_init>
    //vmm_test();
    //bitmap_test();
	//user_task_test();
    asm volatile("sti");
c0206bdb:	fb                   	sti    
    //asm volatile("sti");
	start_user_task_params_t u1;
	u1.fd = 0;
c0206bdc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	u1.is_from_file = False;
c0206be3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	u1.function = func;
c0206bea:	8d 83 0d dc ff ff    	lea    -0x23f3(%ebx),%eax
c0206bf0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u1.args = (void*)NULL;
c0206bf3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	create_user_task(2,&u1);
c0206bfa:	83 ec 08             	sub    $0x8,%esp
c0206bfd:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0206c00:	50                   	push   %eax
c0206c01:	6a 02                	push   $0x2
c0206c03:	e8 7f d4 ff ff       	call   c0204087 <create_user_task>
c0206c08:	83 c4 10             	add    $0x10,%esp
while (1){
c0206c0b:	eb fe                	jmp    c0206c0b <kern_entry+0x69>

c0206c0d <func>:
	}
    while(True)
     	asm volatile ("hlt");
}

void func(void* args){
c0206c0d:	55                   	push   %ebp
c0206c0e:	89 e5                	mov    %esp,%ebp
c0206c10:	e8 eb 13 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206c15:	05 eb 23 00 00       	add    $0x23eb,%eax
	while(True){
		*((uint32_t*)0xF0000000)=0;
c0206c1a:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
c0206c1f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0206c25:	eb f3                	jmp    c0206c1a <func+0xd>

c0206c27 <_8259A_init>:
static uint16_t m_control_port = 0x20;     //主片控制端口号  main
static uint16_t m_data_port = 0x21;	       //从片数据端口号
static uint16_t o_control_port = 0xA0;     //从片控制端口号  other
static uint16_t o_data_port = 0xA1;        //从片数据端口号

void _8259A_init(){
c0206c27:	55                   	push   %ebp
c0206c28:	89 e5                	mov    %esp,%ebp
c0206c2a:	53                   	push   %ebx
c0206c2b:	83 ec 04             	sub    $0x4,%esp
c0206c2e:	e8 d1 13 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206c33:	81 c3 cd 23 00 00    	add    $0x23cd,%ebx
	//主片初始化
	outb(m_control_port,0x11);
c0206c39:	0f b7 83 28 f0 ff ff 	movzwl -0xfd8(%ebx),%eax
c0206c40:	0f b7 c0             	movzwl %ax,%eax
c0206c43:	83 ec 08             	sub    $0x8,%esp
c0206c46:	6a 11                	push   $0x11
c0206c48:	50                   	push   %eax
c0206c49:	e8 9d 05 00 00       	call   c02071eb <outb>
c0206c4e:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x20);
c0206c51:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206c58:	0f b7 c0             	movzwl %ax,%eax
c0206c5b:	83 ec 08             	sub    $0x8,%esp
c0206c5e:	6a 20                	push   $0x20
c0206c60:	50                   	push   %eax
c0206c61:	e8 85 05 00 00       	call   c02071eb <outb>
c0206c66:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x04);
c0206c69:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206c70:	0f b7 c0             	movzwl %ax,%eax
c0206c73:	83 ec 08             	sub    $0x8,%esp
c0206c76:	6a 04                	push   $0x4
c0206c78:	50                   	push   %eax
c0206c79:	e8 6d 05 00 00       	call   c02071eb <outb>
c0206c7e:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x01);
c0206c81:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206c88:	0f b7 c0             	movzwl %ax,%eax
c0206c8b:	83 ec 08             	sub    $0x8,%esp
c0206c8e:	6a 01                	push   $0x1
c0206c90:	50                   	push   %eax
c0206c91:	e8 55 05 00 00       	call   c02071eb <outb>
c0206c96:	83 c4 10             	add    $0x10,%esp
	//从片初始化
	outb(o_control_port,0x11);
c0206c99:	0f b7 83 2c f0 ff ff 	movzwl -0xfd4(%ebx),%eax
c0206ca0:	0f b7 c0             	movzwl %ax,%eax
c0206ca3:	83 ec 08             	sub    $0x8,%esp
c0206ca6:	6a 11                	push   $0x11
c0206ca8:	50                   	push   %eax
c0206ca9:	e8 3d 05 00 00       	call   c02071eb <outb>
c0206cae:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x28);
c0206cb1:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206cb8:	0f b7 c0             	movzwl %ax,%eax
c0206cbb:	83 ec 08             	sub    $0x8,%esp
c0206cbe:	6a 28                	push   $0x28
c0206cc0:	50                   	push   %eax
c0206cc1:	e8 25 05 00 00       	call   c02071eb <outb>
c0206cc6:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x02);
c0206cc9:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206cd0:	0f b7 c0             	movzwl %ax,%eax
c0206cd3:	83 ec 08             	sub    $0x8,%esp
c0206cd6:	6a 02                	push   $0x2
c0206cd8:	50                   	push   %eax
c0206cd9:	e8 0d 05 00 00       	call   c02071eb <outb>
c0206cde:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x01);
c0206ce1:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206ce8:	0f b7 c0             	movzwl %ax,%eax
c0206ceb:	83 ec 08             	sub    $0x8,%esp
c0206cee:	6a 01                	push   $0x1
c0206cf0:	50                   	push   %eax
c0206cf1:	e8 f5 04 00 00       	call   c02071eb <outb>
c0206cf6:	83 c4 10             	add    $0x10,%esp
c0206cf9:	90                   	nop
c0206cfa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206cfd:	c9                   	leave  
c0206cfe:	c3                   	ret    

c0206cff <move_cursor>:
static uint8_t *video_memory = (uint8_t *)0xC00B8000;
//光标位置
static uint8_t cursor_x = 0;
static uint8_t cursor_y = 0;
static void move_cursor()
{
c0206cff:	55                   	push   %ebp
c0206d00:	89 e5                	mov    %esp,%ebp
c0206d02:	53                   	push   %ebx
c0206d03:	83 ec 14             	sub    $0x14,%esp
c0206d06:	e8 f9 12 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206d0b:	81 c3 f5 22 00 00    	add    $0x22f5,%ebx
// 屏幕是 80 字节宽
    uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c0206d11:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206d18:	0f b6 d0             	movzbl %al,%edx
c0206d1b:	89 d0                	mov    %edx,%eax
c0206d1d:	c1 e0 02             	shl    $0x2,%eax
c0206d20:	01 d0                	add    %edx,%eax
c0206d22:	c1 e0 04             	shl    $0x4,%eax
c0206d25:	89 c2                	mov    %eax,%edx
c0206d27:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206d2e:	0f b6 c0             	movzbl %al,%eax
c0206d31:	01 d0                	add    %edx,%eax
c0206d33:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    // 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置
    // 的高8位与低8位。
    outb(0x3D4, 14);                    // 告诉 VGA 我们要设置光标的高字节
c0206d37:	83 ec 08             	sub    $0x8,%esp
c0206d3a:	6a 0e                	push   $0xe
c0206d3c:	68 d4 03 00 00       	push   $0x3d4
c0206d41:	e8 a5 04 00 00       	call   c02071eb <outb>
c0206d46:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation >> 8);   // 发送高 8 位
c0206d49:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0206d4d:	66 c1 e8 08          	shr    $0x8,%ax
c0206d51:	0f b6 c0             	movzbl %al,%eax
c0206d54:	83 ec 08             	sub    $0x8,%esp
c0206d57:	50                   	push   %eax
c0206d58:	68 d5 03 00 00       	push   $0x3d5
c0206d5d:	e8 89 04 00 00       	call   c02071eb <outb>
c0206d62:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4, 15);                    // 告诉 VGA 我们要设置光标的低字节
c0206d65:	83 ec 08             	sub    $0x8,%esp
c0206d68:	6a 0f                	push   $0xf
c0206d6a:	68 d4 03 00 00       	push   $0x3d4
c0206d6f:	e8 77 04 00 00       	call   c02071eb <outb>
c0206d74:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation);        // 发送低 8 位
c0206d77:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0206d7b:	0f b6 c0             	movzbl %al,%eax
c0206d7e:	83 ec 08             	sub    $0x8,%esp
c0206d81:	50                   	push   %eax
c0206d82:	68 d5 03 00 00       	push   $0x3d5
c0206d87:	e8 5f 04 00 00       	call   c02071eb <outb>
c0206d8c:	83 c4 10             	add    $0x10,%esp
}
c0206d8f:	90                   	nop
c0206d90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206d93:	c9                   	leave  
c0206d94:	c3                   	ret    

c0206d95 <move_cursor_by_XY>:

void move_cursor_by_XY(uint8_t x,uint8_t y){
c0206d95:	55                   	push   %ebp
c0206d96:	89 e5                	mov    %esp,%ebp
c0206d98:	83 ec 18             	sub    $0x18,%esp
c0206d9b:	e8 60 12 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206da0:	05 60 22 00 00       	add    $0x2260,%eax
c0206da5:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0206da8:	8b 55 0c             	mov    0xc(%ebp),%edx
c0206dab:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0206dae:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if(x>79||y>24)
c0206db1:	80 7d f4 4f          	cmpb   $0x4f,-0xc(%ebp)
c0206db5:	77 21                	ja     c0206dd8 <move_cursor_by_XY+0x43>
c0206db7:	80 7d f0 18          	cmpb   $0x18,-0x10(%ebp)
c0206dbb:	77 1b                	ja     c0206dd8 <move_cursor_by_XY+0x43>
		return ;
	cursor_x=x;
c0206dbd:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0206dc1:	88 90 a0 90 08 00    	mov    %dl,0x890a0(%eax)
	cursor_y=y;
c0206dc7:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c0206dcb:	88 90 a1 90 08 00    	mov    %dl,0x890a1(%eax)
	move_cursor();
c0206dd1:	e8 29 ff ff ff       	call   c0206cff <move_cursor>
c0206dd6:	eb 01                	jmp    c0206dd9 <move_cursor_by_XY+0x44>
		return ;
c0206dd8:	90                   	nop
}
c0206dd9:	c9                   	leave  
c0206dda:	c3                   	ret    

c0206ddb <clear_screen>:

void clear_screen(){
c0206ddb:	55                   	push   %ebp
c0206ddc:	89 e5                	mov    %esp,%ebp
c0206dde:	53                   	push   %ebx
c0206ddf:	83 ec 14             	sub    $0x14,%esp
c0206de2:	e8 1d 12 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206de7:	81 c3 19 22 00 00    	add    $0x2219,%ebx
	cursor_x=0;
c0206ded:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
	cursor_y=0;
c0206df4:	c6 83 a1 90 08 00 00 	movb   $0x0,0x890a1(%ebx)
	for(int j=0;j<25;j++){
c0206dfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0206e02:	eb 28                	jmp    c0206e2c <clear_screen+0x51>
		for(int i=0;i<80;i++)
c0206e04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0206e0b:	eb 15                	jmp    c0206e22 <clear_screen+0x47>
			vga_putc('\0',black,white);
c0206e0d:	83 ec 04             	sub    $0x4,%esp
c0206e10:	6a 0f                	push   $0xf
c0206e12:	6a 00                	push   $0x0
c0206e14:	6a 00                	push   $0x0
c0206e16:	e8 18 01 00 00       	call   c0206f33 <vga_putc>
c0206e1b:	83 c4 10             	add    $0x10,%esp
		for(int i=0;i<80;i++)
c0206e1e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0206e22:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c0206e26:	7e e5                	jle    c0206e0d <clear_screen+0x32>
	for(int j=0;j<25;j++){
c0206e28:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206e2c:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0206e30:	7e d2                	jle    c0206e04 <clear_screen+0x29>
	}
	cursor_x=0;
c0206e32:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
	cursor_y=0;
c0206e39:	c6 83 a1 90 08 00 00 	movb   $0x0,0x890a1(%ebx)
	move_cursor();
c0206e40:	e8 ba fe ff ff       	call   c0206cff <move_cursor>
}
c0206e45:	90                   	nop
c0206e46:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206e49:	c9                   	leave  
c0206e4a:	c3                   	ret    

c0206e4b <screen_uproll_once>:

void screen_uproll_once(){     //光标是会变化的
c0206e4b:	55                   	push   %ebp
c0206e4c:	89 e5                	mov    %esp,%ebp
c0206e4e:	53                   	push   %ebx
c0206e4f:	83 ec 24             	sub    $0x24,%esp
c0206e52:	e8 a9 11 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206e57:	05 a9 21 00 00       	add    $0x21a9,%eax
	for(int j=1;j<25;j++){
c0206e5c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0206e63:	eb 70                	jmp    c0206ed5 <screen_uproll_once+0x8a>
		for(int i=0;i<80;i++){
c0206e65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0206e6c:	eb 5d                	jmp    c0206ecb <screen_uproll_once+0x80>
			uint16_t cursorLocation = j * 80 + i;
c0206e6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206e71:	89 d1                	mov    %edx,%ecx
c0206e73:	89 ca                	mov    %ecx,%edx
c0206e75:	c1 e2 02             	shl    $0x2,%edx
c0206e78:	01 ca                	add    %ecx,%edx
c0206e7a:	c1 e2 04             	shl    $0x4,%edx
c0206e7d:	89 d1                	mov    %edx,%ecx
c0206e7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206e82:	01 ca                	add    %ecx,%edx
c0206e84:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
			uint16_t targetCursorLocation = (j-1) * 80 + i;
c0206e88:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206e8b:	83 ea 01             	sub    $0x1,%edx
c0206e8e:	89 d1                	mov    %edx,%ecx
c0206e90:	89 ca                	mov    %ecx,%edx
c0206e92:	c1 e2 02             	shl    $0x2,%edx
c0206e95:	01 ca                	add    %ecx,%edx
c0206e97:	c1 e2 04             	shl    $0x4,%edx
c0206e9a:	89 d1                	mov    %edx,%ecx
c0206e9c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206e9f:	01 ca                	add    %ecx,%edx
c0206ea1:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
			*((uint16_t *)video_memory+targetCursorLocation)=*((uint16_t *)video_memory+cursorLocation);										
c0206ea5:	8b 90 34 f0 ff ff    	mov    -0xfcc(%eax),%edx
c0206eab:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
c0206eaf:	01 c9                	add    %ecx,%ecx
c0206eb1:	01 ca                	add    %ecx,%edx
c0206eb3:	8b 88 34 f0 ff ff    	mov    -0xfcc(%eax),%ecx
c0206eb9:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
c0206ebd:	01 db                	add    %ebx,%ebx
c0206ebf:	01 d9                	add    %ebx,%ecx
c0206ec1:	0f b7 12             	movzwl (%edx),%edx
c0206ec4:	66 89 11             	mov    %dx,(%ecx)
		for(int i=0;i<80;i++){
c0206ec7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0206ecb:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c0206ecf:	7e 9d                	jle    c0206e6e <screen_uproll_once+0x23>
	for(int j=1;j<25;j++){
c0206ed1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206ed5:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0206ed9:	7e 8a                	jle    c0206e65 <screen_uproll_once+0x1a>
		}
	}
	for(int i=0;i<80;i++){
c0206edb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0206ee2:	eb 22                	jmp    c0206f06 <screen_uproll_once+0xbb>
        int location = 24*80+i;
c0206ee4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0206ee7:	81 c2 80 07 00 00    	add    $0x780,%edx
c0206eed:	89 55 e8             	mov    %edx,-0x18(%ebp)
        *((uint16_t *)video_memory+location)=(0x0F<<8)|'\0';
c0206ef0:	8b 90 34 f0 ff ff    	mov    -0xfcc(%eax),%edx
c0206ef6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0206ef9:	01 c9                	add    %ecx,%ecx
c0206efb:	01 ca                	add    %ecx,%edx
c0206efd:	66 c7 02 00 0f       	movw   $0xf00,(%edx)
	for(int i=0;i<80;i++){
c0206f02:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0206f06:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
c0206f0a:	7e d8                	jle    c0206ee4 <screen_uproll_once+0x99>
	}
	if(cursor_y!=0){
c0206f0c:	0f b6 90 a1 90 08 00 	movzbl 0x890a1(%eax),%edx
c0206f13:	84 d2                	test   %dl,%dl
c0206f15:	74 15                	je     c0206f2c <screen_uproll_once+0xe1>
		cursor_y--;
c0206f17:	0f b6 90 a1 90 08 00 	movzbl 0x890a1(%eax),%edx
c0206f1e:	83 ea 01             	sub    $0x1,%edx
c0206f21:	88 90 a1 90 08 00    	mov    %dl,0x890a1(%eax)
		move_cursor();
c0206f27:	e8 d3 fd ff ff       	call   c0206cff <move_cursor>
	}
}
c0206f2c:	90                   	nop
c0206f2d:	83 c4 24             	add    $0x24,%esp
c0206f30:	5b                   	pop    %ebx
c0206f31:	5d                   	pop    %ebp
c0206f32:	c3                   	ret    

c0206f33 <vga_putc>:
void vga_putc(char input,vga_color_t back,vga_color_t fore){
c0206f33:	55                   	push   %ebp
c0206f34:	89 e5                	mov    %esp,%ebp
c0206f36:	53                   	push   %ebx
c0206f37:	83 ec 24             	sub    $0x24,%esp
c0206f3a:	e8 c5 10 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206f3f:	81 c3 c1 20 00 00    	add    $0x20c1,%ebx
c0206f45:	8b 45 08             	mov    0x8(%ebp),%eax
c0206f48:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c0206f4b:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206f52:	0f b6 d0             	movzbl %al,%edx
c0206f55:	89 d0                	mov    %edx,%eax
c0206f57:	c1 e0 02             	shl    $0x2,%eax
c0206f5a:	01 d0                	add    %edx,%eax
c0206f5c:	c1 e0 04             	shl    $0x4,%eax
c0206f5f:	89 c2                	mov    %eax,%edx
c0206f61:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206f68:	0f b6 c0             	movzbl %al,%eax
c0206f6b:	01 d0                	add    %edx,%eax
c0206f6d:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	*((char *)video_memory+2*cursorLocation)=input;
c0206f71:	8b 83 34 f0 ff ff    	mov    -0xfcc(%ebx),%eax
c0206f77:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0206f7b:	01 d2                	add    %edx,%edx
c0206f7d:	01 c2                	add    %eax,%edx
c0206f7f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0206f83:	88 02                	mov    %al,(%edx)
	*((char *)video_memory+2*cursorLocation+1)=(back<<4)|(fore&0x0F);
c0206f85:	8b 45 0c             	mov    0xc(%ebp),%eax
c0206f88:	c1 e0 04             	shl    $0x4,%eax
c0206f8b:	89 c2                	mov    %eax,%edx
c0206f8d:	8b 45 10             	mov    0x10(%ebp),%eax
c0206f90:	83 e0 0f             	and    $0xf,%eax
c0206f93:	89 d1                	mov    %edx,%ecx
c0206f95:	09 c1                	or     %eax,%ecx
c0206f97:	8b 83 34 f0 ff ff    	mov    -0xfcc(%ebx),%eax
c0206f9d:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0206fa1:	01 d2                	add    %edx,%edx
c0206fa3:	83 c2 01             	add    $0x1,%edx
c0206fa6:	01 d0                	add    %edx,%eax
c0206fa8:	89 ca                	mov    %ecx,%edx
c0206faa:	88 10                	mov    %dl,(%eax)
	if(cursor_x==79){
c0206fac:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206fb3:	3c 4f                	cmp    $0x4f,%al
c0206fb5:	75 39                	jne    c0206ff0 <vga_putc+0xbd>
		if(cursor_y==24){
c0206fb7:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206fbe:	3c 18                	cmp    $0x18,%al
c0206fc0:	75 15                	jne    c0206fd7 <vga_putc+0xa4>
			screen_uproll_once();
c0206fc2:	e8 84 fe ff ff       	call   c0206e4b <screen_uproll_once>
			cursor_x=0;
c0206fc7:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
			cursor_y=24;
c0206fce:	c6 83 a1 90 08 00 18 	movb   $0x18,0x890a1(%ebx)
c0206fd5:	eb 29                	jmp    c0207000 <vga_putc+0xcd>
		}
		else{
			cursor_x=0;
c0206fd7:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
			cursor_y++;
c0206fde:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206fe5:	83 c0 01             	add    $0x1,%eax
c0206fe8:	88 83 a1 90 08 00    	mov    %al,0x890a1(%ebx)
c0206fee:	eb 10                	jmp    c0207000 <vga_putc+0xcd>
		}
	}
	else{
		cursor_x++;
c0206ff0:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206ff7:	83 c0 01             	add    $0x1,%eax
c0206ffa:	88 83 a0 90 08 00    	mov    %al,0x890a0(%ebx)
	}
	move_cursor();
c0207000:	e8 fa fc ff ff       	call   c0206cff <move_cursor>
}
c0207005:	90                   	nop
c0207006:	83 c4 24             	add    $0x24,%esp
c0207009:	5b                   	pop    %ebx
c020700a:	5d                   	pop    %ebp
c020700b:	c3                   	ret    

c020700c <kputc_color>:


void kputc_color(char input,vga_color_t back,vga_color_t fore){
c020700c:	55                   	push   %ebp
c020700d:	89 e5                	mov    %esp,%ebp
c020700f:	53                   	push   %ebx
c0207010:	83 ec 24             	sub    $0x24,%esp
c0207013:	e8 ec 0f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0207018:	81 c3 e8 1f 00 00    	add    $0x1fe8,%ebx
c020701e:	8b 45 08             	mov    0x8(%ebp),%eax
c0207021:	88 45 e4             	mov    %al,-0x1c(%ebp)
	switch (input)
c0207024:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0207028:	83 f8 09             	cmp    $0x9,%eax
c020702b:	74 07                	je     c0207034 <kputc_color+0x28>
c020702d:	83 f8 0a             	cmp    $0xa,%eax
c0207030:	74 33                	je     c0207065 <kputc_color+0x59>
c0207032:	eb 79                	jmp    c02070ad <kputc_color+0xa1>
	{
		case '\t':{
			for(int i=0;i<tab_length;i++)
c0207034:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020703b:	eb 17                	jmp    c0207054 <kputc_color+0x48>
				vga_putc('\0',back,fore);
c020703d:	83 ec 04             	sub    $0x4,%esp
c0207040:	ff 75 10             	pushl  0x10(%ebp)
c0207043:	ff 75 0c             	pushl  0xc(%ebp)
c0207046:	6a 00                	push   $0x0
c0207048:	e8 e6 fe ff ff       	call   c0206f33 <vga_putc>
c020704d:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<tab_length;i++)
c0207050:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0207054:	0f b6 83 30 f0 ff ff 	movzbl -0xfd0(%ebx),%eax
c020705b:	0f b6 c0             	movzbl %al,%eax
c020705e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0207061:	7c da                	jl     c020703d <kputc_color+0x31>
			break;
c0207063:	eb 5e                	jmp    c02070c3 <kputc_color+0xb7>
		}
		case '\n':{
			uint8_t temp_num = 80-cursor_x;
c0207065:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c020706c:	ba 50 00 00 00       	mov    $0x50,%edx
c0207071:	29 c2                	sub    %eax,%edx
c0207073:	89 d0                	mov    %edx,%eax
c0207075:	88 45 f3             	mov    %al,-0xd(%ebp)
			if(temp_num==0)
c0207078:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c020707c:	75 04                	jne    c0207082 <kputc_color+0x76>
				temp_num=80;
c020707e:	c6 45 f3 50          	movb   $0x50,-0xd(%ebp)
			for(int i=0;i<temp_num;i++)
c0207082:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0207089:	eb 17                	jmp    c02070a2 <kputc_color+0x96>
			vga_putc('\0',back,fore);
c020708b:	83 ec 04             	sub    $0x4,%esp
c020708e:	ff 75 10             	pushl  0x10(%ebp)
c0207091:	ff 75 0c             	pushl  0xc(%ebp)
c0207094:	6a 00                	push   $0x0
c0207096:	e8 98 fe ff ff       	call   c0206f33 <vga_putc>
c020709b:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<temp_num;i++)
c020709e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c02070a2:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c02070a6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c02070a9:	7c e0                	jl     c020708b <kputc_color+0x7f>
			break;
c02070ab:	eb 16                	jmp    c02070c3 <kputc_color+0xb7>
		}
		default:
			vga_putc(input,back,fore);	
c02070ad:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c02070b1:	83 ec 04             	sub    $0x4,%esp
c02070b4:	ff 75 10             	pushl  0x10(%ebp)
c02070b7:	ff 75 0c             	pushl  0xc(%ebp)
c02070ba:	50                   	push   %eax
c02070bb:	e8 73 fe ff ff       	call   c0206f33 <vga_putc>
c02070c0:	83 c4 10             	add    $0x10,%esp
	}
}
c02070c3:	90                   	nop
c02070c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02070c7:	c9                   	leave  
c02070c8:	c3                   	ret    

c02070c9 <kputc>:

void kputc(char input){
c02070c9:	55                   	push   %ebp
c02070ca:	89 e5                	mov    %esp,%ebp
c02070cc:	83 ec 18             	sub    $0x18,%esp
c02070cf:	e8 2c 0f 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02070d4:	05 2c 1f 00 00       	add    $0x1f2c,%eax
c02070d9:	8b 45 08             	mov    0x8(%ebp),%eax
c02070dc:	88 45 f4             	mov    %al,-0xc(%ebp)
	kputc_color(input,black,white);
c02070df:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c02070e3:	83 ec 04             	sub    $0x4,%esp
c02070e6:	6a 0f                	push   $0xf
c02070e8:	6a 00                	push   $0x0
c02070ea:	50                   	push   %eax
c02070eb:	e8 1c ff ff ff       	call   c020700c <kputc_color>
c02070f0:	83 c4 10             	add    $0x10,%esp
}
c02070f3:	90                   	nop
c02070f4:	c9                   	leave  
c02070f5:	c3                   	ret    

c02070f6 <kputs_color>:

void kputs_color(char * input_str,vga_color_t back,vga_color_t fore){
c02070f6:	55                   	push   %ebp
c02070f7:	89 e5                	mov    %esp,%ebp
c02070f9:	83 ec 18             	sub    $0x18,%esp
c02070fc:	e8 ff 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207101:	05 ff 1e 00 00       	add    $0x1eff,%eax
	char * probe=input_str;
c0207106:	8b 45 08             	mov    0x8(%ebp),%eax
c0207109:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(*probe!='\0')
c020710c:	eb 21                	jmp    c020712f <kputs_color+0x39>
		kputc_color(*probe++,back,fore);
c020710e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207111:	8d 50 01             	lea    0x1(%eax),%edx
c0207114:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0207117:	0f b6 00             	movzbl (%eax),%eax
c020711a:	0f be c0             	movsbl %al,%eax
c020711d:	83 ec 04             	sub    $0x4,%esp
c0207120:	ff 75 10             	pushl  0x10(%ebp)
c0207123:	ff 75 0c             	pushl  0xc(%ebp)
c0207126:	50                   	push   %eax
c0207127:	e8 e0 fe ff ff       	call   c020700c <kputc_color>
c020712c:	83 c4 10             	add    $0x10,%esp
	while(*probe!='\0')
c020712f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207132:	0f b6 00             	movzbl (%eax),%eax
c0207135:	84 c0                	test   %al,%al
c0207137:	75 d5                	jne    c020710e <kputs_color+0x18>
}
c0207139:	90                   	nop
c020713a:	c9                   	leave  
c020713b:	c3                   	ret    

c020713c <kputs>:

void kputs(char *input_str){
c020713c:	55                   	push   %ebp
c020713d:	89 e5                	mov    %esp,%ebp
c020713f:	83 ec 08             	sub    $0x8,%esp
c0207142:	e8 b9 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207147:	05 b9 1e 00 00       	add    $0x1eb9,%eax
	kputs_color(input_str,black,white);
c020714c:	83 ec 04             	sub    $0x4,%esp
c020714f:	6a 0f                	push   $0xf
c0207151:	6a 00                	push   $0x0
c0207153:	ff 75 08             	pushl  0x8(%ebp)
c0207156:	e8 9b ff ff ff       	call   c02070f6 <kputs_color>
c020715b:	83 c4 10             	add    $0x10,%esp
}
c020715e:	90                   	nop
c020715f:	c9                   	leave  
c0207160:	c3                   	ret    

c0207161 <vga_init>:

void vga_init(){
c0207161:	55                   	push   %ebp
c0207162:	89 e5                	mov    %esp,%ebp
c0207164:	83 ec 08             	sub    $0x8,%esp
c0207167:	e8 94 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020716c:	05 94 1e 00 00       	add    $0x1e94,%eax
	clear_screen();
c0207171:	e8 65 fc ff ff       	call   c0206ddb <clear_screen>
}
c0207176:	90                   	nop
c0207177:	c9                   	leave  
c0207178:	c3                   	ret    

c0207179 <vga_test_clear_last_row>:

void vga_test_clear_last_row(){
c0207179:	55                   	push   %ebp
c020717a:	89 e5                	mov    %esp,%ebp
c020717c:	e8 7f 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207181:	05 7f 1e 00 00       	add    $0x1e7f,%eax

}
c0207186:	90                   	nop
c0207187:	5d                   	pop    %ebp
c0207188:	c3                   	ret    

c0207189 <vga_basic_test>:

void vga_basic_test(){
c0207189:	55                   	push   %ebp
c020718a:	89 e5                	mov    %esp,%ebp
c020718c:	53                   	push   %ebx
c020718d:	83 ec 14             	sub    $0x14,%esp
c0207190:	e8 6f 0e 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0207195:	81 c3 6b 1e 00 00    	add    $0x1e6b,%ebx
    for(int i = 0;i<10;i++){
c020719b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02071a2:	eb 16                	jmp    c02071ba <vga_basic_test+0x31>
        kputs("A\n");
c02071a4:	83 ec 0c             	sub    $0xc,%esp
c02071a7:	8d 83 ad 06 00 00    	lea    0x6ad(%ebx),%eax
c02071ad:	50                   	push   %eax
c02071ae:	e8 89 ff ff ff       	call   c020713c <kputs>
c02071b3:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<10;i++){
c02071b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02071ba:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c02071be:	7e e4                	jle    c02071a4 <vga_basic_test+0x1b>
    }
    kputs("MBCDEFG\n");
c02071c0:	83 ec 0c             	sub    $0xc,%esp
c02071c3:	8d 83 b0 06 00 00    	lea    0x6b0(%ebx),%eax
c02071c9:	50                   	push   %eax
c02071ca:	e8 6d ff ff ff       	call   c020713c <kputs>
c02071cf:	83 c4 10             	add    $0x10,%esp
    kputs("QWERTYU\n");
c02071d2:	83 ec 0c             	sub    $0xc,%esp
c02071d5:	8d 83 b9 06 00 00    	lea    0x6b9(%ebx),%eax
c02071db:	50                   	push   %eax
c02071dc:	e8 5b ff ff ff       	call   c020713c <kputs>
c02071e1:	83 c4 10             	add    $0x10,%esp
    screen_uproll_once();
c02071e4:	e8 62 fc ff ff       	call   c0206e4b <screen_uproll_once>
    while(1);
c02071e9:	eb fe                	jmp    c02071e9 <vga_basic_test+0x60>

c02071eb <outb>:
#include "port.h"
// 端口写一个字节
inline void outb(uint16_t port, uint8_t value)
{
c02071eb:	55                   	push   %ebp
c02071ec:	89 e5                	mov    %esp,%ebp
c02071ee:	83 ec 08             	sub    $0x8,%esp
c02071f1:	e8 0a 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02071f6:	05 0a 1e 00 00       	add    $0x1e0a,%eax
c02071fb:	8b 55 08             	mov    0x8(%ebp),%edx
c02071fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207201:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0207205:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
c0207208:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c020720c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0207210:	ee                   	out    %al,(%dx)
}
c0207211:	90                   	nop
c0207212:	c9                   	leave  
c0207213:	c3                   	ret    

c0207214 <inb>:

// 端口读一个字节
inline uint8_t inb(uint16_t port)
{
c0207214:	55                   	push   %ebp
c0207215:	89 e5                	mov    %esp,%ebp
c0207217:	83 ec 14             	sub    $0x14,%esp
c020721a:	e8 e1 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020721f:	05 e1 1d 00 00       	add    $0x1de1,%eax
c0207224:	8b 45 08             	mov    0x8(%ebp),%eax
c0207227:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint8_t ret;

    asm volatile("inb %1, %0" : "=a" (ret) : "dN" (port));
c020722b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c020722f:	89 c2                	mov    %eax,%edx
c0207231:	ec                   	in     (%dx),%al
c0207232:	88 45 ff             	mov    %al,-0x1(%ebp)

    return ret;
c0207235:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0207239:	c9                   	leave  
c020723a:	c3                   	ret    

c020723b <inw>:

// 端口读一个字
inline uint16_t inw(uint16_t port)
{
c020723b:	55                   	push   %ebp
c020723c:	89 e5                	mov    %esp,%ebp
c020723e:	83 ec 14             	sub    $0x14,%esp
c0207241:	e8 ba 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207246:	05 ba 1d 00 00       	add    $0x1dba,%eax
c020724b:	8b 45 08             	mov    0x8(%ebp),%eax
c020724e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint16_t ret;

    asm volatile ("inw %1, %0" : "=a" (ret) : "dN" (port));
c0207252:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0207256:	89 c2                	mov    %eax,%edx
c0207258:	66 ed                	in     (%dx),%ax
c020725a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    return ret;
c020725e:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0207262:	c9                   	leave  
c0207263:	c3                   	ret    

c0207264 <print_debug_1>:
#include "printk.h"
#include "types.h"

void print_debug_1(uint32_t val){
c0207264:	55                   	push   %ebp
c0207265:	89 e5                	mov    %esp,%ebp
c0207267:	53                   	push   %ebx
c0207268:	83 ec 04             	sub    $0x4,%esp
c020726b:	e8 90 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207270:	05 90 1d 00 00       	add    $0x1d90,%eax
    printk("debug1:0x%h\n",val);
c0207275:	83 ec 08             	sub    $0x8,%esp
c0207278:	ff 75 08             	pushl  0x8(%ebp)
c020727b:	8d 90 c2 06 00 00    	lea    0x6c2(%eax),%edx
c0207281:	52                   	push   %edx
c0207282:	89 c3                	mov    %eax,%ebx
c0207284:	e8 ab 00 00 00       	call   c0207334 <printk>
c0207289:	83 c4 10             	add    $0x10,%esp
c020728c:	90                   	nop
c020728d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0207290:	c9                   	leave  
c0207291:	c3                   	ret    

c0207292 <insert_str>:
#include "vga_basic.h"
#include "vargs.h"


void insert_str(char *inserted_str,char *inserting_str,uint32_t offset)  //插入辅助函数
{
c0207292:	55                   	push   %ebp
c0207293:	89 e5                	mov    %esp,%ebp
c0207295:	57                   	push   %edi
c0207296:	53                   	push   %ebx
c0207297:	83 ec 70             	sub    $0x70,%esp
c020729a:	e8 65 0d 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020729f:	81 c3 61 1d 00 00    	add    $0x1d61,%ebx
	char m[100]={0};
c02072a5:	8d 55 90             	lea    -0x70(%ebp),%edx
c02072a8:	b8 00 00 00 00       	mov    $0x0,%eax
c02072ad:	b9 19 00 00 00       	mov    $0x19,%ecx
c02072b2:	89 d7                	mov    %edx,%edi
c02072b4:	f3 ab                	rep stos %eax,%es:(%edi)
	char *afterInsetedPositionStr=m;
c02072b6:	8d 45 90             	lea    -0x70(%ebp),%eax
c02072b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	strcpy(afterInsetedPositionStr,inserted_str+offset+2);
c02072bc:	8b 45 10             	mov    0x10(%ebp),%eax
c02072bf:	8d 50 02             	lea    0x2(%eax),%edx
c02072c2:	8b 45 08             	mov    0x8(%ebp),%eax
c02072c5:	01 d0                	add    %edx,%eax
c02072c7:	83 ec 08             	sub    $0x8,%esp
c02072ca:	50                   	push   %eax
c02072cb:	ff 75 f4             	pushl  -0xc(%ebp)
c02072ce:	e8 11 08 00 00       	call   c0207ae4 <strcpy>
c02072d3:	83 c4 10             	add    $0x10,%esp
	memcpy(inserted_str+offset,inserting_str,strlen(inserting_str));
c02072d6:	83 ec 0c             	sub    $0xc,%esp
c02072d9:	ff 75 0c             	pushl  0xc(%ebp)
c02072dc:	e8 d2 07 00 00       	call   c0207ab3 <strlen>
c02072e1:	83 c4 10             	add    $0x10,%esp
c02072e4:	89 c1                	mov    %eax,%ecx
c02072e6:	8b 55 08             	mov    0x8(%ebp),%edx
c02072e9:	8b 45 10             	mov    0x10(%ebp),%eax
c02072ec:	01 d0                	add    %edx,%eax
c02072ee:	83 ec 04             	sub    $0x4,%esp
c02072f1:	51                   	push   %ecx
c02072f2:	ff 75 0c             	pushl  0xc(%ebp)
c02072f5:	50                   	push   %eax
c02072f6:	e8 cd 06 00 00       	call   c02079c8 <memcpy>
c02072fb:	83 c4 10             	add    $0x10,%esp
	*(inserted_str+offset+strlen(inserting_str))='\0';
c02072fe:	83 ec 0c             	sub    $0xc,%esp
c0207301:	ff 75 0c             	pushl  0xc(%ebp)
c0207304:	e8 aa 07 00 00       	call   c0207ab3 <strlen>
c0207309:	83 c4 10             	add    $0x10,%esp
c020730c:	89 c2                	mov    %eax,%edx
c020730e:	8b 45 10             	mov    0x10(%ebp),%eax
c0207311:	01 c2                	add    %eax,%edx
c0207313:	8b 45 08             	mov    0x8(%ebp),%eax
c0207316:	01 d0                	add    %edx,%eax
c0207318:	c6 00 00             	movb   $0x0,(%eax)
	strcat(inserted_str,afterInsetedPositionStr);
c020731b:	83 ec 08             	sub    $0x8,%esp
c020731e:	ff 75 f4             	pushl  -0xc(%ebp)
c0207321:	ff 75 08             	pushl  0x8(%ebp)
c0207324:	e8 01 08 00 00       	call   c0207b2a <strcat>
c0207329:	83 c4 10             	add    $0x10,%esp
	//memcpy(*(inserted_str+offset+1+strlen(inserting_str)),afterInsetedPositionStr,strlen(afterInsetedPositionStr));
	return inserted_str;
c020732c:	90                   	nop
}
c020732d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0207330:	5b                   	pop    %ebx
c0207331:	5f                   	pop    %edi
c0207332:	5d                   	pop    %ebp
c0207333:	c3                   	ret    

c0207334 <printk>:

void printk(char *input_str,...)
{	
c0207334:	55                   	push   %ebp
c0207335:	89 e5                	mov    %esp,%ebp
c0207337:	53                   	push   %ebx
c0207338:	83 ec 34             	sub    $0x34,%esp
c020733b:	e8 c4 0c 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0207340:	81 c3 c0 1c 00 00    	add    $0x1cc0,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0207346:	8d 83 c0 90 08 00    	lea    0x890c0(%ebx),%eax
c020734c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c020734f:	83 ec 08             	sub    $0x8,%esp
c0207352:	ff 75 08             	pushl  0x8(%ebp)
c0207355:	ff 75 f0             	pushl  -0x10(%ebp)
c0207358:	e8 87 07 00 00       	call   c0207ae4 <strcpy>
c020735d:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0207360:	8d 45 0c             	lea    0xc(%ebp),%eax
c0207363:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0207366:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c020736d:	e9 9e 01 00 00       	jmp    c0207510 <printk+0x1dc>
	{
		char *charptr=output_str+offset;
c0207372:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207375:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0207378:	01 d0                	add    %edx,%eax
c020737a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c020737d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207380:	0f b6 00             	movzbl (%eax),%eax
c0207383:	3c 25                	cmp    $0x25,%al
c0207385:	0f 85 81 01 00 00    	jne    c020750c <printk+0x1d8>
		{
			if (*(charptr+1)=='s')
c020738b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020738e:	83 c0 01             	add    $0x1,%eax
c0207391:	0f b6 00             	movzbl (%eax),%eax
c0207394:	3c 73                	cmp    $0x73,%al
c0207396:	75 43                	jne    c02073db <printk+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c0207398:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020739b:	8d 50 04             	lea    0x4(%eax),%edx
c020739e:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02073a1:	8b 00                	mov    (%eax),%eax
c02073a3:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c02073a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02073a9:	83 ec 04             	sub    $0x4,%esp
c02073ac:	50                   	push   %eax
c02073ad:	ff 75 d0             	pushl  -0x30(%ebp)
c02073b0:	ff 75 f0             	pushl  -0x10(%ebp)
c02073b3:	e8 da fe ff ff       	call   c0207292 <insert_str>
c02073b8:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c02073bb:	83 ec 0c             	sub    $0xc,%esp
c02073be:	ff 75 d0             	pushl  -0x30(%ebp)
c02073c1:	e8 ed 06 00 00       	call   c0207ab3 <strlen>
c02073c6:	83 c4 10             	add    $0x10,%esp
c02073c9:	89 c2                	mov    %eax,%edx
c02073cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02073ce:	01 d0                	add    %edx,%eax
c02073d0:	83 e8 01             	sub    $0x1,%eax
c02073d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02073d6:	e9 31 01 00 00       	jmp    c020750c <printk+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c02073db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02073de:	83 c0 01             	add    $0x1,%eax
c02073e1:	0f b6 00             	movzbl (%eax),%eax
c02073e4:	3c 64                	cmp    $0x64,%al
c02073e6:	75 55                	jne    c020743d <printk+0x109>
			{
				int arg_int=va_arg(ptr,int);
c02073e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02073eb:	8d 50 04             	lea    0x4(%eax),%edx
c02073ee:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02073f1:	8b 00                	mov    (%eax),%eax
c02073f3:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c02073f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
c02073f9:	83 ec 0c             	sub    $0xc,%esp
c02073fc:	50                   	push   %eax
c02073fd:	e8 61 07 00 00       	call   c0207b63 <uintTostring>
c0207402:	83 c4 10             	add    $0x10,%esp
c0207405:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c0207408:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020740b:	83 ec 04             	sub    $0x4,%esp
c020740e:	50                   	push   %eax
c020740f:	ff 75 d4             	pushl  -0x2c(%ebp)
c0207412:	ff 75 f0             	pushl  -0x10(%ebp)
c0207415:	e8 78 fe ff ff       	call   c0207292 <insert_str>
c020741a:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c020741d:	83 ec 0c             	sub    $0xc,%esp
c0207420:	ff 75 d4             	pushl  -0x2c(%ebp)
c0207423:	e8 8b 06 00 00       	call   c0207ab3 <strlen>
c0207428:	83 c4 10             	add    $0x10,%esp
c020742b:	89 c2                	mov    %eax,%edx
c020742d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207430:	01 d0                	add    %edx,%eax
c0207432:	83 e8 01             	sub    $0x1,%eax
c0207435:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0207438:	e9 cf 00 00 00       	jmp    c020750c <printk+0x1d8>
			}
			else if(*(charptr+1)=='c')
c020743d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207440:	83 c0 01             	add    $0x1,%eax
c0207443:	0f b6 00             	movzbl (%eax),%eax
c0207446:	3c 63                	cmp    $0x63,%al
c0207448:	0f 84 be 00 00 00    	je     c020750c <printk+0x1d8>
			{
				;
			}
			else if(*(charptr+1)=='H')
c020744e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207451:	83 c0 01             	add    $0x1,%eax
c0207454:	0f b6 00             	movzbl (%eax),%eax
c0207457:	3c 48                	cmp    $0x48,%al
c0207459:	75 53                	jne    c02074ae <printk+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c020745b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020745e:	8d 50 04             	lea    0x4(%eax),%edx
c0207461:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207464:	8b 00                	mov    (%eax),%eax
c0207466:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c0207469:	83 ec 08             	sub    $0x8,%esp
c020746c:	6a 01                	push   $0x1
c020746e:	ff 75 e0             	pushl  -0x20(%ebp)
c0207471:	e8 2c 04 00 00       	call   c02078a2 <num2hexstr>
c0207476:	83 c4 10             	add    $0x10,%esp
c0207479:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c020747c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020747f:	83 ec 04             	sub    $0x4,%esp
c0207482:	50                   	push   %eax
c0207483:	ff 75 dc             	pushl  -0x24(%ebp)
c0207486:	ff 75 f0             	pushl  -0x10(%ebp)
c0207489:	e8 04 fe ff ff       	call   c0207292 <insert_str>
c020748e:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0207491:	83 ec 0c             	sub    $0xc,%esp
c0207494:	ff 75 dc             	pushl  -0x24(%ebp)
c0207497:	e8 17 06 00 00       	call   c0207ab3 <strlen>
c020749c:	83 c4 10             	add    $0x10,%esp
c020749f:	89 c2                	mov    %eax,%edx
c02074a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02074a4:	01 d0                	add    %edx,%eax
c02074a6:	83 e8 01             	sub    $0x1,%eax
c02074a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02074ac:	eb 5e                	jmp    c020750c <printk+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c02074ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02074b1:	83 c0 01             	add    $0x1,%eax
c02074b4:	0f b6 00             	movzbl (%eax),%eax
c02074b7:	3c 68                	cmp    $0x68,%al
c02074b9:	75 51                	jne    c020750c <printk+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c02074bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02074be:	8d 50 04             	lea    0x4(%eax),%edx
c02074c1:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02074c4:	8b 00                	mov    (%eax),%eax
c02074c6:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c02074c9:	83 ec 08             	sub    $0x8,%esp
c02074cc:	6a 00                	push   $0x0
c02074ce:	ff 75 e8             	pushl  -0x18(%ebp)
c02074d1:	e8 cc 03 00 00       	call   c02078a2 <num2hexstr>
c02074d6:	83 c4 10             	add    $0x10,%esp
c02074d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c02074dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02074df:	83 ec 04             	sub    $0x4,%esp
c02074e2:	50                   	push   %eax
c02074e3:	ff 75 e4             	pushl  -0x1c(%ebp)
c02074e6:	ff 75 f0             	pushl  -0x10(%ebp)
c02074e9:	e8 a4 fd ff ff       	call   c0207292 <insert_str>
c02074ee:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c02074f1:	83 ec 0c             	sub    $0xc,%esp
c02074f4:	ff 75 e4             	pushl  -0x1c(%ebp)
c02074f7:	e8 b7 05 00 00       	call   c0207ab3 <strlen>
c02074fc:	83 c4 10             	add    $0x10,%esp
c02074ff:	89 c2                	mov    %eax,%edx
c0207501:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207504:	01 d0                	add    %edx,%eax
c0207506:	83 e8 01             	sub    $0x1,%eax
c0207509:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c020750c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0207510:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207513:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0207516:	01 d0                	add    %edx,%eax
c0207518:	0f b6 00             	movzbl (%eax),%eax
c020751b:	84 c0                	test   %al,%al
c020751d:	0f 85 4f fe ff ff    	jne    c0207372 <printk+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs(output_str);
c0207523:	83 ec 0c             	sub    $0xc,%esp
c0207526:	ff 75 f0             	pushl  -0x10(%ebp)
c0207529:	e8 0e fc ff ff       	call   c020713c <kputs>
c020752e:	83 c4 10             	add    $0x10,%esp
}
c0207531:	90                   	nop
c0207532:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0207535:	c9                   	leave  
c0207536:	c3                   	ret    

c0207537 <printbasic>:


//输入uint32_t或者char*  使用%d或者%s
//wdnmd 这个可变参有问题！！
void printbasic(char *format_str,char *m)
{
c0207537:	55                   	push   %ebp
c0207538:	89 e5                	mov    %esp,%ebp
c020753a:	83 ec 18             	sub    $0x18,%esp
c020753d:	e8 be 0a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207542:	05 be 1a 00 00       	add    $0x1abe,%eax
	//va_list ptr_start=NULL;
	char *formatStr=format_str;
c0207547:	8b 45 08             	mov    0x8(%ebp),%eax
c020754a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//va_start(ptr_start,format_str);
	//kputs_color(va_arg(ptr_start,char *), rc_black, rc_green);	
	int i=0;
c020754d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0207554:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0207557:	89 45 ec             	mov    %eax,-0x14(%ebp)
c020755a:	eb 3a                	jmp    c0207596 <printbasic+0x5f>
	{
		if (*(head+i)=='%'){
c020755c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020755f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207562:	01 d0                	add    %edx,%eax
c0207564:	0f b6 00             	movzbl (%eax),%eax
c0207567:	3c 25                	cmp    $0x25,%al
c0207569:	75 27                	jne    c0207592 <printbasic+0x5b>
			if(*(head+i+1)=='s')
c020756b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020756e:	8d 50 01             	lea    0x1(%eax),%edx
c0207571:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207574:	01 d0                	add    %edx,%eax
c0207576:	0f b6 00             	movzbl (%eax),%eax
c0207579:	3c 73                	cmp    $0x73,%al
c020757b:	75 15                	jne    c0207592 <printbasic+0x5b>
			{
				//char *str_head=va_arg(&ptr_start,char*);
				insert_str(format_str,m,i);
c020757d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207580:	83 ec 04             	sub    $0x4,%esp
c0207583:	50                   	push   %eax
c0207584:	ff 75 0c             	pushl  0xc(%ebp)
c0207587:	ff 75 08             	pushl  0x8(%ebp)
c020758a:	e8 03 fd ff ff       	call   c0207292 <insert_str>
c020758f:	83 c4 10             	add    $0x10,%esp
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0207592:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0207596:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207599:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020759c:	01 d0                	add    %edx,%eax
c020759e:	0f b6 00             	movzbl (%eax),%eax
c02075a1:	84 c0                	test   %al,%al
c02075a3:	75 b7                	jne    c020755c <printbasic+0x25>
			else;
		}
	}
	//kputs_color(formatStr, black, white);
	
}
c02075a5:	90                   	nop
c02075a6:	c9                   	leave  
c02075a7:	c3                   	ret    

c02075a8 <printk_color>:



void printk_color(char *input_str,vga_color_t back,vga_color_t fore,...)
{
c02075a8:	55                   	push   %ebp
c02075a9:	89 e5                	mov    %esp,%ebp
c02075ab:	53                   	push   %ebx
c02075ac:	83 ec 34             	sub    $0x34,%esp
c02075af:	e8 50 0a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02075b4:	81 c3 4c 1a 00 00    	add    $0x1a4c,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c02075ba:	8d 83 40 91 08 00    	lea    0x89140(%ebx),%eax
c02075c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c02075c3:	83 ec 08             	sub    $0x8,%esp
c02075c6:	ff 75 08             	pushl  0x8(%ebp)
c02075c9:	ff 75 f0             	pushl  -0x10(%ebp)
c02075cc:	e8 13 05 00 00       	call   c0207ae4 <strcpy>
c02075d1:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c02075d4:	8d 45 14             	lea    0x14(%ebp),%eax
c02075d7:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c02075da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c02075e1:	e9 9e 01 00 00       	jmp    c0207784 <printk_color+0x1dc>
	{
		char *charptr=output_str+offset;
c02075e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02075e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02075ec:	01 d0                	add    %edx,%eax
c02075ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c02075f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02075f4:	0f b6 00             	movzbl (%eax),%eax
c02075f7:	3c 25                	cmp    $0x25,%al
c02075f9:	0f 85 81 01 00 00    	jne    c0207780 <printk_color+0x1d8>
		{
			if (*(charptr+1)=='s')
c02075ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207602:	83 c0 01             	add    $0x1,%eax
c0207605:	0f b6 00             	movzbl (%eax),%eax
c0207608:	3c 73                	cmp    $0x73,%al
c020760a:	75 43                	jne    c020764f <printk_color+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c020760c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020760f:	8d 50 04             	lea    0x4(%eax),%edx
c0207612:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207615:	8b 00                	mov    (%eax),%eax
c0207617:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c020761a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020761d:	83 ec 04             	sub    $0x4,%esp
c0207620:	50                   	push   %eax
c0207621:	ff 75 d0             	pushl  -0x30(%ebp)
c0207624:	ff 75 f0             	pushl  -0x10(%ebp)
c0207627:	e8 66 fc ff ff       	call   c0207292 <insert_str>
c020762c:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c020762f:	83 ec 0c             	sub    $0xc,%esp
c0207632:	ff 75 d0             	pushl  -0x30(%ebp)
c0207635:	e8 79 04 00 00       	call   c0207ab3 <strlen>
c020763a:	83 c4 10             	add    $0x10,%esp
c020763d:	89 c2                	mov    %eax,%edx
c020763f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207642:	01 d0                	add    %edx,%eax
c0207644:	83 e8 01             	sub    $0x1,%eax
c0207647:	89 45 f4             	mov    %eax,-0xc(%ebp)
c020764a:	e9 31 01 00 00       	jmp    c0207780 <printk_color+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c020764f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207652:	83 c0 01             	add    $0x1,%eax
c0207655:	0f b6 00             	movzbl (%eax),%eax
c0207658:	3c 64                	cmp    $0x64,%al
c020765a:	75 55                	jne    c02076b1 <printk_color+0x109>
			{
				int arg_int=va_arg(ptr,int);
c020765c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020765f:	8d 50 04             	lea    0x4(%eax),%edx
c0207662:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207665:	8b 00                	mov    (%eax),%eax
c0207667:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c020766a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020766d:	83 ec 0c             	sub    $0xc,%esp
c0207670:	50                   	push   %eax
c0207671:	e8 ed 04 00 00       	call   c0207b63 <uintTostring>
c0207676:	83 c4 10             	add    $0x10,%esp
c0207679:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c020767c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020767f:	83 ec 04             	sub    $0x4,%esp
c0207682:	50                   	push   %eax
c0207683:	ff 75 d4             	pushl  -0x2c(%ebp)
c0207686:	ff 75 f0             	pushl  -0x10(%ebp)
c0207689:	e8 04 fc ff ff       	call   c0207292 <insert_str>
c020768e:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c0207691:	83 ec 0c             	sub    $0xc,%esp
c0207694:	ff 75 d4             	pushl  -0x2c(%ebp)
c0207697:	e8 17 04 00 00       	call   c0207ab3 <strlen>
c020769c:	83 c4 10             	add    $0x10,%esp
c020769f:	89 c2                	mov    %eax,%edx
c02076a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02076a4:	01 d0                	add    %edx,%eax
c02076a6:	83 e8 01             	sub    $0x1,%eax
c02076a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02076ac:	e9 cf 00 00 00       	jmp    c0207780 <printk_color+0x1d8>
			}
			else if(*(charptr+1)=='c')
c02076b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02076b4:	83 c0 01             	add    $0x1,%eax
c02076b7:	0f b6 00             	movzbl (%eax),%eax
c02076ba:	3c 63                	cmp    $0x63,%al
c02076bc:	0f 84 be 00 00 00    	je     c0207780 <printk_color+0x1d8>
			{
			
			}
			else if(*(charptr+1)=='H')
c02076c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02076c5:	83 c0 01             	add    $0x1,%eax
c02076c8:	0f b6 00             	movzbl (%eax),%eax
c02076cb:	3c 48                	cmp    $0x48,%al
c02076cd:	75 53                	jne    c0207722 <printk_color+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c02076cf:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02076d2:	8d 50 04             	lea    0x4(%eax),%edx
c02076d5:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02076d8:	8b 00                	mov    (%eax),%eax
c02076da:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c02076dd:	83 ec 08             	sub    $0x8,%esp
c02076e0:	6a 01                	push   $0x1
c02076e2:	ff 75 e0             	pushl  -0x20(%ebp)
c02076e5:	e8 b8 01 00 00       	call   c02078a2 <num2hexstr>
c02076ea:	83 c4 10             	add    $0x10,%esp
c02076ed:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c02076f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02076f3:	83 ec 04             	sub    $0x4,%esp
c02076f6:	50                   	push   %eax
c02076f7:	ff 75 dc             	pushl  -0x24(%ebp)
c02076fa:	ff 75 f0             	pushl  -0x10(%ebp)
c02076fd:	e8 90 fb ff ff       	call   c0207292 <insert_str>
c0207702:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0207705:	83 ec 0c             	sub    $0xc,%esp
c0207708:	ff 75 dc             	pushl  -0x24(%ebp)
c020770b:	e8 a3 03 00 00       	call   c0207ab3 <strlen>
c0207710:	83 c4 10             	add    $0x10,%esp
c0207713:	89 c2                	mov    %eax,%edx
c0207715:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207718:	01 d0                	add    %edx,%eax
c020771a:	83 e8 01             	sub    $0x1,%eax
c020771d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0207720:	eb 5e                	jmp    c0207780 <printk_color+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c0207722:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207725:	83 c0 01             	add    $0x1,%eax
c0207728:	0f b6 00             	movzbl (%eax),%eax
c020772b:	3c 68                	cmp    $0x68,%al
c020772d:	75 51                	jne    c0207780 <printk_color+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c020772f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0207732:	8d 50 04             	lea    0x4(%eax),%edx
c0207735:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207738:	8b 00                	mov    (%eax),%eax
c020773a:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c020773d:	83 ec 08             	sub    $0x8,%esp
c0207740:	6a 00                	push   $0x0
c0207742:	ff 75 e8             	pushl  -0x18(%ebp)
c0207745:	e8 58 01 00 00       	call   c02078a2 <num2hexstr>
c020774a:	83 c4 10             	add    $0x10,%esp
c020774d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0207750:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207753:	83 ec 04             	sub    $0x4,%esp
c0207756:	50                   	push   %eax
c0207757:	ff 75 e4             	pushl  -0x1c(%ebp)
c020775a:	ff 75 f0             	pushl  -0x10(%ebp)
c020775d:	e8 30 fb ff ff       	call   c0207292 <insert_str>
c0207762:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0207765:	83 ec 0c             	sub    $0xc,%esp
c0207768:	ff 75 e4             	pushl  -0x1c(%ebp)
c020776b:	e8 43 03 00 00       	call   c0207ab3 <strlen>
c0207770:	83 c4 10             	add    $0x10,%esp
c0207773:	89 c2                	mov    %eax,%edx
c0207775:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207778:	01 d0                	add    %edx,%eax
c020777a:	83 e8 01             	sub    $0x1,%eax
c020777d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0207780:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0207784:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207787:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020778a:	01 d0                	add    %edx,%eax
c020778c:	0f b6 00             	movzbl (%eax),%eax
c020778f:	84 c0                	test   %al,%al
c0207791:	0f 85 4f fe ff ff    	jne    c02075e6 <printk_color+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs_color(output_str,back,fore);
c0207797:	83 ec 04             	sub    $0x4,%esp
c020779a:	ff 75 10             	pushl  0x10(%ebp)
c020779d:	ff 75 0c             	pushl  0xc(%ebp)
c02077a0:	ff 75 f0             	pushl  -0x10(%ebp)
c02077a3:	e8 4e f9 ff ff       	call   c02070f6 <kputs_color>
c02077a8:	83 c4 10             	add    $0x10,%esp
}
c02077ab:	90                   	nop
c02077ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02077af:	c9                   	leave  
c02077b0:	c3                   	ret    

c02077b1 <printkDebug>:

void printkDebug(){
c02077b1:	55                   	push   %ebp
c02077b2:	89 e5                	mov    %esp,%ebp
c02077b4:	53                   	push   %ebx
c02077b5:	83 ec 04             	sub    $0x4,%esp
c02077b8:	e8 47 08 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02077bd:	81 c3 43 18 00 00    	add    $0x1843,%ebx
	printk("wkawda----");
c02077c3:	83 ec 0c             	sub    $0xc,%esp
c02077c6:	8d 83 cf 06 00 00    	lea    0x6cf(%ebx),%eax
c02077cc:	50                   	push   %eax
c02077cd:	e8 62 fb ff ff       	call   c0207334 <printk>
c02077d2:	83 c4 10             	add    $0x10,%esp
	printk_color("wkdaowd",black,white);
c02077d5:	83 ec 04             	sub    $0x4,%esp
c02077d8:	6a 0f                	push   $0xf
c02077da:	6a 00                	push   $0x0
c02077dc:	8d 83 da 06 00 00    	lea    0x6da(%ebx),%eax
c02077e2:	50                   	push   %eax
c02077e3:	e8 c0 fd ff ff       	call   c02075a8 <printk_color>
c02077e8:	83 c4 10             	add    $0x10,%esp
c02077eb:	90                   	nop
c02077ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02077ef:	c9                   	leave  
c02077f0:	c3                   	ret    

c02077f1 <func>:
#include "string.h"

//进制转换的辅助函数
static int func(char *s,int n,uint32_t i)          //n表示输入的数 i表示转化的进制
{
c02077f1:	55                   	push   %ebp
c02077f2:	89 e5                	mov    %esp,%ebp
c02077f4:	83 ec 28             	sub    $0x28,%esp
c02077f7:	e8 04 08 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02077fc:	05 04 18 00 00       	add    $0x1804,%eax
    char bit[]={"0123456789ABCDEF"};
c0207801:	c7 45 e3 30 31 32 33 	movl   $0x33323130,-0x1d(%ebp)
c0207808:	c7 45 e7 34 35 36 37 	movl   $0x37363534,-0x19(%ebp)
c020780f:	c7 45 eb 38 39 41 42 	movl   $0x42413938,-0x15(%ebp)
c0207816:	c7 45 ef 43 44 45 46 	movl   $0x46454443,-0x11(%ebp)
c020781d:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int len;
    if(n==0)
c0207821:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0207825:	75 1c                	jne    c0207843 <func+0x52>
    {
        strcpy(s,"");
c0207827:	83 ec 08             	sub    $0x8,%esp
c020782a:	8d 80 e2 06 00 00    	lea    0x6e2(%eax),%eax
c0207830:	50                   	push   %eax
c0207831:	ff 75 08             	pushl  0x8(%ebp)
c0207834:	e8 ab 02 00 00       	call   c0207ae4 <strcpy>
c0207839:	83 c4 10             	add    $0x10,%esp
        return 0;
c020783c:	b8 00 00 00 00       	mov    $0x0,%eax
c0207841:	eb 5d                	jmp    c02078a0 <func+0xaf>
    }
    func(s,n/i,i);
c0207843:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207846:	ba 00 00 00 00       	mov    $0x0,%edx
c020784b:	f7 75 10             	divl   0x10(%ebp)
c020784e:	83 ec 04             	sub    $0x4,%esp
c0207851:	ff 75 10             	pushl  0x10(%ebp)
c0207854:	50                   	push   %eax
c0207855:	ff 75 08             	pushl  0x8(%ebp)
c0207858:	e8 94 ff ff ff       	call   c02077f1 <func>
c020785d:	83 c4 10             	add    $0x10,%esp
    len=strlen(s);
c0207860:	83 ec 0c             	sub    $0xc,%esp
c0207863:	ff 75 08             	pushl  0x8(%ebp)
c0207866:	e8 48 02 00 00       	call   c0207ab3 <strlen>
c020786b:	83 c4 10             	add    $0x10,%esp
c020786e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    s[len]=bit[n%i];
c0207871:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207874:	ba 00 00 00 00       	mov    $0x0,%edx
c0207879:	f7 75 10             	divl   0x10(%ebp)
c020787c:	89 d1                	mov    %edx,%ecx
c020787e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207881:	8b 45 08             	mov    0x8(%ebp),%eax
c0207884:	01 c2                	add    %eax,%edx
c0207886:	0f b6 44 0d e3       	movzbl -0x1d(%ebp,%ecx,1),%eax
c020788b:	88 02                	mov    %al,(%edx)
    s[len+1]='\0';
c020788d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207890:	8d 50 01             	lea    0x1(%eax),%edx
c0207893:	8b 45 08             	mov    0x8(%ebp),%eax
c0207896:	01 d0                	add    %edx,%eax
c0207898:	c6 00 00             	movb   $0x0,(%eax)
    return 1;
c020789b:	b8 01 00 00 00       	mov    $0x1,%eax
}
c02078a0:	c9                   	leave  
c02078a1:	c3                   	ret    

c02078a2 <num2hexstr>:

//32位的16进制数 使用0x+8位字符表示+\0   共11位字符
inline char *num2hexstr(int number,int need0x)
{	if (number!=0)
c02078a2:	55                   	push   %ebp
c02078a3:	89 e5                	mov    %esp,%ebp
c02078a5:	53                   	push   %ebx
c02078a6:	83 ec 34             	sub    $0x34,%esp
c02078a9:	e8 56 07 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02078ae:	81 c3 52 17 00 00    	add    $0x1752,%ebx
c02078b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c02078b8:	0f 84 f1 00 00 00    	je     c02079af <num2hexstr+0x10d>
	{
	static char static_hexstr[11]={0};
	static_hexstr[0]='0';
c02078be:	c6 83 c0 91 08 00 30 	movb   $0x30,0x891c0(%ebx)
	static_hexstr[1]='x';
c02078c5:	c6 83 c1 91 08 00 78 	movb   $0x78,0x891c1(%ebx)
	char temp_arry[9]={0};
c02078cc:	c7 45 df 00 00 00 00 	movl   $0x0,-0x21(%ebp)
c02078d3:	c7 45 e3 00 00 00 00 	movl   $0x0,-0x1d(%ebp)
c02078da:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	char *temp_arry_ptr=temp_arry;
c02078de:	8d 45 df             	lea    -0x21(%ebp),%eax
c02078e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	func(temp_arry_ptr,number,16);
c02078e4:	83 ec 04             	sub    $0x4,%esp
c02078e7:	6a 10                	push   $0x10
c02078e9:	ff 75 08             	pushl  0x8(%ebp)
c02078ec:	ff 75 f0             	pushl  -0x10(%ebp)
c02078ef:	e8 fd fe ff ff       	call   c02077f1 <func>
c02078f4:	83 c4 10             	add    $0x10,%esp
	char temp_arry2[9]={0};
c02078f7:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
c02078fe:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
c0207905:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	char *temp_arry2_ptr=temp_arry2;
c0207909:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c020790c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	strcpy(temp_arry2_ptr,temp_arry_ptr);
c020790f:	83 ec 08             	sub    $0x8,%esp
c0207912:	ff 75 f0             	pushl  -0x10(%ebp)
c0207915:	ff 75 ec             	pushl  -0x14(%ebp)
c0207918:	e8 c7 01 00 00       	call   c0207ae4 <strcpy>
c020791d:	83 c4 10             	add    $0x10,%esp
	int offset=8-strlen(temp_arry);
c0207920:	83 ec 0c             	sub    $0xc,%esp
c0207923:	8d 45 df             	lea    -0x21(%ebp),%eax
c0207926:	50                   	push   %eax
c0207927:	e8 87 01 00 00       	call   c0207ab3 <strlen>
c020792c:	83 c4 10             	add    $0x10,%esp
c020792f:	ba 08 00 00 00       	mov    $0x8,%edx
c0207934:	29 c2                	sub    %eax,%edx
c0207936:	89 d0                	mov    %edx,%eax
c0207938:	89 45 e8             	mov    %eax,-0x18(%ebp)
	strcpy(temp_arry+offset,temp_arry2);
c020793b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020793e:	8d 55 df             	lea    -0x21(%ebp),%edx
c0207941:	01 c2                	add    %eax,%edx
c0207943:	83 ec 08             	sub    $0x8,%esp
c0207946:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0207949:	50                   	push   %eax
c020794a:	52                   	push   %edx
c020794b:	e8 94 01 00 00       	call   c0207ae4 <strcpy>
c0207950:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<offset;i++)
c0207953:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020795a:	eb 0f                	jmp    c020796b <num2hexstr+0xc9>
		*(temp_arry+i)='0';
c020795c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020795f:	8d 55 df             	lea    -0x21(%ebp),%edx
c0207962:	01 d0                	add    %edx,%eax
c0207964:	c6 00 30             	movb   $0x30,(%eax)
	for(int i=0;i<offset;i++)
c0207967:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c020796b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020796e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0207971:	7c e9                	jl     c020795c <num2hexstr+0xba>
	if(need0x)
c0207973:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0207977:	74 18                	je     c0207991 <num2hexstr+0xef>
		strcpy(static_hexstr+2,temp_arry);
c0207979:	8d 83 c2 91 08 00    	lea    0x891c2(%ebx),%eax
c020797f:	83 ec 08             	sub    $0x8,%esp
c0207982:	8d 55 df             	lea    -0x21(%ebp),%edx
c0207985:	52                   	push   %edx
c0207986:	50                   	push   %eax
c0207987:	e8 58 01 00 00       	call   c0207ae4 <strcpy>
c020798c:	83 c4 10             	add    $0x10,%esp
c020798f:	eb 16                	jmp    c02079a7 <num2hexstr+0x105>
	else
		strcpy(static_hexstr,temp_arry);
c0207991:	83 ec 08             	sub    $0x8,%esp
c0207994:	8d 45 df             	lea    -0x21(%ebp),%eax
c0207997:	50                   	push   %eax
c0207998:	8d 83 c0 91 08 00    	lea    0x891c0(%ebx),%eax
c020799e:	50                   	push   %eax
c020799f:	e8 40 01 00 00       	call   c0207ae4 <strcpy>
c02079a4:	83 c4 10             	add    $0x10,%esp
	return static_hexstr;
c02079a7:	8d 83 c0 91 08 00    	lea    0x891c0(%ebx),%eax
c02079ad:	eb 14                	jmp    c02079c3 <num2hexstr+0x121>
	}
	else 
	{
		if(need0x)
c02079af:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c02079b3:	74 08                	je     c02079bd <num2hexstr+0x11b>
			return "0x00000000";
c02079b5:	8d 83 e3 06 00 00    	lea    0x6e3(%ebx),%eax
c02079bb:	eb 06                	jmp    c02079c3 <num2hexstr+0x121>
		else
			return "00000000";
c02079bd:	8d 83 ee 06 00 00    	lea    0x6ee(%ebx),%eax
	}
}
c02079c3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02079c6:	c9                   	leave  
c02079c7:	c3                   	ret    

c02079c8 <memcpy>:


inline void memcpy(uint8_t *dest ,const uint8_t *src,uint32_t len)
{
c02079c8:	55                   	push   %ebp
c02079c9:	89 e5                	mov    %esp,%ebp
c02079cb:	e8 30 06 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02079d0:	05 30 16 00 00       	add    $0x1630,%eax
	for(;len!=0;len--)
c02079d5:	eb 17                	jmp    c02079ee <memcpy+0x26>
	{
		*dest=*src;
c02079d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c02079da:	0f b6 10             	movzbl (%eax),%edx
c02079dd:	8b 45 08             	mov    0x8(%ebp),%eax
c02079e0:	88 10                	mov    %dl,(%eax)
		dest++;
c02079e2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c02079e6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	for(;len!=0;len--)
c02079ea:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c02079ee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c02079f2:	75 e3                	jne    c02079d7 <memcpy+0xf>
	}
}
c02079f4:	90                   	nop
c02079f5:	5d                   	pop    %ebp
c02079f6:	c3                   	ret    

c02079f7 <memset>:

inline void memset(void *dest,uint8_t val ,uint32_t len)
{
c02079f7:	55                   	push   %ebp
c02079f8:	89 e5                	mov    %esp,%ebp
c02079fa:	83 ec 14             	sub    $0x14,%esp
c02079fd:	e8 fe 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a02:	05 fe 15 00 00       	add    $0x15fe,%eax
c0207a07:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a0a:	88 45 ec             	mov    %al,-0x14(%ebp)
	uint8_t *dst = (uint8_t *)dest;
c0207a0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a10:	89 45 fc             	mov    %eax,-0x4(%ebp)

    for ( ; len != 0; len--) {
c0207a13:	eb 13                	jmp    c0207a28 <memset+0x31>
        *dst++ = val;
c0207a15:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207a18:	8d 50 01             	lea    0x1(%eax),%edx
c0207a1b:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0207a1e:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0207a22:	88 10                	mov    %dl,(%eax)
    for ( ; len != 0; len--) {
c0207a24:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0207a28:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0207a2c:	75 e7                	jne    c0207a15 <memset+0x1e>
    }
}
c0207a2e:	90                   	nop
c0207a2f:	c9                   	leave  
c0207a30:	c3                   	ret    

c0207a31 <bzero>:

inline void bzero(void *dest, uint32_t len)
{
c0207a31:	55                   	push   %ebp
c0207a32:	89 e5                	mov    %esp,%ebp
c0207a34:	e8 c7 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a39:	05 c7 15 00 00       	add    $0x15c7,%eax
    memset(dest, 0, len);
c0207a3e:	ff 75 0c             	pushl  0xc(%ebp)
c0207a41:	6a 00                	push   $0x0
c0207a43:	ff 75 08             	pushl  0x8(%ebp)
c0207a46:	e8 ac ff ff ff       	call   c02079f7 <memset>
c0207a4b:	83 c4 0c             	add    $0xc,%esp
}
c0207a4e:	90                   	nop
c0207a4f:	c9                   	leave  
c0207a50:	c3                   	ret    

c0207a51 <strcmp>:

inline int strcmp(const char *str1,const char *str2)
{
c0207a51:	55                   	push   %ebp
c0207a52:	89 e5                	mov    %esp,%ebp
c0207a54:	e8 a7 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a59:	05 a7 15 00 00       	add    $0x15a7,%eax
	while(1){
		if (*str1=='\0'&&*str2=='\0')
c0207a5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a61:	0f b6 00             	movzbl (%eax),%eax
c0207a64:	84 c0                	test   %al,%al
c0207a66:	75 11                	jne    c0207a79 <strcmp+0x28>
c0207a68:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a6b:	0f b6 00             	movzbl (%eax),%eax
c0207a6e:	84 c0                	test   %al,%al
c0207a70:	75 07                	jne    c0207a79 <strcmp+0x28>
			return 0;
c0207a72:	b8 00 00 00 00       	mov    $0x0,%eax
c0207a77:	eb 38                	jmp    c0207ab1 <strcmp+0x60>
		else if ((int)*str1>(int)*str2){
c0207a79:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a7c:	0f b6 10             	movzbl (%eax),%edx
c0207a7f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a82:	0f b6 00             	movzbl (%eax),%eax
c0207a85:	38 c2                	cmp    %al,%dl
c0207a87:	7e 07                	jle    c0207a90 <strcmp+0x3f>
			return 1;
c0207a89:	b8 01 00 00 00       	mov    $0x1,%eax
c0207a8e:	eb 21                	jmp    c0207ab1 <strcmp+0x60>
		}
		else if((int)*str1>(int)*str2){
c0207a90:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a93:	0f b6 10             	movzbl (%eax),%edx
c0207a96:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a99:	0f b6 00             	movzbl (%eax),%eax
c0207a9c:	38 c2                	cmp    %al,%dl
c0207a9e:	7e 07                	jle    c0207aa7 <strcmp+0x56>
			return -1;
c0207aa0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0207aa5:	eb 0a                	jmp    c0207ab1 <strcmp+0x60>
		}
		else{
			str1++;
c0207aa7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
			str2++;
c0207aab:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		if (*str1=='\0'&&*str2=='\0')
c0207aaf:	eb ad                	jmp    c0207a5e <strcmp+0xd>
		}
	}
}
c0207ab1:	5d                   	pop    %ebp
c0207ab2:	c3                   	ret    

c0207ab3 <strlen>:

inline int strlen(const char *src)
{
c0207ab3:	55                   	push   %ebp
c0207ab4:	89 e5                	mov    %esp,%ebp
c0207ab6:	83 ec 10             	sub    $0x10,%esp
c0207ab9:	e8 42 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207abe:	05 42 15 00 00       	add    $0x1542,%eax
	int i=0;
c0207ac3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(*(src+i)!='\0')
c0207aca:	eb 04                	jmp    c0207ad0 <strlen+0x1d>
		i++;
c0207acc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while(*(src+i)!='\0')
c0207ad0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0207ad3:	8b 45 08             	mov    0x8(%ebp),%eax
c0207ad6:	01 d0                	add    %edx,%eax
c0207ad8:	0f b6 00             	movzbl (%eax),%eax
c0207adb:	84 c0                	test   %al,%al
c0207add:	75 ed                	jne    c0207acc <strlen+0x19>
	return i;
c0207adf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0207ae2:	c9                   	leave  
c0207ae3:	c3                   	ret    

c0207ae4 <strcpy>:

inline char *strcpy(char *dest, const char *src)
{
c0207ae4:	55                   	push   %ebp
c0207ae5:	89 e5                	mov    %esp,%ebp
c0207ae7:	83 ec 10             	sub    $0x10,%esp
c0207aea:	e8 11 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207aef:	05 11 15 00 00       	add    $0x1511,%eax
	char *dest_head=dest;
c0207af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0207af7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(*(src)!='\0')
c0207afa:	eb 13                	jmp    c0207b0f <strcpy+0x2b>
	{
		*dest=*src;
c0207afc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207aff:	0f b6 10             	movzbl (%eax),%edx
c0207b02:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b05:	88 10                	mov    %dl,(%eax)
		dest++;
c0207b07:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c0207b0b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	while(*(src)!='\0')
c0207b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207b12:	0f b6 00             	movzbl (%eax),%eax
c0207b15:	84 c0                	test   %al,%al
c0207b17:	75 e3                	jne    c0207afc <strcpy+0x18>
	}
	*dest='\0';
c0207b19:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b1c:	c6 00 00             	movb   $0x0,(%eax)
	dest=dest_head;
c0207b1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207b22:	89 45 08             	mov    %eax,0x8(%ebp)
	return dest;
c0207b25:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0207b28:	c9                   	leave  
c0207b29:	c3                   	ret    

c0207b2a <strcat>:

inline char *strcat(char *dest, const char *src)
{
c0207b2a:	55                   	push   %ebp
c0207b2b:	89 e5                	mov    %esp,%ebp
c0207b2d:	83 ec 10             	sub    $0x10,%esp
c0207b30:	e8 cb 04 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207b35:	05 cb 14 00 00       	add    $0x14cb,%eax
	char *pointer=dest;
c0207b3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for(;*pointer!='\0';pointer++);
c0207b40:	eb 04                	jmp    c0207b46 <strcat+0x1c>
c0207b42:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0207b46:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207b49:	0f b6 00             	movzbl (%eax),%eax
c0207b4c:	84 c0                	test   %al,%al
c0207b4e:	75 f2                	jne    c0207b42 <strcat+0x18>
	strcpy(pointer,src);
c0207b50:	ff 75 0c             	pushl  0xc(%ebp)
c0207b53:	ff 75 fc             	pushl  -0x4(%ebp)
c0207b56:	e8 89 ff ff ff       	call   c0207ae4 <strcpy>
c0207b5b:	83 c4 08             	add    $0x8,%esp
	return dest;		
c0207b5e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0207b61:	c9                   	leave  
c0207b62:	c3                   	ret    

c0207b63 <uintTostring>:

inline char *uintTostring(uint32_t num)
{
c0207b63:	55                   	push   %ebp
c0207b64:	89 e5                	mov    %esp,%ebp
c0207b66:	83 ec 28             	sub    $0x28,%esp
c0207b69:	e8 92 04 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207b6e:	05 92 14 00 00       	add    $0x1492,%eax
	char i2stable[10]={'0','1','2','3','4','5','6','7','8','9'};
c0207b73:	c6 45 da 30          	movb   $0x30,-0x26(%ebp)
c0207b77:	c6 45 db 31          	movb   $0x31,-0x25(%ebp)
c0207b7b:	c6 45 dc 32          	movb   $0x32,-0x24(%ebp)
c0207b7f:	c6 45 dd 33          	movb   $0x33,-0x23(%ebp)
c0207b83:	c6 45 de 34          	movb   $0x34,-0x22(%ebp)
c0207b87:	c6 45 df 35          	movb   $0x35,-0x21(%ebp)
c0207b8b:	c6 45 e0 36          	movb   $0x36,-0x20(%ebp)
c0207b8f:	c6 45 e1 37          	movb   $0x37,-0x1f(%ebp)
c0207b93:	c6 45 e2 38          	movb   $0x38,-0x1e(%ebp)
c0207b97:	c6 45 e3 39          	movb   $0x39,-0x1d(%ebp)
	static char m[32]={0};
	char *str_ptr=m;
c0207b9b:	8d 80 e0 91 08 00    	lea    0x891e0(%eax),%eax
c0207ba1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char *head=str_ptr;
c0207ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207ba7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int i=0;
c0207baa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(;num>=10;i++)
c0207bb1:	eb 46                	jmp    c0207bf9 <uintTostring+0x96>
	{
		uint32_t num_=num/10;
c0207bb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0207bb6:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0207bbb:	f7 e2                	mul    %edx
c0207bbd:	89 d0                	mov    %edx,%eax
c0207bbf:	c1 e8 03             	shr    $0x3,%eax
c0207bc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32_t index=num-(num_*10);
c0207bc5:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0207bc8:	89 d0                	mov    %edx,%eax
c0207bca:	c1 e0 02             	shl    $0x2,%eax
c0207bcd:	01 d0                	add    %edx,%eax
c0207bcf:	01 c0                	add    %eax,%eax
c0207bd1:	89 c2                	mov    %eax,%edx
c0207bd3:	8b 45 08             	mov    0x8(%ebp),%eax
c0207bd6:	29 d0                	sub    %edx,%eax
c0207bd8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		num=num_;
c0207bdb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0207bde:	89 45 08             	mov    %eax,0x8(%ebp)
		*str_ptr=i2stable[index];
c0207be1:	8d 55 da             	lea    -0x26(%ebp),%edx
c0207be4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0207be7:	01 d0                	add    %edx,%eax
c0207be9:	0f b6 10             	movzbl (%eax),%edx
c0207bec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207bef:	88 10                	mov    %dl,(%eax)
		str_ptr++;
c0207bf1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	for(;num>=10;i++)
c0207bf5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0207bf9:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0207bfd:	77 b4                	ja     c0207bb3 <uintTostring+0x50>
	}
	*str_ptr=i2stable[num];
c0207bff:	8d 55 da             	lea    -0x26(%ebp),%edx
c0207c02:	8b 45 08             	mov    0x8(%ebp),%eax
c0207c05:	01 d0                	add    %edx,%eax
c0207c07:	0f b6 10             	movzbl (%eax),%edx
c0207c0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c0d:	88 10                	mov    %dl,(%eax)
	*(str_ptr+1)='\0';
c0207c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c12:	83 c0 01             	add    $0x1,%eax
c0207c15:	c6 00 00             	movb   $0x0,(%eax)
	return strrevers(head);
c0207c18:	83 ec 0c             	sub    $0xc,%esp
c0207c1b:	ff 75 ec             	pushl  -0x14(%ebp)
c0207c1e:	e8 05 00 00 00       	call   c0207c28 <strrevers>
c0207c23:	83 c4 10             	add    $0x10,%esp
}
c0207c26:	c9                   	leave  
c0207c27:	c3                   	ret    

c0207c28 <strrevers>:

inline  char *strrevers(char *str)
{
c0207c28:	55                   	push   %ebp
c0207c29:	89 e5                	mov    %esp,%ebp
c0207c2b:	83 ec 20             	sub    $0x20,%esp
c0207c2e:	e8 cd 03 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207c33:	05 cd 13 00 00       	add    $0x13cd,%eax
	char *str_head=str;
c0207c38:	8b 45 08             	mov    0x8(%ebp),%eax
c0207c3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int lenth=strlen(str);
c0207c3e:	ff 75 08             	pushl  0x8(%ebp)
c0207c41:	e8 6d fe ff ff       	call   c0207ab3 <strlen>
c0207c46:	83 c4 04             	add    $0x4,%esp
c0207c49:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ptr_h=0;
c0207c4c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int ptr_t=--lenth;
c0207c53:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0207c57:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0207c5a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c0207c5d:	eb 39                	jmp    c0207c98 <strrevers+0x70>
	{
		char temp=*(str_head+ptr_t);
c0207c5f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0207c62:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c65:	01 d0                	add    %edx,%eax
c0207c67:	0f b6 00             	movzbl (%eax),%eax
c0207c6a:	88 45 ef             	mov    %al,-0x11(%ebp)
		*(str_head+ptr_t)=*(str_head+ptr_h);
c0207c6d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0207c70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c73:	01 d0                	add    %edx,%eax
c0207c75:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c0207c78:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207c7b:	01 ca                	add    %ecx,%edx
c0207c7d:	0f b6 00             	movzbl (%eax),%eax
c0207c80:	88 02                	mov    %al,(%edx)
		*(str_head+ptr_h)=temp;
c0207c82:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0207c85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c88:	01 c2                	add    %eax,%edx
c0207c8a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0207c8e:	88 02                	mov    %al,(%edx)
		ptr_h++;
c0207c90:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		ptr_t--;
c0207c94:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c0207c98:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207c9b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0207c9e:	7c bf                	jl     c0207c5f <strrevers+0x37>
	}
	return str_head;
c0207ca0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0207ca3:	c9                   	leave  
c0207ca4:	c3                   	ret    

c0207ca5 <get_elem>:
#include "list.h"
elem_t get_elem(link_list_node_t* link_list_node_ptr){
c0207ca5:	55                   	push   %ebp
c0207ca6:	89 e5                	mov    %esp,%ebp
c0207ca8:	e8 53 03 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207cad:	05 53 13 00 00       	add    $0x1353,%eax
    return link_list_node_ptr->elem;
c0207cb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0207cb5:	8b 40 04             	mov    0x4(%eax),%eax
}
c0207cb8:	5d                   	pop    %ebp
c0207cb9:	c3                   	ret    

c0207cba <get_next>:

elem_t get_next(link_list_node_t* link_list_node_ptr){
c0207cba:	55                   	push   %ebp
c0207cbb:	89 e5                	mov    %esp,%ebp
c0207cbd:	e8 3e 03 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207cc2:	05 3e 13 00 00       	add    $0x133e,%eax
    return link_list_node_ptr->next;
c0207cc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0207cca:	8b 00                	mov    (%eax),%eax
c0207ccc:	5d                   	pop    %ebp
c0207ccd:	c3                   	ret    
c0207cce:	66 90                	xchg   %ax,%ax
c0207cd0:	66 90                	xchg   %ax,%ax
c0207cd2:	66 90                	xchg   %ax,%ax
c0207cd4:	66 90                	xchg   %ax,%ax
c0207cd6:	66 90                	xchg   %ax,%ax
c0207cd8:	66 90                	xchg   %ax,%ax
c0207cda:	66 90                	xchg   %ax,%ax
c0207cdc:	66 90                	xchg   %ax,%ax
c0207cde:	66 90                	xchg   %ax,%ax
c0207ce0:	66 90                	xchg   %ax,%ax
c0207ce2:	66 90                	xchg   %ax,%ax
c0207ce4:	66 90                	xchg   %ax,%ax
c0207ce6:	66 90                	xchg   %ax,%ax
c0207ce8:	66 90                	xchg   %ax,%ax
c0207cea:	66 90                	xchg   %ax,%ax
c0207cec:	66 90                	xchg   %ax,%ax
c0207cee:	66 90                	xchg   %ax,%ax
c0207cf0:	66 90                	xchg   %ax,%ax
c0207cf2:	66 90                	xchg   %ax,%ax
c0207cf4:	66 90                	xchg   %ax,%ax
c0207cf6:	66 90                	xchg   %ax,%ax
c0207cf8:	66 90                	xchg   %ax,%ax
c0207cfa:	66 90                	xchg   %ax,%ax
c0207cfc:	66 90                	xchg   %ax,%ax
c0207cfe:	66 90                	xchg   %ax,%ax
c0207d00:	66 90                	xchg   %ax,%ax
c0207d02:	66 90                	xchg   %ax,%ax
c0207d04:	66 90                	xchg   %ax,%ax
c0207d06:	66 90                	xchg   %ax,%ax
c0207d08:	66 90                	xchg   %ax,%ax
c0207d0a:	66 90                	xchg   %ax,%ax
c0207d0c:	66 90                	xchg   %ax,%ax
c0207d0e:	66 90                	xchg   %ax,%ax
c0207d10:	66 90                	xchg   %ax,%ax
c0207d12:	66 90                	xchg   %ax,%ax
c0207d14:	66 90                	xchg   %ax,%ax
c0207d16:	66 90                	xchg   %ax,%ax
c0207d18:	66 90                	xchg   %ax,%ax
c0207d1a:	66 90                	xchg   %ax,%ax
c0207d1c:	66 90                	xchg   %ax,%ax
c0207d1e:	66 90                	xchg   %ax,%ax
c0207d20:	66 90                	xchg   %ax,%ax
c0207d22:	66 90                	xchg   %ax,%ax
c0207d24:	66 90                	xchg   %ax,%ax
c0207d26:	66 90                	xchg   %ax,%ax
c0207d28:	66 90                	xchg   %ax,%ax
c0207d2a:	66 90                	xchg   %ax,%ax
c0207d2c:	66 90                	xchg   %ax,%ax
c0207d2e:	66 90                	xchg   %ax,%ax
c0207d30:	66 90                	xchg   %ax,%ax
c0207d32:	66 90                	xchg   %ax,%ax
c0207d34:	66 90                	xchg   %ax,%ax
c0207d36:	66 90                	xchg   %ax,%ax
c0207d38:	66 90                	xchg   %ax,%ax
c0207d3a:	66 90                	xchg   %ax,%ax
c0207d3c:	66 90                	xchg   %ax,%ax
c0207d3e:	66 90                	xchg   %ax,%ax
c0207d40:	66 90                	xchg   %ax,%ax
c0207d42:	66 90                	xchg   %ax,%ax
c0207d44:	66 90                	xchg   %ax,%ax
c0207d46:	66 90                	xchg   %ax,%ax
c0207d48:	66 90                	xchg   %ax,%ax
c0207d4a:	66 90                	xchg   %ax,%ax
c0207d4c:	66 90                	xchg   %ax,%ax
c0207d4e:	66 90                	xchg   %ax,%ax
c0207d50:	66 90                	xchg   %ax,%ax
c0207d52:	66 90                	xchg   %ax,%ax
c0207d54:	66 90                	xchg   %ax,%ax
c0207d56:	66 90                	xchg   %ax,%ax
c0207d58:	66 90                	xchg   %ax,%ax
c0207d5a:	66 90                	xchg   %ax,%ax
c0207d5c:	66 90                	xchg   %ax,%ax
c0207d5e:	66 90                	xchg   %ax,%ax
c0207d60:	66 90                	xchg   %ax,%ax
c0207d62:	66 90                	xchg   %ax,%ax
c0207d64:	66 90                	xchg   %ax,%ax
c0207d66:	66 90                	xchg   %ax,%ax
c0207d68:	66 90                	xchg   %ax,%ax
c0207d6a:	66 90                	xchg   %ax,%ax
c0207d6c:	66 90                	xchg   %ax,%ax
c0207d6e:	66 90                	xchg   %ax,%ax
c0207d70:	66 90                	xchg   %ax,%ax
c0207d72:	66 90                	xchg   %ax,%ax
c0207d74:	66 90                	xchg   %ax,%ax
c0207d76:	66 90                	xchg   %ax,%ax
c0207d78:	66 90                	xchg   %ax,%ax
c0207d7a:	66 90                	xchg   %ax,%ax
c0207d7c:	66 90                	xchg   %ax,%ax
c0207d7e:	66 90                	xchg   %ax,%ax
c0207d80:	66 90                	xchg   %ax,%ax
c0207d82:	66 90                	xchg   %ax,%ax
c0207d84:	66 90                	xchg   %ax,%ax
c0207d86:	66 90                	xchg   %ax,%ax
c0207d88:	66 90                	xchg   %ax,%ax
c0207d8a:	66 90                	xchg   %ax,%ax
c0207d8c:	66 90                	xchg   %ax,%ax
c0207d8e:	66 90                	xchg   %ax,%ax
c0207d90:	66 90                	xchg   %ax,%ax
c0207d92:	66 90                	xchg   %ax,%ax
c0207d94:	66 90                	xchg   %ax,%ax
c0207d96:	66 90                	xchg   %ax,%ax
c0207d98:	66 90                	xchg   %ax,%ax
c0207d9a:	66 90                	xchg   %ax,%ax
c0207d9c:	66 90                	xchg   %ax,%ax
c0207d9e:	66 90                	xchg   %ax,%ax
c0207da0:	66 90                	xchg   %ax,%ax
c0207da2:	66 90                	xchg   %ax,%ax
c0207da4:	66 90                	xchg   %ax,%ax
c0207da6:	66 90                	xchg   %ax,%ax
c0207da8:	66 90                	xchg   %ax,%ax
c0207daa:	66 90                	xchg   %ax,%ax
c0207dac:	66 90                	xchg   %ax,%ax
c0207dae:	66 90                	xchg   %ax,%ax
c0207db0:	66 90                	xchg   %ax,%ax
c0207db2:	66 90                	xchg   %ax,%ax
c0207db4:	66 90                	xchg   %ax,%ax
c0207db6:	66 90                	xchg   %ax,%ax
c0207db8:	66 90                	xchg   %ax,%ax
c0207dba:	66 90                	xchg   %ax,%ax
c0207dbc:	66 90                	xchg   %ax,%ax
c0207dbe:	66 90                	xchg   %ax,%ax
c0207dc0:	66 90                	xchg   %ax,%ax
c0207dc2:	66 90                	xchg   %ax,%ax
c0207dc4:	66 90                	xchg   %ax,%ax
c0207dc6:	66 90                	xchg   %ax,%ax
c0207dc8:	66 90                	xchg   %ax,%ax
c0207dca:	66 90                	xchg   %ax,%ax
c0207dcc:	66 90                	xchg   %ax,%ax
c0207dce:	66 90                	xchg   %ax,%ax
c0207dd0:	66 90                	xchg   %ax,%ax
c0207dd2:	66 90                	xchg   %ax,%ax
c0207dd4:	66 90                	xchg   %ax,%ax
c0207dd6:	66 90                	xchg   %ax,%ax
c0207dd8:	66 90                	xchg   %ax,%ax
c0207dda:	66 90                	xchg   %ax,%ax
c0207ddc:	66 90                	xchg   %ax,%ax
c0207dde:	66 90                	xchg   %ax,%ax
c0207de0:	66 90                	xchg   %ax,%ax
c0207de2:	66 90                	xchg   %ax,%ax
c0207de4:	66 90                	xchg   %ax,%ax
c0207de6:	66 90                	xchg   %ax,%ax
c0207de8:	66 90                	xchg   %ax,%ax
c0207dea:	66 90                	xchg   %ax,%ax
c0207dec:	66 90                	xchg   %ax,%ax
c0207dee:	66 90                	xchg   %ax,%ax
c0207df0:	66 90                	xchg   %ax,%ax
c0207df2:	66 90                	xchg   %ax,%ax
c0207df4:	66 90                	xchg   %ax,%ax
c0207df6:	66 90                	xchg   %ax,%ax
c0207df8:	66 90                	xchg   %ax,%ax
c0207dfa:	66 90                	xchg   %ax,%ax
c0207dfc:	66 90                	xchg   %ax,%ax
c0207dfe:	66 90                	xchg   %ax,%ax
c0207e00:	66 90                	xchg   %ax,%ax
c0207e02:	66 90                	xchg   %ax,%ax
c0207e04:	66 90                	xchg   %ax,%ax
c0207e06:	66 90                	xchg   %ax,%ax
c0207e08:	66 90                	xchg   %ax,%ax
c0207e0a:	66 90                	xchg   %ax,%ax
c0207e0c:	66 90                	xchg   %ax,%ax
c0207e0e:	66 90                	xchg   %ax,%ax
c0207e10:	66 90                	xchg   %ax,%ax
c0207e12:	66 90                	xchg   %ax,%ax
c0207e14:	66 90                	xchg   %ax,%ax
c0207e16:	66 90                	xchg   %ax,%ax
c0207e18:	66 90                	xchg   %ax,%ax
c0207e1a:	66 90                	xchg   %ax,%ax
c0207e1c:	66 90                	xchg   %ax,%ax
c0207e1e:	66 90                	xchg   %ax,%ax
c0207e20:	66 90                	xchg   %ax,%ax
c0207e22:	66 90                	xchg   %ax,%ax
c0207e24:	66 90                	xchg   %ax,%ax
c0207e26:	66 90                	xchg   %ax,%ax
c0207e28:	66 90                	xchg   %ax,%ax
c0207e2a:	66 90                	xchg   %ax,%ax
c0207e2c:	66 90                	xchg   %ax,%ax
c0207e2e:	66 90                	xchg   %ax,%ax
c0207e30:	66 90                	xchg   %ax,%ax
c0207e32:	66 90                	xchg   %ax,%ax
c0207e34:	66 90                	xchg   %ax,%ax
c0207e36:	66 90                	xchg   %ax,%ax
c0207e38:	66 90                	xchg   %ax,%ax
c0207e3a:	66 90                	xchg   %ax,%ax
c0207e3c:	66 90                	xchg   %ax,%ax
c0207e3e:	66 90                	xchg   %ax,%ax
c0207e40:	66 90                	xchg   %ax,%ax
c0207e42:	66 90                	xchg   %ax,%ax
c0207e44:	66 90                	xchg   %ax,%ax
c0207e46:	66 90                	xchg   %ax,%ax
c0207e48:	66 90                	xchg   %ax,%ax
c0207e4a:	66 90                	xchg   %ax,%ax
c0207e4c:	66 90                	xchg   %ax,%ax
c0207e4e:	66 90                	xchg   %ax,%ax
c0207e50:	66 90                	xchg   %ax,%ax
c0207e52:	66 90                	xchg   %ax,%ax
c0207e54:	66 90                	xchg   %ax,%ax
c0207e56:	66 90                	xchg   %ax,%ax
c0207e58:	66 90                	xchg   %ax,%ax
c0207e5a:	66 90                	xchg   %ax,%ax
c0207e5c:	66 90                	xchg   %ax,%ax
c0207e5e:	66 90                	xchg   %ax,%ax
c0207e60:	66 90                	xchg   %ax,%ax
c0207e62:	66 90                	xchg   %ax,%ax
c0207e64:	66 90                	xchg   %ax,%ax
c0207e66:	66 90                	xchg   %ax,%ax
c0207e68:	66 90                	xchg   %ax,%ax
c0207e6a:	66 90                	xchg   %ax,%ax
c0207e6c:	66 90                	xchg   %ax,%ax
c0207e6e:	66 90                	xchg   %ax,%ax
c0207e70:	66 90                	xchg   %ax,%ax
c0207e72:	66 90                	xchg   %ax,%ax
c0207e74:	66 90                	xchg   %ax,%ax
c0207e76:	66 90                	xchg   %ax,%ax
c0207e78:	66 90                	xchg   %ax,%ax
c0207e7a:	66 90                	xchg   %ax,%ax
c0207e7c:	66 90                	xchg   %ax,%ax
c0207e7e:	66 90                	xchg   %ax,%ax
c0207e80:	66 90                	xchg   %ax,%ax
c0207e82:	66 90                	xchg   %ax,%ax
c0207e84:	66 90                	xchg   %ax,%ax
c0207e86:	66 90                	xchg   %ax,%ax
c0207e88:	66 90                	xchg   %ax,%ax
c0207e8a:	66 90                	xchg   %ax,%ax
c0207e8c:	66 90                	xchg   %ax,%ax
c0207e8e:	66 90                	xchg   %ax,%ax
c0207e90:	66 90                	xchg   %ax,%ax
c0207e92:	66 90                	xchg   %ax,%ax
c0207e94:	66 90                	xchg   %ax,%ax
c0207e96:	66 90                	xchg   %ax,%ax
c0207e98:	66 90                	xchg   %ax,%ax
c0207e9a:	66 90                	xchg   %ax,%ax
c0207e9c:	66 90                	xchg   %ax,%ax
c0207e9e:	66 90                	xchg   %ax,%ax
c0207ea0:	66 90                	xchg   %ax,%ax
c0207ea2:	66 90                	xchg   %ax,%ax
c0207ea4:	66 90                	xchg   %ax,%ax
c0207ea6:	66 90                	xchg   %ax,%ax
c0207ea8:	66 90                	xchg   %ax,%ax
c0207eaa:	66 90                	xchg   %ax,%ax
c0207eac:	66 90                	xchg   %ax,%ax
c0207eae:	66 90                	xchg   %ax,%ax
c0207eb0:	66 90                	xchg   %ax,%ax
c0207eb2:	66 90                	xchg   %ax,%ax
c0207eb4:	66 90                	xchg   %ax,%ax
c0207eb6:	66 90                	xchg   %ax,%ax
c0207eb8:	66 90                	xchg   %ax,%ax
c0207eba:	66 90                	xchg   %ax,%ax
c0207ebc:	66 90                	xchg   %ax,%ax
c0207ebe:	66 90                	xchg   %ax,%ax
c0207ec0:	66 90                	xchg   %ax,%ax
c0207ec2:	66 90                	xchg   %ax,%ax
c0207ec4:	66 90                	xchg   %ax,%ax
c0207ec6:	66 90                	xchg   %ax,%ax
c0207ec8:	66 90                	xchg   %ax,%ax
c0207eca:	66 90                	xchg   %ax,%ax
c0207ecc:	66 90                	xchg   %ax,%ax
c0207ece:	66 90                	xchg   %ax,%ax
c0207ed0:	66 90                	xchg   %ax,%ax
c0207ed2:	66 90                	xchg   %ax,%ax
c0207ed4:	66 90                	xchg   %ax,%ax
c0207ed6:	66 90                	xchg   %ax,%ax
c0207ed8:	66 90                	xchg   %ax,%ax
c0207eda:	66 90                	xchg   %ax,%ax
c0207edc:	66 90                	xchg   %ax,%ax
c0207ede:	66 90                	xchg   %ax,%ax
c0207ee0:	66 90                	xchg   %ax,%ax
c0207ee2:	66 90                	xchg   %ax,%ax
c0207ee4:	66 90                	xchg   %ax,%ax
c0207ee6:	66 90                	xchg   %ax,%ax
c0207ee8:	66 90                	xchg   %ax,%ax
c0207eea:	66 90                	xchg   %ax,%ax
c0207eec:	66 90                	xchg   %ax,%ax
c0207eee:	66 90                	xchg   %ax,%ax
c0207ef0:	66 90                	xchg   %ax,%ax
c0207ef2:	66 90                	xchg   %ax,%ax
c0207ef4:	66 90                	xchg   %ax,%ax
c0207ef6:	66 90                	xchg   %ax,%ax
c0207ef8:	66 90                	xchg   %ax,%ax
c0207efa:	66 90                	xchg   %ax,%ax
c0207efc:	66 90                	xchg   %ax,%ax
c0207efe:	66 90                	xchg   %ax,%ax
c0207f00:	66 90                	xchg   %ax,%ax
c0207f02:	66 90                	xchg   %ax,%ax
c0207f04:	66 90                	xchg   %ax,%ax
c0207f06:	66 90                	xchg   %ax,%ax
c0207f08:	66 90                	xchg   %ax,%ax
c0207f0a:	66 90                	xchg   %ax,%ax
c0207f0c:	66 90                	xchg   %ax,%ax
c0207f0e:	66 90                	xchg   %ax,%ax
c0207f10:	66 90                	xchg   %ax,%ax
c0207f12:	66 90                	xchg   %ax,%ax
c0207f14:	66 90                	xchg   %ax,%ax
c0207f16:	66 90                	xchg   %ax,%ax
c0207f18:	66 90                	xchg   %ax,%ax
c0207f1a:	66 90                	xchg   %ax,%ax
c0207f1c:	66 90                	xchg   %ax,%ax
c0207f1e:	66 90                	xchg   %ax,%ax
c0207f20:	66 90                	xchg   %ax,%ax
c0207f22:	66 90                	xchg   %ax,%ax
c0207f24:	66 90                	xchg   %ax,%ax
c0207f26:	66 90                	xchg   %ax,%ax
c0207f28:	66 90                	xchg   %ax,%ax
c0207f2a:	66 90                	xchg   %ax,%ax
c0207f2c:	66 90                	xchg   %ax,%ax
c0207f2e:	66 90                	xchg   %ax,%ax
c0207f30:	66 90                	xchg   %ax,%ax
c0207f32:	66 90                	xchg   %ax,%ax
c0207f34:	66 90                	xchg   %ax,%ax
c0207f36:	66 90                	xchg   %ax,%ax
c0207f38:	66 90                	xchg   %ax,%ax
c0207f3a:	66 90                	xchg   %ax,%ax
c0207f3c:	66 90                	xchg   %ax,%ax
c0207f3e:	66 90                	xchg   %ax,%ax
c0207f40:	66 90                	xchg   %ax,%ax
c0207f42:	66 90                	xchg   %ax,%ax
c0207f44:	66 90                	xchg   %ax,%ax
c0207f46:	66 90                	xchg   %ax,%ax
c0207f48:	66 90                	xchg   %ax,%ax
c0207f4a:	66 90                	xchg   %ax,%ax
c0207f4c:	66 90                	xchg   %ax,%ax
c0207f4e:	66 90                	xchg   %ax,%ax
c0207f50:	66 90                	xchg   %ax,%ax
c0207f52:	66 90                	xchg   %ax,%ax
c0207f54:	66 90                	xchg   %ax,%ax
c0207f56:	66 90                	xchg   %ax,%ax
c0207f58:	66 90                	xchg   %ax,%ax
c0207f5a:	66 90                	xchg   %ax,%ax
c0207f5c:	66 90                	xchg   %ax,%ax
c0207f5e:	66 90                	xchg   %ax,%ax
c0207f60:	66 90                	xchg   %ax,%ax
c0207f62:	66 90                	xchg   %ax,%ax
c0207f64:	66 90                	xchg   %ax,%ax
c0207f66:	66 90                	xchg   %ax,%ax
c0207f68:	66 90                	xchg   %ax,%ax
c0207f6a:	66 90                	xchg   %ax,%ax
c0207f6c:	66 90                	xchg   %ax,%ax
c0207f6e:	66 90                	xchg   %ax,%ax
c0207f70:	66 90                	xchg   %ax,%ax
c0207f72:	66 90                	xchg   %ax,%ax
c0207f74:	66 90                	xchg   %ax,%ax
c0207f76:	66 90                	xchg   %ax,%ax
c0207f78:	66 90                	xchg   %ax,%ax
c0207f7a:	66 90                	xchg   %ax,%ax
c0207f7c:	66 90                	xchg   %ax,%ax
c0207f7e:	66 90                	xchg   %ax,%ax
c0207f80:	66 90                	xchg   %ax,%ax
c0207f82:	66 90                	xchg   %ax,%ax
c0207f84:	66 90                	xchg   %ax,%ax
c0207f86:	66 90                	xchg   %ax,%ax
c0207f88:	66 90                	xchg   %ax,%ax
c0207f8a:	66 90                	xchg   %ax,%ax
c0207f8c:	66 90                	xchg   %ax,%ax
c0207f8e:	66 90                	xchg   %ax,%ax
c0207f90:	66 90                	xchg   %ax,%ax
c0207f92:	66 90                	xchg   %ax,%ax
c0207f94:	66 90                	xchg   %ax,%ax
c0207f96:	66 90                	xchg   %ax,%ax
c0207f98:	66 90                	xchg   %ax,%ax
c0207f9a:	66 90                	xchg   %ax,%ax
c0207f9c:	66 90                	xchg   %ax,%ax
c0207f9e:	66 90                	xchg   %ax,%ax
c0207fa0:	66 90                	xchg   %ax,%ax
c0207fa2:	66 90                	xchg   %ax,%ax
c0207fa4:	66 90                	xchg   %ax,%ax
c0207fa6:	66 90                	xchg   %ax,%ax
c0207fa8:	66 90                	xchg   %ax,%ax
c0207faa:	66 90                	xchg   %ax,%ax
c0207fac:	66 90                	xchg   %ax,%ax
c0207fae:	66 90                	xchg   %ax,%ax
c0207fb0:	66 90                	xchg   %ax,%ax
c0207fb2:	66 90                	xchg   %ax,%ax
c0207fb4:	66 90                	xchg   %ax,%ax
c0207fb6:	66 90                	xchg   %ax,%ax
c0207fb8:	66 90                	xchg   %ax,%ax
c0207fba:	66 90                	xchg   %ax,%ax
c0207fbc:	66 90                	xchg   %ax,%ax
c0207fbe:	66 90                	xchg   %ax,%ax
c0207fc0:	66 90                	xchg   %ax,%ax
c0207fc2:	66 90                	xchg   %ax,%ax
c0207fc4:	66 90                	xchg   %ax,%ax
c0207fc6:	66 90                	xchg   %ax,%ax
c0207fc8:	66 90                	xchg   %ax,%ax
c0207fca:	66 90                	xchg   %ax,%ax
c0207fcc:	66 90                	xchg   %ax,%ax
c0207fce:	66 90                	xchg   %ax,%ax
c0207fd0:	66 90                	xchg   %ax,%ax
c0207fd2:	66 90                	xchg   %ax,%ax
c0207fd4:	66 90                	xchg   %ax,%ax
c0207fd6:	66 90                	xchg   %ax,%ax
c0207fd8:	66 90                	xchg   %ax,%ax
c0207fda:	66 90                	xchg   %ax,%ax
c0207fdc:	66 90                	xchg   %ax,%ax
c0207fde:	66 90                	xchg   %ax,%ax
c0207fe0:	66 90                	xchg   %ax,%ax
c0207fe2:	66 90                	xchg   %ax,%ax
c0207fe4:	66 90                	xchg   %ax,%ax
c0207fe6:	66 90                	xchg   %ax,%ax
c0207fe8:	66 90                	xchg   %ax,%ax
c0207fea:	66 90                	xchg   %ax,%ax
c0207fec:	66 90                	xchg   %ax,%ax
c0207fee:	66 90                	xchg   %ax,%ax
c0207ff0:	66 90                	xchg   %ax,%ax
c0207ff2:	66 90                	xchg   %ax,%ax
c0207ff4:	66 90                	xchg   %ax,%ax
c0207ff6:	66 90                	xchg   %ax,%ax
c0207ff8:	66 90                	xchg   %ax,%ax
c0207ffa:	66 90                	xchg   %ax,%ax
c0207ffc:	66 90                	xchg   %ax,%ax
c0207ffe:	66 90                	xchg   %ax,%ax

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0208000 <__x86.get_pc_thunk.ax>:
c0208000:	8b 04 24             	mov    (%esp),%eax
c0208003:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c0208004 <__x86.get_pc_thunk.bx>:
c0208004:	8b 1c 24             	mov    (%esp),%ebx
c0208007:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c0208008 <__x86.get_pc_thunk.dx>:
c0208008:	8b 14 24             	mov    (%esp),%edx
c020800b:	c3                   	ret    
