
kernel.elf：     文件格式 elf32-i386


Disassembly of section .text:

c0203000 <get_esp>:
;内核线程模块的汇编函数文件
[bits 32]
[GLOBAL get_esp]
get_esp:
	mov eax,esp
c0203000:	89 e0                	mov    %esp,%eax
	ret
c0203002:	c3                   	ret    

c0203003 <get_eflags>:
[GLOBAL get_eflags]
get_eflags:
	pushf
c0203003:	9c                   	pushf  
	pop eax
c0203004:	58                   	pop    %eax
	ret
c0203005:	c3                   	ret    

c0203006 <switch_to>:
[GLOBAL switch_to]
switch_to:
	;保存上下文
	mov eax,[esp+4]     ;第一个参数 
c0203006:	8b 44 24 04          	mov    0x4(%esp),%eax
	mov [eax],ebp
c020300a:	89 28                	mov    %ebp,(%eax)
	mov [eax+4],ebx
c020300c:	89 58 04             	mov    %ebx,0x4(%eax)
	mov [eax+8],ecx
c020300f:	89 48 08             	mov    %ecx,0x8(%eax)
	mov [eax+12],edx
c0203012:	89 50 0c             	mov    %edx,0xc(%eax)
	mov [eax+16],esi
c0203015:	89 70 10             	mov    %esi,0x10(%eax)
	mov [eax+20],edi
c0203018:	89 78 14             	mov    %edi,0x14(%eax)
	mov [eax+28],esp
c020301b:	89 60 1c             	mov    %esp,0x1c(%eax)
	push ebx
c020301e:	53                   	push   %ebx
	mov ebx,eax
c020301f:	89 c3                	mov    %eax,%ebx
	pushf
c0203021:	9c                   	pushf  
	pop eax
c0203022:	58                   	pop    %eax
	mov [ebx+24],eax
c0203023:	89 43 18             	mov    %eax,0x18(%ebx)
	mov eax,ebx
c0203026:	89 d8                	mov    %ebx,%eax
	pop ebx
c0203028:	5b                   	pop    %ebx

	;加载上下文
	mov eax,[esp+8]      ;第二个参数
c0203029:	8b 44 24 08          	mov    0x8(%esp),%eax
	mov esp,[eax+28]    ;切换了esp    导致ret指令控制流转移
c020302d:	8b 60 1c             	mov    0x1c(%eax),%esp
	mov ebp,[eax]
c0203030:	8b 28                	mov    (%eax),%ebp
	mov ebx,[eax+4]
c0203032:	8b 58 04             	mov    0x4(%eax),%ebx
	mov ecx,[eax+8]
c0203035:	8b 48 08             	mov    0x8(%eax),%ecx
	mov edx,[eax+12]
c0203038:	8b 50 0c             	mov    0xc(%eax),%edx
	mov esi,[eax+16]
c020303b:	8b 70 10             	mov    0x10(%eax),%esi
	mov edi,[eax+20]
c020303e:	8b 78 14             	mov    0x14(%eax),%edi
	add eax,24
c0203041:	83 c0 18             	add    $0x18,%eax
	push dword [eax] ;eflags
c0203044:	ff 30                	pushl  (%eax)
	popf	
c0203046:	9d                   	popf   

	;由于8259a设置的手动模式 所以必须给主片与从片发送信号 否则8259a会暂停
	;这个bug找了一下午才找到 顺便吐槽下 内核级的代码debug太难了(GDB在多线程与汇编级会失效 只有print调试法) 
	mov al,0x20         
c0203047:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c0203049:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c020304b:	e6 20                	out    %al,$0x20
	
c020304d:	c3                   	ret    
c020304e:	66 90                	xchg   %ax,%ax

c0203050 <asm_change_esp>:

[bits 32]
[GLOBAL asm_change_esp]
[GLOBAL asm_active_page_dir_table]
asm_change_esp:
    ret
c0203050:	c3                   	ret    

c0203051 <asm_active_page_dir_table>:
asm_active_page_dir_table:
c0203051:	c3                   	ret    
c0203052:	66 90                	xchg   %ax,%ax
c0203054:	66 90                	xchg   %ax,%ax
c0203056:	66 90                	xchg   %ax,%ax
c0203058:	66 90                	xchg   %ax,%ax
c020305a:	66 90                	xchg   %ax,%ax
c020305c:	66 90                	xchg   %ax,%ax
c020305e:	66 90                	xchg   %ax,%ax

c0203060 <pre_handle>:
%endmacro

;这个中断流程是内核与用户共用的
[EXTERN int_func_route]
pre_handle:
	pushad               ;压入八个32位
c0203060:	60                   	pusha  
	mov ecx,[ss:esp+32]
c0203061:	36 8b 4c 24 20       	mov    %ss:0x20(%esp),%ecx
	;mov ebx,eax
	mov ax,es          ;进入时ss已经被切换了
c0203066:	66 8c c0             	mov    %es,%ax
	and eax,0x0000FFFF
c0203069:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c020306e:	50                   	push   %eax
	mov ax,fs          
c020306f:	66 8c e0             	mov    %fs,%ax
	and eax,0x0000FFFF
c0203072:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c0203077:	50                   	push   %eax
	mov ax,gs
c0203078:	66 8c e8             	mov    %gs,%ax
	and eax,0x0000FFFF
c020307b:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c0203080:	50                   	push   %eax
;切换回内核的中断相关段寄存器  cs与ss不用管 在中断时已经被cpu自动从tss中切换
	mov ax,KERN_DATA_SELECTOR    ;不包含ss
c0203081:	66 b8 10 00          	mov    $0x10,%ax
	mov es,ax
c0203085:	8e c0                	mov    %eax,%es
	mov fs,ax
c0203087:	8e e0                	mov    %eax,%fs
	mov ax,KERN_VGA_SELECTOR
c0203089:	66 b8 18 00          	mov    $0x18,%ax
	mov gs,ax
c020308d:	8e e8                	mov    %eax,%gs
	push ebx     ;传入void *
c020308f:	53                   	push   %ebx
	push ecx     ;传入int类型中断号
c0203090:	51                   	push   %ecx
;                              	es（扩展为32位）
;                               fs（扩展为32位）
;                               gs（扩展为32位）
;                               中断参数
; low addr            中断号
	call int_func_route
c0203091:	e8 15 32 00 00       	call   c02062ab <int_func_route>
;以下部分为中断退出结构
;C遵循函数调用者处理函数压入参数问题 所以使用add esp,8去除压入的两个参数（intr   AND    args）
;使用函数handle_int_exit_stack的开始位置
	add esp,8
c0203096:	83 c4 08             	add    $0x8,%esp
	pop eax
c0203099:	58                   	pop    %eax
	mov gs,ax
c020309a:	8e e8                	mov    %eax,%gs
	pop eax
c020309c:	58                   	pop    %eax
	mov fs,ax
c020309d:	8e e0                	mov    %eax,%fs
	pop eax
c020309f:	58                   	pop    %eax
	mov es,ax
c02030a0:	8e c0                	mov    %eax,%es
	popad
c02030a2:	61                   	popa   
	add esp,8
c02030a3:	83 c4 08             	add    $0x8,%esp
	mov al,0x20
c02030a6:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02030a8:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02030aa:	e6 20                	out    %al,$0x20
;此处的al是否需要保存？
	iret
c02030ac:	cf                   	iret   

c02030ad <isr0>:


NO_ERROCODE 0
c02030ad:	6a 00                	push   $0x0
c02030af:	6a 00                	push   $0x0
c02030b1:	eb ad                	jmp    c0203060 <pre_handle>

c02030b3 <isr1>:
NO_ERROCODE 1
c02030b3:	6a 00                	push   $0x0
c02030b5:	6a 01                	push   $0x1
c02030b7:	eb a7                	jmp    c0203060 <pre_handle>

c02030b9 <isr2>:
NO_ERROCODE 2
c02030b9:	6a 00                	push   $0x0
c02030bb:	6a 02                	push   $0x2
c02030bd:	eb a1                	jmp    c0203060 <pre_handle>

c02030bf <isr3>:
NO_ERROCODE 3
c02030bf:	6a 00                	push   $0x0
c02030c1:	6a 03                	push   $0x3
c02030c3:	eb 9b                	jmp    c0203060 <pre_handle>

c02030c5 <isr4>:
NO_ERROCODE 4
c02030c5:	6a 00                	push   $0x0
c02030c7:	6a 04                	push   $0x4
c02030c9:	eb 95                	jmp    c0203060 <pre_handle>

c02030cb <isr5>:
NO_ERROCODE 5
c02030cb:	6a 00                	push   $0x0
c02030cd:	6a 05                	push   $0x5
c02030cf:	eb 8f                	jmp    c0203060 <pre_handle>

c02030d1 <isr6>:
NO_ERROCODE 6
c02030d1:	6a 00                	push   $0x0
c02030d3:	6a 06                	push   $0x6
c02030d5:	eb 89                	jmp    c0203060 <pre_handle>

c02030d7 <isr7>:
NO_ERROCODE 7
c02030d7:	6a 00                	push   $0x0
c02030d9:	6a 07                	push   $0x7
c02030db:	eb 83                	jmp    c0203060 <pre_handle>

c02030dd <isr8>:
HAVE_ERROCODE 8
c02030dd:	90                   	nop
c02030de:	6a 08                	push   $0x8
c02030e0:	e9 7b ff ff ff       	jmp    c0203060 <pre_handle>

c02030e5 <isr9>:
NO_ERROCODE 9
c02030e5:	6a 00                	push   $0x0
c02030e7:	6a 09                	push   $0x9
c02030e9:	e9 72 ff ff ff       	jmp    c0203060 <pre_handle>

c02030ee <isr10>:
HAVE_ERROCODE 10
c02030ee:	90                   	nop
c02030ef:	6a 0a                	push   $0xa
c02030f1:	e9 6a ff ff ff       	jmp    c0203060 <pre_handle>

c02030f6 <isr11>:
HAVE_ERROCODE 11
c02030f6:	90                   	nop
c02030f7:	6a 0b                	push   $0xb
c02030f9:	e9 62 ff ff ff       	jmp    c0203060 <pre_handle>

c02030fe <isr12>:
HAVE_ERROCODE 12 
c02030fe:	90                   	nop
c02030ff:	6a 0c                	push   $0xc
c0203101:	e9 5a ff ff ff       	jmp    c0203060 <pre_handle>

c0203106 <isr13>:
HAVE_ERROCODE 13 
c0203106:	90                   	nop
c0203107:	6a 0d                	push   $0xd
c0203109:	e9 52 ff ff ff       	jmp    c0203060 <pre_handle>

c020310e <isr14>:
HAVE_ERROCODE 14
c020310e:	90                   	nop
c020310f:	6a 0e                	push   $0xe
c0203111:	e9 4a ff ff ff       	jmp    c0203060 <pre_handle>

c0203116 <isr15>:
NO_ERROCODE 15
c0203116:	6a 00                	push   $0x0
c0203118:	6a 0f                	push   $0xf
c020311a:	e9 41 ff ff ff       	jmp    c0203060 <pre_handle>

c020311f <isr16>:
NO_ERROCODE 16
c020311f:	6a 00                	push   $0x0
c0203121:	6a 10                	push   $0x10
c0203123:	e9 38 ff ff ff       	jmp    c0203060 <pre_handle>

c0203128 <isr17>:
HAVE_ERROCODE 17
c0203128:	90                   	nop
c0203129:	6a 11                	push   $0x11
c020312b:	e9 30 ff ff ff       	jmp    c0203060 <pre_handle>

c0203130 <isr18>:
NO_ERROCODE 18
c0203130:	6a 00                	push   $0x0
c0203132:	6a 12                	push   $0x12
c0203134:	e9 27 ff ff ff       	jmp    c0203060 <pre_handle>

c0203139 <isr19>:
NO_ERROCODE 19
c0203139:	6a 00                	push   $0x0
c020313b:	6a 13                	push   $0x13
c020313d:	e9 1e ff ff ff       	jmp    c0203060 <pre_handle>

c0203142 <isr20>:

NO_ERROCODE 20
c0203142:	6a 00                	push   $0x0
c0203144:	6a 14                	push   $0x14
c0203146:	e9 15 ff ff ff       	jmp    c0203060 <pre_handle>

c020314b <isr21>:
NO_ERROCODE 21
c020314b:	6a 00                	push   $0x0
c020314d:	6a 15                	push   $0x15
c020314f:	e9 0c ff ff ff       	jmp    c0203060 <pre_handle>

c0203154 <isr22>:
NO_ERROCODE 22
c0203154:	6a 00                	push   $0x0
c0203156:	6a 16                	push   $0x16
c0203158:	e9 03 ff ff ff       	jmp    c0203060 <pre_handle>

c020315d <isr23>:
NO_ERROCODE 23
c020315d:	6a 00                	push   $0x0
c020315f:	6a 17                	push   $0x17
c0203161:	e9 fa fe ff ff       	jmp    c0203060 <pre_handle>

c0203166 <isr24>:
NO_ERROCODE 24
c0203166:	6a 00                	push   $0x0
c0203168:	6a 18                	push   $0x18
c020316a:	e9 f1 fe ff ff       	jmp    c0203060 <pre_handle>

c020316f <isr25>:
NO_ERROCODE 25
c020316f:	6a 00                	push   $0x0
c0203171:	6a 19                	push   $0x19
c0203173:	e9 e8 fe ff ff       	jmp    c0203060 <pre_handle>

c0203178 <isr26>:
NO_ERROCODE 26
c0203178:	6a 00                	push   $0x0
c020317a:	6a 1a                	push   $0x1a
c020317c:	e9 df fe ff ff       	jmp    c0203060 <pre_handle>

c0203181 <isr27>:
NO_ERROCODE 27
c0203181:	6a 00                	push   $0x0
c0203183:	6a 1b                	push   $0x1b
c0203185:	e9 d6 fe ff ff       	jmp    c0203060 <pre_handle>

c020318a <isr28>:
NO_ERROCODE 28
c020318a:	6a 00                	push   $0x0
c020318c:	6a 1c                	push   $0x1c
c020318e:	e9 cd fe ff ff       	jmp    c0203060 <pre_handle>

c0203193 <isr29>:
NO_ERROCODE 29
c0203193:	6a 00                	push   $0x0
c0203195:	6a 1d                	push   $0x1d
c0203197:	e9 c4 fe ff ff       	jmp    c0203060 <pre_handle>

c020319c <isr30>:
NO_ERROCODE 30
c020319c:	6a 00                	push   $0x0
c020319e:	6a 1e                	push   $0x1e
c02031a0:	e9 bb fe ff ff       	jmp    c0203060 <pre_handle>

c02031a5 <isr31>:
NO_ERROCODE 31
c02031a5:	6a 00                	push   $0x0
c02031a7:	6a 1f                	push   $0x1f
c02031a9:	e9 b2 fe ff ff       	jmp    c0203060 <pre_handle>

c02031ae <isr32>:
NO_ERROCODE 32
c02031ae:	6a 00                	push   $0x0
c02031b0:	6a 20                	push   $0x20
c02031b2:	e9 a9 fe ff ff       	jmp    c0203060 <pre_handle>

c02031b7 <load_idt>:


[GLOBAL load_idt]
load_idt:
	mov eax, [esp+4]  ; 参数存入 eax 寄存器
c02031b7:	8b 44 24 04          	mov    0x4(%esp),%eax
    lidt [eax]        ; 加载到 IDTR
c02031bb:	0f 01 18             	lidtl  (%eax)
    ret
c02031be:	c3                   	ret    

c02031bf <get_cr2>:

[GLOBAL get_cr2]
[GLOBAL _CR2]
get_cr2:
	mov eax,cr2
c02031bf:	0f 20 d0             	mov    %cr2,%eax
	mov [_CR2],eax
c02031c2:	a3 c8 31 20 c0       	mov    %eax,0xc02031c8
	ret
c02031c7:	c3                   	ret    

c02031c8 <_CR2>:
_CR2:
c02031c8:	00 00                	add    %al,(%eax)
c02031ca:	00 00                	add    %al,(%eax)
c02031cc:	66 90                	xchg   %ax,%ax
c02031ce:	66 90                	xchg   %ax,%ax

c02031d0 <reload_gdt>:
[GLOBAL reload_gdt]
[GLOBAL exit_int]
;------------------------------------------------

reload_gdt:
    lgdt [gdt_ptr]
c02031d0:	0f 01 15 78 32 20 c0 	lgdtl  0xc0203278
    ret
c02031d7:	c3                   	ret    

c02031d8 <exit_int>:

;参数1   esp的值
;C语言原型     void *  exit_int(void* esp)     esp必须是栈指针（地址）
exit_int:
    mov eax,[esp+4]
c02031d8:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov esp,eax       ;修改栈位置
c02031dc:	89 c4                	mov    %eax,%esp
    ;以下部分是模拟中断中的执行返回(见interrupt_asm.s)
    add esp,8
c02031de:	83 c4 08             	add    $0x8,%esp
	pop eax
c02031e1:	58                   	pop    %eax
	mov gs,ax
c02031e2:	8e e8                	mov    %eax,%gs
	pop eax
c02031e4:	58                   	pop    %eax
	mov fs,ax
c02031e5:	8e e0                	mov    %eax,%fs
	pop eax
c02031e7:	58                   	pop    %eax
	mov es,ax
c02031e8:	8e c0                	mov    %eax,%es
	popad
c02031ea:	61                   	popa   
	add esp,4
c02031eb:	83 c4 04             	add    $0x4,%esp


	cli
c02031ee:	fa                   	cli    

	mov eax,[esp]
c02031ef:	8b 04 24             	mov    (%esp),%eax
	push eax
c02031f2:	50                   	push   %eax
	call print_debug_1
c02031f3:	e8 9f 40 00 00       	call   c0207297 <print_debug_1>
	pop eax
c02031f8:	58                   	pop    %eax

    mov eax,[esp+4]
c02031f9:	8b 44 24 04          	mov    0x4(%esp),%eax
    	push eax
c02031fd:	50                   	push   %eax
    	call print_debug_1
c02031fe:	e8 94 40 00 00       	call   c0207297 <print_debug_1>
    	pop eax
c0203203:	58                   	pop    %eax
    mov eax,[esp+8]
c0203204:	8b 44 24 08          	mov    0x8(%esp),%eax
        	push eax
c0203208:	50                   	push   %eax
        	call print_debug_1
c0203209:	e8 89 40 00 00       	call   c0207297 <print_debug_1>
        	pop eax
c020320e:	58                   	pop    %eax
       mov eax,[esp+12]
c020320f:	8b 44 24 0c          	mov    0xc(%esp),%eax
           	push eax
c0203213:	50                   	push   %eax
           	call print_debug_1
c0203214:	e8 7e 40 00 00       	call   c0207297 <print_debug_1>
           	pop eax
c0203219:	58                   	pop    %eax
       mov eax,[esp+16]
c020321a:	8b 44 24 10          	mov    0x10(%esp),%eax
           	push eax
c020321e:	50                   	push   %eax
           	call print_debug_1
c020321f:	e8 73 40 00 00       	call   c0207297 <print_debug_1>
           	pop eax
c0203224:	58                   	pop    %eax
    jmp $
c0203225:	eb fe                	jmp    c0203225 <exit_int+0x4d>
;由于start_user_task函数执行时一定是因为时钟中断的线程调度  调度完成以后就已经打开了中断并且设置了8259A   
;执行到此步时无需再次打开8259A   
	;mov al,0x20
	;out 0xA0,al
	;out 0x20,al
c0203227:	cf                   	iret   
c0203228:	66 90                	xchg   %ax,%ax
c020322a:	66 90                	xchg   %ax,%ax
c020322c:	66 90                	xchg   %ax,%ax
c020322e:	66 90                	xchg   %ax,%ax

c0203230 <GDT_BASE>:
	...

c0203238 <CODE_DESC>:
[GLOBAL gdt_ptr]
; GDT安装位置
   GDT_BASE:   dd    0x00000000 
           	   dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
c0203238:	ff ff 00 00 00 98 cf 00                             ........

c0203240 <DATA_STACK_DESC>:
               dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
c0203240:	ff ff 00 00 00 92 cf 00                             ........

c0203248 <VIDEO_DESC>:
                     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007        ; limit=(0xbffff-0xb8000)/4k=0x7
c0203248:	07 00 00 80 0b 92 c0 00                             ........

c0203250 <USER_CODE_DESC>:
               dd    DESC_VIDEO_HIGH4  ; 此时dpl为0

    ;---------新增段描述符-----------
    ;用户代码段与数据段
    USER_CODE_DESC: dd 0x0000FFFF
c0203250:	ff ff 00 00 00 f8 cf 00                             ........

c0203258 <USER_DATA_DESC>:
                dd   DESC_USER_CODE_HIGH4

    USER_DATA_DESC: dd 0x0000FFFF
c0203258:	ff ff 00 00 00 f2 cf 00                             ........

c0203260 <TSS_CPU0>:
	...

c0203268 <SELECTOR_CODE_MEM>:
   SELECTOR_USER_CODE equ (0x0004<<3) + TI_GDT + RPL3
   SELECTOR_USER_DATA equ (0x0005<<3) + TI_GDT + RPL3
   SELECTOR_TSS_CPU0 equ (0x0006<<3) + TI_GDT +RPL0
   

   SELECTOR_CODE_MEM dw SELECTOR_CODE
c0203268:	08 00                	or     %al,(%eax)

c020326a <SELECTOR_DATA_MEM>:
   SELECTOR_DATA_MEM dw SELECTOR_DATA
c020326a:	10 00                	adc    %al,(%eax)

c020326c <SELECTOR_VIDEO_MEM>:
   SELECTOR_VIDEO_MEM dw SELECTOR_VIDEO
c020326c:	18 00                	sbb    %al,(%eax)

c020326e <SELECTOR_USER_CODE_MEM>:
   SELECTOR_USER_CODE_MEM dw SELECTOR_USER_CODE
c020326e:	23 00                	and    (%eax),%eax

c0203270 <SELECTOR_USER_DATA_MEM>:
   SELECTOR_USER_DATA_MEM dw SELECTOR_USER_DATA
c0203270:	2b 00                	sub    (%eax),%eax

c0203272 <SELECTOR_TSS_CPU0_MEM>:
   SELECTOR_TSS_CPU0_MEM dw SELECTOR_TSS_CPU0
c0203272:	30 00                	xor    %al,(%eax)

c0203274 <total_mem_bytes>:
   


   total_mem_bytes dd 0                  
c0203274:	00 00 00 00                                         ....

c0203278 <gdt_ptr>:
   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址
   gdt_ptr  dw  GDT_LIMIT 
c0203278:	37                   	aaa    
c0203279:	00 30                	add    %dh,(%eax)
        	dd  GDT_BASE
c020327b:	32 20                	xor    (%eax),%ah
c020327d:	c0                   	.byte 0xc0

c020327e <boot_start_after_set_paging>:
;boot开始！
boot_start_after_set_paging:        ;此处修改了函数名     在设置好页表后调用此函数
    mov ebx,[temp_mboot_ptr]     ;此处将暂存的mboot信息取出    但是一定要注意：必须要前4MB的物理-虚拟内存映射才能够使用
c020327e:	8b 1d 0c 00 10 00    	mov    0x10000c,%ebx
    mov [mboot_ptr], ebx ; GRUB加载内核后会将mutiboot信息地址存放在ebx中
c0203284:	89 1d 10 80 20 c0    	mov    %ebx,0xc0208010
    ;-----------------   准备进入保护模式   -------------------
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1
   ;-----------------  打开A20  ----------------
    in al,0x92
c020328a:	e4 92                	in     $0x92,%al
    or al,0000_0010B
c020328c:	0c 02                	or     $0x2,%al
    out 0x92,al
c020328e:	e6 92                	out    %al,$0x92
   ;-----------------  加载GDT  ----------------
   ; 注意：lgdt装载的低32位是线性地址（逻辑地址----》线性地址------》物理地址）
   ; 所有的段的实际偏移都是0    故线性地址等效于逻辑地址   即虚拟地址    所以此处gdt_ptr内容中低32位实际上是GDT的虚拟地址   
    lgdt [gdt_ptr]
c0203290:	0f 01 15 78 32 20 c0 	lgdtl  0xc0203278
   ;-----------------  cr0第0位置1  ----------------
    mov eax, cr0
c0203297:	0f 20 c0             	mov    %cr0,%eax
    or eax, 0x00000001
c020329a:	83 c8 01             	or     $0x1,%eax
    mov cr0, eax
c020329d:	0f 22 c0             	mov    %eax,%cr0
    jmp dword SELECTOR_CODE:far_jmp_target      ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
c02032a0:	ea a7 32 20 c0 08 00 	ljmp   $0x8,$0xc02032a7

c02032a7 <far_jmp_target>:

;初始化段寄存器以及栈结构
    far_jmp_target:
    mov ax,SELECTOR_DATA
c02032a7:	66 b8 10 00          	mov    $0x10,%ax
    mov ss,ax
c02032ab:	8e d0                	mov    %eax,%ss
    mov ds,ax
c02032ad:	8e d8                	mov    %eax,%ds
  	mov ax,SELECTOR_VIDEO
c02032af:	66 b8 18 00          	mov    $0x18,%ax
  	mov gs,ax
c02032b3:	8e e8                	mov    %eax,%gs
    mov esp, STACK_TOP      
c02032b5:	bc 03 20 29 c0       	mov    $0xc0292003,%esp
    and esp, 0xFFFFFFF0  ;16字节对齐
c02032ba:	83 e4 f0             	and    $0xfffffff0,%esp
    mov ebp, 0         
c02032bd:	bd 00 00 00 00       	mov    $0x0,%ebp
    mov eax,kern_bitmap_block
c02032c2:	b8 00 a0 20 c0       	mov    $0xc020a000,%eax
    mov [kern_bitmap],eax
c02032c7:	a3 0c 80 20 c0       	mov    %eax,0xc020800c
    mov eax,kern_dir_table
c02032cc:	b8 00 10 10 00       	mov    $0x101000,%eax
    mov [kern_dir_table_paddr],eax
c02032d1:	a3 14 80 20 c0       	mov    %eax,0xc0208014
    mov eax,kern_page_table
c02032d6:	b8 00 20 10 00       	mov    $0x102000,%eax
    mov [kern_page_table_paddr],eax
c02032db:	a3 18 80 20 c0       	mov    %eax,0xc0208018
;进入内核主函数    
    cli
c02032e0:	fa                   	cli    
    call kern_entry                    
c02032e1:	e8 b8 38 00 00       	call   c0206b9e <kern_entry>
    jmp dword $          ;防止意外退出内核
c02032e6:	e9 fb ff ff ff       	jmp    c02032e6 <far_jmp_target+0x3f>

c02032eb <bitmap_init_mem>:
#include "string.h"
#include "printk.h"
//4KB为一个页来管理

//初始化目标bitmap的内存区域
void bitmap_init_mem(bitmap bm){
c02032eb:	55                   	push   %ebp
c02032ec:	89 e5                	mov    %esp,%ebp
c02032ee:	53                   	push   %ebx
c02032ef:	83 ec 14             	sub    $0x14,%esp
c02032f2:	e8 0d 4d 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02032f7:	81 c3 09 5d 00 00    	add    $0x5d09,%ebx
    printk("bitmap init mem=%h,%h,%h\n",bm.target_addr_header,bm.vaddr_header,bm.length);
c02032fd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0203300:	8b 55 08             	mov    0x8(%ebp),%edx
c0203303:	8b 45 10             	mov    0x10(%ebp),%eax
c0203306:	51                   	push   %ecx
c0203307:	52                   	push   %edx
c0203308:	50                   	push   %eax
c0203309:	8d 83 18 00 00 00    	lea    0x18(%ebx),%eax
c020330f:	50                   	push   %eax
c0203310:	e8 52 40 00 00       	call   c0207367 <printk>
c0203315:	83 c4 10             	add    $0x10,%esp
    uint32_t length = bm.length;
c0203318:	8b 45 0c             	mov    0xc(%ebp),%eax
c020331b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c020331e:	8b 45 08             	mov    0x8(%ebp),%eax
c0203321:	89 45 f0             	mov    %eax,-0x10(%ebp)
//    for(uint32_t i = 0;i<length;i++){
//        *((byte*)(vaddr_header+i)) = 255;   //11111111b
//    }
    memset(vaddr_header,255,length);
c0203324:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203327:	83 ec 04             	sub    $0x4,%esp
c020332a:	ff 75 f4             	pushl  -0xc(%ebp)
c020332d:	68 ff 00 00 00       	push   $0xff
c0203332:	50                   	push   %eax
c0203333:	e8 f2 46 00 00       	call   c0207a2a <memset>
c0203338:	83 c4 10             	add    $0x10,%esp
}
c020333b:	90                   	nop
c020333c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020333f:	c9                   	leave  
c0203340:	c3                   	ret    

c0203341 <bitmap_alloc_one_page>:


//指定分配目标页  0xc0293ca0
//分配成功：返回目标页起始地址
//分配失败：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc_one_page(bitmap bm,uint32_t target){
c0203341:	55                   	push   %ebp
c0203342:	89 e5                	mov    %esp,%ebp
c0203344:	83 ec 20             	sub    $0x20,%esp
c0203347:	e8 b4 4c 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020334c:	05 b4 5c 00 00       	add    $0x5cb4,%eax
    uint32_t lenght = bm.length;
c0203351:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203354:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0203357:	8b 45 08             	mov    0x8(%ebp),%eax
c020335a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c020335d:	8b 45 10             	mov    0x10(%ebp),%eax
c0203360:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0203363:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;   //必须要-1 否则可能造成max_addr溢出为0
c020336a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020336d:	c1 e0 0f             	shl    $0xf,%eax
c0203370:	89 c2                	mov    %eax,%edx
c0203372:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203375:	01 d0                	add    %edx,%eax
c0203377:	83 e8 01             	sub    $0x1,%eax
c020337a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c020337d:	8b 45 14             	mov    0x14(%ebp),%eax
c0203380:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0203383:	0f 82 8e 00 00 00    	jb     c0203417 <bitmap_alloc_one_page+0xd6>
c0203389:	8b 45 14             	mov    0x14(%ebp),%eax
c020338c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c020338f:	0f 83 82 00 00 00    	jae    c0203417 <bitmap_alloc_one_page+0xd6>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c0203395:	8b 45 14             	mov    0x14(%ebp),%eax
c0203398:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020339b:	c1 e8 0c             	shr    $0xc,%eax
c020339e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c02033a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02033a4:	8d 50 07             	lea    0x7(%eax),%edx
c02033a7:	85 c0                	test   %eax,%eax
c02033a9:	0f 48 c2             	cmovs  %edx,%eax
c02033ac:	c1 f8 03             	sar    $0x3,%eax
c02033af:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c02033b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02033b5:	99                   	cltd   
c02033b6:	c1 ea 1d             	shr    $0x1d,%edx
c02033b9:	01 d0                	add    %edx,%eax
c02033bb:	83 e0 07             	and    $0x7,%eax
c02033be:	29 d0                	sub    %edx,%eax
c02033c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c02033c3:	b8 07 00 00 00       	mov    $0x7,%eax
c02033c8:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c02033cb:	ba 01 00 00 00       	mov    $0x1,%edx
c02033d0:	89 c1                	mov    %eax,%ecx
c02033d2:	d3 e2                	shl    %cl,%edx
c02033d4:	89 d0                	mov    %edx,%eax
c02033d6:	88 45 e3             	mov    %al,-0x1d(%ebp)
        byte target_byte = *((byte*)(vaddr_header+i));
c02033d9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02033dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02033df:	01 d0                	add    %edx,%eax
c02033e1:	0f b6 00             	movzbl (%eax),%eax
c02033e4:	88 45 e2             	mov    %al,-0x1e(%ebp)
        if(target_byte== (target_byte| byte_mask)){
c02033e7:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
c02033eb:	0a 45 e3             	or     -0x1d(%ebp),%al
c02033ee:	38 45 e2             	cmp    %al,-0x1e(%ebp)
c02033f1:	75 1d                	jne    c0203410 <bitmap_alloc_one_page+0xcf>
            //此时目标bit为1 空闲状态
            *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) - byte_mask;
c02033f3:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02033f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02033f9:	01 d0                	add    %edx,%eax
c02033fb:	0f b6 00             	movzbl (%eax),%eax
c02033fe:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0203401:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0203404:	01 ca                	add    %ecx,%edx
c0203406:	2a 45 e3             	sub    -0x1d(%ebp),%al
c0203409:	88 02                	mov    %al,(%edx)
            return target;    
c020340b:	8b 45 14             	mov    0x14(%ebp),%eax
c020340e:	eb 0c                	jmp    c020341c <bitmap_alloc_one_page+0xdb>
        }
        else{
            //此时目标bit为0     忙碌状态
            return BITMAP_RETURN_ERRO;
c0203410:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0203415:	eb 05                	jmp    c020341c <bitmap_alloc_one_page+0xdb>
        }   
    }
    else{
        return BITMAP_RETURN_ERRO;
c0203417:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c020341c:	c9                   	leave  
c020341d:	c3                   	ret    

c020341e <bitmap_release_one_page>:

//BUG!!!!!!!!
//释放指定的目标页
//释放成功或者失败都不会返回信息
void bitmap_release_one_page(bitmap bm,uint32_t target){
c020341e:	55                   	push   %ebp
c020341f:	89 e5                	mov    %esp,%ebp
c0203421:	83 ec 20             	sub    $0x20,%esp
c0203424:	e8 d7 4b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203429:	05 d7 5b 00 00       	add    $0x5bd7,%eax
    uint32_t lenght = bm.length;
c020342e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203431:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0203434:	8b 45 08             	mov    0x8(%ebp),%eax
c0203437:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c020343a:	8b 45 10             	mov    0x10(%ebp),%eax
c020343d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0203440:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;
c0203447:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020344a:	c1 e0 0f             	shl    $0xf,%eax
c020344d:	89 c2                	mov    %eax,%edx
c020344f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203452:	01 d0                	add    %edx,%eax
c0203454:	83 e8 01             	sub    $0x1,%eax
c0203457:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c020345a:	8b 45 14             	mov    0x14(%ebp),%eax
c020345d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0203460:	72 64                	jb     c02034c6 <bitmap_release_one_page+0xa8>
c0203462:	8b 45 14             	mov    0x14(%ebp),%eax
c0203465:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0203468:	73 5c                	jae    c02034c6 <bitmap_release_one_page+0xa8>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c020346a:	8b 45 14             	mov    0x14(%ebp),%eax
c020346d:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0203470:	c1 e8 0c             	shr    $0xc,%eax
c0203473:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c0203476:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203479:	8d 50 07             	lea    0x7(%eax),%edx
c020347c:	85 c0                	test   %eax,%eax
c020347e:	0f 48 c2             	cmovs  %edx,%eax
c0203481:	c1 f8 03             	sar    $0x3,%eax
c0203484:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c0203487:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020348a:	99                   	cltd   
c020348b:	c1 ea 1d             	shr    $0x1d,%edx
c020348e:	01 d0                	add    %edx,%eax
c0203490:	83 e0 07             	and    $0x7,%eax
c0203493:	29 d0                	sub    %edx,%eax
c0203495:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c0203498:	b8 07 00 00 00       	mov    $0x7,%eax
c020349d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c02034a0:	ba 01 00 00 00       	mov    $0x1,%edx
c02034a5:	89 c1                	mov    %eax,%ecx
c02034a7:	d3 e2                	shl    %cl,%edx
c02034a9:	89 d0                	mov    %edx,%eax
c02034ab:	88 45 e3             	mov    %al,-0x1d(%ebp)
        *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) | byte_mask;
c02034ae:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02034b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02034b4:	01 d0                	add    %edx,%eax
c02034b6:	0f b6 00             	movzbl (%eax),%eax
c02034b9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c02034bc:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02034bf:	01 ca                	add    %ecx,%edx
c02034c1:	0a 45 e3             	or     -0x1d(%ebp),%al
c02034c4:	88 02                	mov    %al,(%edx)
    }
}
c02034c6:	90                   	nop
c02034c7:	c9                   	leave  
c02034c8:	c3                   	ret    

c02034c9 <bitmap_alloc>:

//任意分配 未指定分配的目标
//分配成功：返回目标页起始地址
//没有可用页：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc(bitmap bm){
c02034c9:	55                   	push   %ebp
c02034ca:	89 e5                	mov    %esp,%ebp
c02034cc:	83 ec 30             	sub    $0x30,%esp
c02034cf:	e8 2c 4b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02034d4:	05 2c 5b 00 00       	add    $0x5b2c,%eax
    uint32_t lenght = bm.length;
c02034d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c02034dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02034df:	8b 45 08             	mov    0x8(%ebp),%eax
c02034e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c02034e5:	8b 45 10             	mov    0x10(%ebp),%eax
c02034e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(uint32_t i =0;i<lenght;i++){
c02034eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c02034f2:	e9 96 00 00 00       	jmp    c020358d <bitmap_alloc+0xc4>
        byte * byte_ptr = (byte*)(vaddr_header+i);
c02034f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02034fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02034fd:	01 d0                	add    %edx,%eax
c02034ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
        byte byte_now = *byte_ptr ;
c0203502:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0203505:	0f b6 00             	movzbl (%eax),%eax
c0203508:	88 45 fb             	mov    %al,-0x5(%ebp)
        if(byte_now != 0x00){
c020350b:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c020350f:	74 78                	je     c0203589 <bitmap_alloc+0xc0>
            int pos;     //在本字节中目标bit所在位置（从左往右 从0开始）
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0203511:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0203518:	eb 22                	jmp    c020353c <bitmap_alloc+0x73>
                byte temp_byte = (byte_now)&(0x7F);    // 01111-1111b
c020351a:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c020351e:	83 e0 7f             	and    $0x7f,%eax
c0203521:	88 45 df             	mov    %al,-0x21(%ebp)
                if(byte_now!=temp_byte){
c0203524:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0203528:	3a 45 df             	cmp    -0x21(%ebp),%al
c020352b:	74 08                	je     c0203535 <bitmap_alloc+0x6c>
                    pos = j;
c020352d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203530:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    break;
c0203533:	eb 0d                	jmp    c0203542 <bitmap_alloc+0x79>
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0203535:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0203539:	d0 65 fb             	shlb   -0x5(%ebp)
c020353c:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c0203540:	7e d8                	jle    c020351a <bitmap_alloc+0x51>
                }
            }
            byte byte_sub = 0x01<<(7-pos);     //1=00000001b
c0203542:	b8 07 00 00 00       	mov    $0x7,%eax
c0203547:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020354a:	ba 01 00 00 00       	mov    $0x1,%edx
c020354f:	89 c1                	mov    %eax,%ecx
c0203551:	d3 e2                	shl    %cl,%edx
c0203553:	89 d0                	mov    %edx,%eax
c0203555:	88 45 de             	mov    %al,-0x22(%ebp)
            *byte_ptr = *byte_ptr-byte_sub;
c0203558:	8b 45 e0             	mov    -0x20(%ebp),%eax
c020355b:	0f b6 00             	movzbl (%eax),%eax
c020355e:	2a 45 de             	sub    -0x22(%ebp),%al
c0203561:	89 c2                	mov    %eax,%edx
c0203563:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0203566:	88 10                	mov    %dl,(%eax)
            int page_no = i*8+pos;
c0203568:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020356b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0203572:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203575:	01 d0                	add    %edx,%eax
c0203577:	89 45 d8             	mov    %eax,-0x28(%ebp)
            return page_no*PAGE_SIZE+target_addr_header;
c020357a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020357d:	c1 e0 0c             	shl    $0xc,%eax
c0203580:	89 c2                	mov    %eax,%edx
c0203582:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0203585:	01 d0                	add    %edx,%eax
c0203587:	eb 15                	jmp    c020359e <bitmap_alloc+0xd5>
    for(uint32_t i =0;i<lenght;i++){
c0203589:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c020358d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203590:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0203593:	0f 82 5e ff ff ff    	jb     c02034f7 <bitmap_alloc+0x2e>
        }
    }
    return BITMAP_RETURN_ERRO;
c0203599:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c020359e:	c9                   	leave  
c020359f:	c3                   	ret    

c02035a0 <print_mem>:

void print_mem(bitmap bm){
c02035a0:	55                   	push   %ebp
c02035a1:	89 e5                	mov    %esp,%ebp
c02035a3:	53                   	push   %ebx
c02035a4:	83 ec 14             	sub    $0x14,%esp
c02035a7:	e8 54 4a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02035ac:	05 54 5a 00 00       	add    $0x5a54,%eax
    uint32_t addr = bm.vaddr_header;
c02035b1:	8b 55 08             	mov    0x8(%ebp),%edx
c02035b4:	89 55 f4             	mov    %edx,-0xc(%ebp)
    printk("4BYTES:%h\n",*(uint32_t*)addr);
c02035b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02035ba:	8b 12                	mov    (%edx),%edx
c02035bc:	83 ec 08             	sub    $0x8,%esp
c02035bf:	52                   	push   %edx
c02035c0:	8d 90 32 00 00 00    	lea    0x32(%eax),%edx
c02035c6:	52                   	push   %edx
c02035c7:	89 c3                	mov    %eax,%ebx
c02035c9:	e8 99 3d 00 00       	call   c0207367 <printk>
c02035ce:	83 c4 10             	add    $0x10,%esp
}
c02035d1:	90                   	nop
c02035d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02035d5:	c9                   	leave  
c02035d6:	c3                   	ret    

c02035d7 <bitmap_test>:

void bitmap_test(){
c02035d7:	55                   	push   %ebp
c02035d8:	89 e5                	mov    %esp,%ebp
c02035da:	53                   	push   %ebx
c02035db:	83 ec 24             	sub    $0x24,%esp
c02035de:	e8 21 4a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02035e3:	81 c3 1d 5a 00 00    	add    $0x5a1d,%ebx
    void clear_screen();
    clear_screen();
c02035e9:	e8 20 38 00 00       	call   c0206e0e <clear_screen>
    extern uint32_t kern_bitmap;
    bitmap bm;
    bm.vaddr_header = kern_bitmap;
c02035ee:	c7 c0 0c 80 20 c0    	mov    $0xc020800c,%eax
c02035f4:	8b 00                	mov    (%eax),%eax
c02035f6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bm.length=4;
c02035f9:	c7 45 dc 04 00 00 00 	movl   $0x4,-0x24(%ebp)
    bm.target_addr_header = 0x1000;
c0203600:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
    bitmap_init_mem(bm);
c0203607:	83 ec 04             	sub    $0x4,%esp
c020360a:	ff 75 e0             	pushl  -0x20(%ebp)
c020360d:	ff 75 dc             	pushl  -0x24(%ebp)
c0203610:	ff 75 d8             	pushl  -0x28(%ebp)
c0203613:	e8 d3 fc ff ff       	call   c02032eb <bitmap_init_mem>
c0203618:	83 c4 10             	add    $0x10,%esp
    print_mem(bm);
c020361b:	83 ec 04             	sub    $0x4,%esp
c020361e:	ff 75 e0             	pushl  -0x20(%ebp)
c0203621:	ff 75 dc             	pushl  -0x24(%ebp)
c0203624:	ff 75 d8             	pushl  -0x28(%ebp)
c0203627:	e8 74 ff ff ff       	call   c02035a0 <print_mem>
c020362c:	83 c4 10             	add    $0x10,%esp
    while(1){
        uint32_t addr_head = bitmap_alloc(bm);
c020362f:	83 ec 04             	sub    $0x4,%esp
c0203632:	ff 75 e0             	pushl  -0x20(%ebp)
c0203635:	ff 75 dc             	pushl  -0x24(%ebp)
c0203638:	ff 75 d8             	pushl  -0x28(%ebp)
c020363b:	e8 89 fe ff ff       	call   c02034c9 <bitmap_alloc>
c0203640:	83 c4 10             	add    $0x10,%esp
c0203643:	89 45 e8             	mov    %eax,-0x18(%ebp)
        printk("addr:0x%h\n",addr_head);
c0203646:	83 ec 08             	sub    $0x8,%esp
c0203649:	ff 75 e8             	pushl  -0x18(%ebp)
c020364c:	8d 83 3d 00 00 00    	lea    0x3d(%ebx),%eax
c0203652:	50                   	push   %eax
c0203653:	e8 0f 3d 00 00       	call   c0207367 <printk>
c0203658:	83 c4 10             	add    $0x10,%esp
        uint32_t addr_probe=addr_head;
c020365b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020365e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        print_mem(bm);
c0203661:	83 ec 04             	sub    $0x4,%esp
c0203664:	ff 75 e0             	pushl  -0x20(%ebp)
c0203667:	ff 75 dc             	pushl  -0x24(%ebp)
c020366a:	ff 75 d8             	pushl  -0x28(%ebp)
c020366d:	e8 2e ff ff ff       	call   c02035a0 <print_mem>
c0203672:	83 c4 10             	add    $0x10,%esp
        for(int i = 0; i<23;i++){
c0203675:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020367c:	eb 50                	jmp    c02036ce <bitmap_test+0xf7>
            addr_probe +=0x1000;
c020367e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
            uint32_t alloc_addr=bitmap_alloc_one_page(bm,addr_probe);
c0203685:	ff 75 f4             	pushl  -0xc(%ebp)
c0203688:	ff 75 e0             	pushl  -0x20(%ebp)
c020368b:	ff 75 dc             	pushl  -0x24(%ebp)
c020368e:	ff 75 d8             	pushl  -0x28(%ebp)
c0203691:	e8 ab fc ff ff       	call   c0203341 <bitmap_alloc_one_page>
c0203696:	83 c4 10             	add    $0x10,%esp
c0203699:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            print_mem(bm);
c020369c:	83 ec 04             	sub    $0x4,%esp
c020369f:	ff 75 e0             	pushl  -0x20(%ebp)
c02036a2:	ff 75 dc             	pushl  -0x24(%ebp)
c02036a5:	ff 75 d8             	pushl  -0x28(%ebp)
c02036a8:	e8 f3 fe ff ff       	call   c02035a0 <print_mem>
c02036ad:	83 c4 10             	add    $0x10,%esp
            if(alloc_addr==BITMAP_RETURN_ERRO){
c02036b0:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c02036b4:	75 14                	jne    c02036ca <bitmap_test+0xf3>
                printk("ERRO");
c02036b6:	83 ec 0c             	sub    $0xc,%esp
c02036b9:	8d 83 48 00 00 00    	lea    0x48(%ebx),%eax
c02036bf:	50                   	push   %eax
c02036c0:	e8 a2 3c 00 00       	call   c0207367 <printk>
c02036c5:	83 c4 10             	add    $0x10,%esp
                while (1);
c02036c8:	eb fe                	jmp    c02036c8 <bitmap_test+0xf1>
        for(int i = 0; i<23;i++){
c02036ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02036ce:	83 7d f0 16          	cmpl   $0x16,-0x10(%ebp)
c02036d2:	7e aa                	jle    c020367e <bitmap_test+0xa7>
            }
        }
        printk("bit map alloc all:");
c02036d4:	83 ec 0c             	sub    $0xc,%esp
c02036d7:	8d 83 4d 00 00 00    	lea    0x4d(%ebx),%eax
c02036dd:	50                   	push   %eax
c02036de:	e8 84 3c 00 00       	call   c0207367 <printk>
c02036e3:	83 c4 10             	add    $0x10,%esp
        print_mem(bm);
c02036e6:	83 ec 04             	sub    $0x4,%esp
c02036e9:	ff 75 e0             	pushl  -0x20(%ebp)
c02036ec:	ff 75 dc             	pushl  -0x24(%ebp)
c02036ef:	ff 75 d8             	pushl  -0x28(%ebp)
c02036f2:	e8 a9 fe ff ff       	call   c02035a0 <print_mem>
c02036f7:	83 c4 10             	add    $0x10,%esp
        printk("start release");
c02036fa:	83 ec 0c             	sub    $0xc,%esp
c02036fd:	8d 83 60 00 00 00    	lea    0x60(%ebx),%eax
c0203703:	50                   	push   %eax
c0203704:	e8 5e 3c 00 00       	call   c0207367 <printk>
c0203709:	83 c4 10             	add    $0x10,%esp
        addr_probe = addr_head;
c020370c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020370f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(int i = 0;i<24;i++){
c0203712:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0203719:	eb 33                	jmp    c020374e <bitmap_test+0x177>
            bitmap_release_one_page(bm,addr_probe);
c020371b:	ff 75 f4             	pushl  -0xc(%ebp)
c020371e:	ff 75 e0             	pushl  -0x20(%ebp)
c0203721:	ff 75 dc             	pushl  -0x24(%ebp)
c0203724:	ff 75 d8             	pushl  -0x28(%ebp)
c0203727:	e8 f2 fc ff ff       	call   c020341e <bitmap_release_one_page>
c020372c:	83 c4 10             	add    $0x10,%esp
            print_mem(bm);
c020372f:	83 ec 04             	sub    $0x4,%esp
c0203732:	ff 75 e0             	pushl  -0x20(%ebp)
c0203735:	ff 75 dc             	pushl  -0x24(%ebp)
c0203738:	ff 75 d8             	pushl  -0x28(%ebp)
c020373b:	e8 60 fe ff ff       	call   c02035a0 <print_mem>
c0203740:	83 c4 10             	add    $0x10,%esp
            addr_probe+=0x1000;
c0203743:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
        for(int i = 0;i<24;i++){
c020374a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c020374e:	83 7d ec 17          	cmpl   $0x17,-0x14(%ebp)
c0203752:	7e c7                	jle    c020371b <bitmap_test+0x144>
    while(1){
c0203754:	e9 d6 fe ff ff       	jmp    c020362f <bitmap_test+0x58>

c0203759 <get_running_progress>:
TCB_t main_TCB;    //内核主线程TCB
TCB_t* cur_tcb;
static char* LOG_SRC_THREADS = "THREADS";


TCB_t* get_running_progress(){
c0203759:	55                   	push   %ebp
c020375a:	89 e5                	mov    %esp,%ebp
c020375c:	e8 9f 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203761:	05 9f 58 00 00       	add    $0x589f,%eax
	return cur_tcb;
c0203766:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c020376c:	8b 00                	mov    (%eax),%eax
}
c020376e:	5d                   	pop    %ebp
c020376f:	c3                   	ret    

c0203770 <check_kern_stack_overflow>:

bool check_kern_stack_overflow(TCB_t* tcb_ptr){
c0203770:	55                   	push   %ebp
c0203771:	89 e5                	mov    %esp,%ebp
c0203773:	e8 88 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203778:	05 88 58 00 00       	add    $0x5888,%eax
	if(tcb_ptr->tcb_magic_number==TCB_MAGIC_NUMBER){
c020377d:	8b 45 08             	mov    0x8(%ebp),%eax
c0203780:	8b 40 54             	mov    0x54(%eax),%eax
c0203783:	3d ab 21 0d fc       	cmp    $0xfc0d21ab,%eax
c0203788:	75 07                	jne    c0203791 <check_kern_stack_overflow+0x21>
		return True;
c020378a:	b8 01 00 00 00       	mov    $0x1,%eax
c020378f:	eb 05                	jmp    c0203796 <check_kern_stack_overflow+0x26>
	}
	else{
		return False;
c0203791:	b8 00 00 00 00       	mov    $0x0,%eax
	}	
}
c0203796:	5d                   	pop    %ebp
c0203797:	c3                   	ret    

c0203798 <kern_overflow_handler>:

static void kern_overflow_handler(TCB_t * tcb_ptr){
c0203798:	55                   	push   %ebp
c0203799:	89 e5                	mov    %esp,%ebp
c020379b:	53                   	push   %ebx
c020379c:	83 ec 14             	sub    $0x14,%esp
c020379f:	e8 5c 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02037a4:	05 5c 58 00 00       	add    $0x585c,%eax
	uint32_t tid = tcb_ptr->tid;
c02037a9:	8b 55 08             	mov    0x8(%ebp),%edx
c02037ac:	8b 52 14             	mov    0x14(%edx),%edx
c02037af:	89 55 f4             	mov    %edx,-0xc(%ebp)
	STOP(LOG_SRC_THREADS,"Thread Kern Stack Overflow!STOP!");
c02037b2:	8b 90 0c 00 00 00    	mov    0xc(%eax),%edx
c02037b8:	83 ec 08             	sub    $0x8,%esp
c02037bb:	8d 88 78 00 00 00    	lea    0x78(%eax),%ecx
c02037c1:	51                   	push   %ecx
c02037c2:	52                   	push   %edx
c02037c3:	89 c3                	mov    %eax,%ebx
c02037c5:	e8 bd 20 00 00       	call   c0205887 <stop_kern>
c02037ca:	83 c4 10             	add    $0x10,%esp
}
c02037cd:	90                   	nop
c02037ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02037d1:	c9                   	leave  
c02037d2:	c3                   	ret    

c02037d3 <_init_main_thread>:
//主要功能： 1 页表切换   2  tss栈修改    
// static void active_task(TCB_t * next){
	
// }

static void  _init_main_thread(TCB_t * main_tcb){
c02037d3:	55                   	push   %ebp
c02037d4:	89 e5                	mov    %esp,%ebp
c02037d6:	83 ec 10             	sub    $0x10,%esp
c02037d9:	e8 22 48 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02037de:	05 22 58 00 00       	add    $0x5822,%eax
	TCB_t *tcb_buffer_addr = main_tcb;
c02037e3:	8b 45 08             	mov    0x8(%ebp),%eax
c02037e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = 0;        //主线程的编号为0  
c02037e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037ec:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c02037f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02037f6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c02037fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203800:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c0203807:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020380a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=0;   //主线程不会被回收内存 所以可以任意赋值
c0203811:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203814:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	tcb_buffer_addr->page_addr=0;
c020381b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020381e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	tcb_buffer_addr->next = tcb_buffer_addr;
c0203825:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203828:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020382b:	89 50 10             	mov    %edx,0x10(%eax)
	tcb_buffer_addr->kern_stack_top=0;
c020382e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203831:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	tcb_buffer_addr->is_kern_thread = True;
c0203837:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020383a:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%eax)
	tcb_buffer_addr->tcb_magic_number = TCB_MAGIC_NUMBER;
c0203841:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203844:	c7 40 54 ab 21 0d fc 	movl   $0xfc0d21ab,0x54(%eax)
}
c020384b:	90                   	nop
c020384c:	c9                   	leave  
c020384d:	c3                   	ret    

c020384e <threads_init>:

void threads_init(){
c020384e:	55                   	push   %ebp
c020384f:	89 e5                	mov    %esp,%ebp
c0203851:	53                   	push   %ebx
c0203852:	83 ec 10             	sub    $0x10,%esp
c0203855:	e8 aa 47 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020385a:	81 c3 a6 57 00 00    	add    $0x57a6,%ebx
	TCB_t *tcb_buffer_addr = &main_TCB;
c0203860:	c7 c0 20 30 29 c0    	mov    $0xc0293020,%eax
c0203866:	89 45 f8             	mov    %eax,-0x8(%ebp)
	_init_main_thread(&main_TCB);
c0203869:	c7 c0 20 30 29 c0    	mov    $0xc0293020,%eax
c020386f:	50                   	push   %eax
c0203870:	e8 5e ff ff ff       	call   c02037d3 <_init_main_thread>
c0203875:	83 c4 04             	add    $0x4,%esp
	cur_tcb = &main_TCB;
c0203878:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c020387e:	c7 c2 20 30 29 c0    	mov    $0xc0293020,%edx
c0203884:	89 10                	mov    %edx,(%eax)
}
c0203886:	90                   	nop
c0203887:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020388a:	c9                   	leave  
c020388b:	c3                   	ret    

c020388c <create_TCB>:

//用于创建线程的PCB
TCB_t* create_TCB(uint32_t tid,uint32_t page_addr,uint32_t page_counte){
c020388c:	55                   	push   %ebp
c020388d:	89 e5                	mov    %esp,%ebp
c020388f:	83 ec 10             	sub    $0x10,%esp
c0203892:	e8 69 47 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203897:	05 69 57 00 00       	add    $0x5769,%eax
	TCB_t * tcb_buffer_addr = (TCB_t*)page_addr;
c020389c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020389f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = tid;         
c02038a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038a5:	8b 55 08             	mov    0x8(%ebp),%edx
c02038a8:	89 50 14             	mov    %edx,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c02038ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038ae:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c02038b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038b8:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c02038bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038c2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=page_counte; 
c02038c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038cc:	8b 55 10             	mov    0x10(%ebp),%edx
c02038cf:	89 50 18             	mov    %edx,0x18(%eax)
	tcb_buffer_addr->page_addr=page_addr;
c02038d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038d5:	8b 55 0c             	mov    0xc(%ebp),%edx
c02038d8:	89 50 1c             	mov    %edx,0x1c(%eax)
	tcb_buffer_addr->kern_stack_top=page_addr+page_counte*PAGE_SIZE;    
c02038db:	8b 45 10             	mov    0x10(%ebp),%eax
c02038de:	c1 e0 0c             	shl    $0xc,%eax
c02038e1:	89 c2                	mov    %eax,%edx
c02038e3:	8b 45 0c             	mov    0xc(%ebp),%eax
c02038e6:	01 d0                	add    %edx,%eax
c02038e8:	89 c2                	mov    %eax,%edx
c02038ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038ed:	89 10                	mov    %edx,(%eax)
	tcb_buffer_addr->tcb_magic_number = TCB_MAGIC_NUMBER;
c02038ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02038f2:	c7 40 54 ab 21 0d fc 	movl   $0xfc0d21ab,0x54(%eax)
	return (TCB_t*)page_addr;
c02038f9:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c02038fc:	c9                   	leave  
c02038fd:	c3                   	ret    

c02038fe <create_thread>:

//创建最终线程的核心函数     创建用户进程以及创建内核线程的函数都是对这个函数的封装
//会操作TCB链表 需要加锁
void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte,bool is_kern_thread,bitmap user_vmm_pool,uint32_t pdt_vaddr){	
c02038fe:	55                   	push   %ebp
c02038ff:	89 e5                	mov    %esp,%ebp
c0203901:	53                   	push   %ebx
c0203902:	83 ec 10             	sub    $0x10,%esp
c0203905:	e8 fa 46 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020390a:	81 c3 f6 56 00 00    	add    $0x56f6,%ebx
	asm volatile("cli");  //由于创建过程会使用到共享的数据 不使用锁的话会造成临界区错误 所以我们在此处关闭中断
c0203910:	fa                   	cli    
	TCB_t * new_tcb = create_TCB(tid,addr,page_counte);
c0203911:	ff 75 18             	pushl  0x18(%ebp)
c0203914:	ff 75 14             	pushl  0x14(%ebp)
c0203917:	ff 75 08             	pushl  0x8(%ebp)
c020391a:	e8 6d ff ff ff       	call   c020388c <create_TCB>
c020391f:	83 c4 0c             	add    $0xc,%esp
c0203922:	89 45 f8             	mov    %eax,-0x8(%ebp)
	TCB_t * temp_next = cur_tcb->next;
c0203925:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c020392b:	8b 00                	mov    (%eax),%eax
c020392d:	8b 40 10             	mov    0x10(%eax),%eax
c0203930:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cur_tcb->next = new_tcb;
c0203933:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203939:	8b 00                	mov    (%eax),%eax
c020393b:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020393e:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->next = temp_next;
c0203941:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203944:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203947:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->is_kern_thread = is_kern_thread;
c020394a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020394d:	8b 55 1c             	mov    0x1c(%ebp),%edx
c0203950:	89 50 20             	mov    %edx,0x20(%eax)
	if(!is_kern_thread){
c0203953:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
c0203957:	75 1e                	jne    c0203977 <create_thread+0x79>
		//用户进程需要填充页表等
		new_tcb->user_vmm_pool = user_vmm_pool;
c0203959:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020395c:	8b 55 20             	mov    0x20(%ebp),%edx
c020395f:	89 50 24             	mov    %edx,0x24(%eax)
c0203962:	8b 55 24             	mov    0x24(%ebp),%edx
c0203965:	89 50 28             	mov    %edx,0x28(%eax)
c0203968:	8b 55 28             	mov    0x28(%ebp),%edx
c020396b:	89 50 2c             	mov    %edx,0x2c(%eax)
		new_tcb->pdt_vaddr = pdt_vaddr;
c020396e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203971:	8b 55 2c             	mov    0x2c(%ebp),%edx
c0203974:	89 50 30             	mov    %edx,0x30(%eax)
	}
	*(--new_tcb->kern_stack_top)=args;     //压入初始化的参数与线程执行函数
c0203977:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020397a:	8b 00                	mov    (%eax),%eax
c020397c:	8d 50 fc             	lea    -0x4(%eax),%edx
c020397f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203982:	89 10                	mov    %edx,(%eax)
c0203984:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203987:	8b 00                	mov    (%eax),%eax
c0203989:	8b 55 10             	mov    0x10(%ebp),%edx
c020398c:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=exit;
c020398e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203991:	8b 00                	mov    (%eax),%eax
c0203993:	8d 50 fc             	lea    -0x4(%eax),%edx
c0203996:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0203999:	89 10                	mov    %edx,(%eax)
c020399b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020399e:	8b 00                	mov    (%eax),%eax
c02039a0:	8d 93 8d ab ff ff    	lea    -0x5473(%ebx),%edx
c02039a6:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=func;
c02039a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039ab:	8b 00                	mov    (%eax),%eax
c02039ad:	8d 50 fc             	lea    -0x4(%eax),%edx
c02039b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039b3:	89 10                	mov    %edx,(%eax)
c02039b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039b8:	8b 00                	mov    (%eax),%eax
c02039ba:	8b 55 0c             	mov    0xc(%ebp),%edx
c02039bd:	89 10                	mov    %edx,(%eax)
	//此处存在修改！    0x200 ------->0x202    IF为1（打开硬中断）   IOPL为0（只允许内核访问IO）   1号位为1（eflags格式默认）
	new_tcb->context.eflags = 0x202; 
c02039bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039c2:	c7 40 4c 02 02 00 00 	movl   $0x202,0x4c(%eax)
	new_tcb->context.esp =new_tcb->kern_stack_top;
c02039c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039cc:	8b 00                	mov    (%eax),%eax
c02039ce:	89 c2                	mov    %eax,%edx
c02039d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02039d3:	89 50 50             	mov    %edx,0x50(%eax)
	asm volatile("sti");	
c02039d6:	fb                   	sti    
}
c02039d7:	90                   	nop
c02039d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02039db:	c9                   	leave  
c02039dc:	c3                   	ret    

c02039dd <create_kern_thread>:
//                                            1.func必须保证存在，不会被内存回收
//                                            2.args必须保证存在， 不会被内存回收
//内核线程的func与args都是内核内存空间中的     func通过函数定义的方式保存在os内核的程序段中 ，args保存在调用者函数的定义中，一旦调用者函数退出，args就会被回收
//如何解决这个问题？  线程的创建者函数不能退出！！！使用特定指令阻塞对应的函数（join）
//使用detach，在detach中实现线程将参数复制
void create_kern_thread(uint32_t tid,thread_function *func,void *args){
c02039dd:	55                   	push   %ebp
c02039de:	89 e5                	mov    %esp,%ebp
c02039e0:	53                   	push   %ebx
c02039e1:	83 ec 24             	sub    $0x24,%esp
c02039e4:	e8 1b 46 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02039e9:	81 c3 17 56 00 00    	add    $0x5617,%ebx
	bitmap default_bitmap;
	uint32_t page_counte = 1;
c02039ef:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	uint32_t TCB_page = vmm_kern_alloc();
c02039f6:	e8 ec 2b 00 00       	call   c02065e7 <vmm_kern_alloc>
c02039fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t default_pdt_vaddr = 0x0;
c02039fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	bool is_kern_thread = True;
c0203a05:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    if(TCB_page==KERN_VMM_ALLOC_ERRO){
c0203a0c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0203a10:	75 19                	jne    c0203a2b <create_kern_thread+0x4e>
        STOP(LOG_SRC_THREADS,"Can`t Create New User Task Because Of Error When Alloc TCB Page From Kernel VMM!STOP!");
c0203a12:	8b 83 0c 00 00 00    	mov    0xc(%ebx),%eax
c0203a18:	83 ec 08             	sub    $0x8,%esp
c0203a1b:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx
c0203a21:	52                   	push   %edx
c0203a22:	50                   	push   %eax
c0203a23:	e8 5f 1e 00 00       	call   c0205887 <stop_kern>
c0203a28:	83 c4 10             	add    $0x10,%esp
    }
	create_thread(tid,func,args,TCB_page,page_counte,is_kern_thread,default_bitmap,default_pdt_vaddr);
c0203a2b:	83 ec 08             	sub    $0x8,%esp
c0203a2e:	ff 75 ec             	pushl  -0x14(%ebp)
c0203a31:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a34:	ff 75 e0             	pushl  -0x20(%ebp)
c0203a37:	ff 75 dc             	pushl  -0x24(%ebp)
c0203a3a:	ff 75 e8             	pushl  -0x18(%ebp)
c0203a3d:	ff 75 f4             	pushl  -0xc(%ebp)
c0203a40:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a43:	ff 75 10             	pushl  0x10(%ebp)
c0203a46:	ff 75 0c             	pushl  0xc(%ebp)
c0203a49:	ff 75 08             	pushl  0x8(%ebp)
c0203a4c:	e8 ad fe ff ff       	call   c02038fe <create_thread>
c0203a51:	83 c4 30             	add    $0x30,%esp
}
c0203a54:	90                   	nop
c0203a55:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203a58:	c9                   	leave  
c0203a59:	c3                   	ret    

c0203a5a <schedule>:

void schedule(){      //调度函数  检测时间片为0时调用此函数
c0203a5a:	55                   	push   %ebp
c0203a5b:	89 e5                	mov    %esp,%ebp
c0203a5d:	53                   	push   %ebx
c0203a5e:	83 ec 14             	sub    $0x14,%esp
c0203a61:	e8 9e 45 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203a66:	81 c3 9a 55 00 00    	add    $0x559a,%ebx
	//首先判定现在的线程内核栈是否溢出
	if(!check_kern_stack_overflow(get_running_progress())){
c0203a6c:	e8 e8 fc ff ff       	call   c0203759 <get_running_progress>
c0203a71:	50                   	push   %eax
c0203a72:	e8 f9 fc ff ff       	call   c0203770 <check_kern_stack_overflow>
c0203a77:	83 c4 04             	add    $0x4,%esp
c0203a7a:	85 c0                	test   %eax,%eax
c0203a7c:	75 11                	jne    c0203a8f <schedule+0x35>
		//溢出处理！！！
		kern_overflow_handler(get_running_progress());
c0203a7e:	e8 d6 fc ff ff       	call   c0203759 <get_running_progress>
c0203a83:	83 ec 0c             	sub    $0xc,%esp
c0203a86:	50                   	push   %eax
c0203a87:	e8 0c fd ff ff       	call   c0203798 <kern_overflow_handler>
c0203a8c:	83 c4 10             	add    $0x10,%esp
	}
	if(cur_tcb->next==cur_tcb){
c0203a8f:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203a95:	8b 00                	mov    (%eax),%eax
c0203a97:	8b 50 10             	mov    0x10(%eax),%edx
c0203a9a:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203aa0:	8b 00                	mov    (%eax),%eax
c0203aa2:	39 c2                	cmp    %eax,%edx
c0203aa4:	75 11                	jne    c0203ab7 <schedule+0x5d>
		cur_tcb->time_left = TIME_CONT;    //如果只有一个线程 就再次给此线程添加时间片
c0203aa6:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203aac:	8b 00                	mov    (%eax),%eax
c0203aae:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
		return ;
c0203ab5:	eb 5b                	jmp    c0203b12 <schedule+0xb8>
	}
	//进行调度
	TCB_t *now = cur_tcb;
c0203ab7:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203abd:	8b 00                	mov    (%eax),%eax
c0203abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0203ac2:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203ac8:	8b 00                	mov    (%eax),%eax
c0203aca:	8b 40 10             	mov    0x10(%eax),%eax
c0203acd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0203ad0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203ad3:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	cur_tcb = next_tcb;
c0203ada:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203ae0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0203ae3:	89 10                	mov    %edx,(%eax)
	active_task(cur_tcb);
c0203ae5:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203aeb:	8b 00                	mov    (%eax),%eax
c0203aed:	83 ec 0c             	sub    $0xc,%esp
c0203af0:	50                   	push   %eax
c0203af1:	e8 cd 03 00 00       	call   c0203ec3 <active_task>
c0203af6:	83 c4 10             	add    $0x10,%esp
	//get_esp();      //有一个隐藏bug 需要call刷新寄存器
	switch_to(&(now->context),&(next_tcb->context));      
c0203af9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203afc:	8d 50 34             	lea    0x34(%eax),%edx
c0203aff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b02:	83 c0 34             	add    $0x34,%eax
c0203b05:	83 ec 08             	sub    $0x8,%esp
c0203b08:	52                   	push   %edx
c0203b09:	50                   	push   %eax
c0203b0a:	e8 f7 f4 ff ff       	call   c0203006 <switch_to>
c0203b0f:	83 c4 10             	add    $0x10,%esp
}
c0203b12:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203b15:	c9                   	leave  
c0203b16:	c3                   	ret    

c0203b17 <remove_thread>:

void remove_thread(){
c0203b17:	55                   	push   %ebp
c0203b18:	89 e5                	mov    %esp,%ebp
c0203b1a:	53                   	push   %ebx
c0203b1b:	83 ec 14             	sub    $0x14,%esp
c0203b1e:	e8 dd 44 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203b23:	05 dd 54 00 00       	add    $0x54dd,%eax
	asm volatile("cli");
c0203b28:	fa                   	cli    
	if(cur_tcb->tid==0)
c0203b29:	c7 c2 00 30 29 c0    	mov    $0xc0293000,%edx
c0203b2f:	8b 12                	mov    (%edx),%edx
c0203b31:	8b 52 14             	mov    0x14(%edx),%edx
c0203b34:	85 d2                	test   %edx,%edx
c0203b36:	75 16                	jne    c0203b4e <remove_thread+0x37>
		printk("ERRO:main thread can`t use function exit\n");
c0203b38:	83 ec 0c             	sub    $0xc,%esp
c0203b3b:	8d 90 f4 00 00 00    	lea    0xf4(%eax),%edx
c0203b41:	52                   	push   %edx
c0203b42:	89 c3                	mov    %eax,%ebx
c0203b44:	e8 1e 38 00 00       	call   c0207367 <printk>
c0203b49:	83 c4 10             	add    $0x10,%esp
		TCB_t *temp = cur_tcb;
		for(;temp->next!=cur_tcb;temp=temp->next)
			;
		temp->next = cur_tcb->next;
	}
}
c0203b4c:	eb 39                	jmp    c0203b87 <remove_thread+0x70>
		TCB_t *temp = cur_tcb;
c0203b4e:	c7 c2 00 30 29 c0    	mov    $0xc0293000,%edx
c0203b54:	8b 12                	mov    (%edx),%edx
c0203b56:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;temp->next!=cur_tcb;temp=temp->next)
c0203b59:	eb 09                	jmp    c0203b64 <remove_thread+0x4d>
c0203b5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b5e:	8b 52 10             	mov    0x10(%edx),%edx
c0203b61:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0203b64:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b67:	8b 4a 10             	mov    0x10(%edx),%ecx
c0203b6a:	c7 c2 00 30 29 c0    	mov    $0xc0293000,%edx
c0203b70:	8b 12                	mov    (%edx),%edx
c0203b72:	39 d1                	cmp    %edx,%ecx
c0203b74:	75 e5                	jne    c0203b5b <remove_thread+0x44>
		temp->next = cur_tcb->next;
c0203b76:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203b7c:	8b 00                	mov    (%eax),%eax
c0203b7e:	8b 50 10             	mov    0x10(%eax),%edx
c0203b81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b84:	89 50 10             	mov    %edx,0x10(%eax)
}
c0203b87:	90                   	nop
c0203b88:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203b8b:	c9                   	leave  
c0203b8c:	c3                   	ret    

c0203b8d <exit>:


//本exit函数暂时只能被内核线程使用 作为自动退出
void exit(){
c0203b8d:	55                   	push   %ebp
c0203b8e:	89 e5                	mov    %esp,%ebp
c0203b90:	53                   	push   %ebx
c0203b91:	83 ec 14             	sub    $0x14,%esp
c0203b94:	e8 6b 44 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203b99:	81 c3 67 54 00 00    	add    $0x5467,%ebx
	remove_thread();
c0203b9f:	e8 73 ff ff ff       	call   c0203b17 <remove_thread>
	TCB_t *now = cur_tcb;
c0203ba4:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203baa:	8b 00                	mov    (%eax),%eax
c0203bac:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0203baf:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203bb5:	8b 00                	mov    (%eax),%eax
c0203bb7:	8b 40 10             	mov    0x10(%eax),%eax
c0203bba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0203bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203bc0:	c7 40 0c d0 07 00 00 	movl   $0x7d0,0xc(%eax)
	cur_tcb = cur_tcb->next;
c0203bc7:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203bcd:	8b 00                	mov    (%eax),%eax
c0203bcf:	8b 50 10             	mov    0x10(%eax),%edx
c0203bd2:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0203bd8:	89 10                	mov    %edx,(%eax)
	switch_to(&(now->context),&(next_tcb->context));
c0203bda:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203bdd:	8d 50 34             	lea    0x34(%eax),%edx
c0203be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203be3:	83 c0 34             	add    $0x34,%eax
c0203be6:	83 ec 08             	sub    $0x8,%esp
c0203be9:	52                   	push   %edx
c0203bea:	50                   	push   %eax
c0203beb:	e8 16 f4 ff ff       	call   c0203006 <switch_to>
c0203bf0:	83 c4 10             	add    $0x10,%esp
	//注意 暂时没有回收此线程页
}
c0203bf3:	90                   	nop
c0203bf4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203bf7:	c9                   	leave  
c0203bf8:	c3                   	ret    

c0203bf9 <create_user_task_bitmap>:
extern uint16_t SELECTOR_USER_DATA_MEM;       //用户级数据段选择子
//创建用户专用bitmap
//用户的bitmap会占用内核虚拟空间 要在内核空间池中分配 
//注意 进程结束时一定要回收这部分空间
//the bitmap have been init before return;
bitmap create_user_task_bitmap(){
c0203bf9:	55                   	push   %ebp
c0203bfa:	89 e5                	mov    %esp,%ebp
c0203bfc:	53                   	push   %ebx
c0203bfd:	83 ec 24             	sub    $0x24,%esp
c0203c00:	e8 ff 43 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203c05:	81 c3 fb 53 00 00    	add    $0x53fb,%ebx
    //ask <96KB> for Bitmap!!!
    //alloc kern vm for bitmap
    //get the first 4KB
    uint32_t val_4KB = 0x1000;
c0203c0b:	c7 45 e8 00 10 00 00 	movl   $0x1000,-0x18(%ebp)
    uint32_t vm_head = vmm_kern_alloc();
c0203c12:	e8 d0 29 00 00       	call   c02065e7 <vmm_kern_alloc>
c0203c17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(vm_head==KERN_VMM_ALLOC_ERRO){
c0203c1a:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c0203c1e:	75 14                	jne    c0203c34 <create_user_task_bitmap+0x3b>
        printk("[ERRO]:user_task.c/0");
c0203c20:	83 ec 0c             	sub    $0xc,%esp
c0203c23:	8d 83 2a 01 00 00    	lea    0x12a(%ebx),%eax
c0203c29:	50                   	push   %eax
c0203c2a:	e8 38 37 00 00       	call   c0207367 <printk>
c0203c2f:	83 c4 10             	add    $0x10,%esp
        while(True);
c0203c32:	eb fe                	jmp    c0203c32 <create_user_task_bitmap+0x39>
    }
// for 96KB/4KB-1=23 times
    bool alloc_flag = True;
c0203c34:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    uint32_t addr_for = vm_head+val_4KB;
c0203c3b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0203c3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203c41:	01 d0                	add    %edx,%eax
c0203c43:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int item=0;item<23;item++){
c0203c46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0203c4d:	eb 26                	jmp    c0203c75 <create_user_task_bitmap+0x7c>
        if(vmm_kern_alloc_one_page(addr_for)==KERN_VMM_ALLOC_ERRO){
c0203c4f:	83 ec 0c             	sub    $0xc,%esp
c0203c52:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c55:	e8 ca 28 00 00       	call   c0206524 <vmm_kern_alloc_one_page>
c0203c5a:	83 c4 10             	add    $0x10,%esp
c0203c5d:	83 f8 ff             	cmp    $0xffffffff,%eax
c0203c60:	75 09                	jne    c0203c6b <create_user_task_bitmap+0x72>
            alloc_flag = False;
c0203c62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            break;
c0203c69:	eb 10                	jmp    c0203c7b <create_user_task_bitmap+0x82>
        }
        addr_for += val_4KB;
c0203c6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203c6e:	01 45 f0             	add    %eax,-0x10(%ebp)
    for(int item=0;item<23;item++){
c0203c71:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0203c75:	83 7d ec 16          	cmpl   $0x16,-0x14(%ebp)
c0203c79:	7e d4                	jle    c0203c4f <create_user_task_bitmap+0x56>
    }
    if(!alloc_flag){
c0203c7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0203c7f:	75 14                	jne    c0203c95 <create_user_task_bitmap+0x9c>
        printk("[ERRO]:user_task.c/1");
c0203c81:	83 ec 0c             	sub    $0xc,%esp
c0203c84:	8d 83 3f 01 00 00    	lea    0x13f(%ebx),%eax
c0203c8a:	50                   	push   %eax
c0203c8b:	e8 d7 36 00 00       	call   c0207367 <printk>
c0203c90:	83 c4 10             	add    $0x10,%esp
        while (True);
c0203c93:	eb fe                	jmp    c0203c93 <create_user_task_bitmap+0x9a>
    }
    bitmap re_bitmap;
    //从0~3GB虚拟地址来映射
    re_bitmap.vaddr_header = vm_head;
c0203c95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0203c98:	89 45 d8             	mov    %eax,-0x28(%ebp)
    re_bitmap.target_addr_header = 0x00000000;
c0203c9b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    //需要3GB空间映射
    re_bitmap.length = 0x00018000;  //需要96KB的存储空间存放
c0203ca2:	c7 45 dc 00 80 01 00 	movl   $0x18000,-0x24(%ebp)
    bitmap_init_mem(re_bitmap);
c0203ca9:	83 ec 04             	sub    $0x4,%esp
c0203cac:	ff 75 e0             	pushl  -0x20(%ebp)
c0203caf:	ff 75 dc             	pushl  -0x24(%ebp)
c0203cb2:	ff 75 d8             	pushl  -0x28(%ebp)
c0203cb5:	e8 31 f6 ff ff       	call   c02032eb <bitmap_init_mem>
c0203cba:	83 c4 10             	add    $0x10,%esp
    return re_bitmap;
c0203cbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0203cc0:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0203cc3:	89 10                	mov    %edx,(%eax)
c0203cc5:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0203cc8:	89 50 04             	mov    %edx,0x4(%eax)
c0203ccb:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0203cce:	89 50 08             	mov    %edx,0x8(%eax)
}
c0203cd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0203cd4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203cd7:	c9                   	leave  
c0203cd8:	c2 04 00             	ret    $0x4

c0203cdb <release_user_task_bitmap>:

//release all 96KB to kern vm
//need release 96/4 = 24 times;
void release_user_task_bitmap(bitmap bm){
c0203cdb:	55                   	push   %ebp
c0203cdc:	89 e5                	mov    %esp,%ebp
c0203cde:	53                   	push   %ebx
c0203cdf:	83 ec 14             	sub    $0x14,%esp
c0203ce2:	e8 1d 43 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203ce7:	81 c3 19 53 00 00    	add    $0x5319,%ebx
    uint32_t val_4KB = 0x1000;
c0203ced:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
    uint32_t vm = bm.vaddr_header;
c0203cf4:	8b 45 08             	mov    0x8(%ebp),%eax
c0203cf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (int i = 0; i < 24; i++) {
c0203cfa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0203d01:	eb 18                	jmp    c0203d1b <release_user_task_bitmap+0x40>
        vmm_kern_release_one_page(vm);
c0203d03:	83 ec 0c             	sub    $0xc,%esp
c0203d06:	ff 75 f4             	pushl  -0xc(%ebp)
c0203d09:	e8 9c 29 00 00       	call   c02066aa <vmm_kern_release_one_page>
c0203d0e:	83 c4 10             	add    $0x10,%esp
        vm += val_4KB;
c0203d11:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203d14:	01 45 f4             	add    %eax,-0xc(%ebp)
    for (int i = 0; i < 24; i++) {
c0203d17:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0203d1b:	83 7d f0 17          	cmpl   $0x17,-0x10(%ebp)
c0203d1f:	7e e2                	jle    c0203d03 <release_user_task_bitmap+0x28>
    }
}
c0203d21:	90                   	nop
c0203d22:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203d25:	c9                   	leave  
c0203d26:	c3                   	ret    

c0203d27 <pdt_mapping_helper>:

static void pdt_mapping_helper(uint32_t pte_vaddr){
c0203d27:	55                   	push   %ebp
c0203d28:	89 e5                	mov    %esp,%ebp
c0203d2a:	53                   	push   %ebx
c0203d2b:	83 ec 04             	sub    $0x4,%esp
c0203d2e:	e8 d1 42 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203d33:	81 c3 cd 52 00 00    	add    $0x52cd,%ebx
    //copy length is 1024B
    //只映射后256项（共1024项 ，每项4B，共映射1024B）
    memcpy(pte_vaddr+0xC00,get_pde(0xC0000000),1024);
c0203d39:	83 ec 0c             	sub    $0xc,%esp
c0203d3c:	68 00 00 00 c0       	push   $0xc0000000
c0203d41:	e8 9d 27 00 00       	call   c02064e3 <get_pde>
c0203d46:	83 c4 10             	add    $0x10,%esp
c0203d49:	89 c2                	mov    %eax,%edx
c0203d4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0203d4e:	05 00 0c 00 00       	add    $0xc00,%eax
c0203d53:	83 ec 04             	sub    $0x4,%esp
c0203d56:	68 00 04 00 00       	push   $0x400
c0203d5b:	52                   	push   %edx
c0203d5c:	50                   	push   %eax
c0203d5d:	e8 99 3c 00 00       	call   c02079fb <memcpy>
c0203d62:	83 c4 10             	add    $0x10,%esp

    memcpy(pte_vaddr,get_pde(0x0),4);
c0203d65:	83 ec 0c             	sub    $0xc,%esp
c0203d68:	6a 00                	push   $0x0
c0203d6a:	e8 74 27 00 00       	call   c02064e3 <get_pde>
c0203d6f:	83 c4 10             	add    $0x10,%esp
c0203d72:	89 c2                	mov    %eax,%edx
c0203d74:	8b 45 08             	mov    0x8(%ebp),%eax
c0203d77:	83 ec 04             	sub    $0x4,%esp
c0203d7a:	6a 04                	push   $0x4
c0203d7c:	52                   	push   %edx
c0203d7d:	50                   	push   %eax
c0203d7e:	e8 78 3c 00 00       	call   c02079fb <memcpy>
c0203d83:	83 c4 10             	add    $0x10,%esp
}
c0203d86:	90                   	nop
c0203d87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203d8a:	c9                   	leave  
c0203d8b:	c3                   	ret    

c0203d8c <mapping_last_pde>:

static void mapping_last_pde(uint32_t  last_pte_vaddr,uint32_t pdt_paddr){
c0203d8c:	55                   	push   %ebp
c0203d8d:	89 e5                	mov    %esp,%ebp
c0203d8f:	83 ec 10             	sub    $0x10,%esp
c0203d92:	e8 69 42 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203d97:	05 69 52 00 00       	add    $0x5269,%eax
    uint32_t* ptr = (uint32_t*)last_pte_vaddr;
c0203d9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0203d9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    *ptr = (pdt_paddr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c0203da2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203da5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0203daa:	8d 90 03 01 00 00    	lea    0x103(%eax),%edx
c0203db0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203db3:	89 10                	mov    %edx,(%eax)
}
c0203db5:	90                   	nop
c0203db6:	c9                   	leave  
c0203db7:	c3                   	ret    

c0203db8 <pt_release_helper>:

static void pt_release_helper(uint32_t pdt_vaddr){
c0203db8:	55                   	push   %ebp
c0203db9:	89 e5                	mov    %esp,%ebp
c0203dbb:	e8 40 42 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203dc0:	05 40 52 00 00       	add    $0x5240,%eax
    //PAGE DIRECTORY DESC
}
c0203dc5:	90                   	nop
c0203dc6:	5d                   	pop    %ebp
c0203dc7:	c3                   	ret    

c0203dc8 <create_user_task_pdt>:

//create pdt for user_task
//do two things: 1.alloc virtual memory from kern vm pool
//               2.mapping 3-4GB to kern page table (by using pointer)
uint32_t create_user_task_pdt(){
c0203dc8:	55                   	push   %ebp
c0203dc9:	89 e5                	mov    %esp,%ebp
c0203dcb:	53                   	push   %ebx
c0203dcc:	83 ec 14             	sub    $0x14,%esp
c0203dcf:	e8 30 42 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203dd4:	81 c3 2c 52 00 00    	add    $0x522c,%ebx
    uint32_t pdt_vaddr = vmm_kern_alloc();
c0203dda:	e8 08 28 00 00       	call   c02065e7 <vmm_kern_alloc>
c0203ddf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pdt_vaddr==KERN_VMM_ALLOC_ERRO){
c0203de2:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0203de6:	75 07                	jne    c0203def <create_user_task_pdt+0x27>
        return USER_TASK_INIT_ERRO;
c0203de8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0203ded:	eb 4c                	jmp    c0203e3b <create_user_task_pdt+0x73>
    }   
    else{
        //clear mem
        memset((void *) pdt_vaddr, 0, 0x1000);
c0203def:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203df2:	83 ec 04             	sub    $0x4,%esp
c0203df5:	68 00 10 00 00       	push   $0x1000
c0203dfa:	6a 00                	push   $0x0
c0203dfc:	50                   	push   %eax
c0203dfd:	e8 28 3c 00 00       	call   c0207a2a <memset>
c0203e02:	83 c4 10             	add    $0x10,%esp
        //mapping......
        pdt_mapping_helper(pdt_vaddr);
c0203e05:	83 ec 0c             	sub    $0xc,%esp
c0203e08:	ff 75 f4             	pushl  -0xc(%ebp)
c0203e0b:	e8 17 ff ff ff       	call   c0203d27 <pdt_mapping_helper>
c0203e10:	83 c4 10             	add    $0x10,%esp
        //must mapping last page!
        mapping_last_pde(pdt_vaddr+0x1000-4,vmm_v2p(pdt_vaddr));
c0203e13:	83 ec 0c             	sub    $0xc,%esp
c0203e16:	ff 75 f4             	pushl  -0xc(%ebp)
c0203e19:	e8 48 29 00 00       	call   c0206766 <vmm_v2p>
c0203e1e:	83 c4 10             	add    $0x10,%esp
c0203e21:	89 c2                	mov    %eax,%edx
c0203e23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203e26:	05 fc 0f 00 00       	add    $0xffc,%eax
c0203e2b:	83 ec 08             	sub    $0x8,%esp
c0203e2e:	52                   	push   %edx
c0203e2f:	50                   	push   %eax
c0203e30:	e8 57 ff ff ff       	call   c0203d8c <mapping_last_pde>
c0203e35:	83 c4 10             	add    $0x10,%esp
    }
    return pdt_vaddr;
c0203e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0203e3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203e3e:	c9                   	leave  
c0203e3f:	c3                   	ret    

c0203e40 <release_user_task_pdt>:

//release the mem when release user task
//do two things:  1.release the kern mem of page table
//                2.release the kern mem of page dir table(this is alloc when the task creates)
void release_user_task_pdt(uint32_t pdt_vaddr){
c0203e40:	55                   	push   %ebp
c0203e41:	89 e5                	mov    %esp,%ebp
c0203e43:	53                   	push   %ebx
c0203e44:	83 ec 04             	sub    $0x4,%esp
c0203e47:	e8 b8 41 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203e4c:	81 c3 b4 51 00 00    	add    $0x51b4,%ebx
    pt_release_helper(pdt_vaddr);
c0203e52:	ff 75 08             	pushl  0x8(%ebp)
c0203e55:	e8 5e ff ff ff       	call   c0203db8 <pt_release_helper>
c0203e5a:	83 c4 04             	add    $0x4,%esp
    vmm_kern_release_one_page(pdt_vaddr);
c0203e5d:	83 ec 0c             	sub    $0xc,%esp
c0203e60:	ff 75 08             	pushl  0x8(%ebp)
c0203e63:	e8 42 28 00 00       	call   c02066aa <vmm_kern_release_one_page>
c0203e68:	83 c4 10             	add    $0x10,%esp
}
c0203e6b:	90                   	nop
c0203e6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203e6f:	c9                   	leave  
c0203e70:	c3                   	ret    

c0203e71 <_active_pdt>:

//页表装载------------------------------
static void _active_pdt(uint32_t pdt_paddr){
c0203e71:	55                   	push   %ebp
c0203e72:	89 e5                	mov    %esp,%ebp
c0203e74:	e8 87 41 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203e79:	05 87 51 00 00       	add    $0x5187,%eax
    //内联汇编   修改cr3
    asm volatile("movl %0, %%cr3" : : "r" (pdt_paddr) : "memory");
c0203e7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0203e81:	0f 22 d8             	mov    %eax,%cr3
}
c0203e84:	90                   	nop
c0203e85:	5d                   	pop    %ebp
c0203e86:	c3                   	ret    

c0203e87 <_active_kern_pdt>:

static void _active_kern_pdt(){
c0203e87:	55                   	push   %ebp
c0203e88:	89 e5                	mov    %esp,%ebp
c0203e8a:	e8 71 41 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203e8f:	05 71 51 00 00       	add    $0x5171,%eax
    _active_pdt(kern_dir_table_paddr);
c0203e94:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0203e9a:	8b 00                	mov    (%eax),%eax
c0203e9c:	50                   	push   %eax
c0203e9d:	e8 cf ff ff ff       	call   c0203e71 <_active_pdt>
c0203ea2:	83 c4 04             	add    $0x4,%esp
}
c0203ea5:	90                   	nop
c0203ea6:	c9                   	leave  
c0203ea7:	c3                   	ret    

c0203ea8 <_active_user_pdt>:

static void _active_user_pdt(uint32_t pdt_paddr){
c0203ea8:	55                   	push   %ebp
c0203ea9:	89 e5                	mov    %esp,%ebp
c0203eab:	e8 50 41 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0203eb0:	05 50 51 00 00       	add    $0x5150,%eax
    //printk("\n0x%h",pdt_paddr);
    //STOP(LOG_SRC_USER_TASK,"STOP POINT1");
    _active_pdt(pdt_paddr);
c0203eb5:	ff 75 08             	pushl  0x8(%ebp)
c0203eb8:	e8 b4 ff ff ff       	call   c0203e71 <_active_pdt>
c0203ebd:	83 c4 04             	add    $0x4,%esp
}
c0203ec0:	90                   	nop
c0203ec1:	c9                   	leave  
c0203ec2:	c3                   	ret    

c0203ec3 <active_task>:
//页表装载------------------------------

//在调度task之前需要执行此函数激活task的页表以及进程的tss
void active_task(TCB_t* tcb_ptr){
c0203ec3:	55                   	push   %ebp
c0203ec4:	89 e5                	mov    %esp,%ebp
c0203ec6:	53                   	push   %ebx
c0203ec7:	83 ec 14             	sub    $0x14,%esp
c0203eca:	e8 35 41 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203ecf:	81 c3 31 51 00 00    	add    $0x5131,%ebx
    if(tcb_ptr->is_kern_thread){
c0203ed5:	8b 45 08             	mov    0x8(%ebp),%eax
c0203ed8:	8b 40 20             	mov    0x20(%eax),%eax
c0203edb:	85 c0                	test   %eax,%eax
c0203edd:	74 07                	je     c0203ee6 <active_task+0x23>
        //内核线程同样需要重新装载页表      否者可能会访问到上一个用户进程的用户虚拟空间（0-3GB）
        _active_kern_pdt();
c0203edf:	e8 a3 ff ff ff       	call   c0203e87 <_active_kern_pdt>
        }
        _active_user_pdt(user_task_pdt_paddr);
        //对于用户进程 需要更新tss的0特权级栈地址
        tss_update(tcb_ptr);
    }
}
c0203ee4:	eb 50                	jmp    c0203f36 <active_task+0x73>
        uint32_t user_task_pdt_paddr = vmm_v2p(tcb_ptr->pdt_vaddr);
c0203ee6:	8b 45 08             	mov    0x8(%ebp),%eax
c0203ee9:	8b 40 30             	mov    0x30(%eax),%eax
c0203eec:	83 ec 0c             	sub    $0xc,%esp
c0203eef:	50                   	push   %eax
c0203ef0:	e8 71 28 00 00       	call   c0206766 <vmm_v2p>
c0203ef5:	83 c4 10             	add    $0x10,%esp
c0203ef8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(user_task_pdt_paddr==V2P_ERROR){
c0203efb:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0203eff:	75 19                	jne    c0203f1a <active_task+0x57>
            STOP(LOG_SRC_USER_TASK,"V2P Error!STOP!");
c0203f01:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0203f07:	83 ec 08             	sub    $0x8,%esp
c0203f0a:	8d 93 54 01 00 00    	lea    0x154(%ebx),%edx
c0203f10:	52                   	push   %edx
c0203f11:	50                   	push   %eax
c0203f12:	e8 70 19 00 00       	call   c0205887 <stop_kern>
c0203f17:	83 c4 10             	add    $0x10,%esp
        _active_user_pdt(user_task_pdt_paddr);
c0203f1a:	83 ec 0c             	sub    $0xc,%esp
c0203f1d:	ff 75 f4             	pushl  -0xc(%ebp)
c0203f20:	e8 83 ff ff ff       	call   c0203ea8 <_active_user_pdt>
c0203f25:	83 c4 10             	add    $0x10,%esp
        tss_update(tcb_ptr);
c0203f28:	83 ec 0c             	sub    $0xc,%esp
c0203f2b:	ff 75 08             	pushl  0x8(%ebp)
c0203f2e:	e8 57 18 00 00       	call   c020578a <tss_update>
c0203f33:	83 c4 10             	add    $0x10,%esp
}
c0203f36:	90                   	nop
c0203f37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203f3a:	c9                   	leave  
c0203f3b:	c3                   	ret    

c0203f3c <start_user_task>:


//这个函数作为进程创建以后的线程执行的第一个函数   在这个函数中 会根据输入的目标function或者filename名字加载相应的用户进程，执行进程的初始化，最后执行伪中断退出到达3特权级
void start_user_task(start_user_task_params_t* params_ptr){
c0203f3c:	55                   	push   %ebp
c0203f3d:	89 e5                	mov    %esp,%ebp
c0203f3f:	53                   	push   %ebx
c0203f40:	83 ec 64             	sub    $0x64,%esp
c0203f43:	e8 bc 40 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0203f48:	81 c3 b8 50 00 00    	add    $0x50b8,%ebx
    if(params_ptr->is_from_file){
c0203f4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f51:	8b 00                	mov    (%eax),%eax
c0203f53:	85 c0                	test   %eax,%eax
c0203f55:	74 1e                	je     c0203f75 <start_user_task+0x39>
        STOP(LOG_SRC_USER_TASK,"File System is not exits!STOP!");
c0203f57:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0203f5d:	83 ec 08             	sub    $0x8,%esp
c0203f60:	8d 93 64 01 00 00    	lea    0x164(%ebx),%edx
c0203f66:	52                   	push   %edx
c0203f67:	50                   	push   %eax
c0203f68:	e8 1a 19 00 00       	call   c0205887 <stop_kern>
c0203f6d:	83 c4 10             	add    $0x10,%esp
c0203f70:	e9 3e 01 00 00       	jmp    c02040b3 <start_user_task+0x177>
    }
    else{
        //检查function是否为NULL
        if(params_ptr->function == NULL){
c0203f75:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f78:	8b 40 04             	mov    0x4(%eax),%eax
c0203f7b:	85 c0                	test   %eax,%eax
c0203f7d:	0f 84 2f 01 00 00    	je     c02040b2 <start_user_task+0x176>
            goto error_out;
        }
        else{
            //进行jmp 3级特权中断栈填充
            TCB_t * cur_tcb = get_running_progress();
c0203f83:	e8 d1 f7 ff ff       	call   c0203759 <get_running_progress>
c0203f88:	89 45 f4             	mov    %eax,-0xc(%ebp)
            uint32_t kern_stack_max_addr = cur_tcb->page_addr + cur_tcb->page_counte*PAGE_SIZE;
c0203f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203f8e:	8b 50 1c             	mov    0x1c(%eax),%edx
c0203f91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203f94:	8b 40 18             	mov    0x18(%eax),%eax
c0203f97:	c1 e0 0c             	shl    $0xc,%eax
c0203f9a:	01 d0                	add    %edx,%eax
c0203f9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
//            interrupt_stack_t  * int_stack = (interrupt_stack_t*)(kern_stack_max_addr - sizeof(interrupt_stack_t));
            interrupt_stack_t int_stack_temp;
            int_stack_temp.int_no_1 = 0;
c0203f9f:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
            int_stack_temp.args = (void * )0;
c0203fa6:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
            int_stack_temp.gs=0;
c0203fad:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
            int_stack_temp.fs=0;
c0203fb4:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
            int_stack_temp.edi = 0;
c0203fbb:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
            int_stack_temp.esi = 0;
c0203fc2:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
            int_stack_temp.ebp =0;
c0203fc9:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
            int_stack_temp.esp_duplicate = 0;
c0203fd0:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
            int_stack_temp.ebx=0;
c0203fd7:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
            int_stack_temp.edx=0;
c0203fde:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
            int_stack_temp.ecx=0;
c0203fe5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
            int_stack_temp.eax=0;
c0203fec:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
            int_stack_temp.int_no_2=0;
c0203ff3:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	        int_stack_temp.error_no=0;
c0203ffa:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	        int_stack_temp.eip=params_ptr->function;
c0204001:	8b 45 08             	mov    0x8(%ebp),%eax
c0204004:	8b 40 04             	mov    0x4(%eax),%eax
c0204007:	89 45 d8             	mov    %eax,-0x28(%ebp)
	        int_stack_temp.cs=SELECTOR_USER_CODE_MEM&0x0000FFFF;      //填充为用户级别
c020400a:	c7 c0 6e 32 20 c0    	mov    $0xc020326e,%eax
c0204010:	0f b7 00             	movzwl (%eax),%eax
c0204013:	0f b7 c0             	movzwl %ax,%eax
c0204016:	89 45 dc             	mov    %eax,-0x24(%ebp)
	        int_stack_temp.eflags =INTR_TO_LEVEL3_EFLAGS;
c0204019:	c7 45 e0 02 02 00 00 	movl   $0x202,-0x20(%ebp)
            //分配一页用于命令行参数以及function执行参数
            if(vmm_user_alloc_one_page(cur_tcb,0xC0000000-PAGE_SIZE)==USER_VMM_ALLOC_ERRO){
c0204020:	83 ec 08             	sub    $0x8,%esp
c0204023:	68 00 f0 ff bf       	push   $0xbffff000
c0204028:	ff 75 f4             	pushl  -0xc(%ebp)
c020402b:	e8 94 28 00 00       	call   c02068c4 <vmm_user_alloc_one_page>
c0204030:	83 c4 10             	add    $0x10,%esp
c0204033:	83 f8 ff             	cmp    $0xffffffff,%eax
c0204036:	75 19                	jne    c0204051 <start_user_task+0x115>
                STOP(LOG_SRC_USER_TASK,"Can`t Create User Task Args Page!STOP!");
c0204038:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c020403e:	83 ec 08             	sub    $0x8,%esp
c0204041:	8d 93 84 01 00 00    	lea    0x184(%ebx),%edx
c0204047:	52                   	push   %edx
c0204048:	50                   	push   %eax
c0204049:	e8 39 18 00 00       	call   c0205887 <stop_kern>
c020404e:	83 c4 10             	add    $0x10,%esp
            }

            //分配一张用户页用于用户栈
            uint32_t user_stack_page = vmm_user_alloc_one_page(cur_tcb,0xC0000000-2*PAGE_SIZE);
c0204051:	83 ec 08             	sub    $0x8,%esp
c0204054:	68 00 e0 ff bf       	push   $0xbfffe000
c0204059:	ff 75 f4             	pushl  -0xc(%ebp)
c020405c:	e8 63 28 00 00       	call   c02068c4 <vmm_user_alloc_one_page>
c0204061:	83 c4 10             	add    $0x10,%esp
c0204064:	89 45 ec             	mov    %eax,-0x14(%ebp)
	        if(user_stack_page==USER_VMM_ALLOC_ERRO){
c0204067:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c020406b:	75 19                	jne    c0204086 <start_user_task+0x14a>
                STOP(LOG_SRC_USER_TASK,"Can`t Create User Task Stack Page!STOP!");
c020406d:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c0204073:	83 ec 08             	sub    $0x8,%esp
c0204076:	8d 93 ac 01 00 00    	lea    0x1ac(%ebx),%edx
c020407c:	52                   	push   %edx
c020407d:	50                   	push   %eax
c020407e:	e8 04 18 00 00       	call   c0205887 <stop_kern>
c0204083:	83 c4 10             	add    $0x10,%esp
            }
            int_stack_temp.esp = user_stack_page+PAGE_SIZE;
c0204086:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204089:	05 00 10 00 00       	add    $0x1000,%eax
c020408e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	        int_stack_temp.ss=SELECTOR_USER_DATA_MEM&0x0000FFFF;
c0204091:	c7 c0 70 32 20 c0    	mov    $0xc0203270,%eax
c0204097:	0f b7 00             	movzwl (%eax),%eax
c020409a:	0f b7 c0             	movzwl %ax,%eax
c020409d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	        //执行iret伪装中断返回
            //执行了jmp3之后 内核栈会被重置回收 之后本进程使用内核栈都是从栈最大处开始使用
            exit_int((void*)&int_stack_temp);
c02040a0:	83 ec 0c             	sub    $0xc,%esp
c02040a3:	8d 45 a0             	lea    -0x60(%ebp),%eax
c02040a6:	50                   	push   %eax
c02040a7:	e8 2c f1 ff ff       	call   c02031d8 <exit_int>
c02040ac:	83 c4 10             	add    $0x10,%esp
            return;
c02040af:	90                   	nop
c02040b0:	eb 1a                	jmp    c02040cc <start_user_task+0x190>
            goto error_out;
c02040b2:	90                   	nop
        }       
    }

    error_out:
        STOP(LOG_SRC_USER_TASK,"Main Function is NULL when create user task by function input!STOP!");
c02040b3:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c02040b9:	83 ec 08             	sub    $0x8,%esp
c02040bc:	8d 93 d4 01 00 00    	lea    0x1d4(%ebx),%edx
c02040c2:	52                   	push   %edx
c02040c3:	50                   	push   %eax
c02040c4:	e8 be 17 00 00       	call   c0205887 <stop_kern>
c02040c9:	83 c4 10             	add    $0x10,%esp
}
c02040cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02040cf:	c9                   	leave  
c02040d0:	c3                   	ret    

c02040d1 <create_user_task>:

// 用于创建用户进程对应的线程   并且分配相应的用户进程资源
//args是start_user_task_params_t*类型的！！！
//注意：args中的内容不能被回收！！！也就是说调用create_user_task的函数不能退出，只能等待
void create_user_task(uint32_t tid,start_user_task_params_t*args){
c02040d1:	55                   	push   %ebp
c02040d2:	89 e5                	mov    %esp,%ebp
c02040d4:	53                   	push   %ebx
c02040d5:	83 ec 24             	sub    $0x24,%esp
c02040d8:	e8 27 3f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02040dd:	81 c3 23 4f 00 00    	add    $0x4f23,%ebx
	bool is_kern_thread =False;
c02040e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bitmap user_vmm_pool = create_user_task_bitmap();
c02040ea:	8d 45 dc             	lea    -0x24(%ebp),%eax
c02040ed:	83 ec 0c             	sub    $0xc,%esp
c02040f0:	50                   	push   %eax
c02040f1:	e8 03 fb ff ff       	call   c0203bf9 <create_user_task_bitmap>
c02040f6:	83 c4 0c             	add    $0xc,%esp
	uint32_t pdt_vaddr = create_user_task_pdt();
c02040f9:	e8 ca fc ff ff       	call   c0203dc8 <create_user_task_pdt>
c02040fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pdt_vaddr==USER_TASK_INIT_ERRO){
c0204101:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0204105:	75 19                	jne    c0204120 <create_user_task+0x4f>
        STOP(LOG_SRC_USER_TASK,"Can`t Create New User Task Because Of Error When Alloc User Pdt!STOP!");
c0204107:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c020410d:	83 ec 08             	sub    $0x8,%esp
c0204110:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
c0204116:	52                   	push   %edx
c0204117:	50                   	push   %eax
c0204118:	e8 6a 17 00 00       	call   c0205887 <stop_kern>
c020411d:	83 c4 10             	add    $0x10,%esp
    }
	uint32_t page_counte = 1;
c0204120:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	uint32_t TCB_page = vmm_kern_alloc();
c0204127:	e8 bb 24 00 00       	call   c02065e7 <vmm_kern_alloc>
c020412c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(TCB_page==KERN_VMM_ALLOC_ERRO){
c020412f:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
c0204133:	75 19                	jne    c020414e <create_user_task+0x7d>
        STOP(LOG_SRC_USER_TASK,"Can`t Create New User Task Because Of Error When Alloc TCB Page From Kernel VMM!STOP!");
c0204135:	8b 83 10 00 00 00    	mov    0x10(%ebx),%eax
c020413b:	83 ec 08             	sub    $0x8,%esp
c020413e:	8d 93 60 02 00 00    	lea    0x260(%ebx),%edx
c0204144:	52                   	push   %edx
c0204145:	50                   	push   %eax
c0204146:	e8 3c 17 00 00       	call   c0205887 <stop_kern>
c020414b:	83 c4 10             	add    $0x10,%esp
    }
	create_thread(tid,start_user_task,(void*)args,TCB_page,page_counte,is_kern_thread,user_vmm_pool,pdt_vaddr);
c020414e:	83 ec 08             	sub    $0x8,%esp
c0204151:	ff 75 f0             	pushl  -0x10(%ebp)
c0204154:	ff 75 e4             	pushl  -0x1c(%ebp)
c0204157:	ff 75 e0             	pushl  -0x20(%ebp)
c020415a:	ff 75 dc             	pushl  -0x24(%ebp)
c020415d:	ff 75 f4             	pushl  -0xc(%ebp)
c0204160:	ff 75 ec             	pushl  -0x14(%ebp)
c0204163:	ff 75 e8             	pushl  -0x18(%ebp)
c0204166:	ff 75 0c             	pushl  0xc(%ebp)
c0204169:	8d 83 3c af ff ff    	lea    -0x50c4(%ebx),%eax
c020416f:	50                   	push   %eax
c0204170:	ff 75 08             	pushl  0x8(%ebp)
c0204173:	e8 86 f7 ff ff       	call   c02038fe <create_thread>
c0204178:	83 c4 30             	add    $0x30,%esp
}
c020417b:	90                   	nop
c020417c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020417f:	c9                   	leave  
c0204180:	c3                   	ret    

c0204181 <change_esp>:
void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte,bool is_kern_thread,bitmap user_vmm_pool,uint32_t pdt_vaddr);


void change_esp(uint32_t stack_top_addr){
c0204181:	55                   	push   %ebp
c0204182:	89 e5                	mov    %esp,%ebp
c0204184:	e8 77 3e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204189:	05 77 4e 00 00       	add    $0x4e77,%eax

}
c020418e:	90                   	nop
c020418f:	5d                   	pop    %ebp
c0204190:	c3                   	ret    

c0204191 <handle_int_exit_stack>:

//用于清理中断栈 并且实现中断返回
//这个函数是创建user_task时跳转3特权级时调用 在interrupt中的清理中断栈实际上是在interrupt中实现的
//调用此函数之前需要把栈顶指针置于user_task中interrupt_stack顶
void handle_int_exit_stack(interrupt_stack_t * stack_top_ptr){
c0204191:	55                   	push   %ebp
c0204192:	89 e5                	mov    %esp,%ebp
c0204194:	e8 67 3e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204199:	05 67 4e 00 00       	add    $0x4e67,%eax

}
c020419e:	90                   	nop
c020419f:	5d                   	pop    %ebp
c02041a0:	c3                   	ret    

c02041a1 <user_task_test>:



void user_task_test(){
c02041a1:	55                   	push   %ebp
c02041a2:	89 e5                	mov    %esp,%ebp
c02041a4:	53                   	push   %ebx
c02041a5:	83 ec 14             	sub    $0x14,%esp
c02041a8:	e8 57 3e 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02041ad:	81 c3 53 4e 00 00    	add    $0x4e53,%ebx
    for(int i=0;i<1000;i++){
c02041b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02041ba:	eb 3c                	jmp    c02041f8 <user_task_test+0x57>
        printk("running!%d",i);
c02041bc:	83 ec 08             	sub    $0x8,%esp
c02041bf:	ff 75 f4             	pushl  -0xc(%ebp)
c02041c2:	8d 83 b6 02 00 00    	lea    0x2b6(%ebx),%eax
c02041c8:	50                   	push   %eax
c02041c9:	e8 99 31 00 00       	call   c0207367 <printk>
c02041ce:	83 c4 10             	add    $0x10,%esp
        bitmap bm = create_user_task_bitmap();
c02041d1:	8d 45 e8             	lea    -0x18(%ebp),%eax
c02041d4:	83 ec 0c             	sub    $0xc,%esp
c02041d7:	50                   	push   %eax
c02041d8:	e8 1c fa ff ff       	call   c0203bf9 <create_user_task_bitmap>
c02041dd:	83 c4 0c             	add    $0xc,%esp
        release_user_task_bitmap(bm);
c02041e0:	83 ec 04             	sub    $0x4,%esp
c02041e3:	ff 75 f0             	pushl  -0x10(%ebp)
c02041e6:	ff 75 ec             	pushl  -0x14(%ebp)
c02041e9:	ff 75 e8             	pushl  -0x18(%ebp)
c02041ec:	e8 ea fa ff ff       	call   c0203cdb <release_user_task_bitmap>
c02041f1:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<1000;i++){
c02041f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02041f8:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c02041ff:	7e bb                	jle    c02041bc <user_task_test+0x1b>
        //uint32_t addr =create_user_task_pdt();
        //release_user_task_pdt(addr);
    }
c0204201:	90                   	nop
c0204202:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0204205:	c9                   	leave  
c0204206:	c3                   	ret    

c0204207 <pmm_page_no_to_addr>:
pm_page_t *page_array = (pm_page_t*)0xC0000100;       
pm_multi_link_t * MULTI_LINK;   //用大写来表示很重要 并且定义为结构体指针，用->更加美观了～
pm_multi_link_t multi_link_struct={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
pm_page_t * SINGLE_LINK = NULL ;
//获取page编号对应的addr
static uint32_t pmm_page_no_to_addr(uint32_t page_no){
c0204207:	55                   	push   %ebp
c0204208:	89 e5                	mov    %esp,%ebp
c020420a:	e8 f1 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020420f:	05 f1 4d 00 00       	add    $0x4df1,%eax
	return (page_no<<12)+pmm_page_start;
c0204214:	8b 55 08             	mov    0x8(%ebp),%edx
c0204217:	c1 e2 0c             	shl    $0xc,%edx
c020421a:	8b 80 90 90 08 00    	mov    0x89090(%eax),%eax
c0204220:	01 d0                	add    %edx,%eax
}
c0204222:	5d                   	pop    %ebp
c0204223:	c3                   	ret    

c0204224 <addr_to_pmm_page_no>:

//addr转为page_no
static uint32_t addr_to_pmm_page_no(uint32_t addr){
c0204224:	55                   	push   %ebp
c0204225:	89 e5                	mov    %esp,%ebp
c0204227:	e8 d4 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020422c:	05 d4 4d 00 00       	add    $0x4dd4,%eax
	return (addr-pmm_page_start)>>12;
c0204231:	8b 80 90 90 08 00    	mov    0x89090(%eax),%eax
c0204237:	8b 55 08             	mov    0x8(%ebp),%edx
c020423a:	29 c2                	sub    %eax,%edx
c020423c:	89 d0                	mov    %edx,%eax
c020423e:	c1 e8 0c             	shr    $0xc,%eax
}
c0204241:	5d                   	pop    %ebp
c0204242:	c3                   	ret    

c0204243 <c_to_uint32>:

//将 page_c_t枚举类型转化为对应的块大小 如 (page_c_t)_256——> (uint32_t)256
static uint32_t c_to_uint32(page_c_t ph){
c0204243:	55                   	push   %ebp
c0204244:	89 e5                	mov    %esp,%ebp
c0204246:	83 ec 10             	sub    $0x10,%esp
c0204249:	e8 b2 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020424e:	05 b2 4d 00 00       	add    $0x4db2,%eax
	uint32_t re = 1;
c0204253:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
	re = re<<ph;
c020425a:	8b 45 08             	mov    0x8(%ebp),%eax
c020425d:	89 c1                	mov    %eax,%ecx
c020425f:	d3 65 fc             	shll   %cl,-0x4(%ebp)
	return re;
c0204262:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0204265:	c9                   	leave  
c0204266:	c3                   	ret    

c0204267 <get_partner_page_no>:

static uint32_t get_partner_page_no(uint32_t page_no,page_c_t type){
c0204267:	55                   	push   %ebp
c0204268:	89 e5                	mov    %esp,%ebp
c020426a:	83 ec 10             	sub    $0x10,%esp
c020426d:	e8 8e 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204272:	05 8e 4d 00 00       	add    $0x4d8e,%eax
	//--|--|--|--|--|--| 如图 必须整数倍或者0
	uint32_t v1 = c_to_uint32(type);
c0204277:	ff 75 0c             	pushl  0xc(%ebp)
c020427a:	e8 c4 ff ff ff       	call   c0204243 <c_to_uint32>
c020427f:	83 c4 04             	add    $0x4,%esp
c0204282:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t v2 = 2*v1;
c0204285:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204288:	01 c0                	add    %eax,%eax
c020428a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if((page_no - v1)%v2 == 0)
c020428d:	8b 45 08             	mov    0x8(%ebp),%eax
c0204290:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0204293:	ba 00 00 00 00       	mov    $0x0,%edx
c0204298:	f7 75 f8             	divl   -0x8(%ebp)
c020429b:	89 d0                	mov    %edx,%eax
c020429d:	85 c0                	test   %eax,%eax
c020429f:	75 08                	jne    c02042a9 <get_partner_page_no+0x42>
		return page_no-v1;
c02042a1:	8b 45 08             	mov    0x8(%ebp),%eax
c02042a4:	2b 45 fc             	sub    -0x4(%ebp),%eax
c02042a7:	eb 08                	jmp    c02042b1 <get_partner_page_no+0x4a>
	else
		return page_no+v1;
c02042a9:	8b 55 08             	mov    0x8(%ebp),%edx
c02042ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02042af:	01 d0                	add    %edx,%eax
}
c02042b1:	c9                   	leave  
c02042b2:	c3                   	ret    

c02042b3 <append_block>:


//向链表添加块（用于初始化链表以及free后添加块）
//此处可以使用##连接宏（但是我偏不）
static void append_block(int page_no,page_c_t c){
c02042b3:	55                   	push   %ebp
c02042b4:	89 e5                	mov    %esp,%ebp
c02042b6:	53                   	push   %ebx
c02042b7:	83 ec 10             	sub    $0x10,%esp
c02042ba:	e8 41 3d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02042bf:	05 41 4d 00 00       	add    $0x4d41,%eax
	page_array[page_no].next = NULL ;     //一定要设置 新加入块的下个指针为NULL
c02042c4:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02042ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02042cd:	89 ca                	mov    %ecx,%edx
c02042cf:	01 d2                	add    %edx,%edx
c02042d1:	01 ca                	add    %ecx,%edx
c02042d3:	c1 e2 02             	shl    $0x2,%edx
c02042d6:	01 da                	add    %ebx,%edx
c02042d8:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	pm_page_t * header;
	switch(c){
c02042df:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c02042e3:	0f 87 cd 02 00 00    	ja     c02045b6 <.L39+0x22>
c02042e9:	8b 55 0c             	mov    0xc(%ebp),%edx
c02042ec:	c1 e2 02             	shl    $0x2,%edx
c02042ef:	8b 94 02 c4 02 00 00 	mov    0x2c4(%edx,%eax,1),%edx
c02042f6:	01 c2                	add    %eax,%edx
c02042f8:	ff e2                	jmp    *%edx

c02042fa <.L12>:
		case _1:
			header = MULTI_LINK ->_1;
c02042fa:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204300:	8b 12                	mov    (%edx),%edx
c0204302:	8b 12                	mov    (%edx),%edx
c0204304:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204307:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020430b:	0f 85 86 02 00 00    	jne    c0204597 <.L39+0x3>
				MULTI_LINK ->_1 = &(page_array[page_no]);
c0204311:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204317:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020431a:	89 ca                	mov    %ecx,%edx
c020431c:	01 d2                	add    %edx,%edx
c020431e:	01 ca                	add    %ecx,%edx
c0204320:	c1 e2 02             	shl    $0x2,%edx
c0204323:	89 d1                	mov    %edx,%ecx
c0204325:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020432b:	8b 12                	mov    (%edx),%edx
c020432d:	01 d9                	add    %ebx,%ecx
c020432f:	89 0a                	mov    %ecx,(%edx)
			break;
c0204331:	e9 61 02 00 00       	jmp    c0204597 <.L39+0x3>

c0204336 <.L14>:
		case _2:
			header = MULTI_LINK ->_2;
c0204336:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020433c:	8b 12                	mov    (%edx),%edx
c020433e:	8b 52 04             	mov    0x4(%edx),%edx
c0204341:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204344:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204348:	0f 85 4c 02 00 00    	jne    c020459a <.L39+0x6>
				MULTI_LINK ->_2 = &(page_array[page_no]);
c020434e:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204354:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204357:	89 ca                	mov    %ecx,%edx
c0204359:	01 d2                	add    %edx,%edx
c020435b:	01 ca                	add    %ecx,%edx
c020435d:	c1 e2 02             	shl    $0x2,%edx
c0204360:	89 d1                	mov    %edx,%ecx
c0204362:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204368:	8b 12                	mov    (%edx),%edx
c020436a:	01 d9                	add    %ebx,%ecx
c020436c:	89 4a 04             	mov    %ecx,0x4(%edx)
			break;
c020436f:	e9 26 02 00 00       	jmp    c020459a <.L39+0x6>

c0204374 <.L15>:
		case _4:
			header = MULTI_LINK ->_4;
c0204374:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020437a:	8b 12                	mov    (%edx),%edx
c020437c:	8b 52 08             	mov    0x8(%edx),%edx
c020437f:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204382:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204386:	0f 85 11 02 00 00    	jne    c020459d <.L39+0x9>
				MULTI_LINK ->_4 = &(page_array[page_no]);
c020438c:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204392:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204395:	89 ca                	mov    %ecx,%edx
c0204397:	01 d2                	add    %edx,%edx
c0204399:	01 ca                	add    %ecx,%edx
c020439b:	c1 e2 02             	shl    $0x2,%edx
c020439e:	89 d1                	mov    %edx,%ecx
c02043a0:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043a6:	8b 12                	mov    (%edx),%edx
c02043a8:	01 d9                	add    %ebx,%ecx
c02043aa:	89 4a 08             	mov    %ecx,0x8(%edx)
			break;
c02043ad:	e9 eb 01 00 00       	jmp    c020459d <.L39+0x9>

c02043b2 <.L16>:
		case _8:
			header = MULTI_LINK ->_8;
c02043b2:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043b8:	8b 12                	mov    (%edx),%edx
c02043ba:	8b 52 0c             	mov    0xc(%edx),%edx
c02043bd:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02043c0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02043c4:	0f 85 d6 01 00 00    	jne    c02045a0 <.L39+0xc>
				MULTI_LINK ->_8 = &(page_array[page_no]);
c02043ca:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02043d0:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02043d3:	89 ca                	mov    %ecx,%edx
c02043d5:	01 d2                	add    %edx,%edx
c02043d7:	01 ca                	add    %ecx,%edx
c02043d9:	c1 e2 02             	shl    $0x2,%edx
c02043dc:	89 d1                	mov    %edx,%ecx
c02043de:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043e4:	8b 12                	mov    (%edx),%edx
c02043e6:	01 d9                	add    %ebx,%ecx
c02043e8:	89 4a 0c             	mov    %ecx,0xc(%edx)
			break;
c02043eb:	e9 b0 01 00 00       	jmp    c02045a0 <.L39+0xc>

c02043f0 <.L17>:
		case _16:
			header = MULTI_LINK ->_16;
c02043f0:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02043f6:	8b 12                	mov    (%edx),%edx
c02043f8:	8b 52 10             	mov    0x10(%edx),%edx
c02043fb:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02043fe:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204402:	0f 85 9b 01 00 00    	jne    c02045a3 <.L39+0xf>
				MULTI_LINK ->_16 = &(page_array[page_no]);
c0204408:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c020440e:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204411:	89 ca                	mov    %ecx,%edx
c0204413:	01 d2                	add    %edx,%edx
c0204415:	01 ca                	add    %ecx,%edx
c0204417:	c1 e2 02             	shl    $0x2,%edx
c020441a:	89 d1                	mov    %edx,%ecx
c020441c:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204422:	8b 12                	mov    (%edx),%edx
c0204424:	01 d9                	add    %ebx,%ecx
c0204426:	89 4a 10             	mov    %ecx,0x10(%edx)
			break;
c0204429:	e9 75 01 00 00       	jmp    c02045a3 <.L39+0xf>

c020442e <.L18>:
		case _32:
			header = MULTI_LINK ->_32;
c020442e:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204434:	8b 12                	mov    (%edx),%edx
c0204436:	8b 52 14             	mov    0x14(%edx),%edx
c0204439:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020443c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204440:	0f 85 60 01 00 00    	jne    c02045a6 <.L39+0x12>
				MULTI_LINK ->_32 = &(page_array[page_no]);
c0204446:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c020444c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020444f:	89 ca                	mov    %ecx,%edx
c0204451:	01 d2                	add    %edx,%edx
c0204453:	01 ca                	add    %ecx,%edx
c0204455:	c1 e2 02             	shl    $0x2,%edx
c0204458:	89 d1                	mov    %edx,%ecx
c020445a:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204460:	8b 12                	mov    (%edx),%edx
c0204462:	01 d9                	add    %ebx,%ecx
c0204464:	89 4a 14             	mov    %ecx,0x14(%edx)
			break;
c0204467:	e9 3a 01 00 00       	jmp    c02045a6 <.L39+0x12>

c020446c <.L19>:
		case _64:
			header = MULTI_LINK ->_64;
c020446c:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204472:	8b 12                	mov    (%edx),%edx
c0204474:	8b 52 18             	mov    0x18(%edx),%edx
c0204477:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020447a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020447e:	0f 85 25 01 00 00    	jne    c02045a9 <.L39+0x15>
				MULTI_LINK ->_64 = &(page_array[page_no]);
c0204484:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c020448a:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020448d:	89 ca                	mov    %ecx,%edx
c020448f:	01 d2                	add    %edx,%edx
c0204491:	01 ca                	add    %ecx,%edx
c0204493:	c1 e2 02             	shl    $0x2,%edx
c0204496:	89 d1                	mov    %edx,%ecx
c0204498:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020449e:	8b 12                	mov    (%edx),%edx
c02044a0:	01 d9                	add    %ebx,%ecx
c02044a2:	89 4a 18             	mov    %ecx,0x18(%edx)
			break;
c02044a5:	e9 ff 00 00 00       	jmp    c02045a9 <.L39+0x15>

c02044aa <.L20>:
		case _128:
			header = MULTI_LINK ->_128;
c02044aa:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02044b0:	8b 12                	mov    (%edx),%edx
c02044b2:	8b 52 1c             	mov    0x1c(%edx),%edx
c02044b5:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02044b8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02044bc:	0f 85 ea 00 00 00    	jne    c02045ac <.L39+0x18>
				MULTI_LINK ->_128 = &(page_array[page_no]);
c02044c2:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c02044c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02044cb:	89 ca                	mov    %ecx,%edx
c02044cd:	01 d2                	add    %edx,%edx
c02044cf:	01 ca                	add    %ecx,%edx
c02044d1:	c1 e2 02             	shl    $0x2,%edx
c02044d4:	89 d1                	mov    %edx,%ecx
c02044d6:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02044dc:	8b 12                	mov    (%edx),%edx
c02044de:	01 d9                	add    %ebx,%ecx
c02044e0:	89 4a 1c             	mov    %ecx,0x1c(%edx)
			break;
c02044e3:	e9 c4 00 00 00       	jmp    c02045ac <.L39+0x18>

c02044e8 <.L21>:
		case _256:
			header = MULTI_LINK ->_256;
c02044e8:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02044ee:	8b 12                	mov    (%edx),%edx
c02044f0:	8b 52 20             	mov    0x20(%edx),%edx
c02044f3:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02044f6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02044fa:	0f 85 af 00 00 00    	jne    c02045af <.L39+0x1b>
				MULTI_LINK ->_256 = &(page_array[page_no]);
c0204500:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204506:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204509:	89 ca                	mov    %ecx,%edx
c020450b:	01 d2                	add    %edx,%edx
c020450d:	01 ca                	add    %ecx,%edx
c020450f:	c1 e2 02             	shl    $0x2,%edx
c0204512:	89 d1                	mov    %edx,%ecx
c0204514:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020451a:	8b 12                	mov    (%edx),%edx
c020451c:	01 d9                	add    %ebx,%ecx
c020451e:	89 4a 20             	mov    %ecx,0x20(%edx)
			break;
c0204521:	e9 89 00 00 00       	jmp    c02045af <.L39+0x1b>

c0204526 <.L22>:
		case _512:
			header = MULTI_LINK ->_512;
c0204526:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020452c:	8b 12                	mov    (%edx),%edx
c020452e:	8b 52 24             	mov    0x24(%edx),%edx
c0204531:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204534:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204538:	75 78                	jne    c02045b2 <.L39+0x1e>
				MULTI_LINK ->_512 = &(page_array[page_no]);
c020453a:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204540:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204543:	89 ca                	mov    %ecx,%edx
c0204545:	01 d2                	add    %edx,%edx
c0204547:	01 ca                	add    %ecx,%edx
c0204549:	c1 e2 02             	shl    $0x2,%edx
c020454c:	89 d1                	mov    %edx,%ecx
c020454e:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204554:	8b 12                	mov    (%edx),%edx
c0204556:	01 d9                	add    %ebx,%ecx
c0204558:	89 4a 24             	mov    %ecx,0x24(%edx)
			break;
c020455b:	eb 55                	jmp    c02045b2 <.L39+0x1e>

c020455d <.L23>:
		case _1024:
			header = MULTI_LINK ->_1024;
c020455d:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204563:	8b 12                	mov    (%edx),%edx
c0204565:	8b 52 28             	mov    0x28(%edx),%edx
c0204568:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020456b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020456f:	75 44                	jne    c02045b5 <.L39+0x21>
				MULTI_LINK ->_1024 = &(page_array[page_no]);
c0204571:	8b 98 1c f0 ff ff    	mov    -0xfe4(%eax),%ebx
c0204577:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020457a:	89 ca                	mov    %ecx,%edx
c020457c:	01 d2                	add    %edx,%edx
c020457e:	01 ca                	add    %ecx,%edx
c0204580:	c1 e2 02             	shl    $0x2,%edx
c0204583:	89 d1                	mov    %edx,%ecx
c0204585:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020458b:	8b 12                	mov    (%edx),%edx
c020458d:	01 d9                	add    %ebx,%ecx
c020458f:	89 4a 28             	mov    %ecx,0x28(%edx)
			break;
c0204592:	eb 21                	jmp    c02045b5 <.L39+0x21>

c0204594 <.L39>:
		case _erro:
			break;
c0204594:	90                   	nop
c0204595:	eb 1f                	jmp    c02045b6 <.L39+0x22>
			break;
c0204597:	90                   	nop
c0204598:	eb 1c                	jmp    c02045b6 <.L39+0x22>
			break;
c020459a:	90                   	nop
c020459b:	eb 19                	jmp    c02045b6 <.L39+0x22>
			break;
c020459d:	90                   	nop
c020459e:	eb 16                	jmp    c02045b6 <.L39+0x22>
			break;
c02045a0:	90                   	nop
c02045a1:	eb 13                	jmp    c02045b6 <.L39+0x22>
			break;
c02045a3:	90                   	nop
c02045a4:	eb 10                	jmp    c02045b6 <.L39+0x22>
			break;
c02045a6:	90                   	nop
c02045a7:	eb 0d                	jmp    c02045b6 <.L39+0x22>
			break;
c02045a9:	90                   	nop
c02045aa:	eb 0a                	jmp    c02045b6 <.L39+0x22>
			break;
c02045ac:	90                   	nop
c02045ad:	eb 07                	jmp    c02045b6 <.L39+0x22>
			break;
c02045af:	90                   	nop
c02045b0:	eb 04                	jmp    c02045b6 <.L39+0x22>
			break;
c02045b2:	90                   	nop
c02045b3:	eb 01                	jmp    c02045b6 <.L39+0x22>
			break;
c02045b5:	90                   	nop
	}
	if(header!=NULL){
c02045b6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02045ba:	74 36                	je     c02045f2 <.L39+0x5e>
		pm_page_t * probe = header;
c02045bc:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02045bf:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;(probe->next)!=NULL;probe = probe->next)
c02045c2:	eb 09                	jmp    c02045cd <.L39+0x39>
c02045c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02045c7:	8b 52 04             	mov    0x4(%edx),%edx
c02045ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
c02045cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02045d0:	8b 52 04             	mov    0x4(%edx),%edx
c02045d3:	85 d2                	test   %edx,%edx
c02045d5:	75 ed                	jne    c02045c4 <.L39+0x30>
			;
		(probe -> next)=&(page_array[page_no]);
c02045d7:	8b 88 1c f0 ff ff    	mov    -0xfe4(%eax),%ecx
c02045dd:	8b 55 08             	mov    0x8(%ebp),%edx
c02045e0:	89 d0                	mov    %edx,%eax
c02045e2:	01 c0                	add    %eax,%eax
c02045e4:	01 d0                	add    %edx,%eax
c02045e6:	c1 e0 02             	shl    $0x2,%eax
c02045e9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c02045ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02045ef:	89 50 04             	mov    %edx,0x4(%eax)
	}
}
c02045f2:	90                   	nop
c02045f3:	83 c4 10             	add    $0x10,%esp
c02045f6:	5b                   	pop    %ebx
c02045f7:	5d                   	pop    %ebp
c02045f8:	c3                   	ret    

c02045f9 <pop_block>:

//从链表中取出一个块 链表为空返回ERRO_POP_BLOCK
static uint32_t pop_block(page_c_t c){
c02045f9:	55                   	push   %ebp
c02045fa:	89 e5                	mov    %esp,%ebp
c02045fc:	83 ec 10             	sub    $0x10,%esp
c02045ff:	e8 fc 39 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204604:	05 fc 49 00 00       	add    $0x49fc,%eax
	pm_page_t * header;
	switch(c){
c0204609:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c020460d:	0f 87 1e 03 00 00    	ja     c0204931 <.L66+0x26>
c0204613:	8b 55 08             	mov    0x8(%ebp),%edx
c0204616:	c1 e2 02             	shl    $0x2,%edx
c0204619:	8b 94 02 f4 02 00 00 	mov    0x2f4(%edx,%eax,1),%edx
c0204620:	01 c2                	add    %eax,%edx
c0204622:	ff e2                	jmp    *%edx

c0204624 <.L54>:
		case _1:
			header = MULTI_LINK ->_1;
c0204624:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020462a:	8b 12                	mov    (%edx),%edx
c020462c:	8b 12                	mov    (%edx),%edx
c020462e:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204631:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204635:	75 0a                	jne    c0204641 <.L54+0x1d>
				return ERRO_POP_BLOCK;
c0204637:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020463c:	e9 26 03 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c0204641:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204644:	8b 52 04             	mov    0x4(%edx),%edx
c0204647:	85 d2                	test   %edx,%edx
c0204649:	0f 85 c3 02 00 00    	jne    c0204912 <.L66+0x7>
				MULTI_LINK ->_1 =NULL;
c020464f:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204655:	8b 00                	mov    (%eax),%eax
c0204657:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				return header->page_no;
c020465d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204660:	8b 00                	mov    (%eax),%eax
c0204662:	e9 00 03 00 00       	jmp    c0204967 <.L66+0x5c>

c0204667 <.L56>:
			}
			break;
		case _2:
			header = MULTI_LINK ->_2;
c0204667:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020466d:	8b 12                	mov    (%edx),%edx
c020466f:	8b 52 04             	mov    0x4(%edx),%edx
c0204672:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204675:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204679:	75 0a                	jne    c0204685 <.L56+0x1e>
				return ERRO_POP_BLOCK;
c020467b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204680:	e9 e2 02 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c0204685:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204688:	8b 52 04             	mov    0x4(%edx),%edx
c020468b:	85 d2                	test   %edx,%edx
c020468d:	0f 85 82 02 00 00    	jne    c0204915 <.L66+0xa>
				MULTI_LINK ->_2 = NULL;
c0204693:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204699:	8b 00                	mov    (%eax),%eax
c020469b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
				return header->page_no;
c02046a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02046a5:	8b 00                	mov    (%eax),%eax
c02046a7:	e9 bb 02 00 00       	jmp    c0204967 <.L66+0x5c>

c02046ac <.L57>:
			}
			break;
		case _4:
			header = MULTI_LINK ->_4;
c02046ac:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02046b2:	8b 12                	mov    (%edx),%edx
c02046b4:	8b 52 08             	mov    0x8(%edx),%edx
c02046b7:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02046ba:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02046be:	75 0a                	jne    c02046ca <.L57+0x1e>
				return ERRO_POP_BLOCK;
c02046c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02046c5:	e9 9d 02 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c02046ca:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02046cd:	8b 52 04             	mov    0x4(%edx),%edx
c02046d0:	85 d2                	test   %edx,%edx
c02046d2:	0f 85 40 02 00 00    	jne    c0204918 <.L66+0xd>
				MULTI_LINK ->_4 = NULL;
c02046d8:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02046de:	8b 00                	mov    (%eax),%eax
c02046e0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				return header->page_no;
c02046e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02046ea:	8b 00                	mov    (%eax),%eax
c02046ec:	e9 76 02 00 00       	jmp    c0204967 <.L66+0x5c>

c02046f1 <.L58>:
			}
			break;
		case _8:
			header = MULTI_LINK ->_8;
c02046f1:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02046f7:	8b 12                	mov    (%edx),%edx
c02046f9:	8b 52 0c             	mov    0xc(%edx),%edx
c02046fc:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02046ff:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204703:	75 0a                	jne    c020470f <.L58+0x1e>
				return ERRO_POP_BLOCK;
c0204705:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020470a:	e9 58 02 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c020470f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204712:	8b 52 04             	mov    0x4(%edx),%edx
c0204715:	85 d2                	test   %edx,%edx
c0204717:	0f 85 fe 01 00 00    	jne    c020491b <.L66+0x10>
				MULTI_LINK ->_8 = NULL;
c020471d:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204723:	8b 00                	mov    (%eax),%eax
c0204725:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				return header->page_no;
c020472c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020472f:	8b 00                	mov    (%eax),%eax
c0204731:	e9 31 02 00 00       	jmp    c0204967 <.L66+0x5c>

c0204736 <.L59>:
			}
			break;
		case _16:
			header = MULTI_LINK ->_16;
c0204736:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020473c:	8b 12                	mov    (%edx),%edx
c020473e:	8b 52 10             	mov    0x10(%edx),%edx
c0204741:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204744:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204748:	75 0a                	jne    c0204754 <.L59+0x1e>
				return ERRO_POP_BLOCK;
c020474a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020474f:	e9 13 02 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c0204754:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204757:	8b 52 04             	mov    0x4(%edx),%edx
c020475a:	85 d2                	test   %edx,%edx
c020475c:	0f 85 bc 01 00 00    	jne    c020491e <.L66+0x13>
				MULTI_LINK ->_16 = NULL;
c0204762:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204768:	8b 00                	mov    (%eax),%eax
c020476a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
				return header->page_no;
c0204771:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204774:	8b 00                	mov    (%eax),%eax
c0204776:	e9 ec 01 00 00       	jmp    c0204967 <.L66+0x5c>

c020477b <.L60>:
			}
			break;
		case _32:
			header = MULTI_LINK ->_32;
c020477b:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204781:	8b 12                	mov    (%edx),%edx
c0204783:	8b 52 14             	mov    0x14(%edx),%edx
c0204786:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204789:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020478d:	75 0a                	jne    c0204799 <.L60+0x1e>
				return ERRO_POP_BLOCK;
c020478f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204794:	e9 ce 01 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c0204799:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020479c:	8b 52 04             	mov    0x4(%edx),%edx
c020479f:	85 d2                	test   %edx,%edx
c02047a1:	0f 85 7a 01 00 00    	jne    c0204921 <.L66+0x16>
				MULTI_LINK ->_32 = NULL;
c02047a7:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02047ad:	8b 00                	mov    (%eax),%eax
c02047af:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
				return header->page_no;
c02047b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02047b9:	8b 00                	mov    (%eax),%eax
c02047bb:	e9 a7 01 00 00       	jmp    c0204967 <.L66+0x5c>

c02047c0 <.L61>:
			}
			break;
		case _64:
			header = MULTI_LINK ->_64;
c02047c0:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02047c6:	8b 12                	mov    (%edx),%edx
c02047c8:	8b 52 18             	mov    0x18(%edx),%edx
c02047cb:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02047ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02047d2:	75 0a                	jne    c02047de <.L61+0x1e>
				return ERRO_POP_BLOCK;
c02047d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02047d9:	e9 89 01 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c02047de:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02047e1:	8b 52 04             	mov    0x4(%edx),%edx
c02047e4:	85 d2                	test   %edx,%edx
c02047e6:	0f 85 38 01 00 00    	jne    c0204924 <.L66+0x19>
				MULTI_LINK ->_64 = NULL;
c02047ec:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02047f2:	8b 00                	mov    (%eax),%eax
c02047f4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
				return header->page_no;
c02047fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02047fe:	8b 00                	mov    (%eax),%eax
c0204800:	e9 62 01 00 00       	jmp    c0204967 <.L66+0x5c>

c0204805 <.L62>:
			}
			break;
		case _128:
			header = MULTI_LINK ->_128;
c0204805:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c020480b:	8b 12                	mov    (%edx),%edx
c020480d:	8b 52 1c             	mov    0x1c(%edx),%edx
c0204810:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204813:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204817:	75 0a                	jne    c0204823 <.L62+0x1e>
				return ERRO_POP_BLOCK;
c0204819:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020481e:	e9 44 01 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c0204823:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204826:	8b 52 04             	mov    0x4(%edx),%edx
c0204829:	85 d2                	test   %edx,%edx
c020482b:	0f 85 f6 00 00 00    	jne    c0204927 <.L66+0x1c>
				MULTI_LINK ->_128 = NULL;
c0204831:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204837:	8b 00                	mov    (%eax),%eax
c0204839:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
				return header->page_no;
c0204840:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204843:	8b 00                	mov    (%eax),%eax
c0204845:	e9 1d 01 00 00       	jmp    c0204967 <.L66+0x5c>

c020484a <.L63>:
			}
			break;
		case _256:
			header = MULTI_LINK ->_256;
c020484a:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204850:	8b 12                	mov    (%edx),%edx
c0204852:	8b 52 20             	mov    0x20(%edx),%edx
c0204855:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204858:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020485c:	75 0a                	jne    c0204868 <.L63+0x1e>
				return ERRO_POP_BLOCK;
c020485e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204863:	e9 ff 00 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c0204868:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020486b:	8b 52 04             	mov    0x4(%edx),%edx
c020486e:	85 d2                	test   %edx,%edx
c0204870:	0f 85 b4 00 00 00    	jne    c020492a <.L66+0x1f>
				MULTI_LINK ->_256 = NULL;
c0204876:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020487c:	8b 00                	mov    (%eax),%eax
c020487e:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				return header->page_no;
c0204885:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204888:	8b 00                	mov    (%eax),%eax
c020488a:	e9 d8 00 00 00       	jmp    c0204967 <.L66+0x5c>

c020488f <.L64>:
			}
			break;
		case _512:
			header = MULTI_LINK ->_512;
c020488f:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c0204895:	8b 12                	mov    (%edx),%edx
c0204897:	8b 52 24             	mov    0x24(%edx),%edx
c020489a:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c020489d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02048a1:	75 0a                	jne    c02048ad <.L64+0x1e>
				return ERRO_POP_BLOCK;
c02048a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02048a8:	e9 ba 00 00 00       	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c02048ad:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02048b0:	8b 52 04             	mov    0x4(%edx),%edx
c02048b3:	85 d2                	test   %edx,%edx
c02048b5:	75 76                	jne    c020492d <.L66+0x22>
				MULTI_LINK ->_512 = NULL;
c02048b7:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02048bd:	8b 00                	mov    (%eax),%eax
c02048bf:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
				return header->page_no;
c02048c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02048c9:	8b 00                	mov    (%eax),%eax
c02048cb:	e9 97 00 00 00       	jmp    c0204967 <.L66+0x5c>

c02048d0 <.L65>:
			}
			break;
		case _1024:
			header = MULTI_LINK ->_1024;
c02048d0:	c7 c2 78 30 29 c0    	mov    $0xc0293078,%edx
c02048d6:	8b 12                	mov    (%edx),%edx
c02048d8:	8b 52 28             	mov    0x28(%edx),%edx
c02048db:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c02048de:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02048e2:	75 07                	jne    c02048eb <.L65+0x1b>
				return ERRO_POP_BLOCK;
c02048e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02048e9:	eb 7c                	jmp    c0204967 <.L66+0x5c>
			if(header->next==NULL){
c02048eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02048ee:	8b 52 04             	mov    0x4(%edx),%edx
c02048f1:	85 d2                	test   %edx,%edx
c02048f3:	75 3b                	jne    c0204930 <.L66+0x25>
				MULTI_LINK ->_1024 = NULL;
c02048f5:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02048fb:	8b 00                	mov    (%eax),%eax
c02048fd:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
				return header->page_no;
c0204904:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204907:	8b 00                	mov    (%eax),%eax
c0204909:	eb 5c                	jmp    c0204967 <.L66+0x5c>

c020490b <.L66>:
			}
			break;
		case _erro:
			return ERRO_POP_BLOCK; 
c020490b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204910:	eb 55                	jmp    c0204967 <.L66+0x5c>
			break;
c0204912:	90                   	nop
c0204913:	eb 1c                	jmp    c0204931 <.L66+0x26>
			break;
c0204915:	90                   	nop
c0204916:	eb 19                	jmp    c0204931 <.L66+0x26>
			break;
c0204918:	90                   	nop
c0204919:	eb 16                	jmp    c0204931 <.L66+0x26>
			break;
c020491b:	90                   	nop
c020491c:	eb 13                	jmp    c0204931 <.L66+0x26>
			break;
c020491e:	90                   	nop
c020491f:	eb 10                	jmp    c0204931 <.L66+0x26>
			break;
c0204921:	90                   	nop
c0204922:	eb 0d                	jmp    c0204931 <.L66+0x26>
			break;
c0204924:	90                   	nop
c0204925:	eb 0a                	jmp    c0204931 <.L66+0x26>
			break;
c0204927:	90                   	nop
c0204928:	eb 07                	jmp    c0204931 <.L66+0x26>
			break;
c020492a:	90                   	nop
c020492b:	eb 04                	jmp    c0204931 <.L66+0x26>
			break;
c020492d:	90                   	nop
c020492e:	eb 01                	jmp    c0204931 <.L66+0x26>
			break;
c0204930:	90                   	nop
			break;
	}
	pm_page_t * probe = header;
c0204931:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204934:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;probe->next->next!=NULL;probe = probe->next)
c0204937:	eb 09                	jmp    c0204942 <.L66+0x37>
c0204939:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020493c:	8b 40 04             	mov    0x4(%eax),%eax
c020493f:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204942:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204945:	8b 40 04             	mov    0x4(%eax),%eax
c0204948:	8b 40 04             	mov    0x4(%eax),%eax
c020494b:	85 c0                	test   %eax,%eax
c020494d:	75 ea                	jne    c0204939 <.L66+0x2e>
		;
	uint32_t return_page_no = probe->next->page_no;
c020494f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204952:	8b 40 04             	mov    0x4(%eax),%eax
c0204955:	8b 00                	mov    (%eax),%eax
c0204957:	89 45 f4             	mov    %eax,-0xc(%ebp)
	probe->next=NULL;
c020495a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020495d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	return return_page_no;
c0204964:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204967:	c9                   	leave  
c0204968:	c3                   	ret    

c0204969 <find_and_pop_block>:
 
//free合并块使用函数
//如果链表中没有 返回ERRO_POP_BLOCK 否则返回对应page_no
static uint32_t find_and_pop_block(uint32_t target_page_no,page_c_t ph){
c0204969:	55                   	push   %ebp
c020496a:	89 e5                	mov    %esp,%ebp
c020496c:	83 ec 10             	sub    $0x10,%esp
c020496f:	e8 8c 36 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204974:	05 8c 46 00 00       	add    $0x468c,%eax
	pm_page_t * header;
	switch(ph){
c0204979:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c020497d:	0f 87 d3 00 00 00    	ja     c0204a56 <.L117+0xa>
c0204983:	8b 55 0c             	mov    0xc(%ebp),%edx
c0204986:	c1 e2 02             	shl    $0x2,%edx
c0204989:	8b 94 02 24 03 00 00 	mov    0x324(%edx,%eax,1),%edx
c0204990:	01 c2                	add    %eax,%edx
c0204992:	ff e2                	jmp    *%edx

c0204994 <.L105>:
		case _1:
			header = MULTI_LINK -> _1;
c0204994:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020499a:	8b 00                	mov    (%eax),%eax
c020499c:	8b 00                	mov    (%eax),%eax
c020499e:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049a1:	e9 b0 00 00 00       	jmp    c0204a56 <.L117+0xa>

c02049a6 <.L107>:
		case _2:
			header = MULTI_LINK -> _2;
c02049a6:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049ac:	8b 00                	mov    (%eax),%eax
c02049ae:	8b 40 04             	mov    0x4(%eax),%eax
c02049b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049b4:	e9 9d 00 00 00       	jmp    c0204a56 <.L117+0xa>

c02049b9 <.L108>:
		case _4:
			header = MULTI_LINK -> _4;
c02049b9:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049bf:	8b 00                	mov    (%eax),%eax
c02049c1:	8b 40 08             	mov    0x8(%eax),%eax
c02049c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049c7:	e9 8a 00 00 00       	jmp    c0204a56 <.L117+0xa>

c02049cc <.L109>:
		case _8:
			header = MULTI_LINK -> _8;
c02049cc:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049d2:	8b 00                	mov    (%eax),%eax
c02049d4:	8b 40 0c             	mov    0xc(%eax),%eax
c02049d7:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049da:	eb 7a                	jmp    c0204a56 <.L117+0xa>

c02049dc <.L110>:
		case _16:
			header = MULTI_LINK -> _16;
c02049dc:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049e2:	8b 00                	mov    (%eax),%eax
c02049e4:	8b 40 10             	mov    0x10(%eax),%eax
c02049e7:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049ea:	eb 6a                	jmp    c0204a56 <.L117+0xa>

c02049ec <.L111>:
		case _32:
			header = MULTI_LINK -> _32;
c02049ec:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02049f2:	8b 00                	mov    (%eax),%eax
c02049f4:	8b 40 14             	mov    0x14(%eax),%eax
c02049f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c02049fa:	eb 5a                	jmp    c0204a56 <.L117+0xa>

c02049fc <.L112>:
		case _64:
			header = MULTI_LINK -> _64;
c02049fc:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204a02:	8b 00                	mov    (%eax),%eax
c0204a04:	8b 40 18             	mov    0x18(%eax),%eax
c0204a07:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204a0a:	eb 4a                	jmp    c0204a56 <.L117+0xa>

c0204a0c <.L113>:
		case _128:
			header = MULTI_LINK -> _128;
c0204a0c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204a12:	8b 00                	mov    (%eax),%eax
c0204a14:	8b 40 1c             	mov    0x1c(%eax),%eax
c0204a17:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204a1a:	eb 3a                	jmp    c0204a56 <.L117+0xa>

c0204a1c <.L114>:
		case _256:
			header = MULTI_LINK -> _256;
c0204a1c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204a22:	8b 00                	mov    (%eax),%eax
c0204a24:	8b 40 20             	mov    0x20(%eax),%eax
c0204a27:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204a2a:	eb 2a                	jmp    c0204a56 <.L117+0xa>

c0204a2c <.L115>:
		case _512:
			header = MULTI_LINK -> _512;
c0204a2c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204a32:	8b 00                	mov    (%eax),%eax
c0204a34:	8b 40 24             	mov    0x24(%eax),%eax
c0204a37:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204a3a:	eb 1a                	jmp    c0204a56 <.L117+0xa>

c0204a3c <.L116>:
		case _1024:
			header = MULTI_LINK -> _1024;
c0204a3c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204a42:	8b 00                	mov    (%eax),%eax
c0204a44:	8b 40 28             	mov    0x28(%eax),%eax
c0204a47:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204a4a:	eb 0a                	jmp    c0204a56 <.L117+0xa>

c0204a4c <.L117>:
		case _erro:
			return ERRO_POP_BLOCK;
c0204a4c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204a51:	e9 8c 00 00 00       	jmp    c0204ae2 <.L117+0x96>
	}
	if(header == NULL)
c0204a56:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204a5a:	75 07                	jne    c0204a63 <.L117+0x17>
		return ERRO_POP_BLOCK;
c0204a5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204a61:	eb 7f                	jmp    c0204ae2 <.L117+0x96>
	if(header->next==NULL){
c0204a63:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204a66:	8b 40 04             	mov    0x4(%eax),%eax
c0204a69:	85 c0                	test   %eax,%eax
c0204a6b:	75 1a                	jne    c0204a87 <.L117+0x3b>
		if(header->page_no==target_page_no){
c0204a6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204a70:	8b 00                	mov    (%eax),%eax
c0204a72:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204a75:	75 10                	jne    c0204a87 <.L117+0x3b>
			pop_block(ph);
c0204a77:	ff 75 0c             	pushl  0xc(%ebp)
c0204a7a:	e8 7a fb ff ff       	call   c02045f9 <pop_block>
c0204a7f:	83 c4 04             	add    $0x4,%esp
			return target_page_no;
c0204a82:	8b 45 08             	mov    0x8(%ebp),%eax
c0204a85:	eb 5b                	jmp    c0204ae2 <.L117+0x96>
		}
	}
	pm_page_t * probe = header ;
c0204a87:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204a8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	//
	//
	//
	//
	//
	for(; probe->next!=NULL;probe=probe->next){
c0204a8d:	eb 2a                	jmp    c0204ab9 <.L117+0x6d>
		if(probe->next->page_no == target_page_no){
c0204a8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a92:	8b 40 04             	mov    0x4(%eax),%eax
c0204a95:	8b 00                	mov    (%eax),%eax
c0204a97:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204a9a:	75 14                	jne    c0204ab0 <.L117+0x64>
			probe->next = probe->next->next;
c0204a9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204a9f:	8b 40 04             	mov    0x4(%eax),%eax
c0204aa2:	8b 50 04             	mov    0x4(%eax),%edx
c0204aa5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204aa8:	89 50 04             	mov    %edx,0x4(%eax)
			return target_page_no;
c0204aab:	8b 45 08             	mov    0x8(%ebp),%eax
c0204aae:	eb 32                	jmp    c0204ae2 <.L117+0x96>
	for(; probe->next!=NULL;probe=probe->next){
c0204ab0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ab3:	8b 40 04             	mov    0x4(%eax),%eax
c0204ab6:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204ab9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204abc:	8b 40 04             	mov    0x4(%eax),%eax
c0204abf:	85 c0                	test   %eax,%eax
c0204ac1:	75 cc                	jne    c0204a8f <.L117+0x43>
		}
	}
	if(probe->page_no == target_page_no){
c0204ac3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ac6:	8b 00                	mov    (%eax),%eax
c0204ac8:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204acb:	75 10                	jne    c0204add <.L117+0x91>
		pop_block(ph);
c0204acd:	ff 75 0c             	pushl  0xc(%ebp)
c0204ad0:	e8 24 fb ff ff       	call   c02045f9 <pop_block>
c0204ad5:	83 c4 04             	add    $0x4,%esp
		return target_page_no;
c0204ad8:	8b 45 08             	mov    0x8(%ebp),%eax
c0204adb:	eb 05                	jmp    c0204ae2 <.L117+0x96>
	}
	return ERRO_POP_BLOCK;
c0204add:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0204ae2:	c9                   	leave  
c0204ae3:	c3                   	ret    

c0204ae4 <get_max_pm_addr>:

//从multi_boot结构体中取出需要管理的地址空间大小 
static uint32_t get_max_pm_addr(){          //qemu默认为128M
c0204ae4:	55                   	push   %ebp
c0204ae5:	89 e5                	mov    %esp,%ebp
c0204ae7:	56                   	push   %esi
c0204ae8:	53                   	push   %ebx
c0204ae9:	83 ec 10             	sub    $0x10,%esp
c0204aec:	e8 13 35 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0204af1:	81 c3 0f 45 00 00    	add    $0x450f,%ebx
	uint32_t max_addr=0;
c0204af7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204afe:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204b04:	8b 00                	mov    (%eax),%eax
c0204b06:	8b 40 30             	mov    0x30(%eax),%eax
c0204b09:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0204b0c:	eb 6a                	jmp    c0204b78 <get_max_pm_addr+0x94>
		printk("[INFO][PMM]physic_mem_block:0x%h-0x%h-0x%h-%d\n",pm_entry_cur->base_addr_low,pm_entry_cur->length_low,pm_entry_cur->base_addr_low+pm_entry_cur->length_low,pm_entry_cur->type);
c0204b0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b11:	8b 48 14             	mov    0x14(%eax),%ecx
c0204b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b17:	8b 50 04             	mov    0x4(%eax),%edx
c0204b1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b1d:	8b 40 0c             	mov    0xc(%eax),%eax
c0204b20:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0204b23:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b26:	8b 50 0c             	mov    0xc(%eax),%edx
c0204b29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b2c:	8b 40 04             	mov    0x4(%eax),%eax
c0204b2f:	83 ec 0c             	sub    $0xc,%esp
c0204b32:	51                   	push   %ecx
c0204b33:	56                   	push   %esi
c0204b34:	52                   	push   %edx
c0204b35:	50                   	push   %eax
c0204b36:	8d 83 54 03 00 00    	lea    0x354(%ebx),%eax
c0204b3c:	50                   	push   %eax
c0204b3d:	e8 25 28 00 00       	call   c0207367 <printk>
c0204b42:	83 c4 20             	add    $0x20,%esp
		if(pm_entry_cur->type==1&&max_addr<pm_entry_cur->base_addr_low+pm_entry_cur->length_low)
c0204b45:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b48:	8b 40 14             	mov    0x14(%eax),%eax
c0204b4b:	83 f8 01             	cmp    $0x1,%eax
c0204b4e:	75 24                	jne    c0204b74 <get_max_pm_addr+0x90>
c0204b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b53:	8b 50 04             	mov    0x4(%eax),%edx
c0204b56:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b59:	8b 40 0c             	mov    0xc(%eax),%eax
c0204b5c:	01 d0                	add    %edx,%eax
c0204b5e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0204b61:	73 11                	jae    c0204b74 <get_max_pm_addr+0x90>
			max_addr=pm_entry_cur->base_addr_low+pm_entry_cur->length_low;		
c0204b63:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b66:	8b 50 04             	mov    0x4(%eax),%edx
c0204b69:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204b6c:	8b 40 0c             	mov    0xc(%eax),%eax
c0204b6f:	01 d0                	add    %edx,%eax
c0204b71:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204b74:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
c0204b78:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204b7e:	8b 00                	mov    (%eax),%eax
c0204b80:	8b 50 30             	mov    0x30(%eax),%edx
c0204b83:	c7 c0 10 80 20 c0    	mov    $0xc0208010,%eax
c0204b89:	8b 00                	mov    (%eax),%eax
c0204b8b:	8b 40 2c             	mov    0x2c(%eax),%eax
c0204b8e:	01 d0                	add    %edx,%eax
c0204b90:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0204b93:	0f 82 75 ff ff ff    	jb     c0204b0e <get_max_pm_addr+0x2a>
	}
	return max_addr;
c0204b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204b9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0204b9f:	5b                   	pop    %ebx
c0204ba0:	5e                   	pop    %esi
c0204ba1:	5d                   	pop    %ebp
c0204ba2:	c3                   	ret    

c0204ba3 <pmm_page_init>:

//初始化页描述结构体以及装载链表
static void pmm_page_init(){  //初始化链表结构体并且填充链表
c0204ba3:	55                   	push   %ebp
c0204ba4:	89 e5                	mov    %esp,%ebp
c0204ba6:	53                   	push   %ebx
c0204ba7:	83 ec 14             	sub    $0x14,%esp
c0204baa:	e8 55 34 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0204baf:	81 c3 51 44 00 00    	add    $0x4451,%ebx
	MULTI_LINK=&multi_link_struct;
c0204bb5:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bbb:	8d 93 60 90 08 00    	lea    0x89060(%ebx),%edx
c0204bc1:	89 10                	mov    %edx,(%eax)
	MULTI_LINK->_1=NULL;
c0204bc3:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bc9:	8b 00                	mov    (%eax),%eax
c0204bcb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	MULTI_LINK->_2=NULL;
c0204bd1:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bd7:	8b 00                	mov    (%eax),%eax
c0204bd9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	MULTI_LINK->_4=NULL;
c0204be0:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204be6:	8b 00                	mov    (%eax),%eax
c0204be8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	MULTI_LINK->_8=NULL;
c0204bef:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204bf5:	8b 00                	mov    (%eax),%eax
c0204bf7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	MULTI_LINK->_16=NULL;
c0204bfe:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c04:	8b 00                	mov    (%eax),%eax
c0204c06:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	MULTI_LINK->_32=NULL;
c0204c0d:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c13:	8b 00                	mov    (%eax),%eax
c0204c15:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	MULTI_LINK->_64=NULL;
c0204c1c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c22:	8b 00                	mov    (%eax),%eax
c0204c24:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	MULTI_LINK->_128=NULL;
c0204c2b:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c31:	8b 00                	mov    (%eax),%eax
c0204c33:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	MULTI_LINK->_256=NULL;
c0204c3a:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c40:	8b 00                	mov    (%eax),%eax
c0204c42:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	MULTI_LINK->_512=NULL;
c0204c49:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c4f:	8b 00                	mov    (%eax),%eax
c0204c51:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	MULTI_LINK->_1024=NULL;
c0204c58:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0204c5e:	8b 00                	mov    (%eax),%eax
c0204c60:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	//我们将要余出至多1023页来作为单页分配的一个缓冲区 这个缓冲区是与伙伴算法独立的 便于快速分配单页
	for(int i=0;i<pmm_max_page_no;i++){
c0204c67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0204c6e:	eb 51                	jmp    c0204cc1 <pmm_page_init+0x11e>
		page_array[i].page_no = i;
c0204c70:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204c76:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204c79:	89 d0                	mov    %edx,%eax
c0204c7b:	01 c0                	add    %eax,%eax
c0204c7d:	01 d0                	add    %edx,%eax
c0204c7f:	c1 e0 02             	shl    $0x2,%eax
c0204c82:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204c85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204c88:	89 02                	mov    %eax,(%edx)
		page_array[i].state = 1;
c0204c8a:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204c90:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204c93:	89 d0                	mov    %edx,%eax
c0204c95:	01 c0                	add    %eax,%eax
c0204c97:	01 d0                	add    %edx,%eax
c0204c99:	c1 e0 02             	shl    $0x2,%eax
c0204c9c:	01 c8                	add    %ecx,%eax
c0204c9e:	c6 40 08 01          	movb   $0x1,0x8(%eax)
		page_array[i].next = NULL;
c0204ca2:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204cab:	89 d0                	mov    %edx,%eax
c0204cad:	01 c0                	add    %eax,%eax
c0204caf:	01 d0                	add    %edx,%eax
c0204cb1:	c1 e0 02             	shl    $0x2,%eax
c0204cb4:	01 c8                	add    %ecx,%eax
c0204cb6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	for(int i=0;i<pmm_max_page_no;i++){
c0204cbd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0204cc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204cc4:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0204cca:	39 c2                	cmp    %eax,%edx
c0204ccc:	72 a2                	jb     c0204c70 <pmm_page_init+0xcd>
	}
	//装载链表
	append_block(0,_1);    //1页链表
c0204cce:	6a 00                	push   $0x0
c0204cd0:	6a 00                	push   $0x0
c0204cd2:	e8 dc f5 ff ff       	call   c02042b3 <append_block>
c0204cd7:	83 c4 08             	add    $0x8,%esp
	append_block(1,_1);
c0204cda:	6a 00                	push   $0x0
c0204cdc:	6a 01                	push   $0x1
c0204cde:	e8 d0 f5 ff ff       	call   c02042b3 <append_block>
c0204ce3:	83 c4 08             	add    $0x8,%esp

	append_block(2,_2);    //2页链表
c0204ce6:	6a 01                	push   $0x1
c0204ce8:	6a 02                	push   $0x2
c0204cea:	e8 c4 f5 ff ff       	call   c02042b3 <append_block>
c0204cef:	83 c4 08             	add    $0x8,%esp

	append_block(4,_4);
c0204cf2:	6a 02                	push   $0x2
c0204cf4:	6a 04                	push   $0x4
c0204cf6:	e8 b8 f5 ff ff       	call   c02042b3 <append_block>
c0204cfb:	83 c4 08             	add    $0x8,%esp

	append_block(8,_8);
c0204cfe:	6a 03                	push   $0x3
c0204d00:	6a 08                	push   $0x8
c0204d02:	e8 ac f5 ff ff       	call   c02042b3 <append_block>
c0204d07:	83 c4 08             	add    $0x8,%esp

	append_block(16,_16);
c0204d0a:	6a 04                	push   $0x4
c0204d0c:	6a 10                	push   $0x10
c0204d0e:	e8 a0 f5 ff ff       	call   c02042b3 <append_block>
c0204d13:	83 c4 08             	add    $0x8,%esp

	append_block(32,_32);
c0204d16:	6a 05                	push   $0x5
c0204d18:	6a 20                	push   $0x20
c0204d1a:	e8 94 f5 ff ff       	call   c02042b3 <append_block>
c0204d1f:	83 c4 08             	add    $0x8,%esp

	append_block(64,_64);
c0204d22:	6a 06                	push   $0x6
c0204d24:	6a 40                	push   $0x40
c0204d26:	e8 88 f5 ff ff       	call   c02042b3 <append_block>
c0204d2b:	83 c4 08             	add    $0x8,%esp

	append_block(128,_128);
c0204d2e:	6a 07                	push   $0x7
c0204d30:	68 80 00 00 00       	push   $0x80
c0204d35:	e8 79 f5 ff ff       	call   c02042b3 <append_block>
c0204d3a:	83 c4 08             	add    $0x8,%esp

	append_block(256,_256);
c0204d3d:	6a 08                	push   $0x8
c0204d3f:	68 00 01 00 00       	push   $0x100
c0204d44:	e8 6a f5 ff ff       	call   c02042b3 <append_block>
c0204d49:	83 c4 08             	add    $0x8,%esp

	append_block(512,_512);
c0204d4c:	6a 09                	push   $0x9
c0204d4e:	68 00 02 00 00       	push   $0x200
c0204d53:	e8 5b f5 ff ff       	call   c02042b3 <append_block>
c0204d58:	83 c4 08             	add    $0x8,%esp

	append_block(1024,_1024);
c0204d5b:	6a 0a                	push   $0xa
c0204d5d:	68 00 04 00 00       	push   $0x400
c0204d62:	e8 4c f5 ff ff       	call   c02042b3 <append_block>
c0204d67:	83 c4 08             	add    $0x8,%esp


	int temp_page_no=2048;
c0204d6a:	c7 45 f0 00 08 00 00 	movl   $0x800,-0x10(%ebp)
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0204d71:	eb 14                	jmp    c0204d87 <pmm_page_init+0x1e4>
		append_block(temp_page_no,_1024);
c0204d73:	6a 0a                	push   $0xa
c0204d75:	ff 75 f0             	pushl  -0x10(%ebp)
c0204d78:	e8 36 f5 ff ff       	call   c02042b3 <append_block>
c0204d7d:	83 c4 08             	add    $0x8,%esp
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0204d80:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c0204d87:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0204d8d:	8d 90 00 fc ff ff    	lea    -0x400(%eax),%edx
c0204d93:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204d96:	39 c2                	cmp    %eax,%edx
c0204d98:	77 d9                	ja     c0204d73 <pmm_page_init+0x1d0>
	}
	singel_page_first_no = temp_page_no;   //将第一个单页缓冲区的编号存放好
c0204d9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204d9d:	89 83 9c 90 08 00    	mov    %eax,0x8909c(%ebx)

	printk("[INFO][PMM]single_page_count:%d\n",pmm_max_page_no-temp_page_no);
c0204da3:	8b 93 98 90 08 00    	mov    0x89098(%ebx),%edx
c0204da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204dac:	29 c2                	sub    %eax,%edx
c0204dae:	89 d0                	mov    %edx,%eax
c0204db0:	83 ec 08             	sub    $0x8,%esp
c0204db3:	50                   	push   %eax
c0204db4:	8d 83 84 03 00 00    	lea    0x384(%ebx),%eax
c0204dba:	50                   	push   %eax
c0204dbb:	e8 a7 25 00 00       	call   c0207367 <printk>
c0204dc0:	83 c4 10             	add    $0x10,%esp
	pm_page_t * temp_single_probe = NULL;
c0204dc3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c0204dca:	eb 57                	jmp    c0204e23 <pmm_page_init+0x280>
		if(SINGLE_LINK == NULL){
c0204dcc:	8b 83 8c 90 08 00    	mov    0x8908c(%ebx),%eax
c0204dd2:	85 c0                	test   %eax,%eax
c0204dd4:	75 25                	jne    c0204dfb <pmm_page_init+0x258>
			SINGLE_LINK=&(page_array[temp_page_no]);
c0204dd6:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204ddc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204ddf:	89 d0                	mov    %edx,%eax
c0204de1:	01 c0                	add    %eax,%eax
c0204de3:	01 d0                	add    %edx,%eax
c0204de5:	c1 e0 02             	shl    $0x2,%eax
c0204de8:	01 c8                	add    %ecx,%eax
c0204dea:	89 83 8c 90 08 00    	mov    %eax,0x8908c(%ebx)
			temp_single_probe = SINGLE_LINK ;
c0204df0:	8b 83 8c 90 08 00    	mov    0x8908c(%ebx),%eax
c0204df6:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0204df9:	eb 24                	jmp    c0204e1f <pmm_page_init+0x27c>
		}
		else{
			temp_single_probe->next = &(page_array[temp_page_no]);
c0204dfb:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0204e01:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204e04:	89 d0                	mov    %edx,%eax
c0204e06:	01 c0                	add    %eax,%eax
c0204e08:	01 d0                	add    %edx,%eax
c0204e0a:	c1 e0 02             	shl    $0x2,%eax
c0204e0d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204e10:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204e13:	89 50 04             	mov    %edx,0x4(%eax)
			temp_single_probe = temp_single_probe -> next;
c0204e16:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204e19:	8b 40 04             	mov    0x4(%eax),%eax
c0204e1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c0204e1f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0204e23:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0204e26:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0204e2c:	39 c2                	cmp    %eax,%edx
c0204e2e:	72 9c                	jb     c0204dcc <pmm_page_init+0x229>
		}
	}
}
c0204e30:	90                   	nop
c0204e31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0204e34:	c9                   	leave  
c0204e35:	c3                   	ret    

c0204e36 <alloc_helper>:





static uint32_t alloc_helper(page_c_t target_ph,page_c_t pop_ph,uint32_t pop_page_no){
c0204e36:	55                   	push   %ebp
c0204e37:	89 e5                	mov    %esp,%ebp
c0204e39:	83 ec 10             	sub    $0x10,%esp
c0204e3c:	e8 bf 31 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204e41:	05 bf 41 00 00       	add    $0x41bf,%eax
	for(;pop_ph!=target_ph;pop_ph--){
c0204e46:	eb 2e                	jmp    c0204e76 <alloc_helper+0x40>
		uint32_t append_page_no = pop_page_no+(c_to_uint32(pop_ph)/2);
c0204e48:	ff 75 0c             	pushl  0xc(%ebp)
c0204e4b:	e8 f3 f3 ff ff       	call   c0204243 <c_to_uint32>
c0204e50:	83 c4 04             	add    $0x4,%esp
c0204e53:	d1 e8                	shr    %eax
c0204e55:	89 c2                	mov    %eax,%edx
c0204e57:	8b 45 10             	mov    0x10(%ebp),%eax
c0204e5a:	01 d0                	add    %edx,%eax
c0204e5c:	89 45 fc             	mov    %eax,-0x4(%ebp)
		append_block(append_page_no,pop_page_no-1);
c0204e5f:	8b 45 10             	mov    0x10(%ebp),%eax
c0204e62:	8d 50 ff             	lea    -0x1(%eax),%edx
c0204e65:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204e68:	52                   	push   %edx
c0204e69:	50                   	push   %eax
c0204e6a:	e8 44 f4 ff ff       	call   c02042b3 <append_block>
c0204e6f:	83 c4 08             	add    $0x8,%esp
	for(;pop_ph!=target_ph;pop_ph--){
c0204e72:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0204e76:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204e79:	3b 45 08             	cmp    0x8(%ebp),%eax
c0204e7c:	75 ca                	jne    c0204e48 <alloc_helper+0x12>
	}
	return pop_page_no;
c0204e7e:	8b 45 10             	mov    0x10(%ebp),%eax
}
c0204e81:	c9                   	leave  
c0204e82:	c3                   	ret    

c0204e83 <pmm_alloc_pages>:



//伙伴算法多页分配
pm_alloc_t pmm_alloc_pages(uint32_t page_count){
c0204e83:	55                   	push   %ebp
c0204e84:	89 e5                	mov    %esp,%ebp
c0204e86:	83 ec 30             	sub    $0x30,%esp
c0204e89:	e8 72 31 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204e8e:	05 72 41 00 00       	add    $0x4172,%eax
	pm_alloc_t return_struct = {0,_erro,0}; 
c0204e93:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c0204e9a:	c7 45 dc 0b 00 00 00 	movl   $0xb,-0x24(%ebp)
c0204ea1:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
	if (page_count>1024||page_count==0)
c0204ea5:	81 7d 0c 00 04 00 00 	cmpl   $0x400,0xc(%ebp)
c0204eac:	77 06                	ja     c0204eb4 <pmm_alloc_pages+0x31>
c0204eae:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0204eb2:	75 19                	jne    c0204ecd <pmm_alloc_pages+0x4a>
		return return_struct;    //分配失败
c0204eb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0204eb7:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0204eba:	89 10                	mov    %edx,(%eax)
c0204ebc:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0204ebf:	89 50 04             	mov    %edx,0x4(%eax)
c0204ec2:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0204ec5:	89 50 08             	mov    %edx,0x8(%eax)
c0204ec8:	e9 ce 00 00 00       	jmp    c0204f9b <pmm_alloc_pages+0x118>
	//来点骚操作
	//获取需要分配的页数
	uint32_t page_count_probe=page_count;
c0204ecd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204ed0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter1 = 0;
c0204ed3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;page_count_probe!=0 ;counter1++,page_count_probe=page_count_probe>>1)
c0204eda:	eb 07                	jmp    c0204ee3 <pmm_alloc_pages+0x60>
c0204edc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0204ee0:	d1 6d fc             	shrl   -0x4(%ebp)
c0204ee3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ee7:	75 f3                	jne    c0204edc <pmm_alloc_pages+0x59>
		;
	uint32_t counter2= counter1-1;
c0204ee9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204eec:	83 e8 01             	sub    $0x1,%eax
c0204eef:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(page_count==(1<<counter2))
c0204ef2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204ef5:	ba 01 00 00 00       	mov    $0x1,%edx
c0204efa:	89 c1                	mov    %eax,%ecx
c0204efc:	d3 e2                	shl    %cl,%edx
c0204efe:	89 d0                	mov    %edx,%eax
c0204f00:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0204f03:	75 04                	jne    c0204f09 <pmm_alloc_pages+0x86>
		counter1--;
c0204f05:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	//此时的counter1即为pm_c_t枚举的对应值
	page_c_t ph = counter1;
c0204f09:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	page_c_t origin_ph = ph;    //存放原始ph
c0204f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204f12:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pop_page_no = ERRO_POP_BLOCK;
c0204f15:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	for(;ph<_erro;ph++){
c0204f1c:	eb 18                	jmp    c0204f36 <pmm_alloc_pages+0xb3>
		pop_page_no = pop_block(ph);
c0204f1e:	ff 75 f4             	pushl  -0xc(%ebp)
c0204f21:	e8 d3 f6 ff ff       	call   c02045f9 <pop_block>
c0204f26:	83 c4 04             	add    $0x4,%esp
c0204f29:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(pop_page_no!=ERRO_POP_BLOCK)
c0204f2c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0204f30:	75 0c                	jne    c0204f3e <pmm_alloc_pages+0xbb>
	for(;ph<_erro;ph++){
c0204f32:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0204f36:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
c0204f3a:	76 e2                	jbe    c0204f1e <pmm_alloc_pages+0x9b>
c0204f3c:	eb 01                	jmp    c0204f3f <pmm_alloc_pages+0xbc>
			break;
c0204f3e:	90                   	nop
	}
	if(pop_page_no==ERRO_POP_BLOCK){
c0204f3f:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0204f43:	75 16                	jne    c0204f5b <pmm_alloc_pages+0xd8>
		return return_struct;    //分配失败
c0204f45:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f48:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0204f4b:	89 10                	mov    %edx,(%eax)
c0204f4d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0204f50:	89 50 04             	mov    %edx,0x4(%eax)
c0204f53:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0204f56:	89 50 08             	mov    %edx,0x8(%eax)
c0204f59:	eb 40                	jmp    c0204f9b <pmm_alloc_pages+0x118>
	}
	else{
		uint32_t target_page_no = alloc_helper(origin_ph,ph,pop_page_no);
c0204f5b:	ff 75 f0             	pushl  -0x10(%ebp)
c0204f5e:	ff 75 f4             	pushl  -0xc(%ebp)
c0204f61:	ff 75 e8             	pushl  -0x18(%ebp)
c0204f64:	e8 cd fe ff ff       	call   c0204e36 <alloc_helper>
c0204f69:	83 c4 0c             	add    $0xc,%esp
c0204f6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return_struct.addr = pmm_page_no_to_addr(target_page_no);
c0204f6f:	ff 75 e4             	pushl  -0x1c(%ebp)
c0204f72:	e8 90 f2 ff ff       	call   c0204207 <pmm_page_no_to_addr>
c0204f77:	83 c4 04             	add    $0x4,%esp
c0204f7a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		return_struct.state = 1;
c0204f7d:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
		return_struct.size = origin_ph;
c0204f81:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0204f84:	89 45 dc             	mov    %eax,-0x24(%ebp)
		return return_struct;
c0204f87:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f8a:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0204f8d:	89 10                	mov    %edx,(%eax)
c0204f8f:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0204f92:	89 50 04             	mov    %edx,0x4(%eax)
c0204f95:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0204f98:	89 50 08             	mov    %edx,0x8(%eax)
	}
}
c0204f9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f9e:	c9                   	leave  
c0204f9f:	c2 04 00             	ret    $0x4

c0204fa2 <pmm_alloc_one_page>:

//缓冲区及伙伴算法单页分配
//当缓冲区没有页的时候会调用伙伴算法分配一页
pm_alloc_t pmm_alloc_one_page(){
c0204fa2:	55                   	push   %ebp
c0204fa3:	89 e5                	mov    %esp,%ebp
c0204fa5:	83 ec 20             	sub    $0x20,%esp
c0204fa8:	e8 53 30 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0204fad:	05 53 40 00 00       	add    $0x4053,%eax
	pm_alloc_t return_struct = {0,_erro,0};
c0204fb2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0204fb9:	c7 45 f0 0b 00 00 00 	movl   $0xb,-0x10(%ebp)
c0204fc0:	c6 45 f4 00          	movb   $0x0,-0xc(%ebp)
	if(SINGLE_LINK!=NULL){
c0204fc4:	8b 90 8c 90 08 00    	mov    0x8908c(%eax),%edx
c0204fca:	85 d2                	test   %edx,%edx
c0204fcc:	0f 84 ac 00 00 00    	je     c020507e <pmm_alloc_one_page+0xdc>
		pm_page_t * header = SINGLE_LINK;
c0204fd2:	8b 90 8c 90 08 00    	mov    0x8908c(%eax),%edx
c0204fd8:	89 55 f8             	mov    %edx,-0x8(%ebp)
		if(header->next==NULL){
c0204fdb:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204fde:	8b 52 04             	mov    0x4(%edx),%edx
c0204fe1:	85 d2                	test   %edx,%edx
c0204fe3:	75 3c                	jne    c0205021 <pmm_alloc_one_page+0x7f>
			SINGLE_LINK = NULL;
c0204fe5:	c7 80 8c 90 08 00 00 	movl   $0x0,0x8908c(%eax)
c0204fec:	00 00 00 
			return_struct.state = 1;
c0204fef:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c0204ff3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(header->page_no);
c0204ffa:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ffd:	8b 00                	mov    (%eax),%eax
c0204fff:	50                   	push   %eax
c0205000:	e8 02 f2 ff ff       	call   c0204207 <pmm_page_no_to_addr>
c0205005:	83 c4 04             	add    $0x4,%esp
c0205008:	89 45 ec             	mov    %eax,-0x14(%ebp)
			return return_struct;
c020500b:	8b 45 08             	mov    0x8(%ebp),%eax
c020500e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0205011:	89 10                	mov    %edx,(%eax)
c0205013:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205016:	89 50 04             	mov    %edx,0x4(%eax)
c0205019:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020501c:	89 50 08             	mov    %edx,0x8(%eax)
c020501f:	eb 6b                	jmp    c020508c <pmm_alloc_one_page+0xea>
		}
		else{
			pm_page_t * probe = header;
c0205021:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205024:	89 45 fc             	mov    %eax,-0x4(%ebp)
			for(;probe->next->next!=NULL;probe=probe->next){
c0205027:	eb 09                	jmp    c0205032 <pmm_alloc_one_page+0x90>
c0205029:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020502c:	8b 40 04             	mov    0x4(%eax),%eax
c020502f:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0205032:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205035:	8b 40 04             	mov    0x4(%eax),%eax
c0205038:	8b 40 04             	mov    0x4(%eax),%eax
c020503b:	85 c0                	test   %eax,%eax
c020503d:	75 ea                	jne    c0205029 <pmm_alloc_one_page+0x87>
				//printk("%d\n",probe->page_no);
				//if(probe->page_no==0){
				//	while(1);
				//}
			}
			return_struct.state = 1;
c020503f:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c0205043:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(probe->next->page_no);
c020504a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020504d:	8b 40 04             	mov    0x4(%eax),%eax
c0205050:	8b 00                	mov    (%eax),%eax
c0205052:	50                   	push   %eax
c0205053:	e8 af f1 ff ff       	call   c0204207 <pmm_page_no_to_addr>
c0205058:	83 c4 04             	add    $0x4,%esp
c020505b:	89 45 ec             	mov    %eax,-0x14(%ebp)
			probe->next = NULL;
c020505e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205061:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		}
		return return_struct;
c0205068:	8b 45 08             	mov    0x8(%ebp),%eax
c020506b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c020506e:	89 10                	mov    %edx,(%eax)
c0205070:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205073:	89 50 04             	mov    %edx,0x4(%eax)
c0205076:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205079:	89 50 08             	mov    %edx,0x8(%eax)
c020507c:	eb 0e                	jmp    c020508c <pmm_alloc_one_page+0xea>
	}
	else{
		return pmm_alloc_pages(1);
c020507e:	8b 45 08             	mov    0x8(%ebp),%eax
c0205081:	6a 01                	push   $0x1
c0205083:	50                   	push   %eax
c0205084:	e8 fa fd ff ff       	call   c0204e83 <pmm_alloc_pages>
c0205089:	83 c4 04             	add    $0x4,%esp
	}
}
c020508c:	8b 45 08             	mov    0x8(%ebp),%eax
c020508f:	c9                   	leave  
c0205090:	c2 04 00             	ret    $0x4

c0205093 <free_helper>:

static void free_helper(uint32_t page_no,page_c_t size){
c0205093:	55                   	push   %ebp
c0205094:	89 e5                	mov    %esp,%ebp
c0205096:	53                   	push   %ebx
c0205097:	83 ec 14             	sub    $0x14,%esp
c020509a:	e8 65 2f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020509f:	81 c3 61 3f 00 00    	add    $0x3f61,%ebx
	printk("free size : %d\n",c_to_uint32(size));
c02050a5:	ff 75 0c             	pushl  0xc(%ebp)
c02050a8:	e8 96 f1 ff ff       	call   c0204243 <c_to_uint32>
c02050ad:	83 c4 04             	add    $0x4,%esp
c02050b0:	83 ec 08             	sub    $0x8,%esp
c02050b3:	50                   	push   %eax
c02050b4:	8d 83 a5 03 00 00    	lea    0x3a5(%ebx),%eax
c02050ba:	50                   	push   %eax
c02050bb:	e8 a7 22 00 00       	call   c0207367 <printk>
c02050c0:	83 c4 10             	add    $0x10,%esp
	uint32_t partner_page_no = get_partner_page_no(page_no,size);
c02050c3:	83 ec 08             	sub    $0x8,%esp
c02050c6:	ff 75 0c             	pushl  0xc(%ebp)
c02050c9:	ff 75 08             	pushl  0x8(%ebp)
c02050cc:	e8 96 f1 ff ff       	call   c0204267 <get_partner_page_no>
c02050d1:	83 c4 10             	add    $0x10,%esp
c02050d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(find_and_pop_block(partner_page_no,size)!=ERRO_POP_BLOCK){
c02050d7:	83 ec 08             	sub    $0x8,%esp
c02050da:	ff 75 0c             	pushl  0xc(%ebp)
c02050dd:	ff 75 f4             	pushl  -0xc(%ebp)
c02050e0:	e8 84 f8 ff ff       	call   c0204969 <find_and_pop_block>
c02050e5:	83 c4 10             	add    $0x10,%esp
c02050e8:	83 f8 ff             	cmp    $0xffffffff,%eax
c02050eb:	74 1f                	je     c020510c <free_helper+0x79>
		//合并
		free_helper(partner_page_no<page_no?partner_page_no:page_no,size+1);
c02050ed:	8b 45 0c             	mov    0xc(%ebp),%eax
c02050f0:	8d 50 01             	lea    0x1(%eax),%edx
c02050f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02050f6:	39 45 08             	cmp    %eax,0x8(%ebp)
c02050f9:	0f 46 45 08          	cmovbe 0x8(%ebp),%eax
c02050fd:	83 ec 08             	sub    $0x8,%esp
c0205100:	52                   	push   %edx
c0205101:	50                   	push   %eax
c0205102:	e8 8c ff ff ff       	call   c0205093 <free_helper>
c0205107:	83 c4 10             	add    $0x10,%esp
	}
	else{
		append_block(page_no,size);
	}
}
c020510a:	eb 12                	jmp    c020511e <free_helper+0x8b>
		append_block(page_no,size);
c020510c:	8b 45 08             	mov    0x8(%ebp),%eax
c020510f:	83 ec 08             	sub    $0x8,%esp
c0205112:	ff 75 0c             	pushl  0xc(%ebp)
c0205115:	50                   	push   %eax
c0205116:	e8 98 f1 ff ff       	call   c02042b3 <append_block>
c020511b:	83 c4 10             	add    $0x10,%esp
}
c020511e:	90                   	nop
c020511f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205122:	c9                   	leave  
c0205123:	c3                   	ret    

c0205124 <pmm_free_page>:

//free页 返回bool型（定义在typs.h中） True-成功free False-失败
bool pmm_free_page(pm_alloc_t block_disc){
c0205124:	55                   	push   %ebp
c0205125:	89 e5                	mov    %esp,%ebp
c0205127:	53                   	push   %ebx
c0205128:	83 ec 14             	sub    $0x14,%esp
c020512b:	e8 d4 2e 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205130:	81 c3 d0 3e 00 00    	add    $0x3ed0,%ebx
	//检查页是否在页编号范围内
	uint32_t page_no = addr_to_pmm_page_no(block_disc.addr);
c0205136:	8b 45 08             	mov    0x8(%ebp),%eax
c0205139:	50                   	push   %eax
c020513a:	e8 e5 f0 ff ff       	call   c0204224 <addr_to_pmm_page_no>
c020513f:	83 c4 04             	add    $0x4,%esp
c0205142:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(page_no<pmm_max_page_no){
c0205145:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c020514b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c020514e:	73 7f                	jae    c02051cf <pmm_free_page+0xab>
		if(page_no<singel_page_first_no)
c0205150:	8b 83 9c 90 08 00    	mov    0x8909c(%ebx),%eax
c0205156:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0205159:	73 14                	jae    c020516f <pmm_free_page+0x4b>
			free_helper(page_no,block_disc.size);
c020515b:	8b 45 0c             	mov    0xc(%ebp),%eax
c020515e:	83 ec 08             	sub    $0x8,%esp
c0205161:	50                   	push   %eax
c0205162:	ff 75 f0             	pushl  -0x10(%ebp)
c0205165:	e8 29 ff ff ff       	call   c0205093 <free_helper>
c020516a:	83 c4 10             	add    $0x10,%esp
c020516d:	eb 59                	jmp    c02051c8 <pmm_free_page+0xa4>
		else{
			pm_page_t *probe = SINGLE_LINK;
c020516f:	8b 83 8c 90 08 00    	mov    0x8908c(%ebx),%eax
c0205175:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if(probe==NULL){
c0205178:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c020517c:	75 25                	jne    c02051a3 <pmm_free_page+0x7f>
				SINGLE_LINK=&page_array[page_no];
c020517e:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c0205184:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205187:	89 d0                	mov    %edx,%eax
c0205189:	01 c0                	add    %eax,%eax
c020518b:	01 d0                	add    %edx,%eax
c020518d:	c1 e0 02             	shl    $0x2,%eax
c0205190:	01 c8                	add    %ecx,%eax
c0205192:	89 83 8c 90 08 00    	mov    %eax,0x8908c(%ebx)
c0205198:	eb 2e                	jmp    c02051c8 <pmm_free_page+0xa4>
			}
			else{
				for(;probe->next!=NULL;probe=probe->next)
c020519a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020519d:	8b 40 04             	mov    0x4(%eax),%eax
c02051a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02051a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02051a6:	8b 40 04             	mov    0x4(%eax),%eax
c02051a9:	85 c0                	test   %eax,%eax
c02051ab:	75 ed                	jne    c020519a <pmm_free_page+0x76>
					;
				probe->next = &page_array[page_no];
c02051ad:	8b 8b 1c f0 ff ff    	mov    -0xfe4(%ebx),%ecx
c02051b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02051b6:	89 d0                	mov    %edx,%eax
c02051b8:	01 c0                	add    %eax,%eax
c02051ba:	01 d0                	add    %edx,%eax
c02051bc:	c1 e0 02             	shl    $0x2,%eax
c02051bf:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c02051c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02051c5:	89 50 04             	mov    %edx,0x4(%eax)
			}
		}
		return True;
c02051c8:	b8 01 00 00 00       	mov    $0x1,%eax
c02051cd:	eb 05                	jmp    c02051d4 <pmm_free_page+0xb0>
	}
	else
		return False;
c02051cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
c02051d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02051d7:	c9                   	leave  
c02051d8:	c3                   	ret    

c02051d9 <counte_helper>:

static uint32_t counte_helper(pm_page_t * probe){
c02051d9:	55                   	push   %ebp
c02051da:	89 e5                	mov    %esp,%ebp
c02051dc:	83 ec 10             	sub    $0x10,%esp
c02051df:	e8 1c 2e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02051e4:	05 1c 3e 00 00       	add    $0x3e1c,%eax
	uint32_t counter = 0;
c02051e9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02051f0:	eb 0d                	jmp    c02051ff <counte_helper+0x26>
		counter++;
c02051f2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02051f6:	8b 45 08             	mov    0x8(%ebp),%eax
c02051f9:	8b 40 04             	mov    0x4(%eax),%eax
c02051fc:	89 45 08             	mov    %eax,0x8(%ebp)
c02051ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0205203:	75 ed                	jne    c02051f2 <counte_helper+0x19>
	return counter;
c0205205:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0205208:	c9                   	leave  
c0205209:	c3                   	ret    

c020520a <get_block_count>:

uint32_t * get_block_count(){
c020520a:	55                   	push   %ebp
c020520b:	89 e5                	mov    %esp,%ebp
c020520d:	53                   	push   %ebx
c020520e:	e8 f1 2d 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205213:	81 c3 ed 3d 00 00    	add    $0x3ded,%ebx
	block_count_array[_1]=counte_helper(MULTI_LINK->_1);
c0205219:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020521f:	8b 00                	mov    (%eax),%eax
c0205221:	8b 00                	mov    (%eax),%eax
c0205223:	50                   	push   %eax
c0205224:	e8 b0 ff ff ff       	call   c02051d9 <counte_helper>
c0205229:	83 c4 04             	add    $0x4,%esp
c020522c:	89 83 20 90 08 00    	mov    %eax,0x89020(%ebx)
	block_count_array[_2]=counte_helper(MULTI_LINK->_2);
c0205232:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205238:	8b 00                	mov    (%eax),%eax
c020523a:	8b 40 04             	mov    0x4(%eax),%eax
c020523d:	50                   	push   %eax
c020523e:	e8 96 ff ff ff       	call   c02051d9 <counte_helper>
c0205243:	83 c4 04             	add    $0x4,%esp
c0205246:	89 83 24 90 08 00    	mov    %eax,0x89024(%ebx)
	block_count_array[_4]=counte_helper(MULTI_LINK->_4);
c020524c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205252:	8b 00                	mov    (%eax),%eax
c0205254:	8b 40 08             	mov    0x8(%eax),%eax
c0205257:	50                   	push   %eax
c0205258:	e8 7c ff ff ff       	call   c02051d9 <counte_helper>
c020525d:	83 c4 04             	add    $0x4,%esp
c0205260:	89 83 28 90 08 00    	mov    %eax,0x89028(%ebx)
	block_count_array[_8]=counte_helper(MULTI_LINK->_8);
c0205266:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c020526c:	8b 00                	mov    (%eax),%eax
c020526e:	8b 40 0c             	mov    0xc(%eax),%eax
c0205271:	50                   	push   %eax
c0205272:	e8 62 ff ff ff       	call   c02051d9 <counte_helper>
c0205277:	83 c4 04             	add    $0x4,%esp
c020527a:	89 83 2c 90 08 00    	mov    %eax,0x8902c(%ebx)
	block_count_array[_16]=counte_helper(MULTI_LINK->_16);
c0205280:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205286:	8b 00                	mov    (%eax),%eax
c0205288:	8b 40 10             	mov    0x10(%eax),%eax
c020528b:	50                   	push   %eax
c020528c:	e8 48 ff ff ff       	call   c02051d9 <counte_helper>
c0205291:	83 c4 04             	add    $0x4,%esp
c0205294:	89 83 30 90 08 00    	mov    %eax,0x89030(%ebx)
	block_count_array[_32]=counte_helper(MULTI_LINK->_32);
c020529a:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052a0:	8b 00                	mov    (%eax),%eax
c02052a2:	8b 40 14             	mov    0x14(%eax),%eax
c02052a5:	50                   	push   %eax
c02052a6:	e8 2e ff ff ff       	call   c02051d9 <counte_helper>
c02052ab:	83 c4 04             	add    $0x4,%esp
c02052ae:	89 83 34 90 08 00    	mov    %eax,0x89034(%ebx)
	block_count_array[_64]=counte_helper(MULTI_LINK->_64);
c02052b4:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052ba:	8b 00                	mov    (%eax),%eax
c02052bc:	8b 40 18             	mov    0x18(%eax),%eax
c02052bf:	50                   	push   %eax
c02052c0:	e8 14 ff ff ff       	call   c02051d9 <counte_helper>
c02052c5:	83 c4 04             	add    $0x4,%esp
c02052c8:	89 83 38 90 08 00    	mov    %eax,0x89038(%ebx)
	block_count_array[_128]=counte_helper(MULTI_LINK->_128);
c02052ce:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052d4:	8b 00                	mov    (%eax),%eax
c02052d6:	8b 40 1c             	mov    0x1c(%eax),%eax
c02052d9:	50                   	push   %eax
c02052da:	e8 fa fe ff ff       	call   c02051d9 <counte_helper>
c02052df:	83 c4 04             	add    $0x4,%esp
c02052e2:	89 83 3c 90 08 00    	mov    %eax,0x8903c(%ebx)
	block_count_array[_256]=counte_helper(MULTI_LINK->_256);
c02052e8:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c02052ee:	8b 00                	mov    (%eax),%eax
c02052f0:	8b 40 20             	mov    0x20(%eax),%eax
c02052f3:	50                   	push   %eax
c02052f4:	e8 e0 fe ff ff       	call   c02051d9 <counte_helper>
c02052f9:	83 c4 04             	add    $0x4,%esp
c02052fc:	89 83 40 90 08 00    	mov    %eax,0x89040(%ebx)
	block_count_array[_512]=counte_helper(MULTI_LINK->_512);
c0205302:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205308:	8b 00                	mov    (%eax),%eax
c020530a:	8b 40 24             	mov    0x24(%eax),%eax
c020530d:	50                   	push   %eax
c020530e:	e8 c6 fe ff ff       	call   c02051d9 <counte_helper>
c0205313:	83 c4 04             	add    $0x4,%esp
c0205316:	89 83 44 90 08 00    	mov    %eax,0x89044(%ebx)
	block_count_array[_1024]=counte_helper(MULTI_LINK->_1024);
c020531c:	c7 c0 78 30 29 c0    	mov    $0xc0293078,%eax
c0205322:	8b 00                	mov    (%eax),%eax
c0205324:	8b 40 28             	mov    0x28(%eax),%eax
c0205327:	50                   	push   %eax
c0205328:	e8 ac fe ff ff       	call   c02051d9 <counte_helper>
c020532d:	83 c4 04             	add    $0x4,%esp
c0205330:	89 83 48 90 08 00    	mov    %eax,0x89048(%ebx)
	block_count_array[_erro]=0;
c0205336:	c7 83 4c 90 08 00 00 	movl   $0x0,0x8904c(%ebx)
c020533d:	00 00 00 
	return block_count_array;
c0205340:	8d 83 20 90 08 00    	lea    0x89020(%ebx),%eax
}
c0205346:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205349:	c9                   	leave  
c020534a:	c3                   	ret    

c020534b <get_single_count>:

uint32_t get_single_count(){
c020534b:	55                   	push   %ebp
c020534c:	89 e5                	mov    %esp,%ebp
c020534e:	83 ec 10             	sub    $0x10,%esp
c0205351:	e8 aa 2c 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205356:	05 aa 3c 00 00       	add    $0x3caa,%eax
	pm_page_t * probe =SINGLE_LINK;
c020535b:	8b 80 8c 90 08 00    	mov    0x8908c(%eax),%eax
c0205361:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter = 0;
c0205364:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c020536b:	eb 0d                	jmp    c020537a <get_single_count+0x2f>
		counter++;
c020536d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205371:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205374:	8b 40 04             	mov    0x4(%eax),%eax
c0205377:	89 45 fc             	mov    %eax,-0x4(%ebp)
c020537a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020537e:	75 ed                	jne    c020536d <get_single_count+0x22>
	return counter;	
c0205380:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0205383:	c9                   	leave  
c0205384:	c3                   	ret    

c0205385 <pmm_show_page_count>:

//打印块使用情况的函数 
//懒得挨个写 用宏来解决
// #表示字符串化 ##表示连接生成符号操作
#define MACRO_PMM_1(number) printk("_"#number":%d blocks\n",block_count_array[_##number])
void pmm_show_page_count(){
c0205385:	55                   	push   %ebp
c0205386:	89 e5                	mov    %esp,%ebp
c0205388:	53                   	push   %ebx
c0205389:	83 ec 04             	sub    $0x4,%esp
c020538c:	e8 73 2c 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205391:	81 c3 6f 3c 00 00    	add    $0x3c6f,%ebx
	get_block_count();
c0205397:	e8 6e fe ff ff       	call   c020520a <get_block_count>
	printk("Partner:\n");
c020539c:	83 ec 0c             	sub    $0xc,%esp
c020539f:	8d 83 b5 03 00 00    	lea    0x3b5(%ebx),%eax
c02053a5:	50                   	push   %eax
c02053a6:	e8 bc 1f 00 00       	call   c0207367 <printk>
c02053ab:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1);
c02053ae:	8b 83 20 90 08 00    	mov    0x89020(%ebx),%eax
c02053b4:	83 ec 08             	sub    $0x8,%esp
c02053b7:	50                   	push   %eax
c02053b8:	8d 83 bf 03 00 00    	lea    0x3bf(%ebx),%eax
c02053be:	50                   	push   %eax
c02053bf:	e8 a3 1f 00 00       	call   c0207367 <printk>
c02053c4:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(2);
c02053c7:	8b 83 24 90 08 00    	mov    0x89024(%ebx),%eax
c02053cd:	83 ec 08             	sub    $0x8,%esp
c02053d0:	50                   	push   %eax
c02053d1:	8d 83 cd 03 00 00    	lea    0x3cd(%ebx),%eax
c02053d7:	50                   	push   %eax
c02053d8:	e8 8a 1f 00 00       	call   c0207367 <printk>
c02053dd:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(4);
c02053e0:	8b 83 28 90 08 00    	mov    0x89028(%ebx),%eax
c02053e6:	83 ec 08             	sub    $0x8,%esp
c02053e9:	50                   	push   %eax
c02053ea:	8d 83 db 03 00 00    	lea    0x3db(%ebx),%eax
c02053f0:	50                   	push   %eax
c02053f1:	e8 71 1f 00 00       	call   c0207367 <printk>
c02053f6:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(8);
c02053f9:	8b 83 2c 90 08 00    	mov    0x8902c(%ebx),%eax
c02053ff:	83 ec 08             	sub    $0x8,%esp
c0205402:	50                   	push   %eax
c0205403:	8d 83 e9 03 00 00    	lea    0x3e9(%ebx),%eax
c0205409:	50                   	push   %eax
c020540a:	e8 58 1f 00 00       	call   c0207367 <printk>
c020540f:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(16);
c0205412:	8b 83 30 90 08 00    	mov    0x89030(%ebx),%eax
c0205418:	83 ec 08             	sub    $0x8,%esp
c020541b:	50                   	push   %eax
c020541c:	8d 83 f7 03 00 00    	lea    0x3f7(%ebx),%eax
c0205422:	50                   	push   %eax
c0205423:	e8 3f 1f 00 00       	call   c0207367 <printk>
c0205428:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(32);
c020542b:	8b 83 34 90 08 00    	mov    0x89034(%ebx),%eax
c0205431:	83 ec 08             	sub    $0x8,%esp
c0205434:	50                   	push   %eax
c0205435:	8d 83 06 04 00 00    	lea    0x406(%ebx),%eax
c020543b:	50                   	push   %eax
c020543c:	e8 26 1f 00 00       	call   c0207367 <printk>
c0205441:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(64);
c0205444:	8b 83 38 90 08 00    	mov    0x89038(%ebx),%eax
c020544a:	83 ec 08             	sub    $0x8,%esp
c020544d:	50                   	push   %eax
c020544e:	8d 83 15 04 00 00    	lea    0x415(%ebx),%eax
c0205454:	50                   	push   %eax
c0205455:	e8 0d 1f 00 00       	call   c0207367 <printk>
c020545a:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(128);
c020545d:	8b 83 3c 90 08 00    	mov    0x8903c(%ebx),%eax
c0205463:	83 ec 08             	sub    $0x8,%esp
c0205466:	50                   	push   %eax
c0205467:	8d 83 24 04 00 00    	lea    0x424(%ebx),%eax
c020546d:	50                   	push   %eax
c020546e:	e8 f4 1e 00 00       	call   c0207367 <printk>
c0205473:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(256);
c0205476:	8b 83 40 90 08 00    	mov    0x89040(%ebx),%eax
c020547c:	83 ec 08             	sub    $0x8,%esp
c020547f:	50                   	push   %eax
c0205480:	8d 83 34 04 00 00    	lea    0x434(%ebx),%eax
c0205486:	50                   	push   %eax
c0205487:	e8 db 1e 00 00       	call   c0207367 <printk>
c020548c:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(512);
c020548f:	8b 83 44 90 08 00    	mov    0x89044(%ebx),%eax
c0205495:	83 ec 08             	sub    $0x8,%esp
c0205498:	50                   	push   %eax
c0205499:	8d 83 44 04 00 00    	lea    0x444(%ebx),%eax
c020549f:	50                   	push   %eax
c02054a0:	e8 c2 1e 00 00       	call   c0207367 <printk>
c02054a5:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1024);
c02054a8:	8b 83 48 90 08 00    	mov    0x89048(%ebx),%eax
c02054ae:	83 ec 08             	sub    $0x8,%esp
c02054b1:	50                   	push   %eax
c02054b2:	8d 83 54 04 00 00    	lea    0x454(%ebx),%eax
c02054b8:	50                   	push   %eax
c02054b9:	e8 a9 1e 00 00       	call   c0207367 <printk>
c02054be:	83 c4 10             	add    $0x10,%esp
	printk("singel buffer have:%d pages!\n",get_single_count());
c02054c1:	e8 85 fe ff ff       	call   c020534b <get_single_count>
c02054c6:	83 ec 08             	sub    $0x8,%esp
c02054c9:	50                   	push   %eax
c02054ca:	8d 83 65 04 00 00    	lea    0x465(%ebx),%eax
c02054d0:	50                   	push   %eax
c02054d1:	e8 91 1e 00 00       	call   c0207367 <printk>
c02054d6:	83 c4 10             	add    $0x10,%esp
}
c02054d9:	90                   	nop
c02054da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02054dd:	c9                   	leave  
c02054de:	c3                   	ret    

c02054df <pmm_init>:
//取消此宏定义 将宏定义范围限制在此函数中
#undef MACRO_PMM_1(number)

//为内核entry使用的pmm管理模块初始化函数
void pmm_init(){
c02054df:	55                   	push   %ebp
c02054e0:	89 e5                	mov    %esp,%ebp
c02054e2:	53                   	push   %ebx
c02054e3:	83 ec 04             	sub    $0x4,%esp
c02054e6:	e8 19 2b 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02054eb:	81 c3 15 3b 00 00    	add    $0x3b15,%ebx
	printk("[INFO][PMM]kern_physic_start:0x%h\n",kern_start);
c02054f1:	83 ec 08             	sub    $0x8,%esp
c02054f4:	c7 c0 00 00 10 00    	mov    $0x100000,%eax
c02054fa:	50                   	push   %eax
c02054fb:	8d 83 84 04 00 00    	lea    0x484(%ebx),%eax
c0205501:	50                   	push   %eax
c0205502:	e8 60 1e 00 00       	call   c0207367 <printk>
c0205507:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]kern_physic_end:0x%h\n",kern_end);
c020550a:	83 ec 08             	sub    $0x8,%esp
c020550d:	c7 c0 00 30 2a 00    	mov    $0x2a3000,%eax
c0205513:	50                   	push   %eax
c0205514:	8d 83 a8 04 00 00    	lea    0x4a8(%ebx),%eax
c020551a:	50                   	push   %eax
c020551b:	e8 47 1e 00 00       	call   c0207367 <printk>
c0205520:	83 c4 10             	add    $0x10,%esp
	//一定要注意 由于分页必须4k对齐 所以此处的物理页管理必须与虚拟页相同 都要4K对齐
	pmm_page_start = ((((uint32_t)kern_end >> 12))+1)<<12;
c0205523:	c7 c0 00 30 2a 00    	mov    $0x2a3000,%eax
c0205529:	c1 e8 0c             	shr    $0xc,%eax
c020552c:	83 c0 01             	add    $0x1,%eax
c020552f:	c1 e0 0c             	shl    $0xc,%eax
c0205532:	89 83 90 90 08 00    	mov    %eax,0x89090(%ebx)
	pmm_page_end = (((get_max_pm_addr() >> 12)))<<12;
c0205538:	e8 a7 f5 ff ff       	call   c0204ae4 <get_max_pm_addr>
c020553d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0205542:	89 83 94 90 08 00    	mov    %eax,0x89094(%ebx)
	pmm_max_page_no = ((pmm_page_end - pmm_page_start)>>12);
c0205548:	8b 93 94 90 08 00    	mov    0x89094(%ebx),%edx
c020554e:	8b 83 90 90 08 00    	mov    0x89090(%ebx),%eax
c0205554:	29 c2                	sub    %eax,%edx
c0205556:	89 d0                	mov    %edx,%eax
c0205558:	c1 e8 0c             	shr    $0xc,%eax
c020555b:	89 83 98 90 08 00    	mov    %eax,0x89098(%ebx)
	printk("[INFO][PMM]pmm_start:0x%h\n",pmm_page_start);
c0205561:	8b 83 90 90 08 00    	mov    0x89090(%ebx),%eax
c0205567:	83 ec 08             	sub    $0x8,%esp
c020556a:	50                   	push   %eax
c020556b:	8d 83 c9 04 00 00    	lea    0x4c9(%ebx),%eax
c0205571:	50                   	push   %eax
c0205572:	e8 f0 1d 00 00       	call   c0207367 <printk>
c0205577:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]pmm_end:0x%h\n",pmm_page_end);
c020557a:	8b 83 94 90 08 00    	mov    0x89094(%ebx),%eax
c0205580:	83 ec 08             	sub    $0x8,%esp
c0205583:	50                   	push   %eax
c0205584:	8d 83 e4 04 00 00    	lea    0x4e4(%ebx),%eax
c020558a:	50                   	push   %eax
c020558b:	e8 d7 1d 00 00       	call   c0207367 <printk>
c0205590:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]physic_page_count:%d\n",pmm_max_page_no+1);
c0205593:	8b 83 98 90 08 00    	mov    0x89098(%ebx),%eax
c0205599:	83 c0 01             	add    $0x1,%eax
c020559c:	83 ec 08             	sub    $0x8,%esp
c020559f:	50                   	push   %eax
c02055a0:	8d 83 00 05 00 00    	lea    0x500(%ebx),%eax
c02055a6:	50                   	push   %eax
c02055a7:	e8 bb 1d 00 00       	call   c0207367 <printk>
c02055ac:	83 c4 10             	add    $0x10,%esp
	printk("[INFO][PMM]first_page_physic_addr:0x%h\n",pmm_page_no_to_addr(32000));
c02055af:	83 ec 0c             	sub    $0xc,%esp
c02055b2:	68 00 7d 00 00       	push   $0x7d00
c02055b7:	e8 4b ec ff ff       	call   c0204207 <pmm_page_no_to_addr>
c02055bc:	83 c4 10             	add    $0x10,%esp
c02055bf:	83 ec 08             	sub    $0x8,%esp
c02055c2:	50                   	push   %eax
c02055c3:	8d 83 24 05 00 00    	lea    0x524(%ebx),%eax
c02055c9:	50                   	push   %eax
c02055ca:	e8 98 1d 00 00       	call   c0207367 <printk>
c02055cf:	83 c4 10             	add    $0x10,%esp
	pmm_page_init();
c02055d2:	e8 cc f5 ff ff       	call   c0204ba3 <pmm_page_init>
c02055d7:	90                   	nop
c02055d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02055db:	c9                   	leave  
c02055dc:	c3                   	ret    

c02055dd <get_tss_desc>:
#define TSS_ATTR_LOW   0x89//10001001//(1<<7)+(0<<5)+(0<<4)+9
#define TSS_ATTR_HIGH  0x80//10000000//(1<<7)+(0<<6)+(0<<5)+(0<<4)+0x0
#define LOG_SRC_TSS "TSS"
tss_t tss_cpu0;      //存放cpu0的tss    全局变量 不会被栈回收

static  tss_desc_t* get_tss_desc(){
c02055dd:	55                   	push   %ebp
c02055de:	89 e5                	mov    %esp,%ebp
c02055e0:	83 ec 10             	sub    $0x10,%esp
c02055e3:	e8 18 2a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02055e8:	05 18 3a 00 00       	add    $0x3a18,%eax
    //GDT_BASE的地址是虚拟地址
    uint32_t gdt_head_vaddr = (uint32_t)&GDT_BASE;
c02055ed:	c7 c0 30 32 20 c0    	mov    $0xc0203230,%eax
c02055f3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t tss_desc_vaddr = gdt_head_vaddr+GDT_DESC_SIZE*TSS_CPU0_DESC_POS_ON_GDT;
c02055f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02055f9:	83 c0 30             	add    $0x30,%eax
c02055fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return (tss_desc_t*)tss_desc_vaddr;
c02055ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0205602:	c9                   	leave  
c0205603:	c3                   	ret    

c0205604 <create_tss_desc>:

static tss_desc_t create_tss_desc(uint32_t desc_base,uint32_t limit,uint8_t attr_low,uint8_t attr_high){
c0205604:	55                   	push   %ebp
c0205605:	89 e5                	mov    %esp,%ebp
c0205607:	83 ec 18             	sub    $0x18,%esp
c020560a:	e8 f1 29 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020560f:	05 f1 39 00 00       	add    $0x39f1,%eax
c0205614:	8b 55 14             	mov    0x14(%ebp),%edx
c0205617:	8b 45 18             	mov    0x18(%ebp),%eax
c020561a:	88 55 ec             	mov    %dl,-0x14(%ebp)
c020561d:	88 45 e8             	mov    %al,-0x18(%ebp)
    tss_desc_t desc;
    desc.limit_low_word = (uint16_t)(limit & 0x0000FFFF);
c0205620:	8b 45 10             	mov    0x10(%ebp),%eax
c0205623:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc.base_low_word = (uint16_t)(desc_base&0x0000FFFF);
c0205627:	8b 45 0c             	mov    0xc(%ebp),%eax
c020562a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    desc.base_mid_byte = (uint8_t)((desc_base&0x00FF0000)>>16);
c020562e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0205631:	c1 e8 10             	shr    $0x10,%eax
c0205634:	88 45 fc             	mov    %al,-0x4(%ebp)
    desc.attr_low_byte = (uint8_t)attr_low;
c0205637:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c020563b:	88 45 fd             	mov    %al,-0x3(%ebp)
    desc.limit_high_attr_high = ((limit&0x000F0000)>>16)+(uint8_t)(attr_high);
c020563e:	8b 45 10             	mov    0x10(%ebp),%eax
c0205641:	c1 e8 10             	shr    $0x10,%eax
c0205644:	83 e0 0f             	and    $0xf,%eax
c0205647:	89 c2                	mov    %eax,%edx
c0205649:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c020564d:	01 d0                	add    %edx,%eax
c020564f:	88 45 fe             	mov    %al,-0x2(%ebp)
    desc.base_high_byte = (uint8_t)(desc_base>>24);
c0205652:	8b 45 0c             	mov    0xc(%ebp),%eax
c0205655:	c1 e8 18             	shr    $0x18,%eax
c0205658:	88 45 ff             	mov    %al,-0x1(%ebp)
    return desc;
c020565b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020565e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205661:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0205664:	89 01                	mov    %eax,(%ecx)
c0205666:	89 51 04             	mov    %edx,0x4(%ecx)
}
c0205669:	8b 45 08             	mov    0x8(%ebp),%eax
c020566c:	c9                   	leave  
c020566d:	c2 04 00             	ret    $0x4

c0205670 <get_TSS_desc_high_word>:

//这个函数用来验证TSS是否加载成功
//加载成功后TSS描述符的B位会被置为1
static uint32_t get_TSS_desc_high_word(){
c0205670:	55                   	push   %ebp
c0205671:	89 e5                	mov    %esp,%ebp
c0205673:	83 ec 10             	sub    $0x10,%esp
c0205676:	e8 85 29 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020567b:	05 85 39 00 00       	add    $0x3985,%eax
    tss_desc_t * tss_d = get_tss_desc();
c0205680:	e8 58 ff ff ff       	call   c02055dd <get_tss_desc>
c0205685:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t * p = (uint32_t*)tss_d;
c0205688:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020568b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return *(p+1);
c020568e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205691:	8b 40 04             	mov    0x4(%eax),%eax
}
c0205694:	c9                   	leave  
c0205695:	c3                   	ret    

c0205696 <tss_init>:

void tss_init(){
c0205696:	55                   	push   %ebp
c0205697:	89 e5                	mov    %esp,%ebp
c0205699:	56                   	push   %esi
c020569a:	53                   	push   %ebx
c020569b:	83 ec 20             	sub    $0x20,%esp
c020569e:	e8 61 29 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02056a3:	81 c3 5d 39 00 00    	add    $0x395d,%ebx
    uint32_t tss_size = sizeof(tss_t);
c02056a9:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
    tss_desc_t* tss_cpu0_desc_ptr = get_tss_desc();
c02056b0:	e8 28 ff ff ff       	call   c02055dd <get_tss_desc>
c02056b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bzero(&tss_cpu0,tss_size);
c02056b8:	83 ec 08             	sub    $0x8,%esp
c02056bb:	ff 75 f4             	pushl  -0xc(%ebp)
c02056be:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02056c4:	50                   	push   %eax
c02056c5:	e8 9a 23 00 00       	call   c0207a64 <bzero>
c02056ca:	83 c4 10             	add    $0x10,%esp
    tss_cpu0.io_base =tss_size;
c02056cd:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02056d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02056d6:	89 50 68             	mov    %edx,0x68(%eax)
    tss_cpu0.ss0 = SELECTOR_DATA_MEM&0x0000FFFF;    //内核数据段
c02056d9:	c7 c0 6a 32 20 c0    	mov    $0xc020326a,%eax
c02056df:	0f b7 00             	movzwl (%eax),%eax
c02056e2:	0f b7 d0             	movzwl %ax,%edx
c02056e5:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02056eb:	89 50 08             	mov    %edx,0x8(%eax)
    *tss_cpu0_desc_ptr=create_tss_desc(&tss_cpu0,tss_size-1,TSS_ATTR_LOW,TSS_ATTR_HIGH);   
c02056ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02056f1:	8d 50 ff             	lea    -0x1(%eax),%edx
c02056f4:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02056fa:	89 c1                	mov    %eax,%ecx
c02056fc:	8b 75 f0             	mov    -0x10(%ebp),%esi
c02056ff:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0205702:	83 ec 0c             	sub    $0xc,%esp
c0205705:	68 80 00 00 00       	push   $0x80
c020570a:	68 89 00 00 00       	push   $0x89
c020570f:	52                   	push   %edx
c0205710:	51                   	push   %ecx
c0205711:	50                   	push   %eax
c0205712:	e8 ed fe ff ff       	call   c0205604 <create_tss_desc>
c0205717:	83 c4 1c             	add    $0x1c,%esp
c020571a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c020571d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0205720:	89 06                	mov    %eax,(%esi)
c0205722:	89 56 04             	mov    %edx,0x4(%esi)
    //重载GDT
    uint32_t befor_load_val = get_TSS_desc_high_word();
c0205725:	e8 46 ff ff ff       	call   c0205670 <get_TSS_desc_high_word>
c020572a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    reload_gdt();
c020572d:	e8 9e da ff ff       	call   c02031d0 <reload_gdt>
    //加载TSS
    asm volatile("ltr %w0" : : "r" (SELECTOR_TSS_CPU0_MEM));
c0205732:	c7 c0 72 32 20 c0    	mov    $0xc0203272,%eax
c0205738:	0f b7 00             	movzwl (%eax),%eax
c020573b:	0f 00 d8             	ltr    %ax
    uint32_t after_load_val = get_TSS_desc_high_word();
c020573e:	e8 2d ff ff ff       	call   c0205670 <get_TSS_desc_high_word>
c0205743:	89 45 e8             	mov    %eax,-0x18(%ebp)
    //装载tss后 cpu会修改tss描述符B位 所以高32位会变化
    if(after_load_val!=befor_load_val){
c0205746:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0205749:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c020574c:	74 1b                	je     c0205769 <tss_init+0xd3>
        INFO(LOG_SRC_TSS,"Init TSS Success!");
c020574e:	83 ec 08             	sub    $0x8,%esp
c0205751:	8d 83 4c 05 00 00    	lea    0x54c(%ebx),%eax
c0205757:	50                   	push   %eax
c0205758:	8d 83 5e 05 00 00    	lea    0x55e(%ebx),%eax
c020575e:	50                   	push   %eax
c020575f:	e8 88 00 00 00       	call   c02057ec <info_kern>
c0205764:	83 c4 10             	add    $0x10,%esp
    }
    else{
        STOP(LOG_SRC_TSS,"Fail To Load TSS!STOP!");
    }
}
c0205767:	eb 19                	jmp    c0205782 <tss_init+0xec>
        STOP(LOG_SRC_TSS,"Fail To Load TSS!STOP!");
c0205769:	83 ec 08             	sub    $0x8,%esp
c020576c:	8d 83 62 05 00 00    	lea    0x562(%ebx),%eax
c0205772:	50                   	push   %eax
c0205773:	8d 83 5e 05 00 00    	lea    0x55e(%ebx),%eax
c0205779:	50                   	push   %eax
c020577a:	e8 08 01 00 00       	call   c0205887 <stop_kern>
c020577f:	83 c4 10             	add    $0x10,%esp
}
c0205782:	90                   	nop
c0205783:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0205786:	5b                   	pop    %ebx
c0205787:	5e                   	pop    %esi
c0205788:	5d                   	pop    %ebp
c0205789:	c3                   	ret    

c020578a <tss_update>:

void tss_update(TCB_t* tcb_ptr){
c020578a:	55                   	push   %ebp
c020578b:	89 e5                	mov    %esp,%ebp
c020578d:	e8 6e 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205792:	05 6e 38 00 00       	add    $0x386e,%eax
    tss_cpu0.esp0 = (uint32_t*)((uint32_t)tcb_ptr+tcb_ptr->page_counte*PAGE_SIZE);
c0205797:	8b 55 08             	mov    0x8(%ebp),%edx
c020579a:	8b 52 18             	mov    0x18(%edx),%edx
c020579d:	89 d1                	mov    %edx,%ecx
c020579f:	c1 e1 0c             	shl    $0xc,%ecx
c02057a2:	8b 55 08             	mov    0x8(%ebp),%edx
c02057a5:	01 ca                	add    %ecx,%edx
c02057a7:	c7 c0 80 30 29 c0    	mov    $0xc0293080,%eax
c02057ad:	89 50 04             	mov    %edx,0x4(%eax)
}
c02057b0:	90                   	nop
c02057b1:	5d                   	pop    %ebp
c02057b2:	c3                   	ret    

c02057b3 <tss_test>:

void tss_test(){
c02057b3:	55                   	push   %ebp
c02057b4:	89 e5                	mov    %esp,%ebp
c02057b6:	53                   	push   %ebx
c02057b7:	83 ec 04             	sub    $0x4,%esp
c02057ba:	e8 41 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02057bf:	05 41 38 00 00       	add    $0x3841,%eax
    printk("GDT_BASE:%h\nGDT_PTR:0x%h\n",&GDT_BASE,&gdt_ptr);
c02057c4:	83 ec 04             	sub    $0x4,%esp
c02057c7:	c7 c2 78 32 20 c0    	mov    $0xc0203278,%edx
c02057cd:	52                   	push   %edx
c02057ce:	c7 c2 30 32 20 c0    	mov    $0xc0203230,%edx
c02057d4:	52                   	push   %edx
c02057d5:	8d 90 79 05 00 00    	lea    0x579(%eax),%edx
c02057db:	52                   	push   %edx
c02057dc:	89 c3                	mov    %eax,%ebx
c02057de:	e8 84 1b 00 00       	call   c0207367 <printk>
c02057e3:	83 c4 10             	add    $0x10,%esp
c02057e6:	90                   	nop
c02057e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02057ea:	c9                   	leave  
c02057eb:	c3                   	ret    

c02057ec <info_kern>:
#include "kern_log.h"
#include "printk.h"
#include "vga_basic.h"
void info_kern(char* src,char* text){
c02057ec:	55                   	push   %ebp
c02057ed:	89 e5                	mov    %esp,%ebp
c02057ef:	53                   	push   %ebx
c02057f0:	83 ec 04             	sub    $0x4,%esp
c02057f3:	e8 08 28 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02057f8:	05 08 38 00 00       	add    $0x3808,%eax
    printk("[INFO][%s]%s\n",src,text);
c02057fd:	83 ec 04             	sub    $0x4,%esp
c0205800:	ff 75 0c             	pushl  0xc(%ebp)
c0205803:	ff 75 08             	pushl  0x8(%ebp)
c0205806:	8d 90 93 05 00 00    	lea    0x593(%eax),%edx
c020580c:	52                   	push   %edx
c020580d:	89 c3                	mov    %eax,%ebx
c020580f:	e8 53 1b 00 00       	call   c0207367 <printk>
c0205814:	83 c4 10             	add    $0x10,%esp
}
c0205817:	90                   	nop
c0205818:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020581b:	c9                   	leave  
c020581c:	c3                   	ret    

c020581d <error_kern>:

void error_kern(char* src,char* text){
c020581d:	55                   	push   %ebp
c020581e:	89 e5                	mov    %esp,%ebp
c0205820:	53                   	push   %ebx
c0205821:	83 ec 04             	sub    $0x4,%esp
c0205824:	e8 d7 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205829:	05 d7 37 00 00       	add    $0x37d7,%eax
    printk_color("[ERROR][%s]%s\n",black,red,src,text);
c020582e:	83 ec 0c             	sub    $0xc,%esp
c0205831:	ff 75 0c             	pushl  0xc(%ebp)
c0205834:	ff 75 08             	pushl  0x8(%ebp)
c0205837:	6a 04                	push   $0x4
c0205839:	6a 00                	push   $0x0
c020583b:	8d 90 a1 05 00 00    	lea    0x5a1(%eax),%edx
c0205841:	52                   	push   %edx
c0205842:	89 c3                	mov    %eax,%ebx
c0205844:	e8 92 1d 00 00       	call   c02075db <printk_color>
c0205849:	83 c4 20             	add    $0x20,%esp
}
c020584c:	90                   	nop
c020584d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205850:	c9                   	leave  
c0205851:	c3                   	ret    

c0205852 <warning_kern>:

void warning_kern(char* src,char* text){
c0205852:	55                   	push   %ebp
c0205853:	89 e5                	mov    %esp,%ebp
c0205855:	53                   	push   %ebx
c0205856:	83 ec 04             	sub    $0x4,%esp
c0205859:	e8 a2 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020585e:	05 a2 37 00 00       	add    $0x37a2,%eax
    printk_color("[WARNING][%s]%s\n",black,yellow,src,text);
c0205863:	83 ec 0c             	sub    $0xc,%esp
c0205866:	ff 75 0c             	pushl  0xc(%ebp)
c0205869:	ff 75 08             	pushl  0x8(%ebp)
c020586c:	6a 0e                	push   $0xe
c020586e:	6a 00                	push   $0x0
c0205870:	8d 90 b0 05 00 00    	lea    0x5b0(%eax),%edx
c0205876:	52                   	push   %edx
c0205877:	89 c3                	mov    %eax,%ebx
c0205879:	e8 5d 1d 00 00       	call   c02075db <printk_color>
c020587e:	83 c4 20             	add    $0x20,%esp
}
c0205881:	90                   	nop
c0205882:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205885:	c9                   	leave  
c0205886:	c3                   	ret    

c0205887 <stop_kern>:

void stop_kern(char* src,char* text){
c0205887:	55                   	push   %ebp
c0205888:	89 e5                	mov    %esp,%ebp
c020588a:	53                   	push   %ebx
c020588b:	83 ec 04             	sub    $0x4,%esp
c020588e:	e8 6d 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0205893:	05 6d 37 00 00       	add    $0x376d,%eax
    //printk("[STOP][%s]%s\n",src,text);
    printk_color("[STOP][%s]%s\n",white,black,src,text);
c0205898:	83 ec 0c             	sub    $0xc,%esp
c020589b:	ff 75 0c             	pushl  0xc(%ebp)
c020589e:	ff 75 08             	pushl  0x8(%ebp)
c02058a1:	6a 00                	push   $0x0
c02058a3:	6a 0f                	push   $0xf
c02058a5:	8d 90 c1 05 00 00    	lea    0x5c1(%eax),%edx
c02058ab:	52                   	push   %edx
c02058ac:	89 c3                	mov    %eax,%ebx
c02058ae:	e8 28 1d 00 00       	call   c02075db <printk_color>
c02058b3:	83 c4 20             	add    $0x20,%esp
    while(1){}
c02058b6:	eb fe                	jmp    c02058b6 <stop_kern+0x2f>

c02058b8 <debug>:
}

void debug(function func,char *src,char*text){
c02058b8:	55                   	push   %ebp
c02058b9:	89 e5                	mov    %esp,%ebp
c02058bb:	83 ec 08             	sub    $0x8,%esp
c02058be:	e8 3d 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02058c3:	05 3d 37 00 00       	add    $0x373d,%eax
    #ifdef DEBUG_FLAGE
    func(src,text);
c02058c8:	83 ec 08             	sub    $0x8,%esp
c02058cb:	ff 75 10             	pushl  0x10(%ebp)
c02058ce:	ff 75 0c             	pushl  0xc(%ebp)
c02058d1:	8b 45 08             	mov    0x8(%ebp),%eax
c02058d4:	ff d0                	call   *%eax
c02058d6:	83 c4 10             	add    $0x10,%esp
    #endif
c02058d9:	90                   	nop
c02058da:	c9                   	leave  
c02058db:	c3                   	ret    

c02058dc <set_int_disc>:
int_server_func_t int_server_func_list[256];
interrupt_discripter_t idt_entries[256];    //中断描述符表 idt_entries为表首指针
lidt_target_t lidt_target;
static uint8_t default_inf=0x8E;
static uint16_t kern_cs=0x08; 
static void set_int_disc(int int_no, uint32_t offset, uint16_t selector, uint8_t inf){
c02058dc:	55                   	push   %ebp
c02058dd:	89 e5                	mov    %esp,%ebp
c02058df:	53                   	push   %ebx
c02058e0:	83 ec 08             	sub    $0x8,%esp
c02058e3:	e8 18 27 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02058e8:	05 18 37 00 00       	add    $0x3718,%eax
c02058ed:	8b 4d 10             	mov    0x10(%ebp),%ecx
c02058f0:	8b 55 14             	mov    0x14(%ebp),%edx
c02058f3:	66 89 4d f8          	mov    %cx,-0x8(%ebp)
c02058f7:	88 55 f4             	mov    %dl,-0xc(%ebp)
	idt_entries[int_no].offset_low=(uint16_t)offset;
c02058fa:	8b 55 0c             	mov    0xc(%ebp),%edx
c02058fd:	89 d3                	mov    %edx,%ebx
c02058ff:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c0205905:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205908:	66 89 1c ca          	mov    %bx,(%edx,%ecx,8)
	idt_entries[int_no].offset_high=(uint16_t)(offset>>16);
c020590c:	8b 55 0c             	mov    0xc(%ebp),%edx
c020590f:	c1 ea 10             	shr    $0x10,%edx
c0205912:	89 d3                	mov    %edx,%ebx
c0205914:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c020591a:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020591d:	66 89 5c ca 06       	mov    %bx,0x6(%edx,%ecx,8)
	idt_entries[int_no].selector=selector;
c0205922:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c0205928:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020592b:	0f b7 5d f8          	movzwl -0x8(%ebp),%ebx
c020592f:	66 89 5c ca 02       	mov    %bx,0x2(%edx,%ecx,8)
	idt_entries[int_no].inf=inf;
c0205934:	c7 c2 20 35 29 c0    	mov    $0xc0293520,%edx
c020593a:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020593d:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0205941:	88 5c ca 05          	mov    %bl,0x5(%edx,%ecx,8)
	idt_entries[int_no].default_bit8=0;
c0205945:	c7 c0 20 35 29 c0    	mov    $0xc0293520,%eax
c020594b:	8b 55 08             	mov    0x8(%ebp),%edx
c020594e:	c6 44 d0 04 00       	movb   $0x0,0x4(%eax,%edx,8)
}
c0205953:	90                   	nop
c0205954:	83 c4 08             	add    $0x8,%esp
c0205957:	5b                   	pop    %ebx
c0205958:	5d                   	pop    %ebp
c0205959:	c3                   	ret    

c020595a <timer_init>:
static void timer_init(uint32_t frequency){
c020595a:	55                   	push   %ebp
c020595b:	89 e5                	mov    %esp,%ebp
c020595d:	53                   	push   %ebx
c020595e:	83 ec 14             	sub    $0x14,%esp
c0205961:	e8 9e 26 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205966:	81 c3 9a 36 00 00    	add    $0x369a,%ebx
	// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h
    // 输入频率为 1193180，frequency 即每秒中断次数
    uint32_t divisor = 1193180 / frequency;
c020596c:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0205971:	ba 00 00 00 00       	mov    $0x0,%edx
c0205976:	f7 75 08             	divl   0x8(%ebp)
c0205979:	89 45 f4             	mov    %eax,-0xc(%ebp)
    // D7 D6 D5 D4 D3 D2 D1 D0
    // 0  0  1  1  0  1  1  0
    // 即就是 36 H
    // 设置 8253/8254 芯片工作在模式 3 下
    outb(0x43, 0x36);
c020597c:	83 ec 08             	sub    $0x8,%esp
c020597f:	6a 36                	push   $0x36
c0205981:	6a 43                	push   $0x43
c0205983:	e8 96 18 00 00       	call   c020721e <outb>
c0205988:	83 c4 10             	add    $0x10,%esp

    // 拆分低字节和高字节
    uint8_t low = (uint8_t)(divisor & 0xFF);
c020598b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020598e:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t hign = (uint8_t)((divisor >> 8) & 0xFF);
c0205991:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205994:	c1 e8 08             	shr    $0x8,%eax
c0205997:	88 45 f2             	mov    %al,-0xe(%ebp)
    
    // 分别写入低字节和高字节
    outb(0x40, low);
c020599a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c020599e:	83 ec 08             	sub    $0x8,%esp
c02059a1:	50                   	push   %eax
c02059a2:	6a 40                	push   $0x40
c02059a4:	e8 75 18 00 00       	call   c020721e <outb>
c02059a9:	83 c4 10             	add    $0x10,%esp
    outb(0x40, hign);
c02059ac:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
c02059b0:	83 ec 08             	sub    $0x8,%esp
c02059b3:	50                   	push   %eax
c02059b4:	6a 40                	push   $0x40
c02059b6:	e8 63 18 00 00       	call   c020721e <outb>
c02059bb:	83 c4 10             	add    $0x10,%esp
}
c02059be:	90                   	nop
c02059bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02059c2:	c9                   	leave  
c02059c3:	c3                   	ret    

c02059c4 <registe_interrupt>:

static void registe_interrupt(int int_no,int_server_func_t target_func){
c02059c4:	55                   	push   %ebp
c02059c5:	89 e5                	mov    %esp,%ebp
c02059c7:	e8 34 26 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02059cc:	05 34 36 00 00       	add    $0x3634,%eax
	int_server_func_list[int_no] = target_func;
c02059d1:	c7 c0 00 31 29 c0    	mov    $0xc0293100,%eax
c02059d7:	8b 55 08             	mov    0x8(%ebp),%edx
c02059da:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c02059dd:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
}
c02059e0:	90                   	nop
c02059e1:	5d                   	pop    %ebp
c02059e2:	c3                   	ret    

c02059e3 <default_server_func>:

void default_server_func(void *args){
c02059e3:	55                   	push   %ebp
c02059e4:	89 e5                	mov    %esp,%ebp
c02059e6:	e8 15 26 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02059eb:	05 15 36 00 00       	add    $0x3615,%eax
	//printk("Default Int server function!\n");
}
c02059f0:	90                   	nop
c02059f1:	5d                   	pop    %ebp
c02059f2:	c3                   	ret    

c02059f3 <timer_server_func>:


extern TCB_t * cur_tcb; 

//时钟中断函数 主要用于线程调度
void timer_server_func(void *args){
c02059f3:	55                   	push   %ebp
c02059f4:	89 e5                	mov    %esp,%ebp
c02059f6:	53                   	push   %ebx
c02059f7:	83 ec 04             	sub    $0x4,%esp
c02059fa:	e8 05 26 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02059ff:	81 c3 01 36 00 00    	add    $0x3601,%ebx
	if(cur_tcb->time_left!=0){
c0205a05:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0205a0b:	8b 00                	mov    (%eax),%eax
c0205a0d:	8b 40 0c             	mov    0xc(%eax),%eax
c0205a10:	85 c0                	test   %eax,%eax
c0205a12:	74 24                	je     c0205a38 <timer_server_func+0x45>
		(cur_tcb->time_left)--;
c0205a14:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0205a1a:	8b 00                	mov    (%eax),%eax
c0205a1c:	8b 50 0c             	mov    0xc(%eax),%edx
c0205a1f:	83 ea 01             	sub    $0x1,%edx
c0205a22:	89 50 0c             	mov    %edx,0xc(%eax)
		(cur_tcb->time_counter)++;
c0205a25:	c7 c0 00 30 29 c0    	mov    $0xc0293000,%eax
c0205a2b:	8b 00                	mov    (%eax),%eax
c0205a2d:	8b 50 08             	mov    0x8(%eax),%edx
c0205a30:	83 c2 01             	add    $0x1,%edx
c0205a33:	89 50 08             	mov    %edx,0x8(%eax)
	}
	else{
        printk("schedule\n");
		schedule();
	}
}
c0205a36:	eb 17                	jmp    c0205a4f <timer_server_func+0x5c>
        printk("schedule\n");
c0205a38:	83 ec 0c             	sub    $0xc,%esp
c0205a3b:	8d 83 d0 05 00 00    	lea    0x5d0(%ebx),%eax
c0205a41:	50                   	push   %eax
c0205a42:	e8 20 19 00 00       	call   c0207367 <printk>
c0205a47:	83 c4 10             	add    $0x10,%esp
		schedule();
c0205a4a:	e8 0b e0 ff ff       	call   c0203a5a <schedule>
}
c0205a4f:	90                   	nop
c0205a50:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205a53:	c9                   	leave  
c0205a54:	c3                   	ret    

c0205a55 <page_fault_func>:

//cr2 保存引起缺页的线性地址
void get_cr2();
extern uint32_t _CR2;
void page_fault_func(void * args){
c0205a55:	55                   	push   %ebp
c0205a56:	89 e5                	mov    %esp,%ebp
c0205a58:	53                   	push   %ebx
c0205a59:	83 ec 14             	sub    $0x14,%esp
c0205a5c:	e8 a3 25 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205a61:	81 c3 9f 35 00 00    	add    $0x359f,%ebx
	get_cr2();
c0205a67:	e8 53 d7 ff ff       	call   c02031bf <get_cr2>
	struct TCB_t* cur_tcb=get_running_progress();
c0205a6c:	e8 e8 dc ff ff       	call   c0203759 <get_running_progress>
c0205a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
	printk("INT 14:Page Fault:0x%h IN TASK:%d\n",_CR2,cur_tcb->tid);
c0205a74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205a77:	8b 50 14             	mov    0x14(%eax),%edx
c0205a7a:	c7 c0 c8 31 20 c0    	mov    $0xc02031c8,%eax
c0205a80:	8b 00                	mov    (%eax),%eax
c0205a82:	83 ec 04             	sub    $0x4,%esp
c0205a85:	52                   	push   %edx
c0205a86:	50                   	push   %eax
c0205a87:	8d 83 dc 05 00 00    	lea    0x5dc(%ebx),%eax
c0205a8d:	50                   	push   %eax
c0205a8e:	e8 d4 18 00 00       	call   c0207367 <printk>
c0205a93:	83 c4 10             	add    $0x10,%esp
}
c0205a96:	90                   	nop
c0205a97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205a9a:	c9                   	leave  
c0205a9b:	c3                   	ret    

c0205a9c <idt_init>:
void isr30();
void isr31();

void isr32();

void idt_init(){
c0205a9c:	55                   	push   %ebp
c0205a9d:	89 e5                	mov    %esp,%ebp
c0205a9f:	53                   	push   %ebx
c0205aa0:	83 ec 04             	sub    $0x4,%esp
c0205aa3:	e8 5c 25 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0205aa8:	81 c3 58 35 00 00    	add    $0x3558,%ebx
	_8259A_init();   //初始化中断控制器
c0205aae:	e8 a7 11 00 00       	call   c0206c5a <_8259A_init>
	set_int_disc(0,(uint32_t)isr0,kern_cs,default_inf);
c0205ab3:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205aba:	0f b6 d0             	movzbl %al,%edx
c0205abd:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205ac4:	0f b7 c0             	movzwl %ax,%eax
c0205ac7:	c7 c1 ad 30 20 c0    	mov    $0xc02030ad,%ecx
c0205acd:	52                   	push   %edx
c0205ace:	50                   	push   %eax
c0205acf:	51                   	push   %ecx
c0205ad0:	6a 00                	push   $0x0
c0205ad2:	e8 05 fe ff ff       	call   c02058dc <set_int_disc>
c0205ad7:	83 c4 10             	add    $0x10,%esp
	set_int_disc(1,(uint32_t)isr1,kern_cs,default_inf);
c0205ada:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ae1:	0f b6 d0             	movzbl %al,%edx
c0205ae4:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205aeb:	0f b7 c0             	movzwl %ax,%eax
c0205aee:	c7 c1 b3 30 20 c0    	mov    $0xc02030b3,%ecx
c0205af4:	52                   	push   %edx
c0205af5:	50                   	push   %eax
c0205af6:	51                   	push   %ecx
c0205af7:	6a 01                	push   $0x1
c0205af9:	e8 de fd ff ff       	call   c02058dc <set_int_disc>
c0205afe:	83 c4 10             	add    $0x10,%esp
	set_int_disc(2,(uint32_t)isr2,kern_cs,default_inf);
c0205b01:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b08:	0f b6 d0             	movzbl %al,%edx
c0205b0b:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b12:	0f b7 c0             	movzwl %ax,%eax
c0205b15:	c7 c1 b9 30 20 c0    	mov    $0xc02030b9,%ecx
c0205b1b:	52                   	push   %edx
c0205b1c:	50                   	push   %eax
c0205b1d:	51                   	push   %ecx
c0205b1e:	6a 02                	push   $0x2
c0205b20:	e8 b7 fd ff ff       	call   c02058dc <set_int_disc>
c0205b25:	83 c4 10             	add    $0x10,%esp
	set_int_disc(3,(uint32_t)isr3,kern_cs,default_inf);
c0205b28:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b2f:	0f b6 d0             	movzbl %al,%edx
c0205b32:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b39:	0f b7 c0             	movzwl %ax,%eax
c0205b3c:	c7 c1 bf 30 20 c0    	mov    $0xc02030bf,%ecx
c0205b42:	52                   	push   %edx
c0205b43:	50                   	push   %eax
c0205b44:	51                   	push   %ecx
c0205b45:	6a 03                	push   $0x3
c0205b47:	e8 90 fd ff ff       	call   c02058dc <set_int_disc>
c0205b4c:	83 c4 10             	add    $0x10,%esp
	set_int_disc(4,(uint32_t)isr4,kern_cs,default_inf);
c0205b4f:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b56:	0f b6 d0             	movzbl %al,%edx
c0205b59:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b60:	0f b7 c0             	movzwl %ax,%eax
c0205b63:	c7 c1 c5 30 20 c0    	mov    $0xc02030c5,%ecx
c0205b69:	52                   	push   %edx
c0205b6a:	50                   	push   %eax
c0205b6b:	51                   	push   %ecx
c0205b6c:	6a 04                	push   $0x4
c0205b6e:	e8 69 fd ff ff       	call   c02058dc <set_int_disc>
c0205b73:	83 c4 10             	add    $0x10,%esp
	set_int_disc(5,(uint32_t)isr5,kern_cs,default_inf);
c0205b76:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205b7d:	0f b6 d0             	movzbl %al,%edx
c0205b80:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205b87:	0f b7 c0             	movzwl %ax,%eax
c0205b8a:	c7 c1 cb 30 20 c0    	mov    $0xc02030cb,%ecx
c0205b90:	52                   	push   %edx
c0205b91:	50                   	push   %eax
c0205b92:	51                   	push   %ecx
c0205b93:	6a 05                	push   $0x5
c0205b95:	e8 42 fd ff ff       	call   c02058dc <set_int_disc>
c0205b9a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(6,(uint32_t)isr6,kern_cs,default_inf);
c0205b9d:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ba4:	0f b6 d0             	movzbl %al,%edx
c0205ba7:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205bae:	0f b7 c0             	movzwl %ax,%eax
c0205bb1:	c7 c1 d1 30 20 c0    	mov    $0xc02030d1,%ecx
c0205bb7:	52                   	push   %edx
c0205bb8:	50                   	push   %eax
c0205bb9:	51                   	push   %ecx
c0205bba:	6a 06                	push   $0x6
c0205bbc:	e8 1b fd ff ff       	call   c02058dc <set_int_disc>
c0205bc1:	83 c4 10             	add    $0x10,%esp
	set_int_disc(7,(uint32_t)isr7,kern_cs,default_inf);
c0205bc4:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205bcb:	0f b6 d0             	movzbl %al,%edx
c0205bce:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205bd5:	0f b7 c0             	movzwl %ax,%eax
c0205bd8:	c7 c1 d7 30 20 c0    	mov    $0xc02030d7,%ecx
c0205bde:	52                   	push   %edx
c0205bdf:	50                   	push   %eax
c0205be0:	51                   	push   %ecx
c0205be1:	6a 07                	push   $0x7
c0205be3:	e8 f4 fc ff ff       	call   c02058dc <set_int_disc>
c0205be8:	83 c4 10             	add    $0x10,%esp
	set_int_disc(8,(uint32_t)isr8,kern_cs,default_inf);
c0205beb:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205bf2:	0f b6 d0             	movzbl %al,%edx
c0205bf5:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205bfc:	0f b7 c0             	movzwl %ax,%eax
c0205bff:	c7 c1 dd 30 20 c0    	mov    $0xc02030dd,%ecx
c0205c05:	52                   	push   %edx
c0205c06:	50                   	push   %eax
c0205c07:	51                   	push   %ecx
c0205c08:	6a 08                	push   $0x8
c0205c0a:	e8 cd fc ff ff       	call   c02058dc <set_int_disc>
c0205c0f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(9,(uint32_t)isr9,kern_cs,default_inf);
c0205c12:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c19:	0f b6 d0             	movzbl %al,%edx
c0205c1c:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c23:	0f b7 c0             	movzwl %ax,%eax
c0205c26:	c7 c1 e5 30 20 c0    	mov    $0xc02030e5,%ecx
c0205c2c:	52                   	push   %edx
c0205c2d:	50                   	push   %eax
c0205c2e:	51                   	push   %ecx
c0205c2f:	6a 09                	push   $0x9
c0205c31:	e8 a6 fc ff ff       	call   c02058dc <set_int_disc>
c0205c36:	83 c4 10             	add    $0x10,%esp
	set_int_disc(10,(uint32_t)isr10,kern_cs,default_inf);
c0205c39:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c40:	0f b6 d0             	movzbl %al,%edx
c0205c43:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c4a:	0f b7 c0             	movzwl %ax,%eax
c0205c4d:	c7 c1 ee 30 20 c0    	mov    $0xc02030ee,%ecx
c0205c53:	52                   	push   %edx
c0205c54:	50                   	push   %eax
c0205c55:	51                   	push   %ecx
c0205c56:	6a 0a                	push   $0xa
c0205c58:	e8 7f fc ff ff       	call   c02058dc <set_int_disc>
c0205c5d:	83 c4 10             	add    $0x10,%esp
	set_int_disc(11,(uint32_t)isr11,kern_cs,default_inf);
c0205c60:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c67:	0f b6 d0             	movzbl %al,%edx
c0205c6a:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c71:	0f b7 c0             	movzwl %ax,%eax
c0205c74:	c7 c1 f6 30 20 c0    	mov    $0xc02030f6,%ecx
c0205c7a:	52                   	push   %edx
c0205c7b:	50                   	push   %eax
c0205c7c:	51                   	push   %ecx
c0205c7d:	6a 0b                	push   $0xb
c0205c7f:	e8 58 fc ff ff       	call   c02058dc <set_int_disc>
c0205c84:	83 c4 10             	add    $0x10,%esp
	set_int_disc(12,(uint32_t)isr12,kern_cs,default_inf);
c0205c87:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205c8e:	0f b6 d0             	movzbl %al,%edx
c0205c91:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205c98:	0f b7 c0             	movzwl %ax,%eax
c0205c9b:	c7 c1 fe 30 20 c0    	mov    $0xc02030fe,%ecx
c0205ca1:	52                   	push   %edx
c0205ca2:	50                   	push   %eax
c0205ca3:	51                   	push   %ecx
c0205ca4:	6a 0c                	push   $0xc
c0205ca6:	e8 31 fc ff ff       	call   c02058dc <set_int_disc>
c0205cab:	83 c4 10             	add    $0x10,%esp
	set_int_disc(13,(uint32_t)isr13,kern_cs,default_inf);
c0205cae:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205cb5:	0f b6 d0             	movzbl %al,%edx
c0205cb8:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205cbf:	0f b7 c0             	movzwl %ax,%eax
c0205cc2:	c7 c1 06 31 20 c0    	mov    $0xc0203106,%ecx
c0205cc8:	52                   	push   %edx
c0205cc9:	50                   	push   %eax
c0205cca:	51                   	push   %ecx
c0205ccb:	6a 0d                	push   $0xd
c0205ccd:	e8 0a fc ff ff       	call   c02058dc <set_int_disc>
c0205cd2:	83 c4 10             	add    $0x10,%esp
	set_int_disc(14,(uint32_t)isr14,kern_cs,default_inf);
c0205cd5:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205cdc:	0f b6 d0             	movzbl %al,%edx
c0205cdf:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205ce6:	0f b7 c0             	movzwl %ax,%eax
c0205ce9:	c7 c1 0e 31 20 c0    	mov    $0xc020310e,%ecx
c0205cef:	52                   	push   %edx
c0205cf0:	50                   	push   %eax
c0205cf1:	51                   	push   %ecx
c0205cf2:	6a 0e                	push   $0xe
c0205cf4:	e8 e3 fb ff ff       	call   c02058dc <set_int_disc>
c0205cf9:	83 c4 10             	add    $0x10,%esp
	set_int_disc(15,(uint32_t)isr15,kern_cs,default_inf);
c0205cfc:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d03:	0f b6 d0             	movzbl %al,%edx
c0205d06:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d0d:	0f b7 c0             	movzwl %ax,%eax
c0205d10:	c7 c1 16 31 20 c0    	mov    $0xc0203116,%ecx
c0205d16:	52                   	push   %edx
c0205d17:	50                   	push   %eax
c0205d18:	51                   	push   %ecx
c0205d19:	6a 0f                	push   $0xf
c0205d1b:	e8 bc fb ff ff       	call   c02058dc <set_int_disc>
c0205d20:	83 c4 10             	add    $0x10,%esp
	set_int_disc(16,(uint32_t)isr16,kern_cs,default_inf);
c0205d23:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d2a:	0f b6 d0             	movzbl %al,%edx
c0205d2d:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d34:	0f b7 c0             	movzwl %ax,%eax
c0205d37:	c7 c1 1f 31 20 c0    	mov    $0xc020311f,%ecx
c0205d3d:	52                   	push   %edx
c0205d3e:	50                   	push   %eax
c0205d3f:	51                   	push   %ecx
c0205d40:	6a 10                	push   $0x10
c0205d42:	e8 95 fb ff ff       	call   c02058dc <set_int_disc>
c0205d47:	83 c4 10             	add    $0x10,%esp
	set_int_disc(17,(uint32_t)isr17,kern_cs,default_inf);
c0205d4a:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d51:	0f b6 d0             	movzbl %al,%edx
c0205d54:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d5b:	0f b7 c0             	movzwl %ax,%eax
c0205d5e:	c7 c1 28 31 20 c0    	mov    $0xc0203128,%ecx
c0205d64:	52                   	push   %edx
c0205d65:	50                   	push   %eax
c0205d66:	51                   	push   %ecx
c0205d67:	6a 11                	push   $0x11
c0205d69:	e8 6e fb ff ff       	call   c02058dc <set_int_disc>
c0205d6e:	83 c4 10             	add    $0x10,%esp
	set_int_disc(18,(uint32_t)isr18,kern_cs,default_inf);
c0205d71:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d78:	0f b6 d0             	movzbl %al,%edx
c0205d7b:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205d82:	0f b7 c0             	movzwl %ax,%eax
c0205d85:	c7 c1 30 31 20 c0    	mov    $0xc0203130,%ecx
c0205d8b:	52                   	push   %edx
c0205d8c:	50                   	push   %eax
c0205d8d:	51                   	push   %ecx
c0205d8e:	6a 12                	push   $0x12
c0205d90:	e8 47 fb ff ff       	call   c02058dc <set_int_disc>
c0205d95:	83 c4 10             	add    $0x10,%esp
	set_int_disc(19,(uint32_t)isr19,kern_cs,default_inf);
c0205d98:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205d9f:	0f b6 d0             	movzbl %al,%edx
c0205da2:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205da9:	0f b7 c0             	movzwl %ax,%eax
c0205dac:	c7 c1 39 31 20 c0    	mov    $0xc0203139,%ecx
c0205db2:	52                   	push   %edx
c0205db3:	50                   	push   %eax
c0205db4:	51                   	push   %ecx
c0205db5:	6a 13                	push   $0x13
c0205db7:	e8 20 fb ff ff       	call   c02058dc <set_int_disc>
c0205dbc:	83 c4 10             	add    $0x10,%esp
	set_int_disc(20,(uint32_t)isr20,kern_cs,default_inf);
c0205dbf:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205dc6:	0f b6 d0             	movzbl %al,%edx
c0205dc9:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205dd0:	0f b7 c0             	movzwl %ax,%eax
c0205dd3:	c7 c1 42 31 20 c0    	mov    $0xc0203142,%ecx
c0205dd9:	52                   	push   %edx
c0205dda:	50                   	push   %eax
c0205ddb:	51                   	push   %ecx
c0205ddc:	6a 14                	push   $0x14
c0205dde:	e8 f9 fa ff ff       	call   c02058dc <set_int_disc>
c0205de3:	83 c4 10             	add    $0x10,%esp
	set_int_disc(21,(uint32_t)isr21,kern_cs,default_inf);
c0205de6:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ded:	0f b6 d0             	movzbl %al,%edx
c0205df0:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205df7:	0f b7 c0             	movzwl %ax,%eax
c0205dfa:	c7 c1 4b 31 20 c0    	mov    $0xc020314b,%ecx
c0205e00:	52                   	push   %edx
c0205e01:	50                   	push   %eax
c0205e02:	51                   	push   %ecx
c0205e03:	6a 15                	push   $0x15
c0205e05:	e8 d2 fa ff ff       	call   c02058dc <set_int_disc>
c0205e0a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(22,(uint32_t)isr22,kern_cs,default_inf);
c0205e0d:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e14:	0f b6 d0             	movzbl %al,%edx
c0205e17:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e1e:	0f b7 c0             	movzwl %ax,%eax
c0205e21:	c7 c1 54 31 20 c0    	mov    $0xc0203154,%ecx
c0205e27:	52                   	push   %edx
c0205e28:	50                   	push   %eax
c0205e29:	51                   	push   %ecx
c0205e2a:	6a 16                	push   $0x16
c0205e2c:	e8 ab fa ff ff       	call   c02058dc <set_int_disc>
c0205e31:	83 c4 10             	add    $0x10,%esp
	set_int_disc(23,(uint32_t)isr23,kern_cs,default_inf);
c0205e34:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e3b:	0f b6 d0             	movzbl %al,%edx
c0205e3e:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e45:	0f b7 c0             	movzwl %ax,%eax
c0205e48:	c7 c1 5d 31 20 c0    	mov    $0xc020315d,%ecx
c0205e4e:	52                   	push   %edx
c0205e4f:	50                   	push   %eax
c0205e50:	51                   	push   %ecx
c0205e51:	6a 17                	push   $0x17
c0205e53:	e8 84 fa ff ff       	call   c02058dc <set_int_disc>
c0205e58:	83 c4 10             	add    $0x10,%esp
	set_int_disc(24,(uint32_t)isr24,kern_cs,default_inf);
c0205e5b:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e62:	0f b6 d0             	movzbl %al,%edx
c0205e65:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e6c:	0f b7 c0             	movzwl %ax,%eax
c0205e6f:	c7 c1 66 31 20 c0    	mov    $0xc0203166,%ecx
c0205e75:	52                   	push   %edx
c0205e76:	50                   	push   %eax
c0205e77:	51                   	push   %ecx
c0205e78:	6a 18                	push   $0x18
c0205e7a:	e8 5d fa ff ff       	call   c02058dc <set_int_disc>
c0205e7f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(25,(uint32_t)isr25,kern_cs,default_inf);
c0205e82:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205e89:	0f b6 d0             	movzbl %al,%edx
c0205e8c:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205e93:	0f b7 c0             	movzwl %ax,%eax
c0205e96:	c7 c1 6f 31 20 c0    	mov    $0xc020316f,%ecx
c0205e9c:	52                   	push   %edx
c0205e9d:	50                   	push   %eax
c0205e9e:	51                   	push   %ecx
c0205e9f:	6a 19                	push   $0x19
c0205ea1:	e8 36 fa ff ff       	call   c02058dc <set_int_disc>
c0205ea6:	83 c4 10             	add    $0x10,%esp
	set_int_disc(26,(uint32_t)isr26,kern_cs,default_inf);
c0205ea9:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205eb0:	0f b6 d0             	movzbl %al,%edx
c0205eb3:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205eba:	0f b7 c0             	movzwl %ax,%eax
c0205ebd:	c7 c1 78 31 20 c0    	mov    $0xc0203178,%ecx
c0205ec3:	52                   	push   %edx
c0205ec4:	50                   	push   %eax
c0205ec5:	51                   	push   %ecx
c0205ec6:	6a 1a                	push   $0x1a
c0205ec8:	e8 0f fa ff ff       	call   c02058dc <set_int_disc>
c0205ecd:	83 c4 10             	add    $0x10,%esp
	set_int_disc(27,(uint32_t)isr27,kern_cs,default_inf);
c0205ed0:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205ed7:	0f b6 d0             	movzbl %al,%edx
c0205eda:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205ee1:	0f b7 c0             	movzwl %ax,%eax
c0205ee4:	c7 c1 81 31 20 c0    	mov    $0xc0203181,%ecx
c0205eea:	52                   	push   %edx
c0205eeb:	50                   	push   %eax
c0205eec:	51                   	push   %ecx
c0205eed:	6a 1b                	push   $0x1b
c0205eef:	e8 e8 f9 ff ff       	call   c02058dc <set_int_disc>
c0205ef4:	83 c4 10             	add    $0x10,%esp
	set_int_disc(28,(uint32_t)isr28,kern_cs,default_inf);
c0205ef7:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205efe:	0f b6 d0             	movzbl %al,%edx
c0205f01:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f08:	0f b7 c0             	movzwl %ax,%eax
c0205f0b:	c7 c1 8a 31 20 c0    	mov    $0xc020318a,%ecx
c0205f11:	52                   	push   %edx
c0205f12:	50                   	push   %eax
c0205f13:	51                   	push   %ecx
c0205f14:	6a 1c                	push   $0x1c
c0205f16:	e8 c1 f9 ff ff       	call   c02058dc <set_int_disc>
c0205f1b:	83 c4 10             	add    $0x10,%esp
	set_int_disc(29,(uint32_t)isr29,kern_cs,default_inf);
c0205f1e:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f25:	0f b6 d0             	movzbl %al,%edx
c0205f28:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f2f:	0f b7 c0             	movzwl %ax,%eax
c0205f32:	c7 c1 93 31 20 c0    	mov    $0xc0203193,%ecx
c0205f38:	52                   	push   %edx
c0205f39:	50                   	push   %eax
c0205f3a:	51                   	push   %ecx
c0205f3b:	6a 1d                	push   $0x1d
c0205f3d:	e8 9a f9 ff ff       	call   c02058dc <set_int_disc>
c0205f42:	83 c4 10             	add    $0x10,%esp
	set_int_disc(30,(uint32_t)isr30,kern_cs,default_inf);
c0205f45:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f4c:	0f b6 d0             	movzbl %al,%edx
c0205f4f:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f56:	0f b7 c0             	movzwl %ax,%eax
c0205f59:	c7 c1 9c 31 20 c0    	mov    $0xc020319c,%ecx
c0205f5f:	52                   	push   %edx
c0205f60:	50                   	push   %eax
c0205f61:	51                   	push   %ecx
c0205f62:	6a 1e                	push   $0x1e
c0205f64:	e8 73 f9 ff ff       	call   c02058dc <set_int_disc>
c0205f69:	83 c4 10             	add    $0x10,%esp
	set_int_disc(31,(uint32_t)isr31,kern_cs,default_inf);
c0205f6c:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f73:	0f b6 d0             	movzbl %al,%edx
c0205f76:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205f7d:	0f b7 c0             	movzwl %ax,%eax
c0205f80:	c7 c1 a5 31 20 c0    	mov    $0xc02031a5,%ecx
c0205f86:	52                   	push   %edx
c0205f87:	50                   	push   %eax
c0205f88:	51                   	push   %ecx
c0205f89:	6a 1f                	push   $0x1f
c0205f8b:	e8 4c f9 ff ff       	call   c02058dc <set_int_disc>
c0205f90:	83 c4 10             	add    $0x10,%esp
	set_int_disc(32,(uint32_t)isr32,kern_cs,default_inf);
c0205f93:	0f b6 83 20 f0 ff ff 	movzbl -0xfe0(%ebx),%eax
c0205f9a:	0f b6 d0             	movzbl %al,%edx
c0205f9d:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0205fa4:	0f b7 c0             	movzwl %ax,%eax
c0205fa7:	c7 c1 ae 31 20 c0    	mov    $0xc02031ae,%ecx
c0205fad:	52                   	push   %edx
c0205fae:	50                   	push   %eax
c0205faf:	51                   	push   %ecx
c0205fb0:	6a 20                	push   $0x20
c0205fb2:	e8 25 f9 ff ff       	call   c02058dc <set_int_disc>
c0205fb7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(0,default_server_func);
c0205fba:	83 ec 08             	sub    $0x8,%esp
c0205fbd:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0205fc3:	50                   	push   %eax
c0205fc4:	6a 00                	push   $0x0
c0205fc6:	e8 f9 f9 ff ff       	call   c02059c4 <registe_interrupt>
c0205fcb:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(1,default_server_func);
c0205fce:	83 ec 08             	sub    $0x8,%esp
c0205fd1:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0205fd7:	50                   	push   %eax
c0205fd8:	6a 01                	push   $0x1
c0205fda:	e8 e5 f9 ff ff       	call   c02059c4 <registe_interrupt>
c0205fdf:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(2,default_server_func);
c0205fe2:	83 ec 08             	sub    $0x8,%esp
c0205fe5:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0205feb:	50                   	push   %eax
c0205fec:	6a 02                	push   $0x2
c0205fee:	e8 d1 f9 ff ff       	call   c02059c4 <registe_interrupt>
c0205ff3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(3,default_server_func);
c0205ff6:	83 ec 08             	sub    $0x8,%esp
c0205ff9:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0205fff:	50                   	push   %eax
c0206000:	6a 03                	push   $0x3
c0206002:	e8 bd f9 ff ff       	call   c02059c4 <registe_interrupt>
c0206007:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(4,default_server_func);
c020600a:	83 ec 08             	sub    $0x8,%esp
c020600d:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206013:	50                   	push   %eax
c0206014:	6a 04                	push   $0x4
c0206016:	e8 a9 f9 ff ff       	call   c02059c4 <registe_interrupt>
c020601b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(5,default_server_func);
c020601e:	83 ec 08             	sub    $0x8,%esp
c0206021:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206027:	50                   	push   %eax
c0206028:	6a 05                	push   $0x5
c020602a:	e8 95 f9 ff ff       	call   c02059c4 <registe_interrupt>
c020602f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(6,default_server_func);
c0206032:	83 ec 08             	sub    $0x8,%esp
c0206035:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020603b:	50                   	push   %eax
c020603c:	6a 06                	push   $0x6
c020603e:	e8 81 f9 ff ff       	call   c02059c4 <registe_interrupt>
c0206043:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(7,default_server_func);
c0206046:	83 ec 08             	sub    $0x8,%esp
c0206049:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020604f:	50                   	push   %eax
c0206050:	6a 07                	push   $0x7
c0206052:	e8 6d f9 ff ff       	call   c02059c4 <registe_interrupt>
c0206057:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(8,default_server_func);
c020605a:	83 ec 08             	sub    $0x8,%esp
c020605d:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206063:	50                   	push   %eax
c0206064:	6a 08                	push   $0x8
c0206066:	e8 59 f9 ff ff       	call   c02059c4 <registe_interrupt>
c020606b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(9,default_server_func);
c020606e:	83 ec 08             	sub    $0x8,%esp
c0206071:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206077:	50                   	push   %eax
c0206078:	6a 09                	push   $0x9
c020607a:	e8 45 f9 ff ff       	call   c02059c4 <registe_interrupt>
c020607f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(10,default_server_func);
c0206082:	83 ec 08             	sub    $0x8,%esp
c0206085:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020608b:	50                   	push   %eax
c020608c:	6a 0a                	push   $0xa
c020608e:	e8 31 f9 ff ff       	call   c02059c4 <registe_interrupt>
c0206093:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(11,default_server_func);
c0206096:	83 ec 08             	sub    $0x8,%esp
c0206099:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020609f:	50                   	push   %eax
c02060a0:	6a 0b                	push   $0xb
c02060a2:	e8 1d f9 ff ff       	call   c02059c4 <registe_interrupt>
c02060a7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(12,default_server_func);
c02060aa:	83 ec 08             	sub    $0x8,%esp
c02060ad:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02060b3:	50                   	push   %eax
c02060b4:	6a 0c                	push   $0xc
c02060b6:	e8 09 f9 ff ff       	call   c02059c4 <registe_interrupt>
c02060bb:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(13,default_server_func);
c02060be:	83 ec 08             	sub    $0x8,%esp
c02060c1:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02060c7:	50                   	push   %eax
c02060c8:	6a 0d                	push   $0xd
c02060ca:	e8 f5 f8 ff ff       	call   c02059c4 <registe_interrupt>
c02060cf:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(14,default_server_func);
c02060d2:	83 ec 08             	sub    $0x8,%esp
c02060d5:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02060db:	50                   	push   %eax
c02060dc:	6a 0e                	push   $0xe
c02060de:	e8 e1 f8 ff ff       	call   c02059c4 <registe_interrupt>
c02060e3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(15,default_server_func);
c02060e6:	83 ec 08             	sub    $0x8,%esp
c02060e9:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02060ef:	50                   	push   %eax
c02060f0:	6a 0f                	push   $0xf
c02060f2:	e8 cd f8 ff ff       	call   c02059c4 <registe_interrupt>
c02060f7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(16,default_server_func);
c02060fa:	83 ec 08             	sub    $0x8,%esp
c02060fd:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206103:	50                   	push   %eax
c0206104:	6a 10                	push   $0x10
c0206106:	e8 b9 f8 ff ff       	call   c02059c4 <registe_interrupt>
c020610b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(17,default_server_func);
c020610e:	83 ec 08             	sub    $0x8,%esp
c0206111:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206117:	50                   	push   %eax
c0206118:	6a 11                	push   $0x11
c020611a:	e8 a5 f8 ff ff       	call   c02059c4 <registe_interrupt>
c020611f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(18,default_server_func);
c0206122:	83 ec 08             	sub    $0x8,%esp
c0206125:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020612b:	50                   	push   %eax
c020612c:	6a 12                	push   $0x12
c020612e:	e8 91 f8 ff ff       	call   c02059c4 <registe_interrupt>
c0206133:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(19,default_server_func);
c0206136:	83 ec 08             	sub    $0x8,%esp
c0206139:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020613f:	50                   	push   %eax
c0206140:	6a 13                	push   $0x13
c0206142:	e8 7d f8 ff ff       	call   c02059c4 <registe_interrupt>
c0206147:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(20,default_server_func);
c020614a:	83 ec 08             	sub    $0x8,%esp
c020614d:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206153:	50                   	push   %eax
c0206154:	6a 14                	push   $0x14
c0206156:	e8 69 f8 ff ff       	call   c02059c4 <registe_interrupt>
c020615b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(21,default_server_func);
c020615e:	83 ec 08             	sub    $0x8,%esp
c0206161:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206167:	50                   	push   %eax
c0206168:	6a 15                	push   $0x15
c020616a:	e8 55 f8 ff ff       	call   c02059c4 <registe_interrupt>
c020616f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(22,default_server_func);
c0206172:	83 ec 08             	sub    $0x8,%esp
c0206175:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020617b:	50                   	push   %eax
c020617c:	6a 16                	push   $0x16
c020617e:	e8 41 f8 ff ff       	call   c02059c4 <registe_interrupt>
c0206183:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(23,default_server_func);
c0206186:	83 ec 08             	sub    $0x8,%esp
c0206189:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020618f:	50                   	push   %eax
c0206190:	6a 17                	push   $0x17
c0206192:	e8 2d f8 ff ff       	call   c02059c4 <registe_interrupt>
c0206197:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(24,default_server_func);
c020619a:	83 ec 08             	sub    $0x8,%esp
c020619d:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02061a3:	50                   	push   %eax
c02061a4:	6a 18                	push   $0x18
c02061a6:	e8 19 f8 ff ff       	call   c02059c4 <registe_interrupt>
c02061ab:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(25,default_server_func);
c02061ae:	83 ec 08             	sub    $0x8,%esp
c02061b1:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02061b7:	50                   	push   %eax
c02061b8:	6a 19                	push   $0x19
c02061ba:	e8 05 f8 ff ff       	call   c02059c4 <registe_interrupt>
c02061bf:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(26,default_server_func);
c02061c2:	83 ec 08             	sub    $0x8,%esp
c02061c5:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02061cb:	50                   	push   %eax
c02061cc:	6a 1a                	push   $0x1a
c02061ce:	e8 f1 f7 ff ff       	call   c02059c4 <registe_interrupt>
c02061d3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(27,default_server_func);
c02061d6:	83 ec 08             	sub    $0x8,%esp
c02061d9:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02061df:	50                   	push   %eax
c02061e0:	6a 1b                	push   $0x1b
c02061e2:	e8 dd f7 ff ff       	call   c02059c4 <registe_interrupt>
c02061e7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(28,default_server_func);
c02061ea:	83 ec 08             	sub    $0x8,%esp
c02061ed:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c02061f3:	50                   	push   %eax
c02061f4:	6a 1c                	push   $0x1c
c02061f6:	e8 c9 f7 ff ff       	call   c02059c4 <registe_interrupt>
c02061fb:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(29,default_server_func);
c02061fe:	83 ec 08             	sub    $0x8,%esp
c0206201:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c0206207:	50                   	push   %eax
c0206208:	6a 1d                	push   $0x1d
c020620a:	e8 b5 f7 ff ff       	call   c02059c4 <registe_interrupt>
c020620f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(30,default_server_func);
c0206212:	83 ec 08             	sub    $0x8,%esp
c0206215:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020621b:	50                   	push   %eax
c020621c:	6a 1e                	push   $0x1e
c020621e:	e8 a1 f7 ff ff       	call   c02059c4 <registe_interrupt>
c0206223:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(31,default_server_func);
c0206226:	83 ec 08             	sub    $0x8,%esp
c0206229:	8d 83 e3 c9 ff ff    	lea    -0x361d(%ebx),%eax
c020622f:	50                   	push   %eax
c0206230:	6a 1f                	push   $0x1f
c0206232:	e8 8d f7 ff ff       	call   c02059c4 <registe_interrupt>
c0206237:	83 c4 10             	add    $0x10,%esp
	//registe_interrupt(32,default_server_func);
	
	registe_interrupt(14,page_fault_func);
c020623a:	83 ec 08             	sub    $0x8,%esp
c020623d:	8d 83 55 ca ff ff    	lea    -0x35ab(%ebx),%eax
c0206243:	50                   	push   %eax
c0206244:	6a 0e                	push   $0xe
c0206246:	e8 79 f7 ff ff       	call   c02059c4 <registe_interrupt>
c020624b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(32,timer_server_func);
c020624e:	83 ec 08             	sub    $0x8,%esp
c0206251:	8d 83 f3 c9 ff ff    	lea    -0x360d(%ebx),%eax
c0206257:	50                   	push   %eax
c0206258:	6a 20                	push   $0x20
c020625a:	e8 65 f7 ff ff       	call   c02059c4 <registe_interrupt>
c020625f:	83 c4 10             	add    $0x10,%esp
	lidt_target.limit = sizeof(interrupt_discripter_t)*256;
c0206262:	c7 c0 00 35 29 c0    	mov    $0xc0293500,%eax
c0206268:	66 c7 00 00 08       	movw   $0x800,(%eax)
	lidt_target.base = (uint32_t)&idt_entries;
c020626d:	c7 c0 20 35 29 c0    	mov    $0xc0293520,%eax
c0206273:	89 c2                	mov    %eax,%edx
c0206275:	c7 c0 00 35 29 c0    	mov    $0xc0293500,%eax
c020627b:	89 50 02             	mov    %edx,0x2(%eax)
	timer_init(1000);
c020627e:	83 ec 0c             	sub    $0xc,%esp
c0206281:	68 e8 03 00 00       	push   $0x3e8
c0206286:	e8 cf f6 ff ff       	call   c020595a <timer_init>
c020628b:	83 c4 10             	add    $0x10,%esp
	load_idt((uint32_t)&lidt_target);
c020628e:	c7 c0 00 35 29 c0    	mov    $0xc0293500,%eax
c0206294:	83 ec 0c             	sub    $0xc,%esp
c0206297:	50                   	push   %eax
c0206298:	e8 1a cf ff ff       	call   c02031b7 <load_idt>
c020629d:	83 c4 10             	add    $0x10,%esp
    sti();
c02062a0:	e8 41 00 00 00       	call   c02062e6 <sti>
}
c02062a5:	90                   	nop
c02062a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02062a9:	c9                   	leave  
c02062aa:	c3                   	ret    

c02062ab <int_func_route>:

// INT路由函数
void int_func_route(int int_no,void * args){
c02062ab:	55                   	push   %ebp
c02062ac:	89 e5                	mov    %esp,%ebp
c02062ae:	83 ec 08             	sub    $0x8,%esp
c02062b1:	e8 4a 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02062b6:	05 4a 2d 00 00       	add    $0x2d4a,%eax
	int_server_func_list[int_no](args);
c02062bb:	c7 c0 00 31 29 c0    	mov    $0xc0293100,%eax
c02062c1:	8b 55 08             	mov    0x8(%ebp),%edx
c02062c4:	8b 04 90             	mov    (%eax,%edx,4),%eax
c02062c7:	83 ec 0c             	sub    $0xc,%esp
c02062ca:	ff 75 0c             	pushl  0xc(%ebp)
c02062cd:	ff d0                	call   *%eax
c02062cf:	83 c4 10             	add    $0x10,%esp
}
c02062d2:	90                   	nop
c02062d3:	c9                   	leave  
c02062d4:	c3                   	ret    

c02062d5 <cli>:

void cli(){
c02062d5:	55                   	push   %ebp
c02062d6:	89 e5                	mov    %esp,%ebp
c02062d8:	e8 23 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02062dd:	05 23 2d 00 00       	add    $0x2d23,%eax
    asm volatile("cli");
c02062e2:	fa                   	cli    
}
c02062e3:	90                   	nop
c02062e4:	5d                   	pop    %ebp
c02062e5:	c3                   	ret    

c02062e6 <sti>:
void sti(){
c02062e6:	55                   	push   %ebp
c02062e7:	89 e5                	mov    %esp,%ebp
c02062e9:	e8 12 1d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02062ee:	05 12 2d 00 00       	add    $0x2d12,%eax
    asm volatile("sti");
c02062f3:	fb                   	sti    
c02062f4:	90                   	nop
c02062f5:	5d                   	pop    %ebp
c02062f6:	c3                   	ret    

c02062f7 <get_kern_used_page_count>:

bitmap kern_vmm_pool;

static char* LOG_SRC_VMM = "VMM";

static int get_kern_used_page_count(){
c02062f7:	55                   	push   %ebp
c02062f8:	89 e5                	mov    %esp,%ebp
c02062fa:	83 ec 10             	sub    $0x10,%esp
c02062fd:	e8 fe 1c 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206302:	05 fe 2c 00 00       	add    $0x2cfe,%eax
    uint32_t size_bytes = kern_end-0;
c0206307:	c7 c0 00 30 2a 00    	mov    $0x2a3000,%eax
c020630d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (size_bytes+PAGE_SIZE-1)/PAGE_SIZE;     //向上取整
c0206310:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206313:	05 ff 0f 00 00       	add    $0xfff,%eax
c0206318:	c1 e8 0c             	shr    $0xc,%eax
}
c020631b:	c9                   	leave  
c020631c:	c3                   	ret    

c020631d <vmm_kern_init>:

//初始化内核虚拟空间
//预分配已使用内核空间
static void vmm_kern_init(){
c020631d:	55                   	push   %ebp
c020631e:	89 e5                	mov    %esp,%ebp
c0206320:	53                   	push   %ebx
c0206321:	83 ec 24             	sub    $0x24,%esp
c0206324:	e8 db 1c 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206329:	81 c3 d7 2c 00 00    	add    $0x2cd7,%ebx
    kern_vmm_pool.target_addr_header = 0xC0000000;   //内核空间起始地址
c020632f:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206335:	c7 40 08 00 00 00 c0 	movl   $0xc0000000,0x8(%eax)
    kern_vmm_pool.length = 0x8000;     //总共1GB空间
c020633c:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206342:	c7 40 04 00 80 00 00 	movl   $0x8000,0x4(%eax)
    kern_vmm_pool.vaddr_header = kern_bitmap;
c0206349:	c7 c0 0c 80 20 c0    	mov    $0xc020800c,%eax
c020634f:	8b 10                	mov    (%eax),%edx
c0206351:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206357:	89 10                	mov    %edx,(%eax)
    bitmap_init_mem(kern_vmm_pool);
c0206359:	83 ec 04             	sub    $0x4,%esp
c020635c:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206362:	ff 70 08             	pushl  0x8(%eax)
c0206365:	ff 70 04             	pushl  0x4(%eax)
c0206368:	ff 30                	pushl  (%eax)
c020636a:	e8 7c cf ff ff       	call   c02032eb <bitmap_init_mem>
c020636f:	83 c4 10             	add    $0x10,%esp
    int page_used = get_kern_used_page_count();
c0206372:	e8 80 ff ff ff       	call   c02062f7 <get_kern_used_page_count>
c0206377:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(page_used>1024){
c020637a:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
c0206381:	7e 1b                	jle    c020639e <vmm_kern_init+0x81>
        ERROR(LOG_SRC_VMM,"don`t have enough vm page for kernel when init!");
c0206383:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
c0206389:	83 ec 08             	sub    $0x8,%esp
c020638c:	8d 93 04 06 00 00    	lea    0x604(%ebx),%edx
c0206392:	52                   	push   %edx
c0206393:	50                   	push   %eax
c0206394:	e8 84 f4 ff ff       	call   c020581d <error_kern>
c0206399:	83 c4 10             	add    $0x10,%esp
        while (True){
c020639c:	eb fe                	jmp    c020639c <vmm_kern_init+0x7f>
            //内核暂停
        }
    }
    for(int i = 0; i<page_used ;i++){
c020639e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02063a5:	eb 20                	jmp    c02063c7 <vmm_kern_init+0xaa>
        uint32_t rem = bitmap_alloc(kern_vmm_pool); //将内核空间在内存池中置为繁忙   此处可做性能优化
c02063a7:	83 ec 04             	sub    $0x4,%esp
c02063aa:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02063b0:	ff 70 08             	pushl  0x8(%eax)
c02063b3:	ff 70 04             	pushl  0x4(%eax)
c02063b6:	ff 30                	pushl  (%eax)
c02063b8:	e8 0c d1 ff ff       	call   c02034c9 <bitmap_alloc>
c02063bd:	83 c4 10             	add    $0x10,%esp
c02063c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(int i = 0; i<page_used ;i++){
c02063c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02063c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02063ca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c02063cd:	7c d8                	jl     c02063a7 <vmm_kern_init+0x8a>
    }    
    //将内核虚拟内存管理页（最后1024页）在内存池中置为繁忙
    //1024页占用128字节 所以要将bitmap最后128字节清零
    int temp_cnt =0;
c02063cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c02063d6:	c7 c0 0c 80 20 c0    	mov    $0xc020800c,%eax
c02063dc:	8b 00                	mov    (%eax),%eax
c02063de:	05 ff 7f 00 00       	add    $0x7fff,%eax
c02063e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
c02063e6:	eb 0e                	jmp    c02063f6 <vmm_kern_init+0xd9>
        *((byte*)probe) = 0;
c02063e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02063eb:	c6 00 00             	movb   $0x0,(%eax)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c02063ee:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02063f2:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c02063f6:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
c02063fa:	7e ec                	jle    c02063e8 <vmm_kern_init+0xcb>
    }
}
c02063fc:	90                   	nop
c02063fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206400:	c9                   	leave  
c0206401:	c3                   	ret    

c0206402 <create_kern_page_table>:

//create a page table for input pde vaddr
static void create_kern_page_table(uint32_t pde_vaddr){
c0206402:	55                   	push   %ebp
c0206403:	89 e5                	mov    %esp,%ebp
c0206405:	53                   	push   %ebx
c0206406:	83 ec 24             	sub    $0x24,%esp
c0206409:	e8 f6 1b 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020640e:	81 c3 f2 2b 00 00    	add    $0x2bf2,%ebx
    //first:alloc a physic page,don`t alloc from vmm!
    pm_alloc_t pm = pmm_alloc_one_page();
c0206414:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0206417:	83 ec 0c             	sub    $0xc,%esp
c020641a:	50                   	push   %eax
c020641b:	e8 82 eb ff ff       	call   c0204fa2 <pmm_alloc_one_page>
c0206420:	83 c4 0c             	add    $0xc,%esp
    if(pm.state!=0){
c0206423:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0206427:	84 c0                	test   %al,%al
c0206429:	74 1b                	je     c0206446 <create_kern_page_table+0x44>
        STOP(LOG_SRC_VMM,"Fail To Create Kernel Page Table!STOP!");
c020642b:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
c0206431:	83 ec 08             	sub    $0x8,%esp
c0206434:	8d 93 34 06 00 00    	lea    0x634(%ebx),%edx
c020643a:	52                   	push   %edx
c020643b:	50                   	push   %eax
c020643c:	e8 46 f4 ff ff       	call   c0205887 <stop_kern>
c0206441:	83 c4 10             	add    $0x10,%esp
        memset((void *)addr,0x00,PAGE_SIZE);
        //third:change the PDE
        uint32_t* ptr = (uint32_t*) pde_vaddr;
        *ptr = (addr&0xFFFFF000)+PAGE_DESC_P+PAGE_DESC_RW_W+PAGE_DESC_US_S;
    }
}
c0206444:	eb 32                	jmp    c0206478 <create_kern_page_table+0x76>
        uint32_t addr = pm.addr;
c0206446:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0206449:	89 45 f4             	mov    %eax,-0xc(%ebp)
        memset((void *)addr,0x00,PAGE_SIZE);
c020644c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020644f:	83 ec 04             	sub    $0x4,%esp
c0206452:	68 00 10 00 00       	push   $0x1000
c0206457:	6a 00                	push   $0x0
c0206459:	50                   	push   %eax
c020645a:	e8 cb 15 00 00       	call   c0207a2a <memset>
c020645f:	83 c4 10             	add    $0x10,%esp
        uint32_t* ptr = (uint32_t*) pde_vaddr;
c0206462:	8b 45 08             	mov    0x8(%ebp),%eax
c0206465:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *ptr = (addr&0xFFFFF000)+PAGE_DESC_P+PAGE_DESC_RW_W+PAGE_DESC_US_S;
c0206468:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020646b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206470:	8d 50 03             	lea    0x3(%eax),%edx
c0206473:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206476:	89 10                	mov    %edx,(%eax)
}
c0206478:	90                   	nop
c0206479:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020647c:	c9                   	leave  
c020647d:	c3                   	ret    

c020647e <vmm_init>:

void vmm_init(){
c020647e:	55                   	push   %ebp
c020647f:	89 e5                	mov    %esp,%ebp
c0206481:	83 ec 08             	sub    $0x8,%esp
c0206484:	e8 77 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206489:	05 77 2b 00 00       	add    $0x2b77,%eax
       vmm_kern_init(); 
c020648e:	e8 8a fe ff ff       	call   c020631d <vmm_kern_init>
}
c0206493:	90                   	nop
c0206494:	c9                   	leave  
c0206495:	c3                   	ret    

c0206496 <get_pte>:

//通过虚拟地址 获取对应的页表项虚拟地址
uint32_t get_pte(uint32_t target) {
c0206496:	55                   	push   %ebp
c0206497:	89 e5                	mov    %esp,%ebp
c0206499:	83 ec 10             	sub    $0x10,%esp
c020649c:	e8 5f 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02064a1:	05 5f 2b 00 00       	add    $0x2b5f,%eax
    target = target&0xFFFFF000;
c02064a6:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = (0x3FF<<22);     //高10位
c02064ad:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = (target>>10) & 0x003FF000;//中间10位为target高10位
c02064b4:	8b 45 08             	mov    0x8(%ebp),%eax
c02064b7:	c1 e8 0a             	shr    $0xa,%eax
c02064ba:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c02064bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t addr_low12 = (((target>>12)&0x3FF)*4)&0x00000FFF;//低12位为target中间10位×4
c02064c2:	8b 45 08             	mov    0x8(%ebp),%eax
c02064c5:	c1 e8 0c             	shr    $0xc,%eax
c02064c8:	25 ff 03 00 00       	and    $0x3ff,%eax
c02064cd:	c1 e0 02             	shl    $0x2,%eax
c02064d0:	25 fc 0f 00 00       	and    $0xffc,%eax
c02064d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c02064d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02064db:	0b 45 f8             	or     -0x8(%ebp),%eax
c02064de:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c02064e1:	c9                   	leave  
c02064e2:	c3                   	ret    

c02064e3 <get_pde>:

//通过虚拟地址 获取对应的页目录项虚拟地址
uint32_t get_pde(uint32_t target) {
c02064e3:	55                   	push   %ebp
c02064e4:	89 e5                	mov    %esp,%ebp
c02064e6:	83 ec 10             	sub    $0x10,%esp
c02064e9:	e8 12 1b 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02064ee:	05 12 2b 00 00       	add    $0x2b12,%eax
    target = target&0xFFFFF000;
c02064f3:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = (0x3FF<<22);     //高10位
c02064fa:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = 0x003FF000;//中间10位为最后一个页目录项 也就是1023 （1111111111b）
c0206501:	c7 45 f8 00 f0 3f 00 	movl   $0x3ff000,-0x8(%ebp)
    uint32_t addr_low12 = (((target>>22)&0x3FF)*4)&0x00000FFF;//低12位为target中间10位×4
c0206508:	8b 45 08             	mov    0x8(%ebp),%eax
c020650b:	c1 e8 16             	shr    $0x16,%eax
c020650e:	c1 e0 02             	shl    $0x2,%eax
c0206511:	25 fc 0f 00 00       	and    $0xffc,%eax
c0206516:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c0206519:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020651c:	0b 45 f8             	or     -0x8(%ebp),%eax
c020651f:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c0206522:	c9                   	leave  
c0206523:	c3                   	ret    

c0206524 <vmm_kern_alloc_one_page>:
//      1111111111_xxxxxxxxxx_xxxxxxxxxx
//前十位为1表示页目录表最后一项 指向页目录表起始地址
// 中间十位表示在1024项页目录表中的索引
//最后12位表示在页表中的索引（每张页表1024项 共4096B 也就是12位可表达的最大范围）

uint32_t vmm_kern_alloc_one_page(uint32_t target) {
c0206524:	55                   	push   %ebp
c0206525:	89 e5                	mov    %esp,%ebp
c0206527:	53                   	push   %ebx
c0206528:	83 ec 24             	sub    $0x24,%esp
c020652b:	e8 d4 1a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206530:	81 c3 d0 2a 00 00    	add    $0x2ad0,%ebx
    uint32_t vaddr_get=bitmap_alloc_one_page(kern_vmm_pool,target);
c0206536:	ff 75 08             	pushl  0x8(%ebp)
c0206539:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c020653f:	ff 70 08             	pushl  0x8(%eax)
c0206542:	ff 70 04             	pushl  0x4(%eax)
c0206545:	ff 30                	pushl  (%eax)
c0206547:	e8 f5 cd ff ff       	call   c0203341 <bitmap_alloc_one_page>
c020654c:	83 c4 10             	add    $0x10,%esp
c020654f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c0206552:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0206556:	0f 84 80 00 00 00    	je     c02065dc <vmm_kern_alloc_one_page+0xb8>
        goto error_out;
    }
    else{
        //first the check the page table is present~
        uint32_t dir_desc_vaddr = get_pde(target);
c020655c:	83 ec 0c             	sub    $0xc,%esp
c020655f:	ff 75 08             	pushl  0x8(%ebp)
c0206562:	e8 7c ff ff ff       	call   c02064e3 <get_pde>
c0206567:	83 c4 10             	add    $0x10,%esp
c020656a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //the lower is P bit
        uint32_t * ptr = (uint32_t*)dir_desc_vaddr;
c020656d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206570:	89 45 ec             	mov    %eax,-0x14(%ebp)
            * ptr = *ptr|0x00000001;
            uint32_t page_desc_vaddr = get_pte(target);
            //because we change the PDE,we should flush the TLB to access the target PTE
            asm volatile ("invlpg (%0)" : : "a" (page_desc_vaddr&0xFFFFF000));
        }
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206573:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0206576:	83 ec 0c             	sub    $0xc,%esp
c0206579:	50                   	push   %eax
c020657a:	e8 23 ea ff ff       	call   c0204fa2 <pmm_alloc_one_page>
c020657f:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c0206582:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0206586:	84 c0                	test   %al,%al
c0206588:	74 36                	je     c02065c0 <vmm_kern_alloc_one_page+0x9c>
            //没有可用的物理页
            goto clean_bitmap_alloc;
        }
        //修改页表
        uint32_t page_desc_vaddr = get_pte(target);
c020658a:	83 ec 0c             	sub    $0xc,%esp
c020658d:	ff 75 08             	pushl  0x8(%ebp)
c0206590:	e8 01 ff ff ff       	call   c0206496 <get_pte>
c0206595:	83 c4 10             	add    $0x10,%esp
c0206598:	89 45 e8             	mov    %eax,-0x18(%ebp)
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c020659b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c020659e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02065a3:	89 c2                	mov    %eax,%edx
c02065a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c02065a8:	81 c2 03 01 00 00    	add    $0x103,%edx
c02065ae:	89 10                	mov    %edx,(%eax)
        asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c02065b0:	8b 45 08             	mov    0x8(%ebp),%eax
c02065b3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02065b8:	0f 01 38             	invlpg (%eax)
        //reload_kern_page();
        return target;
c02065bb:	8b 45 08             	mov    0x8(%ebp),%eax
c02065be:	eb 22                	jmp    c02065e2 <vmm_kern_alloc_one_page+0xbe>
            goto clean_bitmap_alloc;
c02065c0:	90                   	nop
    }
    clean_bitmap_alloc:
        bitmap_release_one_page(kern_vmm_pool,target);
c02065c1:	ff 75 08             	pushl  0x8(%ebp)
c02065c4:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02065ca:	ff 70 08             	pushl  0x8(%eax)
c02065cd:	ff 70 04             	pushl  0x4(%eax)
c02065d0:	ff 30                	pushl  (%eax)
c02065d2:	e8 47 ce ff ff       	call   c020341e <bitmap_release_one_page>
c02065d7:	83 c4 10             	add    $0x10,%esp
c02065da:	eb 01                	jmp    c02065dd <vmm_kern_alloc_one_page+0xb9>
        goto error_out;
c02065dc:	90                   	nop
    error_out:
        return KERN_VMM_ALLOC_ERRO;
c02065dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c02065e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02065e5:	c9                   	leave  
c02065e6:	c3                   	ret    

c02065e7 <vmm_kern_alloc>:

uint32_t vmm_kern_alloc(){
c02065e7:	55                   	push   %ebp
c02065e8:	89 e5                	mov    %esp,%ebp
c02065ea:	53                   	push   %ebx
c02065eb:	83 ec 24             	sub    $0x24,%esp
c02065ee:	e8 11 1a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02065f3:	81 c3 0d 2a 00 00    	add    $0x2a0d,%ebx
    uint32_t target=bitmap_alloc(kern_vmm_pool);
c02065f9:	83 ec 04             	sub    $0x4,%esp
c02065fc:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c0206602:	ff 70 08             	pushl  0x8(%eax)
c0206605:	ff 70 04             	pushl  0x4(%eax)
c0206608:	ff 30                	pushl  (%eax)
c020660a:	e8 ba ce ff ff       	call   c02034c9 <bitmap_alloc>
c020660f:	83 c4 10             	add    $0x10,%esp
c0206612:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(target == BITMAP_RETURN_ERRO){
c0206615:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0206619:	0f 84 80 00 00 00    	je     c020669f <vmm_kern_alloc+0xb8>
        goto error_out;
    }
    else{
        //first the check the page table is present~
        uint32_t dir_desc_vaddr = get_pde(target);
c020661f:	83 ec 0c             	sub    $0xc,%esp
c0206622:	ff 75 f4             	pushl  -0xc(%ebp)
c0206625:	e8 b9 fe ff ff       	call   c02064e3 <get_pde>
c020662a:	83 c4 10             	add    $0x10,%esp
c020662d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //the lower is P bit
        uint32_t * ptr = (uint32_t*)dir_desc_vaddr;
c0206630:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206633:	89 45 ec             	mov    %eax,-0x14(%ebp)
            * ptr = *ptr|0x00000001;
            uint32_t page_desc_vaddr = get_pte(target);
            //because we change the PDE,we should flush the TLB to access the target PTE
            asm volatile ("invlpg (%0)" : : "a" (page_desc_vaddr&0xFFFFF000));
        }
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206636:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0206639:	83 ec 0c             	sub    $0xc,%esp
c020663c:	50                   	push   %eax
c020663d:	e8 60 e9 ff ff       	call   c0204fa2 <pmm_alloc_one_page>
c0206642:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c0206645:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0206649:	84 c0                	test   %al,%al
c020664b:	74 36                	je     c0206683 <vmm_kern_alloc+0x9c>
            //没有可用的物理页
            goto clean_bitmap_alloc;
        }
        //修改页表
        uint32_t page_desc_vaddr = get_pte(target);
c020664d:	83 ec 0c             	sub    $0xc,%esp
c0206650:	ff 75 f4             	pushl  -0xc(%ebp)
c0206653:	e8 3e fe ff ff       	call   c0206496 <get_pte>
c0206658:	83 c4 10             	add    $0x10,%esp
c020665b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c020665e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0206661:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206666:	89 c2                	mov    %eax,%edx
c0206668:	8b 45 e8             	mov    -0x18(%ebp),%eax
c020666b:	81 c2 03 01 00 00    	add    $0x103,%edx
c0206671:	89 10                	mov    %edx,(%eax)
        asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c0206673:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206676:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020667b:	0f 01 38             	invlpg (%eax)
        //reload_kern_page();
        return target;
c020667e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206681:	eb 22                	jmp    c02066a5 <vmm_kern_alloc+0xbe>
            goto clean_bitmap_alloc;
c0206683:	90                   	nop
    }
    clean_bitmap_alloc:
        bitmap_release_one_page(kern_vmm_pool,target);
c0206684:	ff 75 f4             	pushl  -0xc(%ebp)
c0206687:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c020668d:	ff 70 08             	pushl  0x8(%eax)
c0206690:	ff 70 04             	pushl  0x4(%eax)
c0206693:	ff 30                	pushl  (%eax)
c0206695:	e8 84 cd ff ff       	call   c020341e <bitmap_release_one_page>
c020669a:	83 c4 10             	add    $0x10,%esp
c020669d:	eb 01                	jmp    c02066a0 <vmm_kern_alloc+0xb9>
        goto error_out;
c020669f:	90                   	nop
    error_out:
        return KERN_VMM_ALLOC_ERRO;
c02066a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c02066a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02066a8:	c9                   	leave  
c02066a9:	c3                   	ret    

c02066aa <vmm_kern_release_one_page>:

//释放制定内核虚拟页的空间
//内核的释放与用户的释放要分开 否则用户程序可以使用系统调用指定将内核虚拟页释放掉

void vmm_kern_release_one_page(uint32_t target) {
c02066aa:	55                   	push   %ebp
c02066ab:	89 e5                	mov    %esp,%ebp
c02066ad:	53                   	push   %ebx
c02066ae:	83 ec 24             	sub    $0x24,%esp
c02066b1:	e8 52 19 00 00       	call   c0208008 <__x86.get_pc_thunk.dx>
c02066b6:	81 c2 4a 29 00 00    	add    $0x294a,%edx
    //判定是否是内核页
    if(target<0xC0000000){
c02066bc:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c02066c3:	76 68                	jbe    c020672d <vmm_kern_release_one_page+0x83>
        //不是内核页 直接退出执行
        return ;
    }
    bitmap_release_one_page(kern_vmm_pool,target);
c02066c5:	ff 75 08             	pushl  0x8(%ebp)
c02066c8:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02066ce:	ff 70 08             	pushl  0x8(%eax)
c02066d1:	ff 70 04             	pushl  0x4(%eax)
c02066d4:	ff 30                	pushl  (%eax)
c02066d6:	89 d3                	mov    %edx,%ebx
c02066d8:	e8 41 cd ff ff       	call   c020341e <bitmap_release_one_page>
c02066dd:	83 c4 10             	add    $0x10,%esp
    uint32_t desc_vaddr = get_pte(target);
c02066e0:	83 ec 0c             	sub    $0xc,%esp
c02066e3:	ff 75 08             	pushl  0x8(%ebp)
c02066e6:	e8 ab fd ff ff       	call   c0206496 <get_pte>
c02066eb:	83 c4 10             	add    $0x10,%esp
c02066ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t desc_inf = *((uint32_t*)desc_vaddr);
c02066f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02066f4:	8b 00                	mov    (%eax),%eax
c02066f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *((uint32_t*)desc_vaddr) =  desc_inf&0xFFFFFFFE;    //最低位置为0 表示P位为0 不存在(直接访问会造成page_fault中断)
c02066f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02066fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02066ff:	83 e2 fe             	and    $0xfffffffe,%edx
c0206702:	89 10                	mov    %edx,(%eax)
    uint32_t phy_page_addr = desc_inf&0xFFFFF000;
c0206704:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206707:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020670c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    pm_alloc_t release_page;
    release_page.addr = phy_page_addr;
c020670f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206712:	89 45 e0             	mov    %eax,-0x20(%ebp)
    release_page.size =1;
c0206715:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    release_page.state = 1;
c020671c:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)

    //BUG!!!!!!!!!!!!!!!!!!!!
    //pmm_free_page(release_page);

    /*此处有bug   虽然设置了页不缓存 但是系统还是会自动缓存 所以此处使用嵌入汇编invlpg重载目标页的TLB缓存*/
    asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c0206720:	8b 45 08             	mov    0x8(%ebp),%eax
c0206723:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206728:	0f 01 38             	invlpg (%eax)
c020672b:	eb 01                	jmp    c020672e <vmm_kern_release_one_page+0x84>
        return ;
c020672d:	90                   	nop
    //reload_kern_page();
}
c020672e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206731:	c9                   	leave  
c0206732:	c3                   	ret    

c0206733 <check_vaddr_present>:


//检测vaddr是否可以访问（页表以及页目录项都是P=1）
bool check_vaddr_present(uint32_t vaddr){
c0206733:	55                   	push   %ebp
c0206734:	89 e5                	mov    %esp,%ebp
c0206736:	83 ec 10             	sub    $0x10,%esp
c0206739:	e8 c2 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020673e:	05 c2 28 00 00       	add    $0x28c2,%eax
    uint32_t * pde_ptr = get_pde(vaddr);
c0206743:	ff 75 08             	pushl  0x8(%ebp)
c0206746:	e8 98 fd ff ff       	call   c02064e3 <get_pde>
c020674b:	83 c4 04             	add    $0x4,%esp
c020674e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t * pte_ptr;
    if(*pde_ptr==(*pde_ptr)|0x00000001){
         pte_ptr = get_pte(vaddr);
c0206751:	ff 75 08             	pushl  0x8(%ebp)
c0206754:	e8 3d fd ff ff       	call   c0206496 <get_pte>
c0206759:	83 c4 04             	add    $0x4,%esp
c020675c:	89 45 f8             	mov    %eax,-0x8(%ebp)
         if(*pte_ptr==(*pte_ptr)|0x00000001){
            return True;
c020675f:	b8 01 00 00 00       	mov    $0x1,%eax
         }
    }
    else{
        return False;
    }
}
c0206764:	c9                   	leave  
c0206765:	c3                   	ret    

c0206766 <vmm_v2p>:

//注意：输入的值结尾为FFF时要防止与错误输出冲突
//本函数不会无视页表的P位
//用于根据已安装的页表进行虚拟地址转换
uint32_t vmm_v2p(uint32_t vaddr){
c0206766:	55                   	push   %ebp
c0206767:	89 e5                	mov    %esp,%ebp
c0206769:	83 ec 10             	sub    $0x10,%esp
c020676c:	e8 8f 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206771:	05 8f 28 00 00       	add    $0x288f,%eax
    uint32_t pte_addr = get_pte(vaddr);
c0206776:	ff 75 08             	pushl  0x8(%ebp)
c0206779:	e8 18 fd ff ff       	call   c0206496 <get_pte>
c020677e:	83 c4 04             	add    $0x4,%esp
c0206781:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t * ptr = (uint32_t*)pte_addr;
c0206784:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206787:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(check_vaddr_present(vaddr)){
c020678a:	ff 75 08             	pushl  0x8(%ebp)
c020678d:	e8 a1 ff ff ff       	call   c0206733 <check_vaddr_present>
c0206792:	83 c4 04             	add    $0x4,%esp
c0206795:	85 c0                	test   %eax,%eax
c0206797:	74 18                	je     c02067b1 <vmm_v2p+0x4b>
        //可访问的vaddr
        return (*(ptr)&0xFFFFF000)|(0x00000FFF&vaddr);
c0206799:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020679c:	8b 00                	mov    (%eax),%eax
c020679e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02067a3:	89 c2                	mov    %eax,%edx
c02067a5:	8b 45 08             	mov    0x8(%ebp),%eax
c02067a8:	25 ff 0f 00 00       	and    $0xfff,%eax
c02067ad:	09 d0                	or     %edx,%eax
c02067af:	eb 05                	jmp    c02067b6 <vmm_v2p+0x50>
    }
    else{
        //不可访问的vaddr
        return V2P_ERROR;
c02067b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c02067b6:	c9                   	leave  
c02067b7:	c3                   	ret    

c02067b8 <vmm_user_init>:

static void vmm_user_init(){
c02067b8:	55                   	push   %ebp
c02067b9:	89 e5                	mov    %esp,%ebp
c02067bb:	e8 40 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02067c0:	05 40 28 00 00       	add    $0x2840,%eax

}
c02067c5:	90                   	nop
c02067c6:	5d                   	pop    %ebp
c02067c7:	c3                   	ret    

c02067c8 <user_get_pde>:
*/


//*************for user vmm****************
#define USER_GET_VMM_ERROR  0xFFFFFFFF
static uint32_t user_get_pde(uint32_t user_pdt_vaddr,uint32_t target_vaddr){
c02067c8:	55                   	push   %ebp
c02067c9:	89 e5                	mov    %esp,%ebp
c02067cb:	83 ec 10             	sub    $0x10,%esp
c02067ce:	e8 2d 18 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02067d3:	05 2d 28 00 00       	add    $0x282d,%eax
    uint32_t times = (target_vaddr>>22)&0x000003FF;
c02067d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c02067db:	c1 e8 16             	shr    $0x16,%eax
c02067de:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t pde_vaddr = user_pdt_vaddr+times*4;
c02067e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02067e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c02067eb:	8b 45 08             	mov    0x8(%ebp),%eax
c02067ee:	01 d0                	add    %edx,%eax
c02067f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return pde_vaddr;
c02067f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c02067f6:	c9                   	leave  
c02067f7:	c3                   	ret    

c02067f8 <vmm_user_check_pt_present>:


static bool vmm_user_check_pt_present(uint32_t user_pdt_vaddr,uint32_t target_vaddr){
c02067f8:	55                   	push   %ebp
c02067f9:	89 e5                	mov    %esp,%ebp
c02067fb:	83 ec 10             	sub    $0x10,%esp
c02067fe:	e8 fd 17 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206803:	05 fd 27 00 00       	add    $0x27fd,%eax
    uint32_t times = (target_vaddr>>22)&0x000003FF;
c0206808:	8b 45 0c             	mov    0xc(%ebp),%eax
c020680b:	c1 e8 16             	shr    $0x16,%eax
c020680e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t pde_vaddr = user_pdt_vaddr+times*4;     //目标pde虚拟地址
c0206811:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206814:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c020681b:	8b 45 08             	mov    0x8(%ebp),%eax
c020681e:	01 d0                	add    %edx,%eax
c0206820:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t * ptr = (uint32_t*)pde_vaddr;
c0206823:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206826:	89 45 f4             	mov    %eax,-0xc(%ebp)
    //    == 优先级比 |    & 高
    if(*ptr==((*ptr)|0x00000001)){
c0206829:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020682c:	8b 10                	mov    (%eax),%edx
c020682e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206831:	8b 00                	mov    (%eax),%eax
c0206833:	83 c8 01             	or     $0x1,%eax
c0206836:	39 c2                	cmp    %eax,%edx
c0206838:	75 07                	jne    c0206841 <vmm_user_check_pt_present+0x49>
        //表示存在present
        return True;
c020683a:	b8 01 00 00 00       	mov    $0x1,%eax
c020683f:	eb 05                	jmp    c0206846 <vmm_user_check_pt_present+0x4e>
    }
    else{
        //表示不存在present
        return False;
c0206841:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
c0206846:	c9                   	leave  
c0206847:	c3                   	ret    

c0206848 <create_user_page_table>:


//创建的页表需要在内核中分配
static bool create_user_page_table(uint32_t pde_vaddr){
c0206848:	55                   	push   %ebp
c0206849:	89 e5                	mov    %esp,%ebp
c020684b:	53                   	push   %ebx
c020684c:	83 ec 14             	sub    $0x14,%esp
c020684f:	e8 b0 17 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206854:	81 c3 ac 27 00 00    	add    $0x27ac,%ebx
    //pde_vaddr 0xC02BABFC
    //首先在内核中获取虚拟页
    uint32_t re_vaddr = vmm_kern_alloc();    
c020685a:	e8 88 fd ff ff       	call   c02065e7 <vmm_kern_alloc>
c020685f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(re_vaddr==KERN_VMM_ALLOC_ERRO){
c0206862:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0206866:	75 07                	jne    c020686f <create_user_page_table+0x27>
        return False;
c0206868:	b8 00 00 00 00       	mov    $0x0,%eax
c020686d:	eb 50                	jmp    c02068bf <create_user_page_table+0x77>
    }
    else{
        //进行单页内存清理
        bzero(re_vaddr,PAGE_SIZE);
c020686f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206872:	83 ec 08             	sub    $0x8,%esp
c0206875:	68 00 10 00 00       	push   $0x1000
c020687a:	50                   	push   %eax
c020687b:	e8 e4 11 00 00       	call   c0207a64 <bzero>
c0206880:	83 c4 10             	add    $0x10,%esp
        uint32_t page_paddr = vmm_v2p(re_vaddr);
c0206883:	83 ec 0c             	sub    $0xc,%esp
c0206886:	ff 75 f4             	pushl  -0xc(%ebp)
c0206889:	e8 d8 fe ff ff       	call   c0206766 <vmm_v2p>
c020688e:	83 c4 10             	add    $0x10,%esp
c0206891:	89 45 f0             	mov    %eax,-0x10(%ebp)
        //获取页表物理地址i
        if(page_paddr == V2P_ERROR){
c0206894:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0206898:	75 07                	jne    c02068a1 <create_user_page_table+0x59>
            //转换失败！！！
            return False;
c020689a:	b8 00 00 00 00       	mov    $0x0,%eax
c020689f:	eb 1e                	jmp    c02068bf <create_user_page_table+0x77>
        }
        else{
        //进行用户页表映射
            uint32_t *ptr = (uint32_t *)pde_vaddr;
c02068a1:	8b 45 08             	mov    0x8(%ebp),%eax
c02068a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *ptr = (page_paddr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_U+PAGE_DESC_G+PAGE_DESC_P;
c02068a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02068aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02068af:	8d 90 07 01 00 00    	lea    0x107(%eax),%edx
c02068b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02068b8:	89 10                	mov    %edx,(%eax)
        }
        return True;
c02068ba:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c02068bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02068c2:	c9                   	leave  
c02068c3:	c3                   	ret    

c02068c4 <vmm_user_alloc_one_page>:

//第一个参数是需要分配的虚拟内存池对应的进程
//第二个参数是需要分配的目标地址
//默认要求此进程已经加载并且正在执行中
uint32_t vmm_user_alloc_one_page(TCB_t * tcb_ptr,uint32_t vaddr){    
c02068c4:	55                   	push   %ebp
c02068c5:	89 e5                	mov    %esp,%ebp
c02068c7:	53                   	push   %ebx
c02068c8:	83 ec 34             	sub    $0x34,%esp
c02068cb:	e8 34 17 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02068d0:	81 c3 30 27 00 00    	add    $0x2730,%ebx
    if(!USER_PAGE_DIR_IS_LOADED){
c02068d6:	8b 83 24 f0 ff ff    	mov    -0xfdc(%ebx),%eax
c02068dc:	85 c0                	test   %eax,%eax
c02068de:	0f 84 21 01 00 00    	je     c0206a05 <vmm_user_alloc_one_page+0x141>
        goto error_out;
    }

    bool is_kern_thread = tcb_ptr->is_kern_thread;
c02068e4:	8b 45 08             	mov    0x8(%ebp),%eax
c02068e7:	8b 40 20             	mov    0x20(%eax),%eax
c02068ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(is_kern_thread){
c02068ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c02068f1:	0f 85 11 01 00 00    	jne    c0206a08 <vmm_user_alloc_one_page+0x144>
        goto error_out;
    }
    bitmap user_vmm_pool = tcb_ptr->user_vmm_pool;    //bitmap
c02068f7:	8b 45 08             	mov    0x8(%ebp),%eax
c02068fa:	8b 50 24             	mov    0x24(%eax),%edx
c02068fd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c0206900:	8b 50 28             	mov    0x28(%eax),%edx
c0206903:	89 55 d8             	mov    %edx,-0x28(%ebp)
c0206906:	8b 40 2c             	mov    0x2c(%eax),%eax
c0206909:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uint32_t user_pdt_vaddr = tcb_ptr->pdt_vaddr;    //pdt
c020690c:	8b 45 08             	mov    0x8(%ebp),%eax
c020690f:	8b 40 30             	mov    0x30(%eax),%eax
c0206912:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t vaddr_get=bitmap_alloc_one_page(user_vmm_pool,vaddr);
c0206915:	ff 75 0c             	pushl  0xc(%ebp)
c0206918:	ff 75 dc             	pushl  -0x24(%ebp)
c020691b:	ff 75 d8             	pushl  -0x28(%ebp)
c020691e:	ff 75 d4             	pushl  -0x2c(%ebp)
c0206921:	e8 1b ca ff ff       	call   c0203341 <bitmap_alloc_one_page>
c0206926:	83 c4 10             	add    $0x10,%esp
c0206929:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c020692c:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0206930:	0f 84 ad 00 00 00    	je     c02069e3 <vmm_user_alloc_one_page+0x11f>
        goto clean_bitmap_alloc;
    }
    else{
        if(vmm_user_check_pt_present(user_pdt_vaddr,vaddr)){
c0206936:	83 ec 08             	sub    $0x8,%esp
c0206939:	ff 75 0c             	pushl  0xc(%ebp)
c020693c:	ff 75 f0             	pushl  -0x10(%ebp)
c020693f:	e8 b4 fe ff ff       	call   c02067f8 <vmm_user_check_pt_present>
c0206944:	83 c4 10             	add    $0x10,%esp
c0206947:	85 c0                	test   %eax,%eax
c0206949:	74 19                	je     c0206964 <vmm_user_alloc_one_page+0xa0>
         asm volatile("cli");
c020694b:	fa                   	cli    
            printk("-0x%h\n",user_pdt_vaddr);
c020694c:	83 ec 08             	sub    $0x8,%esp
c020694f:	ff 75 f0             	pushl  -0x10(%ebp)
c0206952:	8d 83 5b 06 00 00    	lea    0x65b(%ebx),%eax
c0206958:	50                   	push   %eax
c0206959:	e8 09 0a 00 00       	call   c0207367 <printk>
c020695e:	83 c4 10             	add    $0x10,%esp
         asm volatile("sti");
c0206961:	fb                   	sti    
c0206962:	eb 2d                	jmp    c0206991 <vmm_user_alloc_one_page+0xcd>

            // the page table is present,do nothing
        }
        else{
            // the page table is not present,create page table
            uint32_t times = (vaddr>>22)&0x000003FF;
c0206964:	8b 45 0c             	mov    0xc(%ebp),%eax
c0206967:	c1 e8 16             	shr    $0x16,%eax
c020696a:	89 45 e8             	mov    %eax,-0x18(%ebp)
            uint32_t user_dir_desc_vaddr= user_pdt_vaddr+times*4;     //目标pde虚拟地址
c020696d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0206970:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0206977:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020697a:	01 d0                	add    %edx,%eax
c020697c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
           if(create_user_page_table(user_dir_desc_vaddr)){
c020697f:	83 ec 0c             	sub    $0xc,%esp
c0206982:	ff 75 e4             	pushl  -0x1c(%ebp)
c0206985:	e8 be fe ff ff       	call   c0206848 <create_user_page_table>
c020698a:	83 c4 10             	add    $0x10,%esp
c020698d:	85 c0                	test   %eax,%eax
c020698f:	74 55                	je     c02069e6 <vmm_user_alloc_one_page+0x122>
           }
           else{
               goto clean_bitmap_alloc;
           }
        }
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206991:	8d 45 c8             	lea    -0x38(%ebp),%eax
c0206994:	83 ec 0c             	sub    $0xc,%esp
c0206997:	50                   	push   %eax
c0206998:	e8 05 e6 ff ff       	call   c0204fa2 <pmm_alloc_one_page>
c020699d:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c02069a0:	0f b6 45 d0          	movzbl -0x30(%ebp),%eax
c02069a4:	84 c0                	test   %al,%al
c02069a6:	74 41                	je     c02069e9 <vmm_user_alloc_one_page+0x125>
            //没有可用的物理页
            goto clean_bitmap_alloc;
        }
        //获取目标页表项在内核空间中的虚拟地址
        uint32_t page_desc_vaddr = get_pte(vaddr);
c02069a8:	83 ec 0c             	sub    $0xc,%esp
c02069ab:	ff 75 0c             	pushl  0xc(%ebp)
c02069ae:	e8 e3 fa ff ff       	call   c0206496 <get_pte>
c02069b3:	83 c4 10             	add    $0x10,%esp
c02069b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
        //修改页表
        //注意一点：这个page_desc_vaddr只能通过页目录最后一项找到，所以必须要用户页表加载以后才可以寻找到
        //此时会产生page错误？？？？？
        //FFEFFF20
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_U+PAGE_DESC_G+PAGE_DESC_P;
c02069b9:	8b 45 c8             	mov    -0x38(%ebp),%eax
c02069bc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069c1:	89 c2                	mov    %eax,%edx
c02069c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c02069c6:	81 c2 07 01 00 00    	add    $0x107,%edx
c02069cc:	89 10                	mov    %edx,(%eax)

        asm volatile ("invlpg (%0)" : : "a" (vaddr&0xFFFFF000));
c02069ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c02069d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069d6:	0f 01 38             	invlpg (%eax)
        return vaddr&0xFFFFF000;
c02069d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c02069dc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069e1:	eb 2b                	jmp    c0206a0e <vmm_user_alloc_one_page+0x14a>
        goto clean_bitmap_alloc;
c02069e3:	90                   	nop
c02069e4:	eb 04                	jmp    c02069ea <vmm_user_alloc_one_page+0x126>
               goto clean_bitmap_alloc;
c02069e6:	90                   	nop
c02069e7:	eb 01                	jmp    c02069ea <vmm_user_alloc_one_page+0x126>
            goto clean_bitmap_alloc;
c02069e9:	90                   	nop
    }
    //clean以后会自动执行错误的返回
    clean_bitmap_alloc:
        bitmap_release_one_page(kern_vmm_pool,vaddr);
c02069ea:	ff 75 0c             	pushl  0xc(%ebp)
c02069ed:	c7 c0 20 3d 29 c0    	mov    $0xc0293d20,%eax
c02069f3:	ff 70 08             	pushl  0x8(%eax)
c02069f6:	ff 70 04             	pushl  0x4(%eax)
c02069f9:	ff 30                	pushl  (%eax)
c02069fb:	e8 1e ca ff ff       	call   c020341e <bitmap_release_one_page>
c0206a00:	83 c4 10             	add    $0x10,%esp
c0206a03:	eb 04                	jmp    c0206a09 <vmm_user_alloc_one_page+0x145>
        goto error_out;
c0206a05:	90                   	nop
c0206a06:	eb 01                	jmp    c0206a09 <vmm_user_alloc_one_page+0x145>
        goto error_out;
c0206a08:	90                   	nop
    error_out:
        return USER_VMM_ALLOC_ERRO;
c0206a09:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0206a0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206a11:	c9                   	leave  
c0206a12:	c3                   	ret    

c0206a13 <vmm_user_alloc>:

uint32_t vmm_user_alloc(uint32_t user_pdt_vaddr){
c0206a13:	55                   	push   %ebp
c0206a14:	89 e5                	mov    %esp,%ebp
c0206a16:	e8 e5 15 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206a1b:	05 e5 25 00 00       	add    $0x25e5,%eax

}
c0206a20:	90                   	nop
c0206a21:	5d                   	pop    %ebp
c0206a22:	c3                   	ret    

c0206a23 <vmm_user_release_one_page>:
void vmm_user_release_one_page(uint32_t target){
c0206a23:	55                   	push   %ebp
c0206a24:	89 e5                	mov    %esp,%ebp
c0206a26:	e8 d5 15 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206a2b:	05 d5 25 00 00       	add    $0x25d5,%eax

}
c0206a30:	90                   	nop
c0206a31:	5d                   	pop    %ebp
c0206a32:	c3                   	ret    

c0206a33 <get_user_used_vmm_info>:

int get_user_used_vmm_info(){
c0206a33:	55                   	push   %ebp
c0206a34:	89 e5                	mov    %esp,%ebp
c0206a36:	e8 c5 15 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206a3b:	05 c5 25 00 00       	add    $0x25c5,%eax
    return 1;
c0206a40:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0206a45:	5d                   	pop    %ebp
c0206a46:	c3                   	ret    

c0206a47 <vmm_test>:




//6(0110)3(0011)
void vmm_test(){
c0206a47:	55                   	push   %ebp
c0206a48:	89 e5                	mov    %esp,%ebp
c0206a4a:	56                   	push   %esi
c0206a4b:	53                   	push   %ebx
c0206a4c:	e8 b3 15 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206a51:	81 c3 af 25 00 00    	add    $0x25af,%ebx
    //vmm_kern_release_one_page(0xC0000000);
    //*((char*)0xC0000000) = 1;   
    printk("\nkern_dir:0x%h\n",kern_dir_table_paddr);
c0206a57:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0206a5d:	8b 00                	mov    (%eax),%eax
c0206a5f:	83 ec 08             	sub    $0x8,%esp
c0206a62:	50                   	push   %eax
c0206a63:	8d 83 62 06 00 00    	lea    0x662(%ebx),%eax
c0206a69:	50                   	push   %eax
c0206a6a:	e8 f8 08 00 00       	call   c0207367 <printk>
c0206a6f:	83 c4 10             	add    $0x10,%esp
    printk("\nkern_page:0x%h\n",kern_page_table_paddr);
c0206a72:	c7 c0 18 80 20 c0    	mov    $0xc0208018,%eax
c0206a78:	8b 00                	mov    (%eax),%eax
c0206a7a:	83 ec 08             	sub    $0x8,%esp
c0206a7d:	50                   	push   %eax
c0206a7e:	8d 83 72 06 00 00    	lea    0x672(%ebx),%eax
c0206a84:	50                   	push   %eax
c0206a85:	e8 dd 08 00 00       	call   c0207367 <printk>
c0206a8a:	83 c4 10             	add    $0x10,%esp
    printk("\nlast_pde:0x%h\n",*((uint32_t*)(kern_dir_table_paddr+0xC00+255*4)));
c0206a8d:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0206a93:	8b 00                	mov    (%eax),%eax
c0206a95:	05 fc 0f 00 00       	add    $0xffc,%eax
c0206a9a:	8b 00                	mov    (%eax),%eax
c0206a9c:	83 ec 08             	sub    $0x8,%esp
c0206a9f:	50                   	push   %eax
c0206aa0:	8d 83 83 06 00 00    	lea    0x683(%ebx),%eax
c0206aa6:	50                   	push   %eax
c0206aa7:	e8 bb 08 00 00       	call   c0207367 <printk>
c0206aac:	83 c4 10             	add    $0x10,%esp
    printk("\nresult:0x%h---%h\n",*((uint32_t*) get_pte(0xC0000000)),*((uint32_t*)kern_page_table_paddr));
c0206aaf:	c7 c0 18 80 20 c0    	mov    $0xc0208018,%eax
c0206ab5:	8b 00                	mov    (%eax),%eax
c0206ab7:	8b 30                	mov    (%eax),%esi
c0206ab9:	83 ec 0c             	sub    $0xc,%esp
c0206abc:	68 00 00 00 c0       	push   $0xc0000000
c0206ac1:	e8 d0 f9 ff ff       	call   c0206496 <get_pte>
c0206ac6:	83 c4 10             	add    $0x10,%esp
c0206ac9:	8b 00                	mov    (%eax),%eax
c0206acb:	83 ec 04             	sub    $0x4,%esp
c0206ace:	56                   	push   %esi
c0206acf:	50                   	push   %eax
c0206ad0:	8d 83 93 06 00 00    	lea    0x693(%ebx),%eax
c0206ad6:	50                   	push   %eax
c0206ad7:	e8 8b 08 00 00       	call   c0207367 <printk>
c0206adc:	83 c4 10             	add    $0x10,%esp
//正常分配情况会导致两次page_fault
    *((char*)0xC1000000) = 'a';
c0206adf:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206ae4:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_alloc_one_page(0xC1000000);
c0206ae7:	83 ec 0c             	sub    $0xc,%esp
c0206aea:	68 00 00 00 c1       	push   $0xc1000000
c0206aef:	e8 30 fa ff ff       	call   c0206524 <vmm_kern_alloc_one_page>
c0206af4:	83 c4 10             	add    $0x10,%esp
    *((char*)0xC1000000) = 'a';
c0206af7:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206afc:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_release_one_page(0xC1000000);
c0206aff:	83 ec 0c             	sub    $0xc,%esp
c0206b02:	68 00 00 00 c1       	push   $0xc1000000
c0206b07:	e8 9e fb ff ff       	call   c02066aa <vmm_kern_release_one_page>
c0206b0c:	83 c4 10             	add    $0x10,%esp
    *((char*)0xC1000000) = 'a';
c0206b0f:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206b14:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_alloc_one_page(0xEE000000);
c0206b17:	83 ec 0c             	sub    $0xc,%esp
c0206b1a:	68 00 00 00 ee       	push   $0xee000000
c0206b1f:	e8 00 fa ff ff       	call   c0206524 <vmm_kern_alloc_one_page>
c0206b24:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0000000))));
c0206b27:	83 ec 0c             	sub    $0xc,%esp
c0206b2a:	68 00 00 00 c0       	push   $0xc0000000
c0206b2f:	e8 af f9 ff ff       	call   c02064e3 <get_pde>
c0206b34:	83 c4 10             	add    $0x10,%esp
c0206b37:	8b 00                	mov    (%eax),%eax
c0206b39:	83 ec 08             	sub    $0x8,%esp
c0206b3c:	50                   	push   %eax
c0206b3d:	8d 83 a6 06 00 00    	lea    0x6a6(%ebx),%eax
c0206b43:	50                   	push   %eax
c0206b44:	e8 1e 08 00 00       	call   c0207367 <printk>
c0206b49:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0400000))));
c0206b4c:	83 ec 0c             	sub    $0xc,%esp
c0206b4f:	68 00 00 40 c0       	push   $0xc0400000
c0206b54:	e8 8a f9 ff ff       	call   c02064e3 <get_pde>
c0206b59:	83 c4 10             	add    $0x10,%esp
c0206b5c:	8b 00                	mov    (%eax),%eax
c0206b5e:	83 ec 08             	sub    $0x8,%esp
c0206b61:	50                   	push   %eax
c0206b62:	8d 83 a6 06 00 00    	lea    0x6a6(%ebx),%eax
c0206b68:	50                   	push   %eax
c0206b69:	e8 f9 07 00 00       	call   c0207367 <printk>
c0206b6e:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0800000))));
c0206b71:	83 ec 0c             	sub    $0xc,%esp
c0206b74:	68 00 00 80 c0       	push   $0xc0800000
c0206b79:	e8 65 f9 ff ff       	call   c02064e3 <get_pde>
c0206b7e:	83 c4 10             	add    $0x10,%esp
c0206b81:	8b 00                	mov    (%eax),%eax
c0206b83:	83 ec 08             	sub    $0x8,%esp
c0206b86:	50                   	push   %eax
c0206b87:	8d 83 a6 06 00 00    	lea    0x6a6(%ebx),%eax
c0206b8d:	50                   	push   %eax
c0206b8e:	e8 d4 07 00 00       	call   c0207367 <printk>
c0206b93:	83 c4 10             	add    $0x10,%esp
c0206b96:	90                   	nop
c0206b97:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0206b9a:	5b                   	pop    %ebx
c0206b9b:	5e                   	pop    %esi
c0206b9c:	5d                   	pop    %ebp
c0206b9d:	c3                   	ret    

c0206b9e <kern_entry>:
void kputc(char);
void screen_uproll_once();
extern TCB_t * cur_tcb;
extern TCB_t main_TCB;
int entry_test_a;
void kern_entry(){
c0206b9e:	55                   	push   %ebp
c0206b9f:	89 e5                	mov    %esp,%ebp
c0206ba1:	53                   	push   %ebx
c0206ba2:	83 ec 14             	sub    $0x14,%esp
c0206ba5:	e8 5a 14 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206baa:	81 c3 56 24 00 00    	add    $0x2456,%ebx
	void func(void* args);
	vga_init();
c0206bb0:	e8 df 05 00 00       	call   c0207194 <vga_init>
	pmm_init();
c0206bb5:	e8 25 e9 ff ff       	call   c02054df <pmm_init>
	printk("kern_pdt_paddr:0x%h\n",kern_dir_table_paddr);
c0206bba:	c7 c0 14 80 20 c0    	mov    $0xc0208014,%eax
c0206bc0:	8b 00                	mov    (%eax),%eax
c0206bc2:	83 ec 08             	sub    $0x8,%esp
c0206bc5:	50                   	push   %eax
c0206bc6:	8d 83 ad 06 00 00    	lea    0x6ad(%ebx),%eax
c0206bcc:	50                   	push   %eax
c0206bcd:	e8 95 07 00 00       	call   c0207367 <printk>
c0206bd2:	83 c4 10             	add    $0x10,%esp
	tss_init();
c0206bd5:	e8 bc ea ff ff       	call   c0205696 <tss_init>
	printk("init\n");
c0206bda:	83 ec 0c             	sub    $0xc,%esp
c0206bdd:	8d 83 c2 06 00 00    	lea    0x6c2(%ebx),%eax
c0206be3:	50                   	push   %eax
c0206be4:	e8 7e 07 00 00       	call   c0207367 <printk>
c0206be9:	83 c4 10             	add    $0x10,%esp
  //while (1);
	idt_init();
c0206bec:	e8 ab ee ff ff       	call   c0205a9c <idt_init>
    //must close hardware interrupt because we have just user IRQ0(Number32/clock)
//asm volatile("sti");
	threads_init();
c0206bf1:	e8 58 cc ff ff       	call   c020384e <threads_init>
    //vga_basic_test();
	vmm_init();
c0206bf6:	e8 83 f8 ff ff       	call   c020647e <vmm_init>
    //vmm_test();
    //bitmap_test();
	//user_task_test();
	start_user_task_params_t u1;
	u1.fd = 0;
c0206bfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	u1.is_from_file = False;
c0206c02:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	u1.function = func;
c0206c09:	8d 83 40 dc ff ff    	lea    -0x23c0(%ebx),%eax
c0206c0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	u1.args = (void*)NULL;
c0206c12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	create_user_task(2,&u1);
c0206c19:	83 ec 08             	sub    $0x8,%esp
c0206c1c:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0206c1f:	50                   	push   %eax
c0206c20:	6a 02                	push   $0x2
c0206c22:	e8 aa d4 ff ff       	call   c02040d1 <create_user_task>
c0206c27:	83 c4 10             	add    $0x10,%esp
while (1){
	 	asm volatile("cli");
c0206c2a:	fa                   	cli    
		printk("123\n");
c0206c2b:	83 ec 0c             	sub    $0xc,%esp
c0206c2e:	8d 83 c8 06 00 00    	lea    0x6c8(%ebx),%eax
c0206c34:	50                   	push   %eax
c0206c35:	e8 2d 07 00 00       	call   c0207367 <printk>
c0206c3a:	83 c4 10             	add    $0x10,%esp
		asm volatile("sti");
c0206c3d:	fb                   	sti    
	 	asm volatile("cli");
c0206c3e:	eb ea                	jmp    c0206c2a <kern_entry+0x8c>

c0206c40 <func>:
	}
    while(True)
     	asm volatile ("hlt");
}

void func(void* args){
c0206c40:	55                   	push   %ebp
c0206c41:	89 e5                	mov    %esp,%ebp
c0206c43:	e8 b8 13 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206c48:	05 b8 23 00 00       	add    $0x23b8,%eax
	while(True){
		*((uint32_t*)0xF0000000)=0;
c0206c4d:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
c0206c52:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0206c58:	eb f3                	jmp    c0206c4d <func+0xd>

c0206c5a <_8259A_init>:
static uint16_t m_control_port = 0x20;     //主片控制端口号  main
static uint16_t m_data_port = 0x21;	       //从片数据端口号
static uint16_t o_control_port = 0xA0;     //从片控制端口号  other
static uint16_t o_data_port = 0xA1;        //从片数据端口号

void _8259A_init(){
c0206c5a:	55                   	push   %ebp
c0206c5b:	89 e5                	mov    %esp,%ebp
c0206c5d:	53                   	push   %ebx
c0206c5e:	83 ec 04             	sub    $0x4,%esp
c0206c61:	e8 9e 13 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206c66:	81 c3 9a 23 00 00    	add    $0x239a,%ebx
	//主片初始化
	outb(m_control_port,0x11);
c0206c6c:	0f b7 83 28 f0 ff ff 	movzwl -0xfd8(%ebx),%eax
c0206c73:	0f b7 c0             	movzwl %ax,%eax
c0206c76:	83 ec 08             	sub    $0x8,%esp
c0206c79:	6a 11                	push   $0x11
c0206c7b:	50                   	push   %eax
c0206c7c:	e8 9d 05 00 00       	call   c020721e <outb>
c0206c81:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x20);
c0206c84:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206c8b:	0f b7 c0             	movzwl %ax,%eax
c0206c8e:	83 ec 08             	sub    $0x8,%esp
c0206c91:	6a 20                	push   $0x20
c0206c93:	50                   	push   %eax
c0206c94:	e8 85 05 00 00       	call   c020721e <outb>
c0206c99:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x04);
c0206c9c:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206ca3:	0f b7 c0             	movzwl %ax,%eax
c0206ca6:	83 ec 08             	sub    $0x8,%esp
c0206ca9:	6a 04                	push   $0x4
c0206cab:	50                   	push   %eax
c0206cac:	e8 6d 05 00 00       	call   c020721e <outb>
c0206cb1:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x01);
c0206cb4:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206cbb:	0f b7 c0             	movzwl %ax,%eax
c0206cbe:	83 ec 08             	sub    $0x8,%esp
c0206cc1:	6a 01                	push   $0x1
c0206cc3:	50                   	push   %eax
c0206cc4:	e8 55 05 00 00       	call   c020721e <outb>
c0206cc9:	83 c4 10             	add    $0x10,%esp
	//从片初始化
	outb(o_control_port,0x11);
c0206ccc:	0f b7 83 2c f0 ff ff 	movzwl -0xfd4(%ebx),%eax
c0206cd3:	0f b7 c0             	movzwl %ax,%eax
c0206cd6:	83 ec 08             	sub    $0x8,%esp
c0206cd9:	6a 11                	push   $0x11
c0206cdb:	50                   	push   %eax
c0206cdc:	e8 3d 05 00 00       	call   c020721e <outb>
c0206ce1:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x28);
c0206ce4:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206ceb:	0f b7 c0             	movzwl %ax,%eax
c0206cee:	83 ec 08             	sub    $0x8,%esp
c0206cf1:	6a 28                	push   $0x28
c0206cf3:	50                   	push   %eax
c0206cf4:	e8 25 05 00 00       	call   c020721e <outb>
c0206cf9:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x02);
c0206cfc:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206d03:	0f b7 c0             	movzwl %ax,%eax
c0206d06:	83 ec 08             	sub    $0x8,%esp
c0206d09:	6a 02                	push   $0x2
c0206d0b:	50                   	push   %eax
c0206d0c:	e8 0d 05 00 00       	call   c020721e <outb>
c0206d11:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x01);
c0206d14:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206d1b:	0f b7 c0             	movzwl %ax,%eax
c0206d1e:	83 ec 08             	sub    $0x8,%esp
c0206d21:	6a 01                	push   $0x1
c0206d23:	50                   	push   %eax
c0206d24:	e8 f5 04 00 00       	call   c020721e <outb>
c0206d29:	83 c4 10             	add    $0x10,%esp
c0206d2c:	90                   	nop
c0206d2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206d30:	c9                   	leave  
c0206d31:	c3                   	ret    

c0206d32 <move_cursor>:
static uint8_t *video_memory = (uint8_t *)0xC00B8000;
//光标位置
static uint8_t cursor_x = 0;
static uint8_t cursor_y = 0;
static void move_cursor()
{
c0206d32:	55                   	push   %ebp
c0206d33:	89 e5                	mov    %esp,%ebp
c0206d35:	53                   	push   %ebx
c0206d36:	83 ec 14             	sub    $0x14,%esp
c0206d39:	e8 c6 12 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206d3e:	81 c3 c2 22 00 00    	add    $0x22c2,%ebx
// 屏幕是 80 字节宽
    uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c0206d44:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206d4b:	0f b6 d0             	movzbl %al,%edx
c0206d4e:	89 d0                	mov    %edx,%eax
c0206d50:	c1 e0 02             	shl    $0x2,%eax
c0206d53:	01 d0                	add    %edx,%eax
c0206d55:	c1 e0 04             	shl    $0x4,%eax
c0206d58:	89 c2                	mov    %eax,%edx
c0206d5a:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206d61:	0f b6 c0             	movzbl %al,%eax
c0206d64:	01 d0                	add    %edx,%eax
c0206d66:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    // 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置
    // 的高8位与低8位。
    outb(0x3D4, 14);                    // 告诉 VGA 我们要设置光标的高字节
c0206d6a:	83 ec 08             	sub    $0x8,%esp
c0206d6d:	6a 0e                	push   $0xe
c0206d6f:	68 d4 03 00 00       	push   $0x3d4
c0206d74:	e8 a5 04 00 00       	call   c020721e <outb>
c0206d79:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation >> 8);   // 发送高 8 位
c0206d7c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0206d80:	66 c1 e8 08          	shr    $0x8,%ax
c0206d84:	0f b6 c0             	movzbl %al,%eax
c0206d87:	83 ec 08             	sub    $0x8,%esp
c0206d8a:	50                   	push   %eax
c0206d8b:	68 d5 03 00 00       	push   $0x3d5
c0206d90:	e8 89 04 00 00       	call   c020721e <outb>
c0206d95:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4, 15);                    // 告诉 VGA 我们要设置光标的低字节
c0206d98:	83 ec 08             	sub    $0x8,%esp
c0206d9b:	6a 0f                	push   $0xf
c0206d9d:	68 d4 03 00 00       	push   $0x3d4
c0206da2:	e8 77 04 00 00       	call   c020721e <outb>
c0206da7:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation);        // 发送低 8 位
c0206daa:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0206dae:	0f b6 c0             	movzbl %al,%eax
c0206db1:	83 ec 08             	sub    $0x8,%esp
c0206db4:	50                   	push   %eax
c0206db5:	68 d5 03 00 00       	push   $0x3d5
c0206dba:	e8 5f 04 00 00       	call   c020721e <outb>
c0206dbf:	83 c4 10             	add    $0x10,%esp
}
c0206dc2:	90                   	nop
c0206dc3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206dc6:	c9                   	leave  
c0206dc7:	c3                   	ret    

c0206dc8 <move_cursor_by_XY>:

void move_cursor_by_XY(uint8_t x,uint8_t y){
c0206dc8:	55                   	push   %ebp
c0206dc9:	89 e5                	mov    %esp,%ebp
c0206dcb:	83 ec 18             	sub    $0x18,%esp
c0206dce:	e8 2d 12 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206dd3:	05 2d 22 00 00       	add    $0x222d,%eax
c0206dd8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0206ddb:	8b 55 0c             	mov    0xc(%ebp),%edx
c0206dde:	88 4d f4             	mov    %cl,-0xc(%ebp)
c0206de1:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if(x>79||y>24)
c0206de4:	80 7d f4 4f          	cmpb   $0x4f,-0xc(%ebp)
c0206de8:	77 21                	ja     c0206e0b <move_cursor_by_XY+0x43>
c0206dea:	80 7d f0 18          	cmpb   $0x18,-0x10(%ebp)
c0206dee:	77 1b                	ja     c0206e0b <move_cursor_by_XY+0x43>
		return ;
	cursor_x=x;
c0206df0:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0206df4:	88 90 a0 90 08 00    	mov    %dl,0x890a0(%eax)
	cursor_y=y;
c0206dfa:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c0206dfe:	88 90 a1 90 08 00    	mov    %dl,0x890a1(%eax)
	move_cursor();
c0206e04:	e8 29 ff ff ff       	call   c0206d32 <move_cursor>
c0206e09:	eb 01                	jmp    c0206e0c <move_cursor_by_XY+0x44>
		return ;
c0206e0b:	90                   	nop
}
c0206e0c:	c9                   	leave  
c0206e0d:	c3                   	ret    

c0206e0e <clear_screen>:

void clear_screen(){
c0206e0e:	55                   	push   %ebp
c0206e0f:	89 e5                	mov    %esp,%ebp
c0206e11:	53                   	push   %ebx
c0206e12:	83 ec 14             	sub    $0x14,%esp
c0206e15:	e8 ea 11 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206e1a:	81 c3 e6 21 00 00    	add    $0x21e6,%ebx
	cursor_x=0;
c0206e20:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
	cursor_y=0;
c0206e27:	c6 83 a1 90 08 00 00 	movb   $0x0,0x890a1(%ebx)
	for(int j=0;j<25;j++){
c0206e2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0206e35:	eb 28                	jmp    c0206e5f <clear_screen+0x51>
		for(int i=0;i<80;i++)
c0206e37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0206e3e:	eb 15                	jmp    c0206e55 <clear_screen+0x47>
			vga_putc('\0',black,white);
c0206e40:	83 ec 04             	sub    $0x4,%esp
c0206e43:	6a 0f                	push   $0xf
c0206e45:	6a 00                	push   $0x0
c0206e47:	6a 00                	push   $0x0
c0206e49:	e8 18 01 00 00       	call   c0206f66 <vga_putc>
c0206e4e:	83 c4 10             	add    $0x10,%esp
		for(int i=0;i<80;i++)
c0206e51:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0206e55:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c0206e59:	7e e5                	jle    c0206e40 <clear_screen+0x32>
	for(int j=0;j<25;j++){
c0206e5b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206e5f:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0206e63:	7e d2                	jle    c0206e37 <clear_screen+0x29>
	}
	cursor_x=0;
c0206e65:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
	cursor_y=0;
c0206e6c:	c6 83 a1 90 08 00 00 	movb   $0x0,0x890a1(%ebx)
	move_cursor();
c0206e73:	e8 ba fe ff ff       	call   c0206d32 <move_cursor>
}
c0206e78:	90                   	nop
c0206e79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206e7c:	c9                   	leave  
c0206e7d:	c3                   	ret    

c0206e7e <screen_uproll_once>:

void screen_uproll_once(){     //光标是会变化的
c0206e7e:	55                   	push   %ebp
c0206e7f:	89 e5                	mov    %esp,%ebp
c0206e81:	53                   	push   %ebx
c0206e82:	83 ec 24             	sub    $0x24,%esp
c0206e85:	e8 76 11 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0206e8a:	05 76 21 00 00       	add    $0x2176,%eax
	for(int j=1;j<25;j++){
c0206e8f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0206e96:	eb 70                	jmp    c0206f08 <screen_uproll_once+0x8a>
		for(int i=0;i<80;i++){
c0206e98:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0206e9f:	eb 5d                	jmp    c0206efe <screen_uproll_once+0x80>
			uint16_t cursorLocation = j * 80 + i;
c0206ea1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206ea4:	89 d1                	mov    %edx,%ecx
c0206ea6:	89 ca                	mov    %ecx,%edx
c0206ea8:	c1 e2 02             	shl    $0x2,%edx
c0206eab:	01 ca                	add    %ecx,%edx
c0206ead:	c1 e2 04             	shl    $0x4,%edx
c0206eb0:	89 d1                	mov    %edx,%ecx
c0206eb2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206eb5:	01 ca                	add    %ecx,%edx
c0206eb7:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
			uint16_t targetCursorLocation = (j-1) * 80 + i;
c0206ebb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206ebe:	83 ea 01             	sub    $0x1,%edx
c0206ec1:	89 d1                	mov    %edx,%ecx
c0206ec3:	89 ca                	mov    %ecx,%edx
c0206ec5:	c1 e2 02             	shl    $0x2,%edx
c0206ec8:	01 ca                	add    %ecx,%edx
c0206eca:	c1 e2 04             	shl    $0x4,%edx
c0206ecd:	89 d1                	mov    %edx,%ecx
c0206ecf:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206ed2:	01 ca                	add    %ecx,%edx
c0206ed4:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
			*((uint16_t *)video_memory+targetCursorLocation)=*((uint16_t *)video_memory+cursorLocation);										
c0206ed8:	8b 90 34 f0 ff ff    	mov    -0xfcc(%eax),%edx
c0206ede:	0f b7 4d e6          	movzwl -0x1a(%ebp),%ecx
c0206ee2:	01 c9                	add    %ecx,%ecx
c0206ee4:	01 ca                	add    %ecx,%edx
c0206ee6:	8b 88 34 f0 ff ff    	mov    -0xfcc(%eax),%ecx
c0206eec:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
c0206ef0:	01 db                	add    %ebx,%ebx
c0206ef2:	01 d9                	add    %ebx,%ecx
c0206ef4:	0f b7 12             	movzwl (%edx),%edx
c0206ef7:	66 89 11             	mov    %dx,(%ecx)
		for(int i=0;i<80;i++){
c0206efa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0206efe:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c0206f02:	7e 9d                	jle    c0206ea1 <screen_uproll_once+0x23>
	for(int j=1;j<25;j++){
c0206f04:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206f08:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0206f0c:	7e 8a                	jle    c0206e98 <screen_uproll_once+0x1a>
		}
	}
	for(int i=0;i<80;i++){
c0206f0e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0206f15:	eb 22                	jmp    c0206f39 <screen_uproll_once+0xbb>
        int location = 24*80+i;
c0206f17:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0206f1a:	81 c2 80 07 00 00    	add    $0x780,%edx
c0206f20:	89 55 e8             	mov    %edx,-0x18(%ebp)
        *((uint16_t *)video_memory+location)=(0x0F<<8)|'\0';
c0206f23:	8b 90 34 f0 ff ff    	mov    -0xfcc(%eax),%edx
c0206f29:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0206f2c:	01 c9                	add    %ecx,%ecx
c0206f2e:	01 ca                	add    %ecx,%edx
c0206f30:	66 c7 02 00 0f       	movw   $0xf00,(%edx)
	for(int i=0;i<80;i++){
c0206f35:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0206f39:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
c0206f3d:	7e d8                	jle    c0206f17 <screen_uproll_once+0x99>
	}
	if(cursor_y!=0){
c0206f3f:	0f b6 90 a1 90 08 00 	movzbl 0x890a1(%eax),%edx
c0206f46:	84 d2                	test   %dl,%dl
c0206f48:	74 15                	je     c0206f5f <screen_uproll_once+0xe1>
		cursor_y--;
c0206f4a:	0f b6 90 a1 90 08 00 	movzbl 0x890a1(%eax),%edx
c0206f51:	83 ea 01             	sub    $0x1,%edx
c0206f54:	88 90 a1 90 08 00    	mov    %dl,0x890a1(%eax)
		move_cursor();
c0206f5a:	e8 d3 fd ff ff       	call   c0206d32 <move_cursor>
	}
}
c0206f5f:	90                   	nop
c0206f60:	83 c4 24             	add    $0x24,%esp
c0206f63:	5b                   	pop    %ebx
c0206f64:	5d                   	pop    %ebp
c0206f65:	c3                   	ret    

c0206f66 <vga_putc>:
void vga_putc(char input,vga_color_t back,vga_color_t fore){
c0206f66:	55                   	push   %ebp
c0206f67:	89 e5                	mov    %esp,%ebp
c0206f69:	53                   	push   %ebx
c0206f6a:	83 ec 24             	sub    $0x24,%esp
c0206f6d:	e8 92 10 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0206f72:	81 c3 8e 20 00 00    	add    $0x208e,%ebx
c0206f78:	8b 45 08             	mov    0x8(%ebp),%eax
c0206f7b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c0206f7e:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206f85:	0f b6 d0             	movzbl %al,%edx
c0206f88:	89 d0                	mov    %edx,%eax
c0206f8a:	c1 e0 02             	shl    $0x2,%eax
c0206f8d:	01 d0                	add    %edx,%eax
c0206f8f:	c1 e0 04             	shl    $0x4,%eax
c0206f92:	89 c2                	mov    %eax,%edx
c0206f94:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206f9b:	0f b6 c0             	movzbl %al,%eax
c0206f9e:	01 d0                	add    %edx,%eax
c0206fa0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	*((char *)video_memory+2*cursorLocation)=input;
c0206fa4:	8b 83 34 f0 ff ff    	mov    -0xfcc(%ebx),%eax
c0206faa:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0206fae:	01 d2                	add    %edx,%edx
c0206fb0:	01 c2                	add    %eax,%edx
c0206fb2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0206fb6:	88 02                	mov    %al,(%edx)
	*((char *)video_memory+2*cursorLocation+1)=(back<<4)|(fore&0x0F);
c0206fb8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0206fbb:	c1 e0 04             	shl    $0x4,%eax
c0206fbe:	89 c2                	mov    %eax,%edx
c0206fc0:	8b 45 10             	mov    0x10(%ebp),%eax
c0206fc3:	83 e0 0f             	and    $0xf,%eax
c0206fc6:	89 d1                	mov    %edx,%ecx
c0206fc8:	09 c1                	or     %eax,%ecx
c0206fca:	8b 83 34 f0 ff ff    	mov    -0xfcc(%ebx),%eax
c0206fd0:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0206fd4:	01 d2                	add    %edx,%edx
c0206fd6:	83 c2 01             	add    $0x1,%edx
c0206fd9:	01 d0                	add    %edx,%eax
c0206fdb:	89 ca                	mov    %ecx,%edx
c0206fdd:	88 10                	mov    %dl,(%eax)
	if(cursor_x==79){
c0206fdf:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c0206fe6:	3c 4f                	cmp    $0x4f,%al
c0206fe8:	75 39                	jne    c0207023 <vga_putc+0xbd>
		if(cursor_y==24){
c0206fea:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0206ff1:	3c 18                	cmp    $0x18,%al
c0206ff3:	75 15                	jne    c020700a <vga_putc+0xa4>
			screen_uproll_once();
c0206ff5:	e8 84 fe ff ff       	call   c0206e7e <screen_uproll_once>
			cursor_x=0;
c0206ffa:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
			cursor_y=24;
c0207001:	c6 83 a1 90 08 00 18 	movb   $0x18,0x890a1(%ebx)
c0207008:	eb 29                	jmp    c0207033 <vga_putc+0xcd>
		}
		else{
			cursor_x=0;
c020700a:	c6 83 a0 90 08 00 00 	movb   $0x0,0x890a0(%ebx)
			cursor_y++;
c0207011:	0f b6 83 a1 90 08 00 	movzbl 0x890a1(%ebx),%eax
c0207018:	83 c0 01             	add    $0x1,%eax
c020701b:	88 83 a1 90 08 00    	mov    %al,0x890a1(%ebx)
c0207021:	eb 10                	jmp    c0207033 <vga_putc+0xcd>
		}
	}
	else{
		cursor_x++;
c0207023:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c020702a:	83 c0 01             	add    $0x1,%eax
c020702d:	88 83 a0 90 08 00    	mov    %al,0x890a0(%ebx)
	}
	move_cursor();
c0207033:	e8 fa fc ff ff       	call   c0206d32 <move_cursor>
}
c0207038:	90                   	nop
c0207039:	83 c4 24             	add    $0x24,%esp
c020703c:	5b                   	pop    %ebx
c020703d:	5d                   	pop    %ebp
c020703e:	c3                   	ret    

c020703f <kputc_color>:


void kputc_color(char input,vga_color_t back,vga_color_t fore){
c020703f:	55                   	push   %ebp
c0207040:	89 e5                	mov    %esp,%ebp
c0207042:	53                   	push   %ebx
c0207043:	83 ec 24             	sub    $0x24,%esp
c0207046:	e8 b9 0f 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c020704b:	81 c3 b5 1f 00 00    	add    $0x1fb5,%ebx
c0207051:	8b 45 08             	mov    0x8(%ebp),%eax
c0207054:	88 45 e4             	mov    %al,-0x1c(%ebp)
	switch (input)
c0207057:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c020705b:	83 f8 09             	cmp    $0x9,%eax
c020705e:	74 07                	je     c0207067 <kputc_color+0x28>
c0207060:	83 f8 0a             	cmp    $0xa,%eax
c0207063:	74 33                	je     c0207098 <kputc_color+0x59>
c0207065:	eb 79                	jmp    c02070e0 <kputc_color+0xa1>
	{
		case '\t':{
			for(int i=0;i<tab_length;i++)
c0207067:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020706e:	eb 17                	jmp    c0207087 <kputc_color+0x48>
				vga_putc('\0',back,fore);
c0207070:	83 ec 04             	sub    $0x4,%esp
c0207073:	ff 75 10             	pushl  0x10(%ebp)
c0207076:	ff 75 0c             	pushl  0xc(%ebp)
c0207079:	6a 00                	push   $0x0
c020707b:	e8 e6 fe ff ff       	call   c0206f66 <vga_putc>
c0207080:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<tab_length;i++)
c0207083:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0207087:	0f b6 83 30 f0 ff ff 	movzbl -0xfd0(%ebx),%eax
c020708e:	0f b6 c0             	movzbl %al,%eax
c0207091:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0207094:	7c da                	jl     c0207070 <kputc_color+0x31>
			break;
c0207096:	eb 5e                	jmp    c02070f6 <kputc_color+0xb7>
		}
		case '\n':{
			uint8_t temp_num = 80-cursor_x;
c0207098:	0f b6 83 a0 90 08 00 	movzbl 0x890a0(%ebx),%eax
c020709f:	ba 50 00 00 00       	mov    $0x50,%edx
c02070a4:	29 c2                	sub    %eax,%edx
c02070a6:	89 d0                	mov    %edx,%eax
c02070a8:	88 45 f3             	mov    %al,-0xd(%ebp)
			if(temp_num==0)
c02070ab:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c02070af:	75 04                	jne    c02070b5 <kputc_color+0x76>
				temp_num=80;
c02070b1:	c6 45 f3 50          	movb   $0x50,-0xd(%ebp)
			for(int i=0;i<temp_num;i++)
c02070b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c02070bc:	eb 17                	jmp    c02070d5 <kputc_color+0x96>
			vga_putc('\0',back,fore);
c02070be:	83 ec 04             	sub    $0x4,%esp
c02070c1:	ff 75 10             	pushl  0x10(%ebp)
c02070c4:	ff 75 0c             	pushl  0xc(%ebp)
c02070c7:	6a 00                	push   $0x0
c02070c9:	e8 98 fe ff ff       	call   c0206f66 <vga_putc>
c02070ce:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<temp_num;i++)
c02070d1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c02070d5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c02070d9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c02070dc:	7c e0                	jl     c02070be <kputc_color+0x7f>
			break;
c02070de:	eb 16                	jmp    c02070f6 <kputc_color+0xb7>
		}
		default:
			vga_putc(input,back,fore);	
c02070e0:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c02070e4:	83 ec 04             	sub    $0x4,%esp
c02070e7:	ff 75 10             	pushl  0x10(%ebp)
c02070ea:	ff 75 0c             	pushl  0xc(%ebp)
c02070ed:	50                   	push   %eax
c02070ee:	e8 73 fe ff ff       	call   c0206f66 <vga_putc>
c02070f3:	83 c4 10             	add    $0x10,%esp
	}
}
c02070f6:	90                   	nop
c02070f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02070fa:	c9                   	leave  
c02070fb:	c3                   	ret    

c02070fc <kputc>:

void kputc(char input){
c02070fc:	55                   	push   %ebp
c02070fd:	89 e5                	mov    %esp,%ebp
c02070ff:	83 ec 18             	sub    $0x18,%esp
c0207102:	e8 f9 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207107:	05 f9 1e 00 00       	add    $0x1ef9,%eax
c020710c:	8b 45 08             	mov    0x8(%ebp),%eax
c020710f:	88 45 f4             	mov    %al,-0xc(%ebp)
	kputc_color(input,black,white);
c0207112:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0207116:	83 ec 04             	sub    $0x4,%esp
c0207119:	6a 0f                	push   $0xf
c020711b:	6a 00                	push   $0x0
c020711d:	50                   	push   %eax
c020711e:	e8 1c ff ff ff       	call   c020703f <kputc_color>
c0207123:	83 c4 10             	add    $0x10,%esp
}
c0207126:	90                   	nop
c0207127:	c9                   	leave  
c0207128:	c3                   	ret    

c0207129 <kputs_color>:

void kputs_color(char * input_str,vga_color_t back,vga_color_t fore){
c0207129:	55                   	push   %ebp
c020712a:	89 e5                	mov    %esp,%ebp
c020712c:	83 ec 18             	sub    $0x18,%esp
c020712f:	e8 cc 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207134:	05 cc 1e 00 00       	add    $0x1ecc,%eax
	char * probe=input_str;
c0207139:	8b 45 08             	mov    0x8(%ebp),%eax
c020713c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(*probe!='\0')
c020713f:	eb 21                	jmp    c0207162 <kputs_color+0x39>
		kputc_color(*probe++,back,fore);
c0207141:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207144:	8d 50 01             	lea    0x1(%eax),%edx
c0207147:	89 55 f4             	mov    %edx,-0xc(%ebp)
c020714a:	0f b6 00             	movzbl (%eax),%eax
c020714d:	0f be c0             	movsbl %al,%eax
c0207150:	83 ec 04             	sub    $0x4,%esp
c0207153:	ff 75 10             	pushl  0x10(%ebp)
c0207156:	ff 75 0c             	pushl  0xc(%ebp)
c0207159:	50                   	push   %eax
c020715a:	e8 e0 fe ff ff       	call   c020703f <kputc_color>
c020715f:	83 c4 10             	add    $0x10,%esp
	while(*probe!='\0')
c0207162:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207165:	0f b6 00             	movzbl (%eax),%eax
c0207168:	84 c0                	test   %al,%al
c020716a:	75 d5                	jne    c0207141 <kputs_color+0x18>
}
c020716c:	90                   	nop
c020716d:	c9                   	leave  
c020716e:	c3                   	ret    

c020716f <kputs>:

void kputs(char *input_str){
c020716f:	55                   	push   %ebp
c0207170:	89 e5                	mov    %esp,%ebp
c0207172:	83 ec 08             	sub    $0x8,%esp
c0207175:	e8 86 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020717a:	05 86 1e 00 00       	add    $0x1e86,%eax
	kputs_color(input_str,black,white);
c020717f:	83 ec 04             	sub    $0x4,%esp
c0207182:	6a 0f                	push   $0xf
c0207184:	6a 00                	push   $0x0
c0207186:	ff 75 08             	pushl  0x8(%ebp)
c0207189:	e8 9b ff ff ff       	call   c0207129 <kputs_color>
c020718e:	83 c4 10             	add    $0x10,%esp
}
c0207191:	90                   	nop
c0207192:	c9                   	leave  
c0207193:	c3                   	ret    

c0207194 <vga_init>:

void vga_init(){
c0207194:	55                   	push   %ebp
c0207195:	89 e5                	mov    %esp,%ebp
c0207197:	83 ec 08             	sub    $0x8,%esp
c020719a:	e8 61 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020719f:	05 61 1e 00 00       	add    $0x1e61,%eax
	clear_screen();
c02071a4:	e8 65 fc ff ff       	call   c0206e0e <clear_screen>
}
c02071a9:	90                   	nop
c02071aa:	c9                   	leave  
c02071ab:	c3                   	ret    

c02071ac <vga_test_clear_last_row>:

void vga_test_clear_last_row(){
c02071ac:	55                   	push   %ebp
c02071ad:	89 e5                	mov    %esp,%ebp
c02071af:	e8 4c 0e 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02071b4:	05 4c 1e 00 00       	add    $0x1e4c,%eax

}
c02071b9:	90                   	nop
c02071ba:	5d                   	pop    %ebp
c02071bb:	c3                   	ret    

c02071bc <vga_basic_test>:

void vga_basic_test(){
c02071bc:	55                   	push   %ebp
c02071bd:	89 e5                	mov    %esp,%ebp
c02071bf:	53                   	push   %ebx
c02071c0:	83 ec 14             	sub    $0x14,%esp
c02071c3:	e8 3c 0e 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02071c8:	81 c3 38 1e 00 00    	add    $0x1e38,%ebx
    for(int i = 0;i<10;i++){
c02071ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02071d5:	eb 16                	jmp    c02071ed <vga_basic_test+0x31>
        kputs("A\n");
c02071d7:	83 ec 0c             	sub    $0xc,%esp
c02071da:	8d 83 cd 06 00 00    	lea    0x6cd(%ebx),%eax
c02071e0:	50                   	push   %eax
c02071e1:	e8 89 ff ff ff       	call   c020716f <kputs>
c02071e6:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<10;i++){
c02071e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02071ed:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c02071f1:	7e e4                	jle    c02071d7 <vga_basic_test+0x1b>
    }
    kputs("MBCDEFG\n");
c02071f3:	83 ec 0c             	sub    $0xc,%esp
c02071f6:	8d 83 d0 06 00 00    	lea    0x6d0(%ebx),%eax
c02071fc:	50                   	push   %eax
c02071fd:	e8 6d ff ff ff       	call   c020716f <kputs>
c0207202:	83 c4 10             	add    $0x10,%esp
    kputs("QWERTYU\n");
c0207205:	83 ec 0c             	sub    $0xc,%esp
c0207208:	8d 83 d9 06 00 00    	lea    0x6d9(%ebx),%eax
c020720e:	50                   	push   %eax
c020720f:	e8 5b ff ff ff       	call   c020716f <kputs>
c0207214:	83 c4 10             	add    $0x10,%esp
    screen_uproll_once();
c0207217:	e8 62 fc ff ff       	call   c0206e7e <screen_uproll_once>
    while(1);
c020721c:	eb fe                	jmp    c020721c <vga_basic_test+0x60>

c020721e <outb>:
#include "port.h"
// 端口写一个字节
inline void outb(uint16_t port, uint8_t value)
{
c020721e:	55                   	push   %ebp
c020721f:	89 e5                	mov    %esp,%ebp
c0207221:	83 ec 08             	sub    $0x8,%esp
c0207224:	e8 d7 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207229:	05 d7 1d 00 00       	add    $0x1dd7,%eax
c020722e:	8b 55 08             	mov    0x8(%ebp),%edx
c0207231:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207234:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0207238:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
c020723b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c020723f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0207243:	ee                   	out    %al,(%dx)
}
c0207244:	90                   	nop
c0207245:	c9                   	leave  
c0207246:	c3                   	ret    

c0207247 <inb>:

// 端口读一个字节
inline uint8_t inb(uint16_t port)
{
c0207247:	55                   	push   %ebp
c0207248:	89 e5                	mov    %esp,%ebp
c020724a:	83 ec 14             	sub    $0x14,%esp
c020724d:	e8 ae 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207252:	05 ae 1d 00 00       	add    $0x1dae,%eax
c0207257:	8b 45 08             	mov    0x8(%ebp),%eax
c020725a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint8_t ret;

    asm volatile("inb %1, %0" : "=a" (ret) : "dN" (port));
c020725e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0207262:	89 c2                	mov    %eax,%edx
c0207264:	ec                   	in     (%dx),%al
c0207265:	88 45 ff             	mov    %al,-0x1(%ebp)

    return ret;
c0207268:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c020726c:	c9                   	leave  
c020726d:	c3                   	ret    

c020726e <inw>:

// 端口读一个字
inline uint16_t inw(uint16_t port)
{
c020726e:	55                   	push   %ebp
c020726f:	89 e5                	mov    %esp,%ebp
c0207271:	83 ec 14             	sub    $0x14,%esp
c0207274:	e8 87 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207279:	05 87 1d 00 00       	add    $0x1d87,%eax
c020727e:	8b 45 08             	mov    0x8(%ebp),%eax
c0207281:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint16_t ret;

    asm volatile ("inw %1, %0" : "=a" (ret) : "dN" (port));
c0207285:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0207289:	89 c2                	mov    %eax,%edx
c020728b:	66 ed                	in     (%dx),%ax
c020728d:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    return ret;
c0207291:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0207295:	c9                   	leave  
c0207296:	c3                   	ret    

c0207297 <print_debug_1>:
#include "printk.h"
#include "types.h"

void print_debug_1(uint32_t val){
c0207297:	55                   	push   %ebp
c0207298:	89 e5                	mov    %esp,%ebp
c020729a:	53                   	push   %ebx
c020729b:	83 ec 04             	sub    $0x4,%esp
c020729e:	e8 5d 0d 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c02072a3:	05 5d 1d 00 00       	add    $0x1d5d,%eax
    printk("debug1:0x%h\n",val);
c02072a8:	83 ec 08             	sub    $0x8,%esp
c02072ab:	ff 75 08             	pushl  0x8(%ebp)
c02072ae:	8d 90 e2 06 00 00    	lea    0x6e2(%eax),%edx
c02072b4:	52                   	push   %edx
c02072b5:	89 c3                	mov    %eax,%ebx
c02072b7:	e8 ab 00 00 00       	call   c0207367 <printk>
c02072bc:	83 c4 10             	add    $0x10,%esp
}
c02072bf:	90                   	nop
c02072c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02072c3:	c9                   	leave  
c02072c4:	c3                   	ret    

c02072c5 <insert_str>:
#include "vga_basic.h"
#include "vargs.h"


void insert_str(char *inserted_str,char *inserting_str,uint32_t offset)  //插入辅助函数
{
c02072c5:	55                   	push   %ebp
c02072c6:	89 e5                	mov    %esp,%ebp
c02072c8:	57                   	push   %edi
c02072c9:	53                   	push   %ebx
c02072ca:	83 ec 70             	sub    $0x70,%esp
c02072cd:	e8 32 0d 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02072d2:	81 c3 2e 1d 00 00    	add    $0x1d2e,%ebx
	char m[100]={0};
c02072d8:	8d 55 90             	lea    -0x70(%ebp),%edx
c02072db:	b8 00 00 00 00       	mov    $0x0,%eax
c02072e0:	b9 19 00 00 00       	mov    $0x19,%ecx
c02072e5:	89 d7                	mov    %edx,%edi
c02072e7:	f3 ab                	rep stos %eax,%es:(%edi)
	char *afterInsetedPositionStr=m;
c02072e9:	8d 45 90             	lea    -0x70(%ebp),%eax
c02072ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
	strcpy(afterInsetedPositionStr,inserted_str+offset+2);
c02072ef:	8b 45 10             	mov    0x10(%ebp),%eax
c02072f2:	8d 50 02             	lea    0x2(%eax),%edx
c02072f5:	8b 45 08             	mov    0x8(%ebp),%eax
c02072f8:	01 d0                	add    %edx,%eax
c02072fa:	83 ec 08             	sub    $0x8,%esp
c02072fd:	50                   	push   %eax
c02072fe:	ff 75 f4             	pushl  -0xc(%ebp)
c0207301:	e8 11 08 00 00       	call   c0207b17 <strcpy>
c0207306:	83 c4 10             	add    $0x10,%esp
	memcpy(inserted_str+offset,inserting_str,strlen(inserting_str));
c0207309:	83 ec 0c             	sub    $0xc,%esp
c020730c:	ff 75 0c             	pushl  0xc(%ebp)
c020730f:	e8 d2 07 00 00       	call   c0207ae6 <strlen>
c0207314:	83 c4 10             	add    $0x10,%esp
c0207317:	89 c1                	mov    %eax,%ecx
c0207319:	8b 55 08             	mov    0x8(%ebp),%edx
c020731c:	8b 45 10             	mov    0x10(%ebp),%eax
c020731f:	01 d0                	add    %edx,%eax
c0207321:	83 ec 04             	sub    $0x4,%esp
c0207324:	51                   	push   %ecx
c0207325:	ff 75 0c             	pushl  0xc(%ebp)
c0207328:	50                   	push   %eax
c0207329:	e8 cd 06 00 00       	call   c02079fb <memcpy>
c020732e:	83 c4 10             	add    $0x10,%esp
	*(inserted_str+offset+strlen(inserting_str))='\0';
c0207331:	83 ec 0c             	sub    $0xc,%esp
c0207334:	ff 75 0c             	pushl  0xc(%ebp)
c0207337:	e8 aa 07 00 00       	call   c0207ae6 <strlen>
c020733c:	83 c4 10             	add    $0x10,%esp
c020733f:	89 c2                	mov    %eax,%edx
c0207341:	8b 45 10             	mov    0x10(%ebp),%eax
c0207344:	01 c2                	add    %eax,%edx
c0207346:	8b 45 08             	mov    0x8(%ebp),%eax
c0207349:	01 d0                	add    %edx,%eax
c020734b:	c6 00 00             	movb   $0x0,(%eax)
	strcat(inserted_str,afterInsetedPositionStr);
c020734e:	83 ec 08             	sub    $0x8,%esp
c0207351:	ff 75 f4             	pushl  -0xc(%ebp)
c0207354:	ff 75 08             	pushl  0x8(%ebp)
c0207357:	e8 01 08 00 00       	call   c0207b5d <strcat>
c020735c:	83 c4 10             	add    $0x10,%esp
	//memcpy(*(inserted_str+offset+1+strlen(inserting_str)),afterInsetedPositionStr,strlen(afterInsetedPositionStr));
	return inserted_str;
c020735f:	90                   	nop
}
c0207360:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0207363:	5b                   	pop    %ebx
c0207364:	5f                   	pop    %edi
c0207365:	5d                   	pop    %ebp
c0207366:	c3                   	ret    

c0207367 <printk>:

void printk(char *input_str,...)
{	
c0207367:	55                   	push   %ebp
c0207368:	89 e5                	mov    %esp,%ebp
c020736a:	53                   	push   %ebx
c020736b:	83 ec 34             	sub    $0x34,%esp
c020736e:	e8 91 0c 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c0207373:	81 c3 8d 1c 00 00    	add    $0x1c8d,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0207379:	8d 83 c0 90 08 00    	lea    0x890c0(%ebx),%eax
c020737f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0207382:	83 ec 08             	sub    $0x8,%esp
c0207385:	ff 75 08             	pushl  0x8(%ebp)
c0207388:	ff 75 f0             	pushl  -0x10(%ebp)
c020738b:	e8 87 07 00 00       	call   c0207b17 <strcpy>
c0207390:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0207393:	8d 45 0c             	lea    0xc(%ebp),%eax
c0207396:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0207399:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c02073a0:	e9 9e 01 00 00       	jmp    c0207543 <printk+0x1dc>
	{
		char *charptr=output_str+offset;
c02073a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02073a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02073ab:	01 d0                	add    %edx,%eax
c02073ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c02073b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02073b3:	0f b6 00             	movzbl (%eax),%eax
c02073b6:	3c 25                	cmp    $0x25,%al
c02073b8:	0f 85 81 01 00 00    	jne    c020753f <printk+0x1d8>
		{
			if (*(charptr+1)=='s')
c02073be:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02073c1:	83 c0 01             	add    $0x1,%eax
c02073c4:	0f b6 00             	movzbl (%eax),%eax
c02073c7:	3c 73                	cmp    $0x73,%al
c02073c9:	75 43                	jne    c020740e <printk+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c02073cb:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02073ce:	8d 50 04             	lea    0x4(%eax),%edx
c02073d1:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02073d4:	8b 00                	mov    (%eax),%eax
c02073d6:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c02073d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02073dc:	83 ec 04             	sub    $0x4,%esp
c02073df:	50                   	push   %eax
c02073e0:	ff 75 d0             	pushl  -0x30(%ebp)
c02073e3:	ff 75 f0             	pushl  -0x10(%ebp)
c02073e6:	e8 da fe ff ff       	call   c02072c5 <insert_str>
c02073eb:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c02073ee:	83 ec 0c             	sub    $0xc,%esp
c02073f1:	ff 75 d0             	pushl  -0x30(%ebp)
c02073f4:	e8 ed 06 00 00       	call   c0207ae6 <strlen>
c02073f9:	83 c4 10             	add    $0x10,%esp
c02073fc:	89 c2                	mov    %eax,%edx
c02073fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207401:	01 d0                	add    %edx,%eax
c0207403:	83 e8 01             	sub    $0x1,%eax
c0207406:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0207409:	e9 31 01 00 00       	jmp    c020753f <printk+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c020740e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207411:	83 c0 01             	add    $0x1,%eax
c0207414:	0f b6 00             	movzbl (%eax),%eax
c0207417:	3c 64                	cmp    $0x64,%al
c0207419:	75 55                	jne    c0207470 <printk+0x109>
			{
				int arg_int=va_arg(ptr,int);
c020741b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020741e:	8d 50 04             	lea    0x4(%eax),%edx
c0207421:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207424:	8b 00                	mov    (%eax),%eax
c0207426:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0207429:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020742c:	83 ec 0c             	sub    $0xc,%esp
c020742f:	50                   	push   %eax
c0207430:	e8 61 07 00 00       	call   c0207b96 <uintTostring>
c0207435:	83 c4 10             	add    $0x10,%esp
c0207438:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c020743b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020743e:	83 ec 04             	sub    $0x4,%esp
c0207441:	50                   	push   %eax
c0207442:	ff 75 d4             	pushl  -0x2c(%ebp)
c0207445:	ff 75 f0             	pushl  -0x10(%ebp)
c0207448:	e8 78 fe ff ff       	call   c02072c5 <insert_str>
c020744d:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c0207450:	83 ec 0c             	sub    $0xc,%esp
c0207453:	ff 75 d4             	pushl  -0x2c(%ebp)
c0207456:	e8 8b 06 00 00       	call   c0207ae6 <strlen>
c020745b:	83 c4 10             	add    $0x10,%esp
c020745e:	89 c2                	mov    %eax,%edx
c0207460:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207463:	01 d0                	add    %edx,%eax
c0207465:	83 e8 01             	sub    $0x1,%eax
c0207468:	89 45 f4             	mov    %eax,-0xc(%ebp)
c020746b:	e9 cf 00 00 00       	jmp    c020753f <printk+0x1d8>
			}
			else if(*(charptr+1)=='c')
c0207470:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207473:	83 c0 01             	add    $0x1,%eax
c0207476:	0f b6 00             	movzbl (%eax),%eax
c0207479:	3c 63                	cmp    $0x63,%al
c020747b:	0f 84 be 00 00 00    	je     c020753f <printk+0x1d8>
			{
				;
			}
			else if(*(charptr+1)=='H')
c0207481:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207484:	83 c0 01             	add    $0x1,%eax
c0207487:	0f b6 00             	movzbl (%eax),%eax
c020748a:	3c 48                	cmp    $0x48,%al
c020748c:	75 53                	jne    c02074e1 <printk+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c020748e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0207491:	8d 50 04             	lea    0x4(%eax),%edx
c0207494:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207497:	8b 00                	mov    (%eax),%eax
c0207499:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c020749c:	83 ec 08             	sub    $0x8,%esp
c020749f:	6a 01                	push   $0x1
c02074a1:	ff 75 e0             	pushl  -0x20(%ebp)
c02074a4:	e8 2c 04 00 00       	call   c02078d5 <num2hexstr>
c02074a9:	83 c4 10             	add    $0x10,%esp
c02074ac:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c02074af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02074b2:	83 ec 04             	sub    $0x4,%esp
c02074b5:	50                   	push   %eax
c02074b6:	ff 75 dc             	pushl  -0x24(%ebp)
c02074b9:	ff 75 f0             	pushl  -0x10(%ebp)
c02074bc:	e8 04 fe ff ff       	call   c02072c5 <insert_str>
c02074c1:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c02074c4:	83 ec 0c             	sub    $0xc,%esp
c02074c7:	ff 75 dc             	pushl  -0x24(%ebp)
c02074ca:	e8 17 06 00 00       	call   c0207ae6 <strlen>
c02074cf:	83 c4 10             	add    $0x10,%esp
c02074d2:	89 c2                	mov    %eax,%edx
c02074d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02074d7:	01 d0                	add    %edx,%eax
c02074d9:	83 e8 01             	sub    $0x1,%eax
c02074dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02074df:	eb 5e                	jmp    c020753f <printk+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c02074e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02074e4:	83 c0 01             	add    $0x1,%eax
c02074e7:	0f b6 00             	movzbl (%eax),%eax
c02074ea:	3c 68                	cmp    $0x68,%al
c02074ec:	75 51                	jne    c020753f <printk+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c02074ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02074f1:	8d 50 04             	lea    0x4(%eax),%edx
c02074f4:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02074f7:	8b 00                	mov    (%eax),%eax
c02074f9:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c02074fc:	83 ec 08             	sub    $0x8,%esp
c02074ff:	6a 00                	push   $0x0
c0207501:	ff 75 e8             	pushl  -0x18(%ebp)
c0207504:	e8 cc 03 00 00       	call   c02078d5 <num2hexstr>
c0207509:	83 c4 10             	add    $0x10,%esp
c020750c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c020750f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207512:	83 ec 04             	sub    $0x4,%esp
c0207515:	50                   	push   %eax
c0207516:	ff 75 e4             	pushl  -0x1c(%ebp)
c0207519:	ff 75 f0             	pushl  -0x10(%ebp)
c020751c:	e8 a4 fd ff ff       	call   c02072c5 <insert_str>
c0207521:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0207524:	83 ec 0c             	sub    $0xc,%esp
c0207527:	ff 75 e4             	pushl  -0x1c(%ebp)
c020752a:	e8 b7 05 00 00       	call   c0207ae6 <strlen>
c020752f:	83 c4 10             	add    $0x10,%esp
c0207532:	89 c2                	mov    %eax,%edx
c0207534:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207537:	01 d0                	add    %edx,%eax
c0207539:	83 e8 01             	sub    $0x1,%eax
c020753c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c020753f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0207543:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207546:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0207549:	01 d0                	add    %edx,%eax
c020754b:	0f b6 00             	movzbl (%eax),%eax
c020754e:	84 c0                	test   %al,%al
c0207550:	0f 85 4f fe ff ff    	jne    c02073a5 <printk+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs(output_str);
c0207556:	83 ec 0c             	sub    $0xc,%esp
c0207559:	ff 75 f0             	pushl  -0x10(%ebp)
c020755c:	e8 0e fc ff ff       	call   c020716f <kputs>
c0207561:	83 c4 10             	add    $0x10,%esp
}
c0207564:	90                   	nop
c0207565:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0207568:	c9                   	leave  
c0207569:	c3                   	ret    

c020756a <printbasic>:


//输入uint32_t或者char*  使用%d或者%s
//wdnmd 这个可变参有问题！！
void printbasic(char *format_str,char *m)
{
c020756a:	55                   	push   %ebp
c020756b:	89 e5                	mov    %esp,%ebp
c020756d:	83 ec 18             	sub    $0x18,%esp
c0207570:	e8 8b 0a 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207575:	05 8b 1a 00 00       	add    $0x1a8b,%eax
	//va_list ptr_start=NULL;
	char *formatStr=format_str;
c020757a:	8b 45 08             	mov    0x8(%ebp),%eax
c020757d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//va_start(ptr_start,format_str);
	//kputs_color(va_arg(ptr_start,char *), rc_black, rc_green);	
	int i=0;
c0207580:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0207587:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020758a:	89 45 ec             	mov    %eax,-0x14(%ebp)
c020758d:	eb 3a                	jmp    c02075c9 <printbasic+0x5f>
	{
		if (*(head+i)=='%'){
c020758f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207592:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207595:	01 d0                	add    %edx,%eax
c0207597:	0f b6 00             	movzbl (%eax),%eax
c020759a:	3c 25                	cmp    $0x25,%al
c020759c:	75 27                	jne    c02075c5 <printbasic+0x5b>
			if(*(head+i+1)=='s')
c020759e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02075a1:	8d 50 01             	lea    0x1(%eax),%edx
c02075a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02075a7:	01 d0                	add    %edx,%eax
c02075a9:	0f b6 00             	movzbl (%eax),%eax
c02075ac:	3c 73                	cmp    $0x73,%al
c02075ae:	75 15                	jne    c02075c5 <printbasic+0x5b>
			{
				//char *str_head=va_arg(&ptr_start,char*);
				insert_str(format_str,m,i);
c02075b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02075b3:	83 ec 04             	sub    $0x4,%esp
c02075b6:	50                   	push   %eax
c02075b7:	ff 75 0c             	pushl  0xc(%ebp)
c02075ba:	ff 75 08             	pushl  0x8(%ebp)
c02075bd:	e8 03 fd ff ff       	call   c02072c5 <insert_str>
c02075c2:	83 c4 10             	add    $0x10,%esp
	for(char *head=formatStr;*(head+i)!='\0';i++)
c02075c5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02075c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02075cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02075cf:	01 d0                	add    %edx,%eax
c02075d1:	0f b6 00             	movzbl (%eax),%eax
c02075d4:	84 c0                	test   %al,%al
c02075d6:	75 b7                	jne    c020758f <printbasic+0x25>
			else;
		}
	}
	//kputs_color(formatStr, black, white);
	
}
c02075d8:	90                   	nop
c02075d9:	c9                   	leave  
c02075da:	c3                   	ret    

c02075db <printk_color>:



void printk_color(char *input_str,vga_color_t back,vga_color_t fore,...)
{
c02075db:	55                   	push   %ebp
c02075dc:	89 e5                	mov    %esp,%ebp
c02075de:	53                   	push   %ebx
c02075df:	83 ec 34             	sub    $0x34,%esp
c02075e2:	e8 1d 0a 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02075e7:	81 c3 19 1a 00 00    	add    $0x1a19,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c02075ed:	8d 83 40 91 08 00    	lea    0x89140(%ebx),%eax
c02075f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c02075f6:	83 ec 08             	sub    $0x8,%esp
c02075f9:	ff 75 08             	pushl  0x8(%ebp)
c02075fc:	ff 75 f0             	pushl  -0x10(%ebp)
c02075ff:	e8 13 05 00 00       	call   c0207b17 <strcpy>
c0207604:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0207607:	8d 45 14             	lea    0x14(%ebp),%eax
c020760a:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c020760d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0207614:	e9 9e 01 00 00       	jmp    c02077b7 <printk_color+0x1dc>
	{
		char *charptr=output_str+offset;
c0207619:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020761c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020761f:	01 d0                	add    %edx,%eax
c0207621:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c0207624:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207627:	0f b6 00             	movzbl (%eax),%eax
c020762a:	3c 25                	cmp    $0x25,%al
c020762c:	0f 85 81 01 00 00    	jne    c02077b3 <printk_color+0x1d8>
		{
			if (*(charptr+1)=='s')
c0207632:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207635:	83 c0 01             	add    $0x1,%eax
c0207638:	0f b6 00             	movzbl (%eax),%eax
c020763b:	3c 73                	cmp    $0x73,%al
c020763d:	75 43                	jne    c0207682 <printk_color+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c020763f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0207642:	8d 50 04             	lea    0x4(%eax),%edx
c0207645:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207648:	8b 00                	mov    (%eax),%eax
c020764a:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c020764d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207650:	83 ec 04             	sub    $0x4,%esp
c0207653:	50                   	push   %eax
c0207654:	ff 75 d0             	pushl  -0x30(%ebp)
c0207657:	ff 75 f0             	pushl  -0x10(%ebp)
c020765a:	e8 66 fc ff ff       	call   c02072c5 <insert_str>
c020765f:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c0207662:	83 ec 0c             	sub    $0xc,%esp
c0207665:	ff 75 d0             	pushl  -0x30(%ebp)
c0207668:	e8 79 04 00 00       	call   c0207ae6 <strlen>
c020766d:	83 c4 10             	add    $0x10,%esp
c0207670:	89 c2                	mov    %eax,%edx
c0207672:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207675:	01 d0                	add    %edx,%eax
c0207677:	83 e8 01             	sub    $0x1,%eax
c020767a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c020767d:	e9 31 01 00 00       	jmp    c02077b3 <printk_color+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c0207682:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207685:	83 c0 01             	add    $0x1,%eax
c0207688:	0f b6 00             	movzbl (%eax),%eax
c020768b:	3c 64                	cmp    $0x64,%al
c020768d:	75 55                	jne    c02076e4 <printk_color+0x109>
			{
				int arg_int=va_arg(ptr,int);
c020768f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0207692:	8d 50 04             	lea    0x4(%eax),%edx
c0207695:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0207698:	8b 00                	mov    (%eax),%eax
c020769a:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c020769d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c02076a0:	83 ec 0c             	sub    $0xc,%esp
c02076a3:	50                   	push   %eax
c02076a4:	e8 ed 04 00 00       	call   c0207b96 <uintTostring>
c02076a9:	83 c4 10             	add    $0x10,%esp
c02076ac:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c02076af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02076b2:	83 ec 04             	sub    $0x4,%esp
c02076b5:	50                   	push   %eax
c02076b6:	ff 75 d4             	pushl  -0x2c(%ebp)
c02076b9:	ff 75 f0             	pushl  -0x10(%ebp)
c02076bc:	e8 04 fc ff ff       	call   c02072c5 <insert_str>
c02076c1:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c02076c4:	83 ec 0c             	sub    $0xc,%esp
c02076c7:	ff 75 d4             	pushl  -0x2c(%ebp)
c02076ca:	e8 17 04 00 00       	call   c0207ae6 <strlen>
c02076cf:	83 c4 10             	add    $0x10,%esp
c02076d2:	89 c2                	mov    %eax,%edx
c02076d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02076d7:	01 d0                	add    %edx,%eax
c02076d9:	83 e8 01             	sub    $0x1,%eax
c02076dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02076df:	e9 cf 00 00 00       	jmp    c02077b3 <printk_color+0x1d8>
			}
			else if(*(charptr+1)=='c')
c02076e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02076e7:	83 c0 01             	add    $0x1,%eax
c02076ea:	0f b6 00             	movzbl (%eax),%eax
c02076ed:	3c 63                	cmp    $0x63,%al
c02076ef:	0f 84 be 00 00 00    	je     c02077b3 <printk_color+0x1d8>
			{
			
			}
			else if(*(charptr+1)=='H')
c02076f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02076f8:	83 c0 01             	add    $0x1,%eax
c02076fb:	0f b6 00             	movzbl (%eax),%eax
c02076fe:	3c 48                	cmp    $0x48,%al
c0207700:	75 53                	jne    c0207755 <printk_color+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c0207702:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0207705:	8d 50 04             	lea    0x4(%eax),%edx
c0207708:	89 55 cc             	mov    %edx,-0x34(%ebp)
c020770b:	8b 00                	mov    (%eax),%eax
c020770d:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c0207710:	83 ec 08             	sub    $0x8,%esp
c0207713:	6a 01                	push   $0x1
c0207715:	ff 75 e0             	pushl  -0x20(%ebp)
c0207718:	e8 b8 01 00 00       	call   c02078d5 <num2hexstr>
c020771d:	83 c4 10             	add    $0x10,%esp
c0207720:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0207723:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207726:	83 ec 04             	sub    $0x4,%esp
c0207729:	50                   	push   %eax
c020772a:	ff 75 dc             	pushl  -0x24(%ebp)
c020772d:	ff 75 f0             	pushl  -0x10(%ebp)
c0207730:	e8 90 fb ff ff       	call   c02072c5 <insert_str>
c0207735:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0207738:	83 ec 0c             	sub    $0xc,%esp
c020773b:	ff 75 dc             	pushl  -0x24(%ebp)
c020773e:	e8 a3 03 00 00       	call   c0207ae6 <strlen>
c0207743:	83 c4 10             	add    $0x10,%esp
c0207746:	89 c2                	mov    %eax,%edx
c0207748:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020774b:	01 d0                	add    %edx,%eax
c020774d:	83 e8 01             	sub    $0x1,%eax
c0207750:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0207753:	eb 5e                	jmp    c02077b3 <printk_color+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c0207755:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0207758:	83 c0 01             	add    $0x1,%eax
c020775b:	0f b6 00             	movzbl (%eax),%eax
c020775e:	3c 68                	cmp    $0x68,%al
c0207760:	75 51                	jne    c02077b3 <printk_color+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c0207762:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0207765:	8d 50 04             	lea    0x4(%eax),%edx
c0207768:	89 55 cc             	mov    %edx,-0x34(%ebp)
c020776b:	8b 00                	mov    (%eax),%eax
c020776d:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c0207770:	83 ec 08             	sub    $0x8,%esp
c0207773:	6a 00                	push   $0x0
c0207775:	ff 75 e8             	pushl  -0x18(%ebp)
c0207778:	e8 58 01 00 00       	call   c02078d5 <num2hexstr>
c020777d:	83 c4 10             	add    $0x10,%esp
c0207780:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0207783:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207786:	83 ec 04             	sub    $0x4,%esp
c0207789:	50                   	push   %eax
c020778a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020778d:	ff 75 f0             	pushl  -0x10(%ebp)
c0207790:	e8 30 fb ff ff       	call   c02072c5 <insert_str>
c0207795:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0207798:	83 ec 0c             	sub    $0xc,%esp
c020779b:	ff 75 e4             	pushl  -0x1c(%ebp)
c020779e:	e8 43 03 00 00       	call   c0207ae6 <strlen>
c02077a3:	83 c4 10             	add    $0x10,%esp
c02077a6:	89 c2                	mov    %eax,%edx
c02077a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02077ab:	01 d0                	add    %edx,%eax
c02077ad:	83 e8 01             	sub    $0x1,%eax
c02077b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c02077b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02077b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02077ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02077bd:	01 d0                	add    %edx,%eax
c02077bf:	0f b6 00             	movzbl (%eax),%eax
c02077c2:	84 c0                	test   %al,%al
c02077c4:	0f 85 4f fe ff ff    	jne    c0207619 <printk_color+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs_color(output_str,back,fore);
c02077ca:	83 ec 04             	sub    $0x4,%esp
c02077cd:	ff 75 10             	pushl  0x10(%ebp)
c02077d0:	ff 75 0c             	pushl  0xc(%ebp)
c02077d3:	ff 75 f0             	pushl  -0x10(%ebp)
c02077d6:	e8 4e f9 ff ff       	call   c0207129 <kputs_color>
c02077db:	83 c4 10             	add    $0x10,%esp
}
c02077de:	90                   	nop
c02077df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02077e2:	c9                   	leave  
c02077e3:	c3                   	ret    

c02077e4 <printkDebug>:

void printkDebug(){
c02077e4:	55                   	push   %ebp
c02077e5:	89 e5                	mov    %esp,%ebp
c02077e7:	53                   	push   %ebx
c02077e8:	83 ec 04             	sub    $0x4,%esp
c02077eb:	e8 14 08 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02077f0:	81 c3 10 18 00 00    	add    $0x1810,%ebx
	printk("wkawda----");
c02077f6:	83 ec 0c             	sub    $0xc,%esp
c02077f9:	8d 83 ef 06 00 00    	lea    0x6ef(%ebx),%eax
c02077ff:	50                   	push   %eax
c0207800:	e8 62 fb ff ff       	call   c0207367 <printk>
c0207805:	83 c4 10             	add    $0x10,%esp
	printk_color("wkdaowd",black,white);
c0207808:	83 ec 04             	sub    $0x4,%esp
c020780b:	6a 0f                	push   $0xf
c020780d:	6a 00                	push   $0x0
c020780f:	8d 83 fa 06 00 00    	lea    0x6fa(%ebx),%eax
c0207815:	50                   	push   %eax
c0207816:	e8 c0 fd ff ff       	call   c02075db <printk_color>
c020781b:	83 c4 10             	add    $0x10,%esp
c020781e:	90                   	nop
c020781f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0207822:	c9                   	leave  
c0207823:	c3                   	ret    

c0207824 <func>:
#include "string.h"

//进制转换的辅助函数
static int func(char *s,int n,uint32_t i)          //n表示输入的数 i表示转化的进制
{
c0207824:	55                   	push   %ebp
c0207825:	89 e5                	mov    %esp,%ebp
c0207827:	83 ec 28             	sub    $0x28,%esp
c020782a:	e8 d1 07 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c020782f:	05 d1 17 00 00       	add    $0x17d1,%eax
    char bit[]={"0123456789ABCDEF"};
c0207834:	c7 45 e3 30 31 32 33 	movl   $0x33323130,-0x1d(%ebp)
c020783b:	c7 45 e7 34 35 36 37 	movl   $0x37363534,-0x19(%ebp)
c0207842:	c7 45 eb 38 39 41 42 	movl   $0x42413938,-0x15(%ebp)
c0207849:	c7 45 ef 43 44 45 46 	movl   $0x46454443,-0x11(%ebp)
c0207850:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int len;
    if(n==0)
c0207854:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0207858:	75 1c                	jne    c0207876 <func+0x52>
    {
        strcpy(s,"");
c020785a:	83 ec 08             	sub    $0x8,%esp
c020785d:	8d 80 02 07 00 00    	lea    0x702(%eax),%eax
c0207863:	50                   	push   %eax
c0207864:	ff 75 08             	pushl  0x8(%ebp)
c0207867:	e8 ab 02 00 00       	call   c0207b17 <strcpy>
c020786c:	83 c4 10             	add    $0x10,%esp
        return 0;
c020786f:	b8 00 00 00 00       	mov    $0x0,%eax
c0207874:	eb 5d                	jmp    c02078d3 <func+0xaf>
    }
    func(s,n/i,i);
c0207876:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207879:	ba 00 00 00 00       	mov    $0x0,%edx
c020787e:	f7 75 10             	divl   0x10(%ebp)
c0207881:	83 ec 04             	sub    $0x4,%esp
c0207884:	ff 75 10             	pushl  0x10(%ebp)
c0207887:	50                   	push   %eax
c0207888:	ff 75 08             	pushl  0x8(%ebp)
c020788b:	e8 94 ff ff ff       	call   c0207824 <func>
c0207890:	83 c4 10             	add    $0x10,%esp
    len=strlen(s);
c0207893:	83 ec 0c             	sub    $0xc,%esp
c0207896:	ff 75 08             	pushl  0x8(%ebp)
c0207899:	e8 48 02 00 00       	call   c0207ae6 <strlen>
c020789e:	83 c4 10             	add    $0x10,%esp
c02078a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    s[len]=bit[n%i];
c02078a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c02078a7:	ba 00 00 00 00       	mov    $0x0,%edx
c02078ac:	f7 75 10             	divl   0x10(%ebp)
c02078af:	89 d1                	mov    %edx,%ecx
c02078b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02078b4:	8b 45 08             	mov    0x8(%ebp),%eax
c02078b7:	01 c2                	add    %eax,%edx
c02078b9:	0f b6 44 0d e3       	movzbl -0x1d(%ebp,%ecx,1),%eax
c02078be:	88 02                	mov    %al,(%edx)
    s[len+1]='\0';
c02078c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02078c3:	8d 50 01             	lea    0x1(%eax),%edx
c02078c6:	8b 45 08             	mov    0x8(%ebp),%eax
c02078c9:	01 d0                	add    %edx,%eax
c02078cb:	c6 00 00             	movb   $0x0,(%eax)
    return 1;
c02078ce:	b8 01 00 00 00       	mov    $0x1,%eax
}
c02078d3:	c9                   	leave  
c02078d4:	c3                   	ret    

c02078d5 <num2hexstr>:

//32位的16进制数 使用0x+8位字符表示+\0   共11位字符
inline char *num2hexstr(int number,int need0x)
{	if (number!=0)
c02078d5:	55                   	push   %ebp
c02078d6:	89 e5                	mov    %esp,%ebp
c02078d8:	53                   	push   %ebx
c02078d9:	83 ec 34             	sub    $0x34,%esp
c02078dc:	e8 23 07 00 00       	call   c0208004 <__x86.get_pc_thunk.bx>
c02078e1:	81 c3 1f 17 00 00    	add    $0x171f,%ebx
c02078e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c02078eb:	0f 84 f1 00 00 00    	je     c02079e2 <num2hexstr+0x10d>
	{
	static char static_hexstr[11]={0};
	static_hexstr[0]='0';
c02078f1:	c6 83 c0 91 08 00 30 	movb   $0x30,0x891c0(%ebx)
	static_hexstr[1]='x';
c02078f8:	c6 83 c1 91 08 00 78 	movb   $0x78,0x891c1(%ebx)
	char temp_arry[9]={0};
c02078ff:	c7 45 df 00 00 00 00 	movl   $0x0,-0x21(%ebp)
c0207906:	c7 45 e3 00 00 00 00 	movl   $0x0,-0x1d(%ebp)
c020790d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	char *temp_arry_ptr=temp_arry;
c0207911:	8d 45 df             	lea    -0x21(%ebp),%eax
c0207914:	89 45 f0             	mov    %eax,-0x10(%ebp)
	func(temp_arry_ptr,number,16);
c0207917:	83 ec 04             	sub    $0x4,%esp
c020791a:	6a 10                	push   $0x10
c020791c:	ff 75 08             	pushl  0x8(%ebp)
c020791f:	ff 75 f0             	pushl  -0x10(%ebp)
c0207922:	e8 fd fe ff ff       	call   c0207824 <func>
c0207927:	83 c4 10             	add    $0x10,%esp
	char temp_arry2[9]={0};
c020792a:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
c0207931:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
c0207938:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	char *temp_arry2_ptr=temp_arry2;
c020793c:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c020793f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	strcpy(temp_arry2_ptr,temp_arry_ptr);
c0207942:	83 ec 08             	sub    $0x8,%esp
c0207945:	ff 75 f0             	pushl  -0x10(%ebp)
c0207948:	ff 75 ec             	pushl  -0x14(%ebp)
c020794b:	e8 c7 01 00 00       	call   c0207b17 <strcpy>
c0207950:	83 c4 10             	add    $0x10,%esp
	int offset=8-strlen(temp_arry);
c0207953:	83 ec 0c             	sub    $0xc,%esp
c0207956:	8d 45 df             	lea    -0x21(%ebp),%eax
c0207959:	50                   	push   %eax
c020795a:	e8 87 01 00 00       	call   c0207ae6 <strlen>
c020795f:	83 c4 10             	add    $0x10,%esp
c0207962:	ba 08 00 00 00       	mov    $0x8,%edx
c0207967:	29 c2                	sub    %eax,%edx
c0207969:	89 d0                	mov    %edx,%eax
c020796b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	strcpy(temp_arry+offset,temp_arry2);
c020796e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0207971:	8d 55 df             	lea    -0x21(%ebp),%edx
c0207974:	01 c2                	add    %eax,%edx
c0207976:	83 ec 08             	sub    $0x8,%esp
c0207979:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c020797c:	50                   	push   %eax
c020797d:	52                   	push   %edx
c020797e:	e8 94 01 00 00       	call   c0207b17 <strcpy>
c0207983:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<offset;i++)
c0207986:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020798d:	eb 0f                	jmp    c020799e <num2hexstr+0xc9>
		*(temp_arry+i)='0';
c020798f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207992:	8d 55 df             	lea    -0x21(%ebp),%edx
c0207995:	01 d0                	add    %edx,%eax
c0207997:	c6 00 30             	movb   $0x30,(%eax)
	for(int i=0;i<offset;i++)
c020799a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c020799e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02079a1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c02079a4:	7c e9                	jl     c020798f <num2hexstr+0xba>
	if(need0x)
c02079a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c02079aa:	74 18                	je     c02079c4 <num2hexstr+0xef>
		strcpy(static_hexstr+2,temp_arry);
c02079ac:	8d 83 c2 91 08 00    	lea    0x891c2(%ebx),%eax
c02079b2:	83 ec 08             	sub    $0x8,%esp
c02079b5:	8d 55 df             	lea    -0x21(%ebp),%edx
c02079b8:	52                   	push   %edx
c02079b9:	50                   	push   %eax
c02079ba:	e8 58 01 00 00       	call   c0207b17 <strcpy>
c02079bf:	83 c4 10             	add    $0x10,%esp
c02079c2:	eb 16                	jmp    c02079da <num2hexstr+0x105>
	else
		strcpy(static_hexstr,temp_arry);
c02079c4:	83 ec 08             	sub    $0x8,%esp
c02079c7:	8d 45 df             	lea    -0x21(%ebp),%eax
c02079ca:	50                   	push   %eax
c02079cb:	8d 83 c0 91 08 00    	lea    0x891c0(%ebx),%eax
c02079d1:	50                   	push   %eax
c02079d2:	e8 40 01 00 00       	call   c0207b17 <strcpy>
c02079d7:	83 c4 10             	add    $0x10,%esp
	return static_hexstr;
c02079da:	8d 83 c0 91 08 00    	lea    0x891c0(%ebx),%eax
c02079e0:	eb 14                	jmp    c02079f6 <num2hexstr+0x121>
	}
	else 
	{
		if(need0x)
c02079e2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c02079e6:	74 08                	je     c02079f0 <num2hexstr+0x11b>
			return "0x00000000";
c02079e8:	8d 83 03 07 00 00    	lea    0x703(%ebx),%eax
c02079ee:	eb 06                	jmp    c02079f6 <num2hexstr+0x121>
		else
			return "00000000";
c02079f0:	8d 83 0e 07 00 00    	lea    0x70e(%ebx),%eax
	}
}
c02079f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02079f9:	c9                   	leave  
c02079fa:	c3                   	ret    

c02079fb <memcpy>:


inline void memcpy(uint8_t *dest ,const uint8_t *src,uint32_t len)
{
c02079fb:	55                   	push   %ebp
c02079fc:	89 e5                	mov    %esp,%ebp
c02079fe:	e8 fd 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a03:	05 fd 15 00 00       	add    $0x15fd,%eax
	for(;len!=0;len--)
c0207a08:	eb 17                	jmp    c0207a21 <memcpy+0x26>
	{
		*dest=*src;
c0207a0a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a0d:	0f b6 10             	movzbl (%eax),%edx
c0207a10:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a13:	88 10                	mov    %dl,(%eax)
		dest++;
c0207a15:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c0207a19:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	for(;len!=0;len--)
c0207a1d:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0207a21:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0207a25:	75 e3                	jne    c0207a0a <memcpy+0xf>
	}
}
c0207a27:	90                   	nop
c0207a28:	5d                   	pop    %ebp
c0207a29:	c3                   	ret    

c0207a2a <memset>:

inline void memset(void *dest,uint8_t val ,uint32_t len)
{
c0207a2a:	55                   	push   %ebp
c0207a2b:	89 e5                	mov    %esp,%ebp
c0207a2d:	83 ec 14             	sub    $0x14,%esp
c0207a30:	e8 cb 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a35:	05 cb 15 00 00       	add    $0x15cb,%eax
c0207a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a3d:	88 45 ec             	mov    %al,-0x14(%ebp)
	uint8_t *dst = (uint8_t *)dest;
c0207a40:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a43:	89 45 fc             	mov    %eax,-0x4(%ebp)

    for ( ; len != 0; len--) {
c0207a46:	eb 13                	jmp    c0207a5b <memset+0x31>
        *dst++ = val;
c0207a48:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207a4b:	8d 50 01             	lea    0x1(%eax),%edx
c0207a4e:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0207a51:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0207a55:	88 10                	mov    %dl,(%eax)
    for ( ; len != 0; len--) {
c0207a57:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0207a5b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0207a5f:	75 e7                	jne    c0207a48 <memset+0x1e>
    }
}
c0207a61:	90                   	nop
c0207a62:	c9                   	leave  
c0207a63:	c3                   	ret    

c0207a64 <bzero>:

inline void bzero(void *dest, uint32_t len)
{
c0207a64:	55                   	push   %ebp
c0207a65:	89 e5                	mov    %esp,%ebp
c0207a67:	e8 94 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a6c:	05 94 15 00 00       	add    $0x1594,%eax
    memset(dest, 0, len);
c0207a71:	ff 75 0c             	pushl  0xc(%ebp)
c0207a74:	6a 00                	push   $0x0
c0207a76:	ff 75 08             	pushl  0x8(%ebp)
c0207a79:	e8 ac ff ff ff       	call   c0207a2a <memset>
c0207a7e:	83 c4 0c             	add    $0xc,%esp
}
c0207a81:	90                   	nop
c0207a82:	c9                   	leave  
c0207a83:	c3                   	ret    

c0207a84 <strcmp>:

inline int strcmp(const char *str1,const char *str2)
{
c0207a84:	55                   	push   %ebp
c0207a85:	89 e5                	mov    %esp,%ebp
c0207a87:	e8 74 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207a8c:	05 74 15 00 00       	add    $0x1574,%eax
	while(1){
		if (*str1=='\0'&&*str2=='\0')
c0207a91:	8b 45 08             	mov    0x8(%ebp),%eax
c0207a94:	0f b6 00             	movzbl (%eax),%eax
c0207a97:	84 c0                	test   %al,%al
c0207a99:	75 11                	jne    c0207aac <strcmp+0x28>
c0207a9b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207a9e:	0f b6 00             	movzbl (%eax),%eax
c0207aa1:	84 c0                	test   %al,%al
c0207aa3:	75 07                	jne    c0207aac <strcmp+0x28>
			return 0;
c0207aa5:	b8 00 00 00 00       	mov    $0x0,%eax
c0207aaa:	eb 38                	jmp    c0207ae4 <strcmp+0x60>
		else if ((int)*str1>(int)*str2){
c0207aac:	8b 45 08             	mov    0x8(%ebp),%eax
c0207aaf:	0f b6 10             	movzbl (%eax),%edx
c0207ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207ab5:	0f b6 00             	movzbl (%eax),%eax
c0207ab8:	38 c2                	cmp    %al,%dl
c0207aba:	7e 07                	jle    c0207ac3 <strcmp+0x3f>
			return 1;
c0207abc:	b8 01 00 00 00       	mov    $0x1,%eax
c0207ac1:	eb 21                	jmp    c0207ae4 <strcmp+0x60>
		}
		else if((int)*str1>(int)*str2){
c0207ac3:	8b 45 08             	mov    0x8(%ebp),%eax
c0207ac6:	0f b6 10             	movzbl (%eax),%edx
c0207ac9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207acc:	0f b6 00             	movzbl (%eax),%eax
c0207acf:	38 c2                	cmp    %al,%dl
c0207ad1:	7e 07                	jle    c0207ada <strcmp+0x56>
			return -1;
c0207ad3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0207ad8:	eb 0a                	jmp    c0207ae4 <strcmp+0x60>
		}
		else{
			str1++;
c0207ada:	83 45 08 01          	addl   $0x1,0x8(%ebp)
			str2++;
c0207ade:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		if (*str1=='\0'&&*str2=='\0')
c0207ae2:	eb ad                	jmp    c0207a91 <strcmp+0xd>
		}
	}
}
c0207ae4:	5d                   	pop    %ebp
c0207ae5:	c3                   	ret    

c0207ae6 <strlen>:

inline int strlen(const char *src)
{
c0207ae6:	55                   	push   %ebp
c0207ae7:	89 e5                	mov    %esp,%ebp
c0207ae9:	83 ec 10             	sub    $0x10,%esp
c0207aec:	e8 0f 05 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207af1:	05 0f 15 00 00       	add    $0x150f,%eax
	int i=0;
c0207af6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(*(src+i)!='\0')
c0207afd:	eb 04                	jmp    c0207b03 <strlen+0x1d>
		i++;
c0207aff:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while(*(src+i)!='\0')
c0207b03:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0207b06:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b09:	01 d0                	add    %edx,%eax
c0207b0b:	0f b6 00             	movzbl (%eax),%eax
c0207b0e:	84 c0                	test   %al,%al
c0207b10:	75 ed                	jne    c0207aff <strlen+0x19>
	return i;
c0207b12:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0207b15:	c9                   	leave  
c0207b16:	c3                   	ret    

c0207b17 <strcpy>:

inline char *strcpy(char *dest, const char *src)
{
c0207b17:	55                   	push   %ebp
c0207b18:	89 e5                	mov    %esp,%ebp
c0207b1a:	83 ec 10             	sub    $0x10,%esp
c0207b1d:	e8 de 04 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207b22:	05 de 14 00 00       	add    $0x14de,%eax
	char *dest_head=dest;
c0207b27:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(*(src)!='\0')
c0207b2d:	eb 13                	jmp    c0207b42 <strcpy+0x2b>
	{
		*dest=*src;
c0207b2f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207b32:	0f b6 10             	movzbl (%eax),%edx
c0207b35:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b38:	88 10                	mov    %dl,(%eax)
		dest++;
c0207b3a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c0207b3e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	while(*(src)!='\0')
c0207b42:	8b 45 0c             	mov    0xc(%ebp),%eax
c0207b45:	0f b6 00             	movzbl (%eax),%eax
c0207b48:	84 c0                	test   %al,%al
c0207b4a:	75 e3                	jne    c0207b2f <strcpy+0x18>
	}
	*dest='\0';
c0207b4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b4f:	c6 00 00             	movb   $0x0,(%eax)
	dest=dest_head;
c0207b52:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207b55:	89 45 08             	mov    %eax,0x8(%ebp)
	return dest;
c0207b58:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0207b5b:	c9                   	leave  
c0207b5c:	c3                   	ret    

c0207b5d <strcat>:

inline char *strcat(char *dest, const char *src)
{
c0207b5d:	55                   	push   %ebp
c0207b5e:	89 e5                	mov    %esp,%ebp
c0207b60:	83 ec 10             	sub    $0x10,%esp
c0207b63:	e8 98 04 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207b68:	05 98 14 00 00       	add    $0x1498,%eax
	char *pointer=dest;
c0207b6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0207b70:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for(;*pointer!='\0';pointer++);
c0207b73:	eb 04                	jmp    c0207b79 <strcat+0x1c>
c0207b75:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0207b79:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207b7c:	0f b6 00             	movzbl (%eax),%eax
c0207b7f:	84 c0                	test   %al,%al
c0207b81:	75 f2                	jne    c0207b75 <strcat+0x18>
	strcpy(pointer,src);
c0207b83:	ff 75 0c             	pushl  0xc(%ebp)
c0207b86:	ff 75 fc             	pushl  -0x4(%ebp)
c0207b89:	e8 89 ff ff ff       	call   c0207b17 <strcpy>
c0207b8e:	83 c4 08             	add    $0x8,%esp
	return dest;		
c0207b91:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0207b94:	c9                   	leave  
c0207b95:	c3                   	ret    

c0207b96 <uintTostring>:

inline char *uintTostring(uint32_t num)
{
c0207b96:	55                   	push   %ebp
c0207b97:	89 e5                	mov    %esp,%ebp
c0207b99:	83 ec 28             	sub    $0x28,%esp
c0207b9c:	e8 5f 04 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207ba1:	05 5f 14 00 00       	add    $0x145f,%eax
	char i2stable[10]={'0','1','2','3','4','5','6','7','8','9'};
c0207ba6:	c6 45 da 30          	movb   $0x30,-0x26(%ebp)
c0207baa:	c6 45 db 31          	movb   $0x31,-0x25(%ebp)
c0207bae:	c6 45 dc 32          	movb   $0x32,-0x24(%ebp)
c0207bb2:	c6 45 dd 33          	movb   $0x33,-0x23(%ebp)
c0207bb6:	c6 45 de 34          	movb   $0x34,-0x22(%ebp)
c0207bba:	c6 45 df 35          	movb   $0x35,-0x21(%ebp)
c0207bbe:	c6 45 e0 36          	movb   $0x36,-0x20(%ebp)
c0207bc2:	c6 45 e1 37          	movb   $0x37,-0x1f(%ebp)
c0207bc6:	c6 45 e2 38          	movb   $0x38,-0x1e(%ebp)
c0207bca:	c6 45 e3 39          	movb   $0x39,-0x1d(%ebp)
	static char m[32]={0};
	char *str_ptr=m;
c0207bce:	8d 80 e0 91 08 00    	lea    0x891e0(%eax),%eax
c0207bd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char *head=str_ptr;
c0207bd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207bda:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int i=0;
c0207bdd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(;num>=10;i++)
c0207be4:	eb 46                	jmp    c0207c2c <uintTostring+0x96>
	{
		uint32_t num_=num/10;
c0207be6:	8b 45 08             	mov    0x8(%ebp),%eax
c0207be9:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0207bee:	f7 e2                	mul    %edx
c0207bf0:	89 d0                	mov    %edx,%eax
c0207bf2:	c1 e8 03             	shr    $0x3,%eax
c0207bf5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32_t index=num-(num_*10);
c0207bf8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0207bfb:	89 d0                	mov    %edx,%eax
c0207bfd:	c1 e0 02             	shl    $0x2,%eax
c0207c00:	01 d0                	add    %edx,%eax
c0207c02:	01 c0                	add    %eax,%eax
c0207c04:	89 c2                	mov    %eax,%edx
c0207c06:	8b 45 08             	mov    0x8(%ebp),%eax
c0207c09:	29 d0                	sub    %edx,%eax
c0207c0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		num=num_;
c0207c0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0207c11:	89 45 08             	mov    %eax,0x8(%ebp)
		*str_ptr=i2stable[index];
c0207c14:	8d 55 da             	lea    -0x26(%ebp),%edx
c0207c17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0207c1a:	01 d0                	add    %edx,%eax
c0207c1c:	0f b6 10             	movzbl (%eax),%edx
c0207c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c22:	88 10                	mov    %dl,(%eax)
		str_ptr++;
c0207c24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	for(;num>=10;i++)
c0207c28:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0207c2c:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0207c30:	77 b4                	ja     c0207be6 <uintTostring+0x50>
	}
	*str_ptr=i2stable[num];
c0207c32:	8d 55 da             	lea    -0x26(%ebp),%edx
c0207c35:	8b 45 08             	mov    0x8(%ebp),%eax
c0207c38:	01 d0                	add    %edx,%eax
c0207c3a:	0f b6 10             	movzbl (%eax),%edx
c0207c3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c40:	88 10                	mov    %dl,(%eax)
	*(str_ptr+1)='\0';
c0207c42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c45:	83 c0 01             	add    $0x1,%eax
c0207c48:	c6 00 00             	movb   $0x0,(%eax)
	return strrevers(head);
c0207c4b:	83 ec 0c             	sub    $0xc,%esp
c0207c4e:	ff 75 ec             	pushl  -0x14(%ebp)
c0207c51:	e8 05 00 00 00       	call   c0207c5b <strrevers>
c0207c56:	83 c4 10             	add    $0x10,%esp
}
c0207c59:	c9                   	leave  
c0207c5a:	c3                   	ret    

c0207c5b <strrevers>:

inline  char *strrevers(char *str)
{
c0207c5b:	55                   	push   %ebp
c0207c5c:	89 e5                	mov    %esp,%ebp
c0207c5e:	83 ec 20             	sub    $0x20,%esp
c0207c61:	e8 9a 03 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207c66:	05 9a 13 00 00       	add    $0x139a,%eax
	char *str_head=str;
c0207c6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0207c6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int lenth=strlen(str);
c0207c71:	ff 75 08             	pushl  0x8(%ebp)
c0207c74:	e8 6d fe ff ff       	call   c0207ae6 <strlen>
c0207c79:	83 c4 04             	add    $0x4,%esp
c0207c7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ptr_h=0;
c0207c7f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int ptr_t=--lenth;
c0207c86:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0207c8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0207c8d:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c0207c90:	eb 39                	jmp    c0207ccb <strrevers+0x70>
	{
		char temp=*(str_head+ptr_t);
c0207c92:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0207c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207c98:	01 d0                	add    %edx,%eax
c0207c9a:	0f b6 00             	movzbl (%eax),%eax
c0207c9d:	88 45 ef             	mov    %al,-0x11(%ebp)
		*(str_head+ptr_t)=*(str_head+ptr_h);
c0207ca0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0207ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207ca6:	01 d0                	add    %edx,%eax
c0207ca8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c0207cab:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0207cae:	01 ca                	add    %ecx,%edx
c0207cb0:	0f b6 00             	movzbl (%eax),%eax
c0207cb3:	88 02                	mov    %al,(%edx)
		*(str_head+ptr_h)=temp;
c0207cb5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0207cb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0207cbb:	01 c2                	add    %eax,%edx
c0207cbd:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0207cc1:	88 02                	mov    %al,(%edx)
		ptr_h++;
c0207cc3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		ptr_t--;
c0207cc7:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c0207ccb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0207cce:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0207cd1:	7c bf                	jl     c0207c92 <strrevers+0x37>
	}
	return str_head;
c0207cd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0207cd6:	c9                   	leave  
c0207cd7:	c3                   	ret    

c0207cd8 <get_elem>:
#include "list.h"
elem_t get_elem(link_list_node_t* link_list_node_ptr){
c0207cd8:	55                   	push   %ebp
c0207cd9:	89 e5                	mov    %esp,%ebp
c0207cdb:	e8 20 03 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207ce0:	05 20 13 00 00       	add    $0x1320,%eax
    return link_list_node_ptr->elem;
c0207ce5:	8b 45 08             	mov    0x8(%ebp),%eax
c0207ce8:	8b 40 04             	mov    0x4(%eax),%eax
}
c0207ceb:	5d                   	pop    %ebp
c0207cec:	c3                   	ret    

c0207ced <get_next>:

elem_t get_next(link_list_node_t* link_list_node_ptr){
c0207ced:	55                   	push   %ebp
c0207cee:	89 e5                	mov    %esp,%ebp
c0207cf0:	e8 0b 03 00 00       	call   c0208000 <__x86.get_pc_thunk.ax>
c0207cf5:	05 0b 13 00 00       	add    $0x130b,%eax
    return link_list_node_ptr->next;
c0207cfa:	8b 45 08             	mov    0x8(%ebp),%eax
c0207cfd:	8b 00                	mov    (%eax),%eax
c0207cff:	5d                   	pop    %ebp
c0207d00:	c3                   	ret    
c0207d01:	66 90                	xchg   %ax,%ax
c0207d03:	66 90                	xchg   %ax,%ax
c0207d05:	66 90                	xchg   %ax,%ax
c0207d07:	66 90                	xchg   %ax,%ax
c0207d09:	66 90                	xchg   %ax,%ax
c0207d0b:	66 90                	xchg   %ax,%ax
c0207d0d:	66 90                	xchg   %ax,%ax
c0207d0f:	66 90                	xchg   %ax,%ax
c0207d11:	66 90                	xchg   %ax,%ax
c0207d13:	66 90                	xchg   %ax,%ax
c0207d15:	66 90                	xchg   %ax,%ax
c0207d17:	66 90                	xchg   %ax,%ax
c0207d19:	66 90                	xchg   %ax,%ax
c0207d1b:	66 90                	xchg   %ax,%ax
c0207d1d:	66 90                	xchg   %ax,%ax
c0207d1f:	66 90                	xchg   %ax,%ax
c0207d21:	66 90                	xchg   %ax,%ax
c0207d23:	66 90                	xchg   %ax,%ax
c0207d25:	66 90                	xchg   %ax,%ax
c0207d27:	66 90                	xchg   %ax,%ax
c0207d29:	66 90                	xchg   %ax,%ax
c0207d2b:	66 90                	xchg   %ax,%ax
c0207d2d:	66 90                	xchg   %ax,%ax
c0207d2f:	66 90                	xchg   %ax,%ax
c0207d31:	66 90                	xchg   %ax,%ax
c0207d33:	66 90                	xchg   %ax,%ax
c0207d35:	66 90                	xchg   %ax,%ax
c0207d37:	66 90                	xchg   %ax,%ax
c0207d39:	66 90                	xchg   %ax,%ax
c0207d3b:	66 90                	xchg   %ax,%ax
c0207d3d:	66 90                	xchg   %ax,%ax
c0207d3f:	66 90                	xchg   %ax,%ax
c0207d41:	66 90                	xchg   %ax,%ax
c0207d43:	66 90                	xchg   %ax,%ax
c0207d45:	66 90                	xchg   %ax,%ax
c0207d47:	66 90                	xchg   %ax,%ax
c0207d49:	66 90                	xchg   %ax,%ax
c0207d4b:	66 90                	xchg   %ax,%ax
c0207d4d:	66 90                	xchg   %ax,%ax
c0207d4f:	66 90                	xchg   %ax,%ax
c0207d51:	66 90                	xchg   %ax,%ax
c0207d53:	66 90                	xchg   %ax,%ax
c0207d55:	66 90                	xchg   %ax,%ax
c0207d57:	66 90                	xchg   %ax,%ax
c0207d59:	66 90                	xchg   %ax,%ax
c0207d5b:	66 90                	xchg   %ax,%ax
c0207d5d:	66 90                	xchg   %ax,%ax
c0207d5f:	66 90                	xchg   %ax,%ax
c0207d61:	66 90                	xchg   %ax,%ax
c0207d63:	66 90                	xchg   %ax,%ax
c0207d65:	66 90                	xchg   %ax,%ax
c0207d67:	66 90                	xchg   %ax,%ax
c0207d69:	66 90                	xchg   %ax,%ax
c0207d6b:	66 90                	xchg   %ax,%ax
c0207d6d:	66 90                	xchg   %ax,%ax
c0207d6f:	66 90                	xchg   %ax,%ax
c0207d71:	66 90                	xchg   %ax,%ax
c0207d73:	66 90                	xchg   %ax,%ax
c0207d75:	66 90                	xchg   %ax,%ax
c0207d77:	66 90                	xchg   %ax,%ax
c0207d79:	66 90                	xchg   %ax,%ax
c0207d7b:	66 90                	xchg   %ax,%ax
c0207d7d:	66 90                	xchg   %ax,%ax
c0207d7f:	66 90                	xchg   %ax,%ax
c0207d81:	66 90                	xchg   %ax,%ax
c0207d83:	66 90                	xchg   %ax,%ax
c0207d85:	66 90                	xchg   %ax,%ax
c0207d87:	66 90                	xchg   %ax,%ax
c0207d89:	66 90                	xchg   %ax,%ax
c0207d8b:	66 90                	xchg   %ax,%ax
c0207d8d:	66 90                	xchg   %ax,%ax
c0207d8f:	66 90                	xchg   %ax,%ax
c0207d91:	66 90                	xchg   %ax,%ax
c0207d93:	66 90                	xchg   %ax,%ax
c0207d95:	66 90                	xchg   %ax,%ax
c0207d97:	66 90                	xchg   %ax,%ax
c0207d99:	66 90                	xchg   %ax,%ax
c0207d9b:	66 90                	xchg   %ax,%ax
c0207d9d:	66 90                	xchg   %ax,%ax
c0207d9f:	66 90                	xchg   %ax,%ax
c0207da1:	66 90                	xchg   %ax,%ax
c0207da3:	66 90                	xchg   %ax,%ax
c0207da5:	66 90                	xchg   %ax,%ax
c0207da7:	66 90                	xchg   %ax,%ax
c0207da9:	66 90                	xchg   %ax,%ax
c0207dab:	66 90                	xchg   %ax,%ax
c0207dad:	66 90                	xchg   %ax,%ax
c0207daf:	66 90                	xchg   %ax,%ax
c0207db1:	66 90                	xchg   %ax,%ax
c0207db3:	66 90                	xchg   %ax,%ax
c0207db5:	66 90                	xchg   %ax,%ax
c0207db7:	66 90                	xchg   %ax,%ax
c0207db9:	66 90                	xchg   %ax,%ax
c0207dbb:	66 90                	xchg   %ax,%ax
c0207dbd:	66 90                	xchg   %ax,%ax
c0207dbf:	66 90                	xchg   %ax,%ax
c0207dc1:	66 90                	xchg   %ax,%ax
c0207dc3:	66 90                	xchg   %ax,%ax
c0207dc5:	66 90                	xchg   %ax,%ax
c0207dc7:	66 90                	xchg   %ax,%ax
c0207dc9:	66 90                	xchg   %ax,%ax
c0207dcb:	66 90                	xchg   %ax,%ax
c0207dcd:	66 90                	xchg   %ax,%ax
c0207dcf:	66 90                	xchg   %ax,%ax
c0207dd1:	66 90                	xchg   %ax,%ax
c0207dd3:	66 90                	xchg   %ax,%ax
c0207dd5:	66 90                	xchg   %ax,%ax
c0207dd7:	66 90                	xchg   %ax,%ax
c0207dd9:	66 90                	xchg   %ax,%ax
c0207ddb:	66 90                	xchg   %ax,%ax
c0207ddd:	66 90                	xchg   %ax,%ax
c0207ddf:	66 90                	xchg   %ax,%ax
c0207de1:	66 90                	xchg   %ax,%ax
c0207de3:	66 90                	xchg   %ax,%ax
c0207de5:	66 90                	xchg   %ax,%ax
c0207de7:	66 90                	xchg   %ax,%ax
c0207de9:	66 90                	xchg   %ax,%ax
c0207deb:	66 90                	xchg   %ax,%ax
c0207ded:	66 90                	xchg   %ax,%ax
c0207def:	66 90                	xchg   %ax,%ax
c0207df1:	66 90                	xchg   %ax,%ax
c0207df3:	66 90                	xchg   %ax,%ax
c0207df5:	66 90                	xchg   %ax,%ax
c0207df7:	66 90                	xchg   %ax,%ax
c0207df9:	66 90                	xchg   %ax,%ax
c0207dfb:	66 90                	xchg   %ax,%ax
c0207dfd:	66 90                	xchg   %ax,%ax
c0207dff:	66 90                	xchg   %ax,%ax
c0207e01:	66 90                	xchg   %ax,%ax
c0207e03:	66 90                	xchg   %ax,%ax
c0207e05:	66 90                	xchg   %ax,%ax
c0207e07:	66 90                	xchg   %ax,%ax
c0207e09:	66 90                	xchg   %ax,%ax
c0207e0b:	66 90                	xchg   %ax,%ax
c0207e0d:	66 90                	xchg   %ax,%ax
c0207e0f:	66 90                	xchg   %ax,%ax
c0207e11:	66 90                	xchg   %ax,%ax
c0207e13:	66 90                	xchg   %ax,%ax
c0207e15:	66 90                	xchg   %ax,%ax
c0207e17:	66 90                	xchg   %ax,%ax
c0207e19:	66 90                	xchg   %ax,%ax
c0207e1b:	66 90                	xchg   %ax,%ax
c0207e1d:	66 90                	xchg   %ax,%ax
c0207e1f:	66 90                	xchg   %ax,%ax
c0207e21:	66 90                	xchg   %ax,%ax
c0207e23:	66 90                	xchg   %ax,%ax
c0207e25:	66 90                	xchg   %ax,%ax
c0207e27:	66 90                	xchg   %ax,%ax
c0207e29:	66 90                	xchg   %ax,%ax
c0207e2b:	66 90                	xchg   %ax,%ax
c0207e2d:	66 90                	xchg   %ax,%ax
c0207e2f:	66 90                	xchg   %ax,%ax
c0207e31:	66 90                	xchg   %ax,%ax
c0207e33:	66 90                	xchg   %ax,%ax
c0207e35:	66 90                	xchg   %ax,%ax
c0207e37:	66 90                	xchg   %ax,%ax
c0207e39:	66 90                	xchg   %ax,%ax
c0207e3b:	66 90                	xchg   %ax,%ax
c0207e3d:	66 90                	xchg   %ax,%ax
c0207e3f:	66 90                	xchg   %ax,%ax
c0207e41:	66 90                	xchg   %ax,%ax
c0207e43:	66 90                	xchg   %ax,%ax
c0207e45:	66 90                	xchg   %ax,%ax
c0207e47:	66 90                	xchg   %ax,%ax
c0207e49:	66 90                	xchg   %ax,%ax
c0207e4b:	66 90                	xchg   %ax,%ax
c0207e4d:	66 90                	xchg   %ax,%ax
c0207e4f:	66 90                	xchg   %ax,%ax
c0207e51:	66 90                	xchg   %ax,%ax
c0207e53:	66 90                	xchg   %ax,%ax
c0207e55:	66 90                	xchg   %ax,%ax
c0207e57:	66 90                	xchg   %ax,%ax
c0207e59:	66 90                	xchg   %ax,%ax
c0207e5b:	66 90                	xchg   %ax,%ax
c0207e5d:	66 90                	xchg   %ax,%ax
c0207e5f:	66 90                	xchg   %ax,%ax
c0207e61:	66 90                	xchg   %ax,%ax
c0207e63:	66 90                	xchg   %ax,%ax
c0207e65:	66 90                	xchg   %ax,%ax
c0207e67:	66 90                	xchg   %ax,%ax
c0207e69:	66 90                	xchg   %ax,%ax
c0207e6b:	66 90                	xchg   %ax,%ax
c0207e6d:	66 90                	xchg   %ax,%ax
c0207e6f:	66 90                	xchg   %ax,%ax
c0207e71:	66 90                	xchg   %ax,%ax
c0207e73:	66 90                	xchg   %ax,%ax
c0207e75:	66 90                	xchg   %ax,%ax
c0207e77:	66 90                	xchg   %ax,%ax
c0207e79:	66 90                	xchg   %ax,%ax
c0207e7b:	66 90                	xchg   %ax,%ax
c0207e7d:	66 90                	xchg   %ax,%ax
c0207e7f:	66 90                	xchg   %ax,%ax
c0207e81:	66 90                	xchg   %ax,%ax
c0207e83:	66 90                	xchg   %ax,%ax
c0207e85:	66 90                	xchg   %ax,%ax
c0207e87:	66 90                	xchg   %ax,%ax
c0207e89:	66 90                	xchg   %ax,%ax
c0207e8b:	66 90                	xchg   %ax,%ax
c0207e8d:	66 90                	xchg   %ax,%ax
c0207e8f:	66 90                	xchg   %ax,%ax
c0207e91:	66 90                	xchg   %ax,%ax
c0207e93:	66 90                	xchg   %ax,%ax
c0207e95:	66 90                	xchg   %ax,%ax
c0207e97:	66 90                	xchg   %ax,%ax
c0207e99:	66 90                	xchg   %ax,%ax
c0207e9b:	66 90                	xchg   %ax,%ax
c0207e9d:	66 90                	xchg   %ax,%ax
c0207e9f:	66 90                	xchg   %ax,%ax
c0207ea1:	66 90                	xchg   %ax,%ax
c0207ea3:	66 90                	xchg   %ax,%ax
c0207ea5:	66 90                	xchg   %ax,%ax
c0207ea7:	66 90                	xchg   %ax,%ax
c0207ea9:	66 90                	xchg   %ax,%ax
c0207eab:	66 90                	xchg   %ax,%ax
c0207ead:	66 90                	xchg   %ax,%ax
c0207eaf:	66 90                	xchg   %ax,%ax
c0207eb1:	66 90                	xchg   %ax,%ax
c0207eb3:	66 90                	xchg   %ax,%ax
c0207eb5:	66 90                	xchg   %ax,%ax
c0207eb7:	66 90                	xchg   %ax,%ax
c0207eb9:	66 90                	xchg   %ax,%ax
c0207ebb:	66 90                	xchg   %ax,%ax
c0207ebd:	66 90                	xchg   %ax,%ax
c0207ebf:	66 90                	xchg   %ax,%ax
c0207ec1:	66 90                	xchg   %ax,%ax
c0207ec3:	66 90                	xchg   %ax,%ax
c0207ec5:	66 90                	xchg   %ax,%ax
c0207ec7:	66 90                	xchg   %ax,%ax
c0207ec9:	66 90                	xchg   %ax,%ax
c0207ecb:	66 90                	xchg   %ax,%ax
c0207ecd:	66 90                	xchg   %ax,%ax
c0207ecf:	66 90                	xchg   %ax,%ax
c0207ed1:	66 90                	xchg   %ax,%ax
c0207ed3:	66 90                	xchg   %ax,%ax
c0207ed5:	66 90                	xchg   %ax,%ax
c0207ed7:	66 90                	xchg   %ax,%ax
c0207ed9:	66 90                	xchg   %ax,%ax
c0207edb:	66 90                	xchg   %ax,%ax
c0207edd:	66 90                	xchg   %ax,%ax
c0207edf:	66 90                	xchg   %ax,%ax
c0207ee1:	66 90                	xchg   %ax,%ax
c0207ee3:	66 90                	xchg   %ax,%ax
c0207ee5:	66 90                	xchg   %ax,%ax
c0207ee7:	66 90                	xchg   %ax,%ax
c0207ee9:	66 90                	xchg   %ax,%ax
c0207eeb:	66 90                	xchg   %ax,%ax
c0207eed:	66 90                	xchg   %ax,%ax
c0207eef:	66 90                	xchg   %ax,%ax
c0207ef1:	66 90                	xchg   %ax,%ax
c0207ef3:	66 90                	xchg   %ax,%ax
c0207ef5:	66 90                	xchg   %ax,%ax
c0207ef7:	66 90                	xchg   %ax,%ax
c0207ef9:	66 90                	xchg   %ax,%ax
c0207efb:	66 90                	xchg   %ax,%ax
c0207efd:	66 90                	xchg   %ax,%ax
c0207eff:	66 90                	xchg   %ax,%ax
c0207f01:	66 90                	xchg   %ax,%ax
c0207f03:	66 90                	xchg   %ax,%ax
c0207f05:	66 90                	xchg   %ax,%ax
c0207f07:	66 90                	xchg   %ax,%ax
c0207f09:	66 90                	xchg   %ax,%ax
c0207f0b:	66 90                	xchg   %ax,%ax
c0207f0d:	66 90                	xchg   %ax,%ax
c0207f0f:	66 90                	xchg   %ax,%ax
c0207f11:	66 90                	xchg   %ax,%ax
c0207f13:	66 90                	xchg   %ax,%ax
c0207f15:	66 90                	xchg   %ax,%ax
c0207f17:	66 90                	xchg   %ax,%ax
c0207f19:	66 90                	xchg   %ax,%ax
c0207f1b:	66 90                	xchg   %ax,%ax
c0207f1d:	66 90                	xchg   %ax,%ax
c0207f1f:	66 90                	xchg   %ax,%ax
c0207f21:	66 90                	xchg   %ax,%ax
c0207f23:	66 90                	xchg   %ax,%ax
c0207f25:	66 90                	xchg   %ax,%ax
c0207f27:	66 90                	xchg   %ax,%ax
c0207f29:	66 90                	xchg   %ax,%ax
c0207f2b:	66 90                	xchg   %ax,%ax
c0207f2d:	66 90                	xchg   %ax,%ax
c0207f2f:	66 90                	xchg   %ax,%ax
c0207f31:	66 90                	xchg   %ax,%ax
c0207f33:	66 90                	xchg   %ax,%ax
c0207f35:	66 90                	xchg   %ax,%ax
c0207f37:	66 90                	xchg   %ax,%ax
c0207f39:	66 90                	xchg   %ax,%ax
c0207f3b:	66 90                	xchg   %ax,%ax
c0207f3d:	66 90                	xchg   %ax,%ax
c0207f3f:	66 90                	xchg   %ax,%ax
c0207f41:	66 90                	xchg   %ax,%ax
c0207f43:	66 90                	xchg   %ax,%ax
c0207f45:	66 90                	xchg   %ax,%ax
c0207f47:	66 90                	xchg   %ax,%ax
c0207f49:	66 90                	xchg   %ax,%ax
c0207f4b:	66 90                	xchg   %ax,%ax
c0207f4d:	66 90                	xchg   %ax,%ax
c0207f4f:	66 90                	xchg   %ax,%ax
c0207f51:	66 90                	xchg   %ax,%ax
c0207f53:	66 90                	xchg   %ax,%ax
c0207f55:	66 90                	xchg   %ax,%ax
c0207f57:	66 90                	xchg   %ax,%ax
c0207f59:	66 90                	xchg   %ax,%ax
c0207f5b:	66 90                	xchg   %ax,%ax
c0207f5d:	66 90                	xchg   %ax,%ax
c0207f5f:	66 90                	xchg   %ax,%ax
c0207f61:	66 90                	xchg   %ax,%ax
c0207f63:	66 90                	xchg   %ax,%ax
c0207f65:	66 90                	xchg   %ax,%ax
c0207f67:	66 90                	xchg   %ax,%ax
c0207f69:	66 90                	xchg   %ax,%ax
c0207f6b:	66 90                	xchg   %ax,%ax
c0207f6d:	66 90                	xchg   %ax,%ax
c0207f6f:	66 90                	xchg   %ax,%ax
c0207f71:	66 90                	xchg   %ax,%ax
c0207f73:	66 90                	xchg   %ax,%ax
c0207f75:	66 90                	xchg   %ax,%ax
c0207f77:	66 90                	xchg   %ax,%ax
c0207f79:	66 90                	xchg   %ax,%ax
c0207f7b:	66 90                	xchg   %ax,%ax
c0207f7d:	66 90                	xchg   %ax,%ax
c0207f7f:	66 90                	xchg   %ax,%ax
c0207f81:	66 90                	xchg   %ax,%ax
c0207f83:	66 90                	xchg   %ax,%ax
c0207f85:	66 90                	xchg   %ax,%ax
c0207f87:	66 90                	xchg   %ax,%ax
c0207f89:	66 90                	xchg   %ax,%ax
c0207f8b:	66 90                	xchg   %ax,%ax
c0207f8d:	66 90                	xchg   %ax,%ax
c0207f8f:	66 90                	xchg   %ax,%ax
c0207f91:	66 90                	xchg   %ax,%ax
c0207f93:	66 90                	xchg   %ax,%ax
c0207f95:	66 90                	xchg   %ax,%ax
c0207f97:	66 90                	xchg   %ax,%ax
c0207f99:	66 90                	xchg   %ax,%ax
c0207f9b:	66 90                	xchg   %ax,%ax
c0207f9d:	66 90                	xchg   %ax,%ax
c0207f9f:	66 90                	xchg   %ax,%ax
c0207fa1:	66 90                	xchg   %ax,%ax
c0207fa3:	66 90                	xchg   %ax,%ax
c0207fa5:	66 90                	xchg   %ax,%ax
c0207fa7:	66 90                	xchg   %ax,%ax
c0207fa9:	66 90                	xchg   %ax,%ax
c0207fab:	66 90                	xchg   %ax,%ax
c0207fad:	66 90                	xchg   %ax,%ax
c0207faf:	66 90                	xchg   %ax,%ax
c0207fb1:	66 90                	xchg   %ax,%ax
c0207fb3:	66 90                	xchg   %ax,%ax
c0207fb5:	66 90                	xchg   %ax,%ax
c0207fb7:	66 90                	xchg   %ax,%ax
c0207fb9:	66 90                	xchg   %ax,%ax
c0207fbb:	66 90                	xchg   %ax,%ax
c0207fbd:	66 90                	xchg   %ax,%ax
c0207fbf:	66 90                	xchg   %ax,%ax
c0207fc1:	66 90                	xchg   %ax,%ax
c0207fc3:	66 90                	xchg   %ax,%ax
c0207fc5:	66 90                	xchg   %ax,%ax
c0207fc7:	66 90                	xchg   %ax,%ax
c0207fc9:	66 90                	xchg   %ax,%ax
c0207fcb:	66 90                	xchg   %ax,%ax
c0207fcd:	66 90                	xchg   %ax,%ax
c0207fcf:	66 90                	xchg   %ax,%ax
c0207fd1:	66 90                	xchg   %ax,%ax
c0207fd3:	66 90                	xchg   %ax,%ax
c0207fd5:	66 90                	xchg   %ax,%ax
c0207fd7:	66 90                	xchg   %ax,%ax
c0207fd9:	66 90                	xchg   %ax,%ax
c0207fdb:	66 90                	xchg   %ax,%ax
c0207fdd:	66 90                	xchg   %ax,%ax
c0207fdf:	66 90                	xchg   %ax,%ax
c0207fe1:	66 90                	xchg   %ax,%ax
c0207fe3:	66 90                	xchg   %ax,%ax
c0207fe5:	66 90                	xchg   %ax,%ax
c0207fe7:	66 90                	xchg   %ax,%ax
c0207fe9:	66 90                	xchg   %ax,%ax
c0207feb:	66 90                	xchg   %ax,%ax
c0207fed:	66 90                	xchg   %ax,%ax
c0207fef:	66 90                	xchg   %ax,%ax
c0207ff1:	66 90                	xchg   %ax,%ax
c0207ff3:	66 90                	xchg   %ax,%ax
c0207ff5:	66 90                	xchg   %ax,%ax
c0207ff7:	66 90                	xchg   %ax,%ax
c0207ff9:	66 90                	xchg   %ax,%ax
c0207ffb:	66 90                	xchg   %ax,%ax
c0207ffd:	66 90                	xchg   %ax,%ax
c0207fff:	90                   	nop

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0208000 <__x86.get_pc_thunk.ax>:
c0208000:	8b 04 24             	mov    (%esp),%eax
c0208003:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c0208004 <__x86.get_pc_thunk.bx>:
c0208004:	8b 1c 24             	mov    (%esp),%ebx
c0208007:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c0208008 <__x86.get_pc_thunk.dx>:
c0208008:	8b 14 24             	mov    (%esp),%edx
c020800b:	c3                   	ret    
