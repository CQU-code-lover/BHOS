
kernel.elf：     文件格式 elf32-i386


Disassembly of section .text:

c0203000 <GDT_BASE>:
	...

c0203008 <CODE_DESC>:
section .text    
[EXTERN kern_entry]
   GDT_BASE:   dd    0x00000000 
           	   dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
c0203008:	ff ff 00 00 00 98 cf 00                             ........

c0203010 <DATA_STACK_DESC>:
               dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
c0203010:	ff ff 00 00 00 92 cf 00                             ........

c0203018 <VIDEO_DESC>:
                     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007        ; limit=(0xbffff-0xb8000)/4k=0x7
c0203018:	07 00 00 80 0b 92 c0 00                             ........

c0203020 <USER_CODE_DESC>:
               dd    DESC_VIDEO_HIGH4  ; 此时dpl为0

    ;---------新增段描述符-----------
    ;用户代码段与数据段
    USER_CODE_DESC: dd 0x0000FFFF
c0203020:	ff ff 00 00 00 f8 cf 00                             ........

c0203028 <USER_DATA_DESC>:
                dd   DESC_USER_CODE_HIGH4

    USER_DATA_DESC: dd 0x0000FFFF
c0203028:	ff ff 00 00 00 f2 cf 00                             ........

c0203030 <total_mem_bytes>:
   SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0     ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
   SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0     ; 同上
   SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0    ; 同上 
   ;SELECTOR_USER_CODE equ (0x004<<3) + TI_GDT + RPL3
   ;SELECTOR_USER_DATA equ (0x005<<3) + TI_GDT + RPL3
   total_mem_bytes dd 0                  
c0203030:	00 00 00 00                                         ....

c0203034 <gdt_ptr>:
   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址
   gdt_ptr  dw  GDT_LIMIT 
c0203034:	2f 00 00 30 20 c0                                   /..0 .

c020303a <boot_start_after_set_paging>:
        	dd  GDT_BASE
;boot开始！
boot_start_after_set_paging:        ;此处修改了函数名     在设置好页表后调用此函数
    mov ebx,[temp_mboot_ptr]     ;此处将暂存的mboot信息取出    但是一定要注意：必须要前4MB的物理-虚拟内存映射才能够使用
c020303a:	8b 1d 0c 00 10 00    	mov    0x10000c,%ebx
    mov [mboot_ptr], ebx ; GRUB加载内核后会将mutiboot信息地址存放在ebx中
c0203040:	89 1d 0c 70 20 c0    	mov    %ebx,0xc020700c
    ;-----------------   准备进入保护模式   -------------------
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1
   ;-----------------  打开A20  ----------------
    in al,0x92
c0203046:	e4 92                	in     $0x92,%al
    or al,0000_0010B
c0203048:	0c 02                	or     $0x2,%al
    out 0x92,al
c020304a:	e6 92                	out    %al,$0x92
   ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]
c020304c:	0f 01 15 34 30 20 c0 	lgdtl  0xc0203034
   ;-----------------  cr0第0位置1  ----------------
    mov eax, cr0
c0203053:	0f 20 c0             	mov    %cr0,%eax
    or eax, 0x00000001
c0203056:	83 c8 01             	or     $0x1,%eax
    mov cr0, eax
c0203059:	0f 22 c0             	mov    %eax,%cr0
    jmp dword SELECTOR_CODE:far_jmp_target      ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
c020305c:	ea 63 30 20 c0 08 00 	ljmp   $0x8,$0xc0203063

c0203063 <far_jmp_target>:

;初始化段寄存器以及栈结构
    far_jmp_target:
    mov ax,SELECTOR_DATA
c0203063:	66 b8 10 00          	mov    $0x10,%ax
    mov ss,ax
c0203067:	8e d0                	mov    %eax,%ss
    mov ds,ax
c0203069:	8e d8                	mov    %eax,%ds
  	mov ax,SELECTOR_VIDEO
c020306b:	66 b8 18 00          	mov    $0x18,%ax
  	mov gs,ax
c020306f:	8e e8                	mov    %eax,%gs
    mov esp, STACK_TOP      
c0203071:	bc 03 10 29 c0       	mov    $0xc0291003,%esp
    and esp, 0xFFFFFFF0  ;16字节对齐
c0203076:	83 e4 f0             	and    $0xfffffff0,%esp
    mov ebp, 0         
c0203079:	bd 00 00 00 00       	mov    $0x0,%ebp
    mov eax,kern_bitmap_block
c020307e:	b8 00 90 20 c0       	mov    $0xc0209000,%eax
    mov [kern_bitmap],eax
c0203083:	a3 08 70 20 c0       	mov    %eax,0xc0207008
    mov eax,kern_dir_table
c0203088:	b8 00 10 10 00       	mov    $0x101000,%eax
    mov [kern_dir_table_paddr],eax
c020308d:	a3 10 70 20 c0       	mov    %eax,0xc0207010
    mov eax,kern_page_table
c0203092:	b8 00 20 10 00       	mov    $0x102000,%eax
    mov [kern_page_table_paddr],eax
c0203097:	a3 14 70 20 c0       	mov    %eax,0xc0207014
;进入内核主函数    
    call kern_entry                    
c020309c:	e8 0e 12 00 00       	call   c02042af <kern_entry>
    jmp dword $          ;防止意外退出内核
c02030a1:	e9 fb ff ff ff       	jmp    c02030a1 <far_jmp_target+0x3e>
c02030a6:	66 90                	xchg   %ax,%ax
c02030a8:	66 90                	xchg   %ax,%ax
c02030aa:	66 90                	xchg   %ax,%ax
c02030ac:	66 90                	xchg   %ax,%ax
c02030ae:	66 90                	xchg   %ax,%ax

c02030b0 <pre_handle>:
%endmacro


[EXTERN int_func_route]
pre_handle:
	pushad               ;压入八个32位
c02030b0:	60                   	pusha  
	mov ecx,[ss:esp+32]
c02030b1:	36 8b 4c 24 20       	mov    %ss:0x20(%esp),%ecx
	mov ebx,eax
c02030b6:	89 c3                	mov    %eax,%ebx
	mov ax,es          ;进入时ss已经被切换了
c02030b8:	66 8c c0             	mov    %es,%ax
	and eax,0x0000FFFF
c02030bb:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030c0:	50                   	push   %eax
	mov ax,fs          
c02030c1:	66 8c e0             	mov    %fs,%ax
	and eax,0x0000FFFF
c02030c4:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030c9:	50                   	push   %eax
	mov ax,gs
c02030ca:	66 8c e8             	mov    %gs,%ax
	and eax,0x0000FFFF
c02030cd:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030d2:	50                   	push   %eax
	mov ax,KERN_DATA_SELECTOR    ;不包含ss
c02030d3:	66 b8 10 00          	mov    $0x10,%ax
	mov es,ax
c02030d7:	8e c0                	mov    %eax,%es
	mov fs,ax
c02030d9:	8e e0                	mov    %eax,%fs
	mov ax,KERN_VGA_SELECTOR
c02030db:	66 b8 18 00          	mov    $0x18,%ax
	mov gs,ax
c02030df:	8e e8                	mov    %eax,%gs
	push ebx     ;传入void *
c02030e1:	53                   	push   %ebx
	push ecx     ;传入int类型中断号
c02030e2:	51                   	push   %ecx
	call int_func_route
c02030e3:	e8 6e 33 00 00       	call   c0206456 <int_func_route>
	add esp,8
c02030e8:	83 c4 08             	add    $0x8,%esp
	pop eax
c02030eb:	58                   	pop    %eax
	mov gs,ax
c02030ec:	8e e8                	mov    %eax,%gs
	pop eax
c02030ee:	58                   	pop    %eax
	mov fs,ax
c02030ef:	8e e0                	mov    %eax,%fs
	pop eax
c02030f1:	58                   	pop    %eax
	mov es,ax
c02030f2:	8e c0                	mov    %eax,%es
	popad
c02030f4:	61                   	popa   
	add esp,8
c02030f5:	83 c4 08             	add    $0x8,%esp
	mov al,0x20
c02030f8:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02030fa:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02030fc:	e6 20                	out    %al,$0x20
	iret
c02030fe:	cf                   	iret   

c02030ff <isr0>:


NO_ERROCODE 0
c02030ff:	89 e0                	mov    %esp,%eax
c0203101:	6a 00                	push   $0x0
c0203103:	6a 00                	push   $0x0
c0203105:	eb a9                	jmp    c02030b0 <pre_handle>

c0203107 <isr1>:
NO_ERROCODE 1
c0203107:	89 e0                	mov    %esp,%eax
c0203109:	6a 00                	push   $0x0
c020310b:	6a 01                	push   $0x1
c020310d:	eb a1                	jmp    c02030b0 <pre_handle>

c020310f <isr2>:
NO_ERROCODE 2
c020310f:	89 e0                	mov    %esp,%eax
c0203111:	6a 00                	push   $0x0
c0203113:	6a 02                	push   $0x2
c0203115:	eb 99                	jmp    c02030b0 <pre_handle>

c0203117 <isr3>:
NO_ERROCODE 3
c0203117:	89 e0                	mov    %esp,%eax
c0203119:	6a 00                	push   $0x0
c020311b:	6a 03                	push   $0x3
c020311d:	eb 91                	jmp    c02030b0 <pre_handle>

c020311f <isr4>:
NO_ERROCODE 4
c020311f:	89 e0                	mov    %esp,%eax
c0203121:	6a 00                	push   $0x0
c0203123:	6a 04                	push   $0x4
c0203125:	eb 89                	jmp    c02030b0 <pre_handle>

c0203127 <isr5>:
NO_ERROCODE 5
c0203127:	89 e0                	mov    %esp,%eax
c0203129:	6a 00                	push   $0x0
c020312b:	6a 05                	push   $0x5
c020312d:	eb 81                	jmp    c02030b0 <pre_handle>

c020312f <isr6>:
NO_ERROCODE 6
c020312f:	89 e0                	mov    %esp,%eax
c0203131:	6a 00                	push   $0x0
c0203133:	6a 06                	push   $0x6
c0203135:	e9 76 ff ff ff       	jmp    c02030b0 <pre_handle>

c020313a <isr7>:
NO_ERROCODE 7
c020313a:	89 e0                	mov    %esp,%eax
c020313c:	6a 00                	push   $0x0
c020313e:	6a 07                	push   $0x7
c0203140:	e9 6b ff ff ff       	jmp    c02030b0 <pre_handle>

c0203145 <isr8>:
HAVE_ERROCODE 8
c0203145:	89 e0                	mov    %esp,%eax
c0203147:	90                   	nop
c0203148:	6a 08                	push   $0x8
c020314a:	e9 61 ff ff ff       	jmp    c02030b0 <pre_handle>

c020314f <isr9>:
NO_ERROCODE 9
c020314f:	89 e0                	mov    %esp,%eax
c0203151:	6a 00                	push   $0x0
c0203153:	6a 09                	push   $0x9
c0203155:	e9 56 ff ff ff       	jmp    c02030b0 <pre_handle>

c020315a <isr10>:
HAVE_ERROCODE 10
c020315a:	89 e0                	mov    %esp,%eax
c020315c:	90                   	nop
c020315d:	6a 0a                	push   $0xa
c020315f:	e9 4c ff ff ff       	jmp    c02030b0 <pre_handle>

c0203164 <isr11>:
HAVE_ERROCODE 11
c0203164:	89 e0                	mov    %esp,%eax
c0203166:	90                   	nop
c0203167:	6a 0b                	push   $0xb
c0203169:	e9 42 ff ff ff       	jmp    c02030b0 <pre_handle>

c020316e <isr12>:
HAVE_ERROCODE 12 
c020316e:	89 e0                	mov    %esp,%eax
c0203170:	90                   	nop
c0203171:	6a 0c                	push   $0xc
c0203173:	e9 38 ff ff ff       	jmp    c02030b0 <pre_handle>

c0203178 <isr13>:
HAVE_ERROCODE 13 
c0203178:	89 e0                	mov    %esp,%eax
c020317a:	90                   	nop
c020317b:	6a 0d                	push   $0xd
c020317d:	e9 2e ff ff ff       	jmp    c02030b0 <pre_handle>

c0203182 <isr14>:
HAVE_ERROCODE 14
c0203182:	89 e0                	mov    %esp,%eax
c0203184:	90                   	nop
c0203185:	6a 0e                	push   $0xe
c0203187:	e9 24 ff ff ff       	jmp    c02030b0 <pre_handle>

c020318c <isr15>:
NO_ERROCODE 15
c020318c:	89 e0                	mov    %esp,%eax
c020318e:	6a 00                	push   $0x0
c0203190:	6a 0f                	push   $0xf
c0203192:	e9 19 ff ff ff       	jmp    c02030b0 <pre_handle>

c0203197 <isr16>:
NO_ERROCODE 16
c0203197:	89 e0                	mov    %esp,%eax
c0203199:	6a 00                	push   $0x0
c020319b:	6a 10                	push   $0x10
c020319d:	e9 0e ff ff ff       	jmp    c02030b0 <pre_handle>

c02031a2 <isr17>:
HAVE_ERROCODE 17
c02031a2:	89 e0                	mov    %esp,%eax
c02031a4:	90                   	nop
c02031a5:	6a 11                	push   $0x11
c02031a7:	e9 04 ff ff ff       	jmp    c02030b0 <pre_handle>

c02031ac <isr18>:
NO_ERROCODE 18
c02031ac:	89 e0                	mov    %esp,%eax
c02031ae:	6a 00                	push   $0x0
c02031b0:	6a 12                	push   $0x12
c02031b2:	e9 f9 fe ff ff       	jmp    c02030b0 <pre_handle>

c02031b7 <isr19>:
NO_ERROCODE 19
c02031b7:	89 e0                	mov    %esp,%eax
c02031b9:	6a 00                	push   $0x0
c02031bb:	6a 13                	push   $0x13
c02031bd:	e9 ee fe ff ff       	jmp    c02030b0 <pre_handle>

c02031c2 <isr20>:

NO_ERROCODE 20
c02031c2:	89 e0                	mov    %esp,%eax
c02031c4:	6a 00                	push   $0x0
c02031c6:	6a 14                	push   $0x14
c02031c8:	e9 e3 fe ff ff       	jmp    c02030b0 <pre_handle>

c02031cd <isr21>:
NO_ERROCODE 21
c02031cd:	89 e0                	mov    %esp,%eax
c02031cf:	6a 00                	push   $0x0
c02031d1:	6a 15                	push   $0x15
c02031d3:	e9 d8 fe ff ff       	jmp    c02030b0 <pre_handle>

c02031d8 <isr22>:
NO_ERROCODE 22
c02031d8:	89 e0                	mov    %esp,%eax
c02031da:	6a 00                	push   $0x0
c02031dc:	6a 16                	push   $0x16
c02031de:	e9 cd fe ff ff       	jmp    c02030b0 <pre_handle>

c02031e3 <isr23>:
NO_ERROCODE 23
c02031e3:	89 e0                	mov    %esp,%eax
c02031e5:	6a 00                	push   $0x0
c02031e7:	6a 17                	push   $0x17
c02031e9:	e9 c2 fe ff ff       	jmp    c02030b0 <pre_handle>

c02031ee <isr24>:
NO_ERROCODE 24
c02031ee:	89 e0                	mov    %esp,%eax
c02031f0:	6a 00                	push   $0x0
c02031f2:	6a 18                	push   $0x18
c02031f4:	e9 b7 fe ff ff       	jmp    c02030b0 <pre_handle>

c02031f9 <isr25>:
NO_ERROCODE 25
c02031f9:	89 e0                	mov    %esp,%eax
c02031fb:	6a 00                	push   $0x0
c02031fd:	6a 19                	push   $0x19
c02031ff:	e9 ac fe ff ff       	jmp    c02030b0 <pre_handle>

c0203204 <isr26>:
NO_ERROCODE 26
c0203204:	89 e0                	mov    %esp,%eax
c0203206:	6a 00                	push   $0x0
c0203208:	6a 1a                	push   $0x1a
c020320a:	e9 a1 fe ff ff       	jmp    c02030b0 <pre_handle>

c020320f <isr27>:
NO_ERROCODE 27
c020320f:	89 e0                	mov    %esp,%eax
c0203211:	6a 00                	push   $0x0
c0203213:	6a 1b                	push   $0x1b
c0203215:	e9 96 fe ff ff       	jmp    c02030b0 <pre_handle>

c020321a <isr28>:
NO_ERROCODE 28
c020321a:	89 e0                	mov    %esp,%eax
c020321c:	6a 00                	push   $0x0
c020321e:	6a 1c                	push   $0x1c
c0203220:	e9 8b fe ff ff       	jmp    c02030b0 <pre_handle>

c0203225 <isr29>:
NO_ERROCODE 29
c0203225:	89 e0                	mov    %esp,%eax
c0203227:	6a 00                	push   $0x0
c0203229:	6a 1d                	push   $0x1d
c020322b:	e9 80 fe ff ff       	jmp    c02030b0 <pre_handle>

c0203230 <isr30>:
NO_ERROCODE 30
c0203230:	89 e0                	mov    %esp,%eax
c0203232:	6a 00                	push   $0x0
c0203234:	6a 1e                	push   $0x1e
c0203236:	e9 75 fe ff ff       	jmp    c02030b0 <pre_handle>

c020323b <isr31>:
NO_ERROCODE 31
c020323b:	89 e0                	mov    %esp,%eax
c020323d:	6a 00                	push   $0x0
c020323f:	6a 1f                	push   $0x1f
c0203241:	e9 6a fe ff ff       	jmp    c02030b0 <pre_handle>

c0203246 <isr32>:
NO_ERROCODE 32
c0203246:	89 e0                	mov    %esp,%eax
c0203248:	6a 00                	push   $0x0
c020324a:	6a 20                	push   $0x20
c020324c:	e9 5f fe ff ff       	jmp    c02030b0 <pre_handle>

c0203251 <load_idt>:


[GLOBAL load_idt]
load_idt:
	mov eax, [esp+4]  ; 参数存入 eax 寄存器
c0203251:	8b 44 24 04          	mov    0x4(%esp),%eax
    lidt [eax]        ; 加载到 IDTR
c0203255:	0f 01 18             	lidtl  (%eax)
    ret
c0203258:	c3                   	ret    

c0203259 <get_cr2>:

[GLOBAL get_cr2]
[GLOBAL _CR2]
get_cr2:
	mov eax,cr2
c0203259:	0f 20 d0             	mov    %cr2,%eax
	mov [_CR2],eax
c020325c:	a3 62 32 20 c0       	mov    %eax,0xc0203262
	ret
c0203261:	c3                   	ret    

c0203262 <_CR2>:
_CR2:
c0203262:	00 00                	add    %al,(%eax)
c0203264:	00 00                	add    %al,(%eax)
c0203266:	66 90                	xchg   %ax,%ax
c0203268:	66 90                	xchg   %ax,%ax
c020326a:	66 90                	xchg   %ax,%ax
c020326c:	66 90                	xchg   %ax,%ax
c020326e:	66 90                	xchg   %ax,%ax

c0203270 <get_esp>:
;内核线程模块的汇编函数文件
[bits 32]
[GLOBAL get_esp]
get_esp:
	mov eax,esp
c0203270:	89 e0                	mov    %esp,%eax
	ret
c0203272:	c3                   	ret    

c0203273 <get_eflags>:
[GLOBAL get_eflags]
get_eflags:
	pushf
c0203273:	9c                   	pushf  
	pop eax
c0203274:	58                   	pop    %eax
	ret
c0203275:	c3                   	ret    

c0203276 <switch_to>:
[GLOBAL switch_to]
switch_to:
	;保存上下文
	mov eax,[esp+4]     ;第一个参数 
c0203276:	8b 44 24 04          	mov    0x4(%esp),%eax
	mov [eax],ebp
c020327a:	89 28                	mov    %ebp,(%eax)
	mov [eax+4],ebx
c020327c:	89 58 04             	mov    %ebx,0x4(%eax)
	mov [eax+8],ecx
c020327f:	89 48 08             	mov    %ecx,0x8(%eax)
	mov [eax+12],edx
c0203282:	89 50 0c             	mov    %edx,0xc(%eax)
	mov [eax+16],esi
c0203285:	89 70 10             	mov    %esi,0x10(%eax)
	mov [eax+20],edi
c0203288:	89 78 14             	mov    %edi,0x14(%eax)
	mov [eax+28],esp
c020328b:	89 60 1c             	mov    %esp,0x1c(%eax)
	push ebx
c020328e:	53                   	push   %ebx
	mov ebx,eax
c020328f:	89 c3                	mov    %eax,%ebx
	pushf
c0203291:	9c                   	pushf  
	pop eax
c0203292:	58                   	pop    %eax
	mov [ebx+24],eax
c0203293:	89 43 18             	mov    %eax,0x18(%ebx)
	mov eax,ebx
c0203296:	89 d8                	mov    %ebx,%eax
	pop ebx
c0203298:	5b                   	pop    %ebx

	;加载上下文
	mov eax,[esp+8]      ;第二个参数
c0203299:	8b 44 24 08          	mov    0x8(%esp),%eax
	mov esp,[eax+28]
c020329d:	8b 60 1c             	mov    0x1c(%eax),%esp
	mov ebp,[eax]
c02032a0:	8b 28                	mov    (%eax),%ebp
	mov ebx,[eax+4]
c02032a2:	8b 58 04             	mov    0x4(%eax),%ebx
	mov ecx,[eax+8]
c02032a5:	8b 48 08             	mov    0x8(%eax),%ecx
	mov edx,[eax+12]
c02032a8:	8b 50 0c             	mov    0xc(%eax),%edx
	mov esi,[eax+16]
c02032ab:	8b 70 10             	mov    0x10(%eax),%esi
	mov edi,[eax+20]
c02032ae:	8b 78 14             	mov    0x14(%eax),%edi
	add eax,24
c02032b1:	83 c0 18             	add    $0x18,%eax
	push dword [eax] ;eflags
c02032b4:	ff 30                	pushl  (%eax)
	popf	
c02032b6:	9d                   	popf   

	;由于8259a设置的手动模式 所以必须给主片与从片发送信号 否则8259a会暂停
	;这个bug找了一下午才找到 顺便吐槽下 内核级的代码debug太难了(GDB在多线程与汇编级会失效 只有print调试法) 
	mov al,0x20         
c02032b7:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02032b9:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02032bb:	e6 20                	out    %al,$0x20
	
	ret                  ;执行下一个函数
c02032bd:	c3                   	ret    

c02032be <move_cursor>:
static uint8_t *video_memory = (uint8_t *)0xC00B8000;
//光标位置
static uint8_t cursor_x = 0;
static uint8_t cursor_y = 0;
static void move_cursor()
{
c02032be:	55                   	push   %ebp
c02032bf:	89 e5                	mov    %esp,%ebp
c02032c1:	53                   	push   %ebx
c02032c2:	83 ec 14             	sub    $0x14,%esp
c02032c5:	e8 3a 3d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02032ca:	81 c3 36 4d 00 00    	add    $0x4d36,%ebx
// 屏幕是 80 字节宽
    uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c02032d0:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c02032d7:	0f b6 d0             	movzbl %al,%edx
c02032da:	89 d0                	mov    %edx,%eax
c02032dc:	c1 e0 02             	shl    $0x2,%eax
c02032df:	01 d0                	add    %edx,%eax
c02032e1:	c1 e0 04             	shl    $0x4,%eax
c02032e4:	89 c2                	mov    %eax,%edx
c02032e6:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c02032ed:	0f b6 c0             	movzbl %al,%eax
c02032f0:	01 d0                	add    %edx,%eax
c02032f2:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    // 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置
    // 的高8位与低8位。
    outb(0x3D4, 14);                    // 告诉 VGA 我们要设置光标的高字节
c02032f6:	83 ec 08             	sub    $0x8,%esp
c02032f9:	6a 0e                	push   $0xe
c02032fb:	68 d4 03 00 00       	push   $0x3d4
c0203300:	e8 46 04 00 00       	call   c020374b <outb>
c0203305:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation >> 8);   // 发送高 8 位
c0203308:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c020330c:	66 c1 e8 08          	shr    $0x8,%ax
c0203310:	0f b6 c0             	movzbl %al,%eax
c0203313:	83 ec 08             	sub    $0x8,%esp
c0203316:	50                   	push   %eax
c0203317:	68 d5 03 00 00       	push   $0x3d5
c020331c:	e8 2a 04 00 00       	call   c020374b <outb>
c0203321:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4, 15);                    // 告诉 VGA 我们要设置光标的低字节
c0203324:	83 ec 08             	sub    $0x8,%esp
c0203327:	6a 0f                	push   $0xf
c0203329:	68 d4 03 00 00       	push   $0x3d4
c020332e:	e8 18 04 00 00       	call   c020374b <outb>
c0203333:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation);        // 发送低 8 位
c0203336:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c020333a:	0f b6 c0             	movzbl %al,%eax
c020333d:	83 ec 08             	sub    $0x8,%esp
c0203340:	50                   	push   %eax
c0203341:	68 d5 03 00 00       	push   $0x3d5
c0203346:	e8 00 04 00 00       	call   c020374b <outb>
c020334b:	83 c4 10             	add    $0x10,%esp
}
c020334e:	90                   	nop
c020334f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203352:	c9                   	leave  
c0203353:	c3                   	ret    

c0203354 <move_cursor_by_XY>:

void move_cursor_by_XY(uint8_t x,uint8_t y){
c0203354:	55                   	push   %ebp
c0203355:	89 e5                	mov    %esp,%ebp
c0203357:	83 ec 18             	sub    $0x18,%esp
c020335a:	e8 a1 3c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020335f:	05 a1 4c 00 00       	add    $0x4ca1,%eax
c0203364:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0203367:	8b 55 0c             	mov    0xc(%ebp),%edx
c020336a:	88 4d f4             	mov    %cl,-0xc(%ebp)
c020336d:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if(x>79||y>24)
c0203370:	80 7d f4 4f          	cmpb   $0x4f,-0xc(%ebp)
c0203374:	77 21                	ja     c0203397 <move_cursor_by_XY+0x43>
c0203376:	80 7d f0 18          	cmpb   $0x18,-0x10(%ebp)
c020337a:	77 1b                	ja     c0203397 <move_cursor_by_XY+0x43>
		return ;
	cursor_x=x;
c020337c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0203380:	88 90 04 90 08 00    	mov    %dl,0x89004(%eax)
	cursor_y=y;
c0203386:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c020338a:	88 90 05 90 08 00    	mov    %dl,0x89005(%eax)
	move_cursor();
c0203390:	e8 29 ff ff ff       	call   c02032be <move_cursor>
c0203395:	eb 01                	jmp    c0203398 <move_cursor_by_XY+0x44>
		return ;
c0203397:	90                   	nop
}
c0203398:	c9                   	leave  
c0203399:	c3                   	ret    

c020339a <clear_screen>:

void clear_screen(){
c020339a:	55                   	push   %ebp
c020339b:	89 e5                	mov    %esp,%ebp
c020339d:	53                   	push   %ebx
c020339e:	83 ec 14             	sub    $0x14,%esp
c02033a1:	e8 5e 3c 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02033a6:	81 c3 5a 4c 00 00    	add    $0x4c5a,%ebx
	cursor_x=0;
c02033ac:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
	cursor_y=0;
c02033b3:	c6 83 05 90 08 00 00 	movb   $0x0,0x89005(%ebx)
	for(int j=0;j<25;j++){
c02033ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02033c1:	eb 28                	jmp    c02033eb <clear_screen+0x51>
		for(int i=0;i<80;i++)
c02033c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c02033ca:	eb 15                	jmp    c02033e1 <clear_screen+0x47>
			vga_putc('\0',black,white);
c02033cc:	83 ec 04             	sub    $0x4,%esp
c02033cf:	6a 0f                	push   $0xf
c02033d1:	6a 00                	push   $0x0
c02033d3:	6a 00                	push   $0x0
c02033d5:	e8 2b 01 00 00       	call   c0203505 <vga_putc>
c02033da:	83 c4 10             	add    $0x10,%esp
		for(int i=0;i<80;i++)
c02033dd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02033e1:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c02033e5:	7e e5                	jle    c02033cc <clear_screen+0x32>
	for(int j=0;j<25;j++){
c02033e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02033eb:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c02033ef:	7e d2                	jle    c02033c3 <clear_screen+0x29>
	}
	cursor_x=0;
c02033f1:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
	cursor_y=0;
c02033f8:	c6 83 05 90 08 00 00 	movb   $0x0,0x89005(%ebx)
	move_cursor();
c02033ff:	e8 ba fe ff ff       	call   c02032be <move_cursor>
}
c0203404:	90                   	nop
c0203405:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203408:	c9                   	leave  
c0203409:	c3                   	ret    

c020340a <screen_uproll_once>:

void screen_uproll_once(){     //光标是会变化的
c020340a:	55                   	push   %ebp
c020340b:	89 e5                	mov    %esp,%ebp
c020340d:	53                   	push   %ebx
c020340e:	83 ec 24             	sub    $0x24,%esp
c0203411:	e8 ea 3b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203416:	05 ea 4b 00 00       	add    $0x4bea,%eax
	for(int j=1;j<25;j++){
c020341b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0203422:	eb 70                	jmp    c0203494 <screen_uproll_once+0x8a>
		for(int i=0;i<80;i++){
c0203424:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020342b:	eb 5d                	jmp    c020348a <screen_uproll_once+0x80>
			uint16_t cursorLocation = j * 80 + i;
c020342d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203430:	89 d1                	mov    %edx,%ecx
c0203432:	89 ca                	mov    %ecx,%edx
c0203434:	c1 e2 02             	shl    $0x2,%edx
c0203437:	01 ca                	add    %ecx,%edx
c0203439:	c1 e2 04             	shl    $0x4,%edx
c020343c:	89 d1                	mov    %edx,%ecx
c020343e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0203441:	01 ca                	add    %ecx,%edx
c0203443:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
			uint16_t targetCursorLocation = (j-1) * 80 + i;
c0203447:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020344a:	83 ea 01             	sub    $0x1,%edx
c020344d:	89 d1                	mov    %edx,%ecx
c020344f:	89 ca                	mov    %ecx,%edx
c0203451:	c1 e2 02             	shl    $0x2,%edx
c0203454:	01 ca                	add    %ecx,%edx
c0203456:	c1 e2 04             	shl    $0x4,%edx
c0203459:	89 d1                	mov    %edx,%ecx
c020345b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c020345e:	01 ca                	add    %ecx,%edx
c0203460:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
			*((uint16_t *)video_memory+targetCursorLocation)=*((uint16_t *)video_memory+cursorLocation);										
c0203464:	8b 90 1c f0 ff ff    	mov    -0xfe4(%eax),%edx
c020346a:	0f b7 4d e8          	movzwl -0x18(%ebp),%ecx
c020346e:	01 c9                	add    %ecx,%ecx
c0203470:	01 ca                	add    %ecx,%edx
c0203472:	8b 88 1c f0 ff ff    	mov    -0xfe4(%eax),%ecx
c0203478:	0f b7 5d e6          	movzwl -0x1a(%ebp),%ebx
c020347c:	01 db                	add    %ebx,%ebx
c020347e:	01 d9                	add    %ebx,%ecx
c0203480:	0f b7 12             	movzwl (%edx),%edx
c0203483:	66 89 11             	mov    %dx,(%ecx)
		for(int i=0;i<80;i++){
c0203486:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020348a:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c020348e:	7e 9d                	jle    c020342d <screen_uproll_once+0x23>
	for(int j=1;j<25;j++){
c0203490:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203494:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0203498:	7e 8a                	jle    c0203424 <screen_uproll_once+0x1a>
		}
	}
	for(int i=0;i<80;i++){
c020349a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c02034a1:	eb 35                	jmp    c02034d8 <screen_uproll_once+0xce>
		uint16_t lastRowCur=24*80+i;
c02034a3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c02034a6:	66 81 c2 80 07       	add    $0x780,%dx
c02034ab:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
		*((char *)video_memory+2*lastRowCur)='\0';
c02034af:	8b 90 1c f0 ff ff    	mov    -0xfe4(%eax),%edx
c02034b5:	0f b7 4d ea          	movzwl -0x16(%ebp),%ecx
c02034b9:	01 c9                	add    %ecx,%ecx
c02034bb:	01 ca                	add    %ecx,%edx
c02034bd:	c6 02 00             	movb   $0x0,(%edx)
		*((char *)video_memory+2*lastRowCur+1)=0x0F;									
c02034c0:	8b 90 1c f0 ff ff    	mov    -0xfe4(%eax),%edx
c02034c6:	0f b7 4d ea          	movzwl -0x16(%ebp),%ecx
c02034ca:	01 c9                	add    %ecx,%ecx
c02034cc:	83 c1 01             	add    $0x1,%ecx
c02034cf:	01 ca                	add    %ecx,%edx
c02034d1:	c6 02 0f             	movb   $0xf,(%edx)
	for(int i=0;i<80;i++){
c02034d4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c02034d8:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
c02034dc:	7e c5                	jle    c02034a3 <screen_uproll_once+0x99>

	}
	if(cursor_y!=0){
c02034de:	0f b6 90 05 90 08 00 	movzbl 0x89005(%eax),%edx
c02034e5:	84 d2                	test   %dl,%dl
c02034e7:	74 15                	je     c02034fe <screen_uproll_once+0xf4>
		cursor_y--;
c02034e9:	0f b6 90 05 90 08 00 	movzbl 0x89005(%eax),%edx
c02034f0:	83 ea 01             	sub    $0x1,%edx
c02034f3:	88 90 05 90 08 00    	mov    %dl,0x89005(%eax)
		move_cursor();
c02034f9:	e8 c0 fd ff ff       	call   c02032be <move_cursor>
	}
}
c02034fe:	90                   	nop
c02034ff:	83 c4 24             	add    $0x24,%esp
c0203502:	5b                   	pop    %ebx
c0203503:	5d                   	pop    %ebp
c0203504:	c3                   	ret    

c0203505 <vga_putc>:
void vga_putc(char input,vga_color_t back,vga_color_t fore){
c0203505:	55                   	push   %ebp
c0203506:	89 e5                	mov    %esp,%ebp
c0203508:	53                   	push   %ebx
c0203509:	83 ec 24             	sub    $0x24,%esp
c020350c:	e8 f3 3a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203511:	81 c3 ef 4a 00 00    	add    $0x4aef,%ebx
c0203517:	8b 45 08             	mov    0x8(%ebp),%eax
c020351a:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c020351d:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c0203524:	0f b6 d0             	movzbl %al,%edx
c0203527:	89 d0                	mov    %edx,%eax
c0203529:	c1 e0 02             	shl    $0x2,%eax
c020352c:	01 d0                	add    %edx,%eax
c020352e:	c1 e0 04             	shl    $0x4,%eax
c0203531:	89 c2                	mov    %eax,%edx
c0203533:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c020353a:	0f b6 c0             	movzbl %al,%eax
c020353d:	01 d0                	add    %edx,%eax
c020353f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	*((char *)video_memory+2*cursorLocation)=input;
c0203543:	8b 83 1c f0 ff ff    	mov    -0xfe4(%ebx),%eax
c0203549:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c020354d:	01 d2                	add    %edx,%edx
c020354f:	01 c2                	add    %eax,%edx
c0203551:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0203555:	88 02                	mov    %al,(%edx)
	*((char *)video_memory+2*cursorLocation+1)=(back<<4)|(fore&0x0F);
c0203557:	8b 45 0c             	mov    0xc(%ebp),%eax
c020355a:	c1 e0 04             	shl    $0x4,%eax
c020355d:	89 c2                	mov    %eax,%edx
c020355f:	8b 45 10             	mov    0x10(%ebp),%eax
c0203562:	83 e0 0f             	and    $0xf,%eax
c0203565:	89 d1                	mov    %edx,%ecx
c0203567:	09 c1                	or     %eax,%ecx
c0203569:	8b 83 1c f0 ff ff    	mov    -0xfe4(%ebx),%eax
c020356f:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0203573:	01 d2                	add    %edx,%edx
c0203575:	83 c2 01             	add    $0x1,%edx
c0203578:	01 d0                	add    %edx,%eax
c020357a:	89 ca                	mov    %ecx,%edx
c020357c:	88 10                	mov    %dl,(%eax)
	if(cursor_x==79){
c020357e:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c0203585:	3c 4f                	cmp    $0x4f,%al
c0203587:	75 39                	jne    c02035c2 <vga_putc+0xbd>
		if(cursor_y==24){
c0203589:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c0203590:	3c 18                	cmp    $0x18,%al
c0203592:	75 15                	jne    c02035a9 <vga_putc+0xa4>
			screen_uproll_once();
c0203594:	e8 71 fe ff ff       	call   c020340a <screen_uproll_once>
			cursor_x=0;
c0203599:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
			cursor_y=24;
c02035a0:	c6 83 05 90 08 00 18 	movb   $0x18,0x89005(%ebx)
c02035a7:	eb 29                	jmp    c02035d2 <vga_putc+0xcd>
		}
		else{
			cursor_x=0;
c02035a9:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
			cursor_y++;
c02035b0:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c02035b7:	83 c0 01             	add    $0x1,%eax
c02035ba:	88 83 05 90 08 00    	mov    %al,0x89005(%ebx)
c02035c0:	eb 10                	jmp    c02035d2 <vga_putc+0xcd>
		}
	}
	else{
		cursor_x++;
c02035c2:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c02035c9:	83 c0 01             	add    $0x1,%eax
c02035cc:	88 83 04 90 08 00    	mov    %al,0x89004(%ebx)
	}
	move_cursor();
c02035d2:	e8 e7 fc ff ff       	call   c02032be <move_cursor>
}
c02035d7:	90                   	nop
c02035d8:	83 c4 24             	add    $0x24,%esp
c02035db:	5b                   	pop    %ebx
c02035dc:	5d                   	pop    %ebp
c02035dd:	c3                   	ret    

c02035de <kputc_color>:
void kputc_color(char input,vga_color_t back,vga_color_t fore){
c02035de:	55                   	push   %ebp
c02035df:	89 e5                	mov    %esp,%ebp
c02035e1:	53                   	push   %ebx
c02035e2:	83 ec 24             	sub    $0x24,%esp
c02035e5:	e8 1a 3a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02035ea:	81 c3 16 4a 00 00    	add    $0x4a16,%ebx
c02035f0:	8b 45 08             	mov    0x8(%ebp),%eax
c02035f3:	88 45 e4             	mov    %al,-0x1c(%ebp)
	switch (input)
c02035f6:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c02035fa:	83 f8 09             	cmp    $0x9,%eax
c02035fd:	74 07                	je     c0203606 <kputc_color+0x28>
c02035ff:	83 f8 0a             	cmp    $0xa,%eax
c0203602:	74 33                	je     c0203637 <kputc_color+0x59>
c0203604:	eb 79                	jmp    c020367f <kputc_color+0xa1>
	{
		case '\t':{
			for(int i=0;i<tab_length;i++)
c0203606:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020360d:	eb 17                	jmp    c0203626 <kputc_color+0x48>
				vga_putc('\0',back,fore);
c020360f:	83 ec 04             	sub    $0x4,%esp
c0203612:	ff 75 10             	pushl  0x10(%ebp)
c0203615:	ff 75 0c             	pushl  0xc(%ebp)
c0203618:	6a 00                	push   $0x0
c020361a:	e8 e6 fe ff ff       	call   c0203505 <vga_putc>
c020361f:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<tab_length;i++)
c0203622:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203626:	0f b6 83 18 f0 ff ff 	movzbl -0xfe8(%ebx),%eax
c020362d:	0f b6 c0             	movzbl %al,%eax
c0203630:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0203633:	7c da                	jl     c020360f <kputc_color+0x31>
			break;
c0203635:	eb 5e                	jmp    c0203695 <kputc_color+0xb7>
		}
		case '\n':{
			uint8_t temp_num = 80-cursor_x;
c0203637:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c020363e:	ba 50 00 00 00       	mov    $0x50,%edx
c0203643:	29 c2                	sub    %eax,%edx
c0203645:	89 d0                	mov    %edx,%eax
c0203647:	88 45 f3             	mov    %al,-0xd(%ebp)
			if(temp_num==0)
c020364a:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c020364e:	75 04                	jne    c0203654 <kputc_color+0x76>
				temp_num=80;
c0203650:	c6 45 f3 50          	movb   $0x50,-0xd(%ebp)
			for(int i=0;i<temp_num;i++)
c0203654:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c020365b:	eb 17                	jmp    c0203674 <kputc_color+0x96>
			vga_putc('\0',back,fore);
c020365d:	83 ec 04             	sub    $0x4,%esp
c0203660:	ff 75 10             	pushl  0x10(%ebp)
c0203663:	ff 75 0c             	pushl  0xc(%ebp)
c0203666:	6a 00                	push   $0x0
c0203668:	e8 98 fe ff ff       	call   c0203505 <vga_putc>
c020366d:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<temp_num;i++)
c0203670:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0203674:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0203678:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c020367b:	7c e0                	jl     c020365d <kputc_color+0x7f>
			break;
c020367d:	eb 16                	jmp    c0203695 <kputc_color+0xb7>
		}
		default:
			vga_putc(input,back,fore);	
c020367f:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0203683:	83 ec 04             	sub    $0x4,%esp
c0203686:	ff 75 10             	pushl  0x10(%ebp)
c0203689:	ff 75 0c             	pushl  0xc(%ebp)
c020368c:	50                   	push   %eax
c020368d:	e8 73 fe ff ff       	call   c0203505 <vga_putc>
c0203692:	83 c4 10             	add    $0x10,%esp
	}
}
c0203695:	90                   	nop
c0203696:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203699:	c9                   	leave  
c020369a:	c3                   	ret    

c020369b <kputc>:

void kputc(char input){
c020369b:	55                   	push   %ebp
c020369c:	89 e5                	mov    %esp,%ebp
c020369e:	83 ec 18             	sub    $0x18,%esp
c02036a1:	e8 5a 39 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02036a6:	05 5a 49 00 00       	add    $0x495a,%eax
c02036ab:	8b 45 08             	mov    0x8(%ebp),%eax
c02036ae:	88 45 f4             	mov    %al,-0xc(%ebp)
	kputc_color(input,black,white);
c02036b1:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c02036b5:	83 ec 04             	sub    $0x4,%esp
c02036b8:	6a 0f                	push   $0xf
c02036ba:	6a 00                	push   $0x0
c02036bc:	50                   	push   %eax
c02036bd:	e8 1c ff ff ff       	call   c02035de <kputc_color>
c02036c2:	83 c4 10             	add    $0x10,%esp
}
c02036c5:	90                   	nop
c02036c6:	c9                   	leave  
c02036c7:	c3                   	ret    

c02036c8 <kputs_color>:

void kputs_color(char * input_str,vga_color_t back,vga_color_t fore){
c02036c8:	55                   	push   %ebp
c02036c9:	89 e5                	mov    %esp,%ebp
c02036cb:	83 ec 18             	sub    $0x18,%esp
c02036ce:	e8 2d 39 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02036d3:	05 2d 49 00 00       	add    $0x492d,%eax
	char * probe=input_str;
c02036d8:	8b 45 08             	mov    0x8(%ebp),%eax
c02036db:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(*probe!='\0')
c02036de:	eb 21                	jmp    c0203701 <kputs_color+0x39>
		kputc_color(*probe++,back,fore);
c02036e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02036e3:	8d 50 01             	lea    0x1(%eax),%edx
c02036e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c02036e9:	0f b6 00             	movzbl (%eax),%eax
c02036ec:	0f be c0             	movsbl %al,%eax
c02036ef:	83 ec 04             	sub    $0x4,%esp
c02036f2:	ff 75 10             	pushl  0x10(%ebp)
c02036f5:	ff 75 0c             	pushl  0xc(%ebp)
c02036f8:	50                   	push   %eax
c02036f9:	e8 e0 fe ff ff       	call   c02035de <kputc_color>
c02036fe:	83 c4 10             	add    $0x10,%esp
	while(*probe!='\0')
c0203701:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203704:	0f b6 00             	movzbl (%eax),%eax
c0203707:	84 c0                	test   %al,%al
c0203709:	75 d5                	jne    c02036e0 <kputs_color+0x18>
}
c020370b:	90                   	nop
c020370c:	c9                   	leave  
c020370d:	c3                   	ret    

c020370e <kputs>:

void kputs(char *input_str){
c020370e:	55                   	push   %ebp
c020370f:	89 e5                	mov    %esp,%ebp
c0203711:	83 ec 08             	sub    $0x8,%esp
c0203714:	e8 e7 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203719:	05 e7 48 00 00       	add    $0x48e7,%eax
	kputs_color(input_str,black,white);
c020371e:	83 ec 04             	sub    $0x4,%esp
c0203721:	6a 0f                	push   $0xf
c0203723:	6a 00                	push   $0x0
c0203725:	ff 75 08             	pushl  0x8(%ebp)
c0203728:	e8 9b ff ff ff       	call   c02036c8 <kputs_color>
c020372d:	83 c4 10             	add    $0x10,%esp
}
c0203730:	90                   	nop
c0203731:	c9                   	leave  
c0203732:	c3                   	ret    

c0203733 <vga_init>:

void vga_init(){
c0203733:	55                   	push   %ebp
c0203734:	89 e5                	mov    %esp,%ebp
c0203736:	83 ec 08             	sub    $0x8,%esp
c0203739:	e8 c2 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020373e:	05 c2 48 00 00       	add    $0x48c2,%eax
	clear_screen();
c0203743:	e8 52 fc ff ff       	call   c020339a <clear_screen>
c0203748:	90                   	nop
c0203749:	c9                   	leave  
c020374a:	c3                   	ret    

c020374b <outb>:
#include "port.h"
// 端口写一个字节
inline void outb(uint16_t port, uint8_t value)
{
c020374b:	55                   	push   %ebp
c020374c:	89 e5                	mov    %esp,%ebp
c020374e:	83 ec 08             	sub    $0x8,%esp
c0203751:	e8 aa 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203756:	05 aa 48 00 00       	add    $0x48aa,%eax
c020375b:	8b 55 08             	mov    0x8(%ebp),%edx
c020375e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203761:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0203765:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
c0203768:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c020376c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0203770:	ee                   	out    %al,(%dx)
}
c0203771:	90                   	nop
c0203772:	c9                   	leave  
c0203773:	c3                   	ret    

c0203774 <inb>:

// 端口读一个字节
inline uint8_t inb(uint16_t port)
{
c0203774:	55                   	push   %ebp
c0203775:	89 e5                	mov    %esp,%ebp
c0203777:	83 ec 14             	sub    $0x14,%esp
c020377a:	e8 81 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020377f:	05 81 48 00 00       	add    $0x4881,%eax
c0203784:	8b 45 08             	mov    0x8(%ebp),%eax
c0203787:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint8_t ret;

    asm volatile("inb %1, %0" : "=a" (ret) : "dN" (port));
c020378b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c020378f:	89 c2                	mov    %eax,%edx
c0203791:	ec                   	in     (%dx),%al
c0203792:	88 45 ff             	mov    %al,-0x1(%ebp)

    return ret;
c0203795:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0203799:	c9                   	leave  
c020379a:	c3                   	ret    

c020379b <inw>:

// 端口读一个字
inline uint16_t inw(uint16_t port)
{
c020379b:	55                   	push   %ebp
c020379c:	89 e5                	mov    %esp,%ebp
c020379e:	83 ec 14             	sub    $0x14,%esp
c02037a1:	e8 5a 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02037a6:	05 5a 48 00 00       	add    $0x485a,%eax
c02037ab:	8b 45 08             	mov    0x8(%ebp),%eax
c02037ae:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint16_t ret;

    asm volatile ("inw %1, %0" : "=a" (ret) : "dN" (port));
c02037b2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c02037b6:	89 c2                	mov    %eax,%edx
c02037b8:	66 ed                	in     (%dx),%ax
c02037ba:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    return ret;
c02037be:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c02037c2:	c9                   	leave  
c02037c3:	c3                   	ret    

c02037c4 <insert_str>:
#include "vga_basic.h"
#include "vargs.h"


void insert_str(char *inserted_str,char *inserting_str,uint32_t offset)  //插入辅助函数
{
c02037c4:	55                   	push   %ebp
c02037c5:	89 e5                	mov    %esp,%ebp
c02037c7:	57                   	push   %edi
c02037c8:	53                   	push   %ebx
c02037c9:	83 ec 70             	sub    $0x70,%esp
c02037cc:	e8 33 38 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02037d1:	81 c3 2f 48 00 00    	add    $0x482f,%ebx
	char m[100]={0};
c02037d7:	8d 55 90             	lea    -0x70(%ebp),%edx
c02037da:	b8 00 00 00 00       	mov    $0x0,%eax
c02037df:	b9 19 00 00 00       	mov    $0x19,%ecx
c02037e4:	89 d7                	mov    %edx,%edi
c02037e6:	f3 ab                	rep stos %eax,%es:(%edi)
	char *afterInsetedPositionStr=m;
c02037e8:	8d 45 90             	lea    -0x70(%ebp),%eax
c02037eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	strcpy(afterInsetedPositionStr,inserted_str+offset+2);
c02037ee:	8b 45 10             	mov    0x10(%ebp),%eax
c02037f1:	8d 50 02             	lea    0x2(%eax),%edx
c02037f4:	8b 45 08             	mov    0x8(%ebp),%eax
c02037f7:	01 d0                	add    %edx,%eax
c02037f9:	83 ec 08             	sub    $0x8,%esp
c02037fc:	50                   	push   %eax
c02037fd:	ff 75 f4             	pushl  -0xc(%ebp)
c0203800:	e8 11 08 00 00       	call   c0204016 <strcpy>
c0203805:	83 c4 10             	add    $0x10,%esp
	memcpy(inserted_str+offset,inserting_str,strlen(inserting_str));
c0203808:	83 ec 0c             	sub    $0xc,%esp
c020380b:	ff 75 0c             	pushl  0xc(%ebp)
c020380e:	e8 d2 07 00 00       	call   c0203fe5 <strlen>
c0203813:	83 c4 10             	add    $0x10,%esp
c0203816:	89 c1                	mov    %eax,%ecx
c0203818:	8b 55 08             	mov    0x8(%ebp),%edx
c020381b:	8b 45 10             	mov    0x10(%ebp),%eax
c020381e:	01 d0                	add    %edx,%eax
c0203820:	83 ec 04             	sub    $0x4,%esp
c0203823:	51                   	push   %ecx
c0203824:	ff 75 0c             	pushl  0xc(%ebp)
c0203827:	50                   	push   %eax
c0203828:	e8 cd 06 00 00       	call   c0203efa <memcpy>
c020382d:	83 c4 10             	add    $0x10,%esp
	*(inserted_str+offset+strlen(inserting_str))='\0';
c0203830:	83 ec 0c             	sub    $0xc,%esp
c0203833:	ff 75 0c             	pushl  0xc(%ebp)
c0203836:	e8 aa 07 00 00       	call   c0203fe5 <strlen>
c020383b:	83 c4 10             	add    $0x10,%esp
c020383e:	89 c2                	mov    %eax,%edx
c0203840:	8b 45 10             	mov    0x10(%ebp),%eax
c0203843:	01 c2                	add    %eax,%edx
c0203845:	8b 45 08             	mov    0x8(%ebp),%eax
c0203848:	01 d0                	add    %edx,%eax
c020384a:	c6 00 00             	movb   $0x0,(%eax)
	strcat(inserted_str,afterInsetedPositionStr);
c020384d:	83 ec 08             	sub    $0x8,%esp
c0203850:	ff 75 f4             	pushl  -0xc(%ebp)
c0203853:	ff 75 08             	pushl  0x8(%ebp)
c0203856:	e8 01 08 00 00       	call   c020405c <strcat>
c020385b:	83 c4 10             	add    $0x10,%esp
	//memcpy(*(inserted_str+offset+1+strlen(inserting_str)),afterInsetedPositionStr,strlen(afterInsetedPositionStr));
	return inserted_str;
c020385e:	90                   	nop
}
c020385f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0203862:	5b                   	pop    %ebx
c0203863:	5f                   	pop    %edi
c0203864:	5d                   	pop    %ebp
c0203865:	c3                   	ret    

c0203866 <printk>:

void printk(char *input_str,...)
{	
c0203866:	55                   	push   %ebp
c0203867:	89 e5                	mov    %esp,%ebp
c0203869:	53                   	push   %ebx
c020386a:	83 ec 34             	sub    $0x34,%esp
c020386d:	e8 92 37 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203872:	81 c3 8e 47 00 00    	add    $0x478e,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0203878:	8d 83 20 90 08 00    	lea    0x89020(%ebx),%eax
c020387e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0203881:	83 ec 08             	sub    $0x8,%esp
c0203884:	ff 75 08             	pushl  0x8(%ebp)
c0203887:	ff 75 f0             	pushl  -0x10(%ebp)
c020388a:	e8 87 07 00 00       	call   c0204016 <strcpy>
c020388f:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0203892:	8d 45 0c             	lea    0xc(%ebp),%eax
c0203895:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0203898:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c020389f:	e9 9e 01 00 00       	jmp    c0203a42 <printk+0x1dc>
	{
		char *charptr=output_str+offset;
c02038a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02038a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02038aa:	01 d0                	add    %edx,%eax
c02038ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c02038af:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02038b2:	0f b6 00             	movzbl (%eax),%eax
c02038b5:	3c 25                	cmp    $0x25,%al
c02038b7:	0f 85 81 01 00 00    	jne    c0203a3e <printk+0x1d8>
		{
			if (*(charptr+1)=='s')
c02038bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02038c0:	83 c0 01             	add    $0x1,%eax
c02038c3:	0f b6 00             	movzbl (%eax),%eax
c02038c6:	3c 73                	cmp    $0x73,%al
c02038c8:	75 43                	jne    c020390d <printk+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c02038ca:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02038cd:	8d 50 04             	lea    0x4(%eax),%edx
c02038d0:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02038d3:	8b 00                	mov    (%eax),%eax
c02038d5:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c02038d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02038db:	83 ec 04             	sub    $0x4,%esp
c02038de:	50                   	push   %eax
c02038df:	ff 75 d0             	pushl  -0x30(%ebp)
c02038e2:	ff 75 f0             	pushl  -0x10(%ebp)
c02038e5:	e8 da fe ff ff       	call   c02037c4 <insert_str>
c02038ea:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c02038ed:	83 ec 0c             	sub    $0xc,%esp
c02038f0:	ff 75 d0             	pushl  -0x30(%ebp)
c02038f3:	e8 ed 06 00 00       	call   c0203fe5 <strlen>
c02038f8:	83 c4 10             	add    $0x10,%esp
c02038fb:	89 c2                	mov    %eax,%edx
c02038fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203900:	01 d0                	add    %edx,%eax
c0203902:	83 e8 01             	sub    $0x1,%eax
c0203905:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203908:	e9 31 01 00 00       	jmp    c0203a3e <printk+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c020390d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203910:	83 c0 01             	add    $0x1,%eax
c0203913:	0f b6 00             	movzbl (%eax),%eax
c0203916:	3c 64                	cmp    $0x64,%al
c0203918:	75 55                	jne    c020396f <printk+0x109>
			{
				int arg_int=va_arg(ptr,int);
c020391a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020391d:	8d 50 04             	lea    0x4(%eax),%edx
c0203920:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203923:	8b 00                	mov    (%eax),%eax
c0203925:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0203928:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020392b:	83 ec 0c             	sub    $0xc,%esp
c020392e:	50                   	push   %eax
c020392f:	e8 61 07 00 00       	call   c0204095 <uintTostring>
c0203934:	83 c4 10             	add    $0x10,%esp
c0203937:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c020393a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020393d:	83 ec 04             	sub    $0x4,%esp
c0203940:	50                   	push   %eax
c0203941:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203944:	ff 75 f0             	pushl  -0x10(%ebp)
c0203947:	e8 78 fe ff ff       	call   c02037c4 <insert_str>
c020394c:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c020394f:	83 ec 0c             	sub    $0xc,%esp
c0203952:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203955:	e8 8b 06 00 00       	call   c0203fe5 <strlen>
c020395a:	83 c4 10             	add    $0x10,%esp
c020395d:	89 c2                	mov    %eax,%edx
c020395f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203962:	01 d0                	add    %edx,%eax
c0203964:	83 e8 01             	sub    $0x1,%eax
c0203967:	89 45 f4             	mov    %eax,-0xc(%ebp)
c020396a:	e9 cf 00 00 00       	jmp    c0203a3e <printk+0x1d8>
			}
			else if(*(charptr+1)=='c')
c020396f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203972:	83 c0 01             	add    $0x1,%eax
c0203975:	0f b6 00             	movzbl (%eax),%eax
c0203978:	3c 63                	cmp    $0x63,%al
c020397a:	0f 84 be 00 00 00    	je     c0203a3e <printk+0x1d8>
			{
				;
			}
			else if(*(charptr+1)=='H')
c0203980:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203983:	83 c0 01             	add    $0x1,%eax
c0203986:	0f b6 00             	movzbl (%eax),%eax
c0203989:	3c 48                	cmp    $0x48,%al
c020398b:	75 53                	jne    c02039e0 <printk+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c020398d:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203990:	8d 50 04             	lea    0x4(%eax),%edx
c0203993:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203996:	8b 00                	mov    (%eax),%eax
c0203998:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c020399b:	83 ec 08             	sub    $0x8,%esp
c020399e:	6a 01                	push   $0x1
c02039a0:	ff 75 e0             	pushl  -0x20(%ebp)
c02039a3:	e8 2c 04 00 00       	call   c0203dd4 <num2hexstr>
c02039a8:	83 c4 10             	add    $0x10,%esp
c02039ab:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c02039ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02039b1:	83 ec 04             	sub    $0x4,%esp
c02039b4:	50                   	push   %eax
c02039b5:	ff 75 dc             	pushl  -0x24(%ebp)
c02039b8:	ff 75 f0             	pushl  -0x10(%ebp)
c02039bb:	e8 04 fe ff ff       	call   c02037c4 <insert_str>
c02039c0:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c02039c3:	83 ec 0c             	sub    $0xc,%esp
c02039c6:	ff 75 dc             	pushl  -0x24(%ebp)
c02039c9:	e8 17 06 00 00       	call   c0203fe5 <strlen>
c02039ce:	83 c4 10             	add    $0x10,%esp
c02039d1:	89 c2                	mov    %eax,%edx
c02039d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02039d6:	01 d0                	add    %edx,%eax
c02039d8:	83 e8 01             	sub    $0x1,%eax
c02039db:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02039de:	eb 5e                	jmp    c0203a3e <printk+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c02039e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02039e3:	83 c0 01             	add    $0x1,%eax
c02039e6:	0f b6 00             	movzbl (%eax),%eax
c02039e9:	3c 68                	cmp    $0x68,%al
c02039eb:	75 51                	jne    c0203a3e <printk+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c02039ed:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02039f0:	8d 50 04             	lea    0x4(%eax),%edx
c02039f3:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02039f6:	8b 00                	mov    (%eax),%eax
c02039f8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c02039fb:	83 ec 08             	sub    $0x8,%esp
c02039fe:	6a 00                	push   $0x0
c0203a00:	ff 75 e8             	pushl  -0x18(%ebp)
c0203a03:	e8 cc 03 00 00       	call   c0203dd4 <num2hexstr>
c0203a08:	83 c4 10             	add    $0x10,%esp
c0203a0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a11:	83 ec 04             	sub    $0x4,%esp
c0203a14:	50                   	push   %eax
c0203a15:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a18:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a1b:	e8 a4 fd ff ff       	call   c02037c4 <insert_str>
c0203a20:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203a23:	83 ec 0c             	sub    $0xc,%esp
c0203a26:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a29:	e8 b7 05 00 00       	call   c0203fe5 <strlen>
c0203a2e:	83 c4 10             	add    $0x10,%esp
c0203a31:	89 c2                	mov    %eax,%edx
c0203a33:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a36:	01 d0                	add    %edx,%eax
c0203a38:	83 e8 01             	sub    $0x1,%eax
c0203a3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203a3e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203a42:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203a45:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203a48:	01 d0                	add    %edx,%eax
c0203a4a:	0f b6 00             	movzbl (%eax),%eax
c0203a4d:	84 c0                	test   %al,%al
c0203a4f:	0f 85 4f fe ff ff    	jne    c02038a4 <printk+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs(output_str);
c0203a55:	83 ec 0c             	sub    $0xc,%esp
c0203a58:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a5b:	e8 ae fc ff ff       	call   c020370e <kputs>
c0203a60:	83 c4 10             	add    $0x10,%esp
}
c0203a63:	90                   	nop
c0203a64:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203a67:	c9                   	leave  
c0203a68:	c3                   	ret    

c0203a69 <printbasic>:


//输入uint32_t或者char*  使用%d或者%s
//wdnmd 这个可变参有问题！！
void printbasic(char *format_str,char *m)
{
c0203a69:	55                   	push   %ebp
c0203a6a:	89 e5                	mov    %esp,%ebp
c0203a6c:	83 ec 18             	sub    $0x18,%esp
c0203a6f:	e8 8c 35 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203a74:	05 8c 45 00 00       	add    $0x458c,%eax
	//va_list ptr_start=NULL;
	char *formatStr=format_str;
c0203a79:	8b 45 08             	mov    0x8(%ebp),%eax
c0203a7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//va_start(ptr_start,format_str);
	//kputs_color(va_arg(ptr_start,char *), rc_black, rc_green);	
	int i=0;
c0203a7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0203a86:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203a89:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0203a8c:	eb 3a                	jmp    c0203ac8 <printbasic+0x5f>
	{
		if (*(head+i)=='%'){
c0203a8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203a91:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203a94:	01 d0                	add    %edx,%eax
c0203a96:	0f b6 00             	movzbl (%eax),%eax
c0203a99:	3c 25                	cmp    $0x25,%al
c0203a9b:	75 27                	jne    c0203ac4 <printbasic+0x5b>
			if(*(head+i+1)=='s')
c0203a9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203aa0:	8d 50 01             	lea    0x1(%eax),%edx
c0203aa3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203aa6:	01 d0                	add    %edx,%eax
c0203aa8:	0f b6 00             	movzbl (%eax),%eax
c0203aab:	3c 73                	cmp    $0x73,%al
c0203aad:	75 15                	jne    c0203ac4 <printbasic+0x5b>
			{
				//char *str_head=va_arg(&ptr_start,char*);
				insert_str(format_str,m,i);
c0203aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203ab2:	83 ec 04             	sub    $0x4,%esp
c0203ab5:	50                   	push   %eax
c0203ab6:	ff 75 0c             	pushl  0xc(%ebp)
c0203ab9:	ff 75 08             	pushl  0x8(%ebp)
c0203abc:	e8 03 fd ff ff       	call   c02037c4 <insert_str>
c0203ac1:	83 c4 10             	add    $0x10,%esp
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0203ac4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203ac8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203acb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203ace:	01 d0                	add    %edx,%eax
c0203ad0:	0f b6 00             	movzbl (%eax),%eax
c0203ad3:	84 c0                	test   %al,%al
c0203ad5:	75 b7                	jne    c0203a8e <printbasic+0x25>
			else;
		}
	}
	//kputs_color(formatStr, black, white);
	
}
c0203ad7:	90                   	nop
c0203ad8:	c9                   	leave  
c0203ad9:	c3                   	ret    

c0203ada <printk_color>:



void printk_color(char *input_str,vga_color_t back,vga_color_t fore,...)
{
c0203ada:	55                   	push   %ebp
c0203adb:	89 e5                	mov    %esp,%ebp
c0203add:	53                   	push   %ebx
c0203ade:	83 ec 34             	sub    $0x34,%esp
c0203ae1:	e8 1e 35 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203ae6:	81 c3 1a 45 00 00    	add    $0x451a,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0203aec:	8d 83 a0 90 08 00    	lea    0x890a0(%ebx),%eax
c0203af2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0203af5:	83 ec 08             	sub    $0x8,%esp
c0203af8:	ff 75 08             	pushl  0x8(%ebp)
c0203afb:	ff 75 f0             	pushl  -0x10(%ebp)
c0203afe:	e8 13 05 00 00       	call   c0204016 <strcpy>
c0203b03:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0203b06:	8d 45 14             	lea    0x14(%ebp),%eax
c0203b09:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0203b0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203b13:	e9 9e 01 00 00       	jmp    c0203cb6 <printk_color+0x1dc>
	{
		char *charptr=output_str+offset;
c0203b18:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203b1e:	01 d0                	add    %edx,%eax
c0203b20:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c0203b23:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b26:	0f b6 00             	movzbl (%eax),%eax
c0203b29:	3c 25                	cmp    $0x25,%al
c0203b2b:	0f 85 81 01 00 00    	jne    c0203cb2 <printk_color+0x1d8>
		{
			if (*(charptr+1)=='s')
c0203b31:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b34:	83 c0 01             	add    $0x1,%eax
c0203b37:	0f b6 00             	movzbl (%eax),%eax
c0203b3a:	3c 73                	cmp    $0x73,%al
c0203b3c:	75 43                	jne    c0203b81 <printk_color+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c0203b3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203b41:	8d 50 04             	lea    0x4(%eax),%edx
c0203b44:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203b47:	8b 00                	mov    (%eax),%eax
c0203b49:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c0203b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b4f:	83 ec 04             	sub    $0x4,%esp
c0203b52:	50                   	push   %eax
c0203b53:	ff 75 d0             	pushl  -0x30(%ebp)
c0203b56:	ff 75 f0             	pushl  -0x10(%ebp)
c0203b59:	e8 66 fc ff ff       	call   c02037c4 <insert_str>
c0203b5e:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c0203b61:	83 ec 0c             	sub    $0xc,%esp
c0203b64:	ff 75 d0             	pushl  -0x30(%ebp)
c0203b67:	e8 79 04 00 00       	call   c0203fe5 <strlen>
c0203b6c:	83 c4 10             	add    $0x10,%esp
c0203b6f:	89 c2                	mov    %eax,%edx
c0203b71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b74:	01 d0                	add    %edx,%eax
c0203b76:	83 e8 01             	sub    $0x1,%eax
c0203b79:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203b7c:	e9 31 01 00 00       	jmp    c0203cb2 <printk_color+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c0203b81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b84:	83 c0 01             	add    $0x1,%eax
c0203b87:	0f b6 00             	movzbl (%eax),%eax
c0203b8a:	3c 64                	cmp    $0x64,%al
c0203b8c:	75 55                	jne    c0203be3 <printk_color+0x109>
			{
				int arg_int=va_arg(ptr,int);
c0203b8e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203b91:	8d 50 04             	lea    0x4(%eax),%edx
c0203b94:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203b97:	8b 00                	mov    (%eax),%eax
c0203b99:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0203b9c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0203b9f:	83 ec 0c             	sub    $0xc,%esp
c0203ba2:	50                   	push   %eax
c0203ba3:	e8 ed 04 00 00       	call   c0204095 <uintTostring>
c0203ba8:	83 c4 10             	add    $0x10,%esp
c0203bab:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c0203bae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203bb1:	83 ec 04             	sub    $0x4,%esp
c0203bb4:	50                   	push   %eax
c0203bb5:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203bb8:	ff 75 f0             	pushl  -0x10(%ebp)
c0203bbb:	e8 04 fc ff ff       	call   c02037c4 <insert_str>
c0203bc0:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c0203bc3:	83 ec 0c             	sub    $0xc,%esp
c0203bc6:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203bc9:	e8 17 04 00 00       	call   c0203fe5 <strlen>
c0203bce:	83 c4 10             	add    $0x10,%esp
c0203bd1:	89 c2                	mov    %eax,%edx
c0203bd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203bd6:	01 d0                	add    %edx,%eax
c0203bd8:	83 e8 01             	sub    $0x1,%eax
c0203bdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203bde:	e9 cf 00 00 00       	jmp    c0203cb2 <printk_color+0x1d8>
			}
			else if(*(charptr+1)=='c')
c0203be3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203be6:	83 c0 01             	add    $0x1,%eax
c0203be9:	0f b6 00             	movzbl (%eax),%eax
c0203bec:	3c 63                	cmp    $0x63,%al
c0203bee:	0f 84 be 00 00 00    	je     c0203cb2 <printk_color+0x1d8>
			{
			
			}
			else if(*(charptr+1)=='H')
c0203bf4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203bf7:	83 c0 01             	add    $0x1,%eax
c0203bfa:	0f b6 00             	movzbl (%eax),%eax
c0203bfd:	3c 48                	cmp    $0x48,%al
c0203bff:	75 53                	jne    c0203c54 <printk_color+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c0203c01:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203c04:	8d 50 04             	lea    0x4(%eax),%edx
c0203c07:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203c0a:	8b 00                	mov    (%eax),%eax
c0203c0c:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c0203c0f:	83 ec 08             	sub    $0x8,%esp
c0203c12:	6a 01                	push   $0x1
c0203c14:	ff 75 e0             	pushl  -0x20(%ebp)
c0203c17:	e8 b8 01 00 00       	call   c0203dd4 <num2hexstr>
c0203c1c:	83 c4 10             	add    $0x10,%esp
c0203c1f:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c25:	83 ec 04             	sub    $0x4,%esp
c0203c28:	50                   	push   %eax
c0203c29:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c2c:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c2f:	e8 90 fb ff ff       	call   c02037c4 <insert_str>
c0203c34:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203c37:	83 ec 0c             	sub    $0xc,%esp
c0203c3a:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c3d:	e8 a3 03 00 00       	call   c0203fe5 <strlen>
c0203c42:	83 c4 10             	add    $0x10,%esp
c0203c45:	89 c2                	mov    %eax,%edx
c0203c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c4a:	01 d0                	add    %edx,%eax
c0203c4c:	83 e8 01             	sub    $0x1,%eax
c0203c4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203c52:	eb 5e                	jmp    c0203cb2 <printk_color+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c0203c54:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203c57:	83 c0 01             	add    $0x1,%eax
c0203c5a:	0f b6 00             	movzbl (%eax),%eax
c0203c5d:	3c 68                	cmp    $0x68,%al
c0203c5f:	75 51                	jne    c0203cb2 <printk_color+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c0203c61:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203c64:	8d 50 04             	lea    0x4(%eax),%edx
c0203c67:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203c6a:	8b 00                	mov    (%eax),%eax
c0203c6c:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c0203c6f:	83 ec 08             	sub    $0x8,%esp
c0203c72:	6a 00                	push   $0x0
c0203c74:	ff 75 e8             	pushl  -0x18(%ebp)
c0203c77:	e8 58 01 00 00       	call   c0203dd4 <num2hexstr>
c0203c7c:	83 c4 10             	add    $0x10,%esp
c0203c7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203c82:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c85:	83 ec 04             	sub    $0x4,%esp
c0203c88:	50                   	push   %eax
c0203c89:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203c8c:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c8f:	e8 30 fb ff ff       	call   c02037c4 <insert_str>
c0203c94:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203c97:	83 ec 0c             	sub    $0xc,%esp
c0203c9a:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203c9d:	e8 43 03 00 00       	call   c0203fe5 <strlen>
c0203ca2:	83 c4 10             	add    $0x10,%esp
c0203ca5:	89 c2                	mov    %eax,%edx
c0203ca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203caa:	01 d0                	add    %edx,%eax
c0203cac:	83 e8 01             	sub    $0x1,%eax
c0203caf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203cb2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203cb6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203cb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203cbc:	01 d0                	add    %edx,%eax
c0203cbe:	0f b6 00             	movzbl (%eax),%eax
c0203cc1:	84 c0                	test   %al,%al
c0203cc3:	0f 85 4f fe ff ff    	jne    c0203b18 <printk_color+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs_color(output_str,back,fore);
c0203cc9:	83 ec 04             	sub    $0x4,%esp
c0203ccc:	ff 75 10             	pushl  0x10(%ebp)
c0203ccf:	ff 75 0c             	pushl  0xc(%ebp)
c0203cd2:	ff 75 f0             	pushl  -0x10(%ebp)
c0203cd5:	e8 ee f9 ff ff       	call   c02036c8 <kputs_color>
c0203cda:	83 c4 10             	add    $0x10,%esp
}
c0203cdd:	90                   	nop
c0203cde:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ce1:	c9                   	leave  
c0203ce2:	c3                   	ret    

c0203ce3 <printkDebug>:

void printkDebug(){
c0203ce3:	55                   	push   %ebp
c0203ce4:	89 e5                	mov    %esp,%ebp
c0203ce6:	53                   	push   %ebx
c0203ce7:	83 ec 04             	sub    $0x4,%esp
c0203cea:	e8 15 33 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203cef:	81 c3 11 43 00 00    	add    $0x4311,%ebx
	printk("wkawda----");
c0203cf5:	83 ec 0c             	sub    $0xc,%esp
c0203cf8:	8d 83 0c 00 00 00    	lea    0xc(%ebx),%eax
c0203cfe:	50                   	push   %eax
c0203cff:	e8 62 fb ff ff       	call   c0203866 <printk>
c0203d04:	83 c4 10             	add    $0x10,%esp
	printk_color("wkdaowd",black,white);
c0203d07:	83 ec 04             	sub    $0x4,%esp
c0203d0a:	6a 0f                	push   $0xf
c0203d0c:	6a 00                	push   $0x0
c0203d0e:	8d 83 17 00 00 00    	lea    0x17(%ebx),%eax
c0203d14:	50                   	push   %eax
c0203d15:	e8 c0 fd ff ff       	call   c0203ada <printk_color>
c0203d1a:	83 c4 10             	add    $0x10,%esp
c0203d1d:	90                   	nop
c0203d1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203d21:	c9                   	leave  
c0203d22:	c3                   	ret    

c0203d23 <func>:
#include "string.h"

//进制转换的辅助函数
static int func(char *s,int n,uint32_t i)          //n表示输入的数 i表示转化的进制
{
c0203d23:	55                   	push   %ebp
c0203d24:	89 e5                	mov    %esp,%ebp
c0203d26:	83 ec 28             	sub    $0x28,%esp
c0203d29:	e8 d2 32 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203d2e:	05 d2 42 00 00       	add    $0x42d2,%eax
    char bit[]={"0123456789ABCDEF"};
c0203d33:	c7 45 e3 30 31 32 33 	movl   $0x33323130,-0x1d(%ebp)
c0203d3a:	c7 45 e7 34 35 36 37 	movl   $0x37363534,-0x19(%ebp)
c0203d41:	c7 45 eb 38 39 41 42 	movl   $0x42413938,-0x15(%ebp)
c0203d48:	c7 45 ef 43 44 45 46 	movl   $0x46454443,-0x11(%ebp)
c0203d4f:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int len;
    if(n==0)
c0203d53:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203d57:	75 1c                	jne    c0203d75 <func+0x52>
    {
        strcpy(s,"");
c0203d59:	83 ec 08             	sub    $0x8,%esp
c0203d5c:	8d 80 1f 00 00 00    	lea    0x1f(%eax),%eax
c0203d62:	50                   	push   %eax
c0203d63:	ff 75 08             	pushl  0x8(%ebp)
c0203d66:	e8 ab 02 00 00       	call   c0204016 <strcpy>
c0203d6b:	83 c4 10             	add    $0x10,%esp
        return 0;
c0203d6e:	b8 00 00 00 00       	mov    $0x0,%eax
c0203d73:	eb 5d                	jmp    c0203dd2 <func+0xaf>
    }
    func(s,n/i,i);
c0203d75:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203d78:	ba 00 00 00 00       	mov    $0x0,%edx
c0203d7d:	f7 75 10             	divl   0x10(%ebp)
c0203d80:	83 ec 04             	sub    $0x4,%esp
c0203d83:	ff 75 10             	pushl  0x10(%ebp)
c0203d86:	50                   	push   %eax
c0203d87:	ff 75 08             	pushl  0x8(%ebp)
c0203d8a:	e8 94 ff ff ff       	call   c0203d23 <func>
c0203d8f:	83 c4 10             	add    $0x10,%esp
    len=strlen(s);
c0203d92:	83 ec 0c             	sub    $0xc,%esp
c0203d95:	ff 75 08             	pushl  0x8(%ebp)
c0203d98:	e8 48 02 00 00       	call   c0203fe5 <strlen>
c0203d9d:	83 c4 10             	add    $0x10,%esp
c0203da0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    s[len]=bit[n%i];
c0203da3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203da6:	ba 00 00 00 00       	mov    $0x0,%edx
c0203dab:	f7 75 10             	divl   0x10(%ebp)
c0203dae:	89 d1                	mov    %edx,%ecx
c0203db0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203db3:	8b 45 08             	mov    0x8(%ebp),%eax
c0203db6:	01 c2                	add    %eax,%edx
c0203db8:	0f b6 44 0d e3       	movzbl -0x1d(%ebp,%ecx,1),%eax
c0203dbd:	88 02                	mov    %al,(%edx)
    s[len+1]='\0';
c0203dbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203dc2:	8d 50 01             	lea    0x1(%eax),%edx
c0203dc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0203dc8:	01 d0                	add    %edx,%eax
c0203dca:	c6 00 00             	movb   $0x0,(%eax)
    return 1;
c0203dcd:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0203dd2:	c9                   	leave  
c0203dd3:	c3                   	ret    

c0203dd4 <num2hexstr>:

//32位的16进制数 使用0x+8位字符表示+\0   共11位字符
inline char *num2hexstr(int number,int need0x)
{	if (number!=0)
c0203dd4:	55                   	push   %ebp
c0203dd5:	89 e5                	mov    %esp,%ebp
c0203dd7:	53                   	push   %ebx
c0203dd8:	83 ec 34             	sub    $0x34,%esp
c0203ddb:	e8 24 32 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203de0:	81 c3 20 42 00 00    	add    $0x4220,%ebx
c0203de6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0203dea:	0f 84 f1 00 00 00    	je     c0203ee1 <num2hexstr+0x10d>
	{
	static char static_hexstr[11]={0};
	static_hexstr[0]='0';
c0203df0:	c6 83 20 91 08 00 30 	movb   $0x30,0x89120(%ebx)
	static_hexstr[1]='x';
c0203df7:	c6 83 21 91 08 00 78 	movb   $0x78,0x89121(%ebx)
	char temp_arry[9]={0};
c0203dfe:	c7 45 df 00 00 00 00 	movl   $0x0,-0x21(%ebp)
c0203e05:	c7 45 e3 00 00 00 00 	movl   $0x0,-0x1d(%ebp)
c0203e0c:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	char *temp_arry_ptr=temp_arry;
c0203e10:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203e13:	89 45 f0             	mov    %eax,-0x10(%ebp)
	func(temp_arry_ptr,number,16);
c0203e16:	83 ec 04             	sub    $0x4,%esp
c0203e19:	6a 10                	push   $0x10
c0203e1b:	ff 75 08             	pushl  0x8(%ebp)
c0203e1e:	ff 75 f0             	pushl  -0x10(%ebp)
c0203e21:	e8 fd fe ff ff       	call   c0203d23 <func>
c0203e26:	83 c4 10             	add    $0x10,%esp
	char temp_arry2[9]={0};
c0203e29:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
c0203e30:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
c0203e37:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	char *temp_arry2_ptr=temp_arry2;
c0203e3b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0203e3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	strcpy(temp_arry2_ptr,temp_arry_ptr);
c0203e41:	83 ec 08             	sub    $0x8,%esp
c0203e44:	ff 75 f0             	pushl  -0x10(%ebp)
c0203e47:	ff 75 ec             	pushl  -0x14(%ebp)
c0203e4a:	e8 c7 01 00 00       	call   c0204016 <strcpy>
c0203e4f:	83 c4 10             	add    $0x10,%esp
	int offset=8-strlen(temp_arry);
c0203e52:	83 ec 0c             	sub    $0xc,%esp
c0203e55:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203e58:	50                   	push   %eax
c0203e59:	e8 87 01 00 00       	call   c0203fe5 <strlen>
c0203e5e:	83 c4 10             	add    $0x10,%esp
c0203e61:	ba 08 00 00 00       	mov    $0x8,%edx
c0203e66:	29 c2                	sub    %eax,%edx
c0203e68:	89 d0                	mov    %edx,%eax
c0203e6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	strcpy(temp_arry+offset,temp_arry2);
c0203e6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203e70:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203e73:	01 c2                	add    %eax,%edx
c0203e75:	83 ec 08             	sub    $0x8,%esp
c0203e78:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0203e7b:	50                   	push   %eax
c0203e7c:	52                   	push   %edx
c0203e7d:	e8 94 01 00 00       	call   c0204016 <strcpy>
c0203e82:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<offset;i++)
c0203e85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0203e8c:	eb 0f                	jmp    c0203e9d <num2hexstr+0xc9>
		*(temp_arry+i)='0';
c0203e8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203e91:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203e94:	01 d0                	add    %edx,%eax
c0203e96:	c6 00 30             	movb   $0x30,(%eax)
	for(int i=0;i<offset;i++)
c0203e99:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203e9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203ea0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0203ea3:	7c e9                	jl     c0203e8e <num2hexstr+0xba>
	if(need0x)
c0203ea5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203ea9:	74 18                	je     c0203ec3 <num2hexstr+0xef>
		strcpy(static_hexstr+2,temp_arry);
c0203eab:	8d 83 22 91 08 00    	lea    0x89122(%ebx),%eax
c0203eb1:	83 ec 08             	sub    $0x8,%esp
c0203eb4:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203eb7:	52                   	push   %edx
c0203eb8:	50                   	push   %eax
c0203eb9:	e8 58 01 00 00       	call   c0204016 <strcpy>
c0203ebe:	83 c4 10             	add    $0x10,%esp
c0203ec1:	eb 16                	jmp    c0203ed9 <num2hexstr+0x105>
	else
		strcpy(static_hexstr,temp_arry);
c0203ec3:	83 ec 08             	sub    $0x8,%esp
c0203ec6:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203ec9:	50                   	push   %eax
c0203eca:	8d 83 20 91 08 00    	lea    0x89120(%ebx),%eax
c0203ed0:	50                   	push   %eax
c0203ed1:	e8 40 01 00 00       	call   c0204016 <strcpy>
c0203ed6:	83 c4 10             	add    $0x10,%esp
	return static_hexstr;
c0203ed9:	8d 83 20 91 08 00    	lea    0x89120(%ebx),%eax
c0203edf:	eb 14                	jmp    c0203ef5 <num2hexstr+0x121>
	}
	else 
	{
		if(need0x)
c0203ee1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203ee5:	74 08                	je     c0203eef <num2hexstr+0x11b>
			return "0x00000000";
c0203ee7:	8d 83 20 00 00 00    	lea    0x20(%ebx),%eax
c0203eed:	eb 06                	jmp    c0203ef5 <num2hexstr+0x121>
		else
			return "00000000";
c0203eef:	8d 83 2b 00 00 00    	lea    0x2b(%ebx),%eax
	}
}
c0203ef5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ef8:	c9                   	leave  
c0203ef9:	c3                   	ret    

c0203efa <memcpy>:


inline void memcpy(uint8_t *dest ,const uint8_t *src,uint32_t len)
{
c0203efa:	55                   	push   %ebp
c0203efb:	89 e5                	mov    %esp,%ebp
c0203efd:	e8 fe 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f02:	05 fe 40 00 00       	add    $0x40fe,%eax
	for(;len!=0;len--)
c0203f07:	eb 17                	jmp    c0203f20 <memcpy+0x26>
	{
		*dest=*src;
c0203f09:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f0c:	0f b6 10             	movzbl (%eax),%edx
c0203f0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f12:	88 10                	mov    %dl,(%eax)
		dest++;
c0203f14:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c0203f18:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	for(;len!=0;len--)
c0203f1c:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0203f20:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0203f24:	75 e3                	jne    c0203f09 <memcpy+0xf>
	}
}
c0203f26:	90                   	nop
c0203f27:	5d                   	pop    %ebp
c0203f28:	c3                   	ret    

c0203f29 <memset>:

inline void memset(void *dest,uint8_t val ,uint32_t len)
{
c0203f29:	55                   	push   %ebp
c0203f2a:	89 e5                	mov    %esp,%ebp
c0203f2c:	83 ec 14             	sub    $0x14,%esp
c0203f2f:	e8 cc 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f34:	05 cc 40 00 00       	add    $0x40cc,%eax
c0203f39:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f3c:	88 45 ec             	mov    %al,-0x14(%ebp)
	uint8_t *dst = (uint8_t *)dest;
c0203f3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f42:	89 45 fc             	mov    %eax,-0x4(%ebp)

    for ( ; len != 0; len--) {
c0203f45:	eb 13                	jmp    c0203f5a <memset+0x31>
        *dst++ = val;
c0203f47:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203f4a:	8d 50 01             	lea    0x1(%eax),%edx
c0203f4d:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0203f50:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0203f54:	88 10                	mov    %dl,(%eax)
    for ( ; len != 0; len--) {
c0203f56:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0203f5a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0203f5e:	75 e7                	jne    c0203f47 <memset+0x1e>
    }
}
c0203f60:	90                   	nop
c0203f61:	c9                   	leave  
c0203f62:	c3                   	ret    

c0203f63 <bzero>:

inline void bzero(void *dest, uint32_t len)
{
c0203f63:	55                   	push   %ebp
c0203f64:	89 e5                	mov    %esp,%ebp
c0203f66:	e8 95 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f6b:	05 95 40 00 00       	add    $0x4095,%eax
    memset(dest, 0, len);
c0203f70:	ff 75 0c             	pushl  0xc(%ebp)
c0203f73:	6a 00                	push   $0x0
c0203f75:	ff 75 08             	pushl  0x8(%ebp)
c0203f78:	e8 ac ff ff ff       	call   c0203f29 <memset>
c0203f7d:	83 c4 0c             	add    $0xc,%esp
}
c0203f80:	90                   	nop
c0203f81:	c9                   	leave  
c0203f82:	c3                   	ret    

c0203f83 <strcmp>:

inline int strcmp(const char *str1,const char *str2)
{
c0203f83:	55                   	push   %ebp
c0203f84:	89 e5                	mov    %esp,%ebp
c0203f86:	e8 75 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f8b:	05 75 40 00 00       	add    $0x4075,%eax
	while(1){
		if (*str1=='\0'&&*str2=='\0')
c0203f90:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f93:	0f b6 00             	movzbl (%eax),%eax
c0203f96:	84 c0                	test   %al,%al
c0203f98:	75 11                	jne    c0203fab <strcmp+0x28>
c0203f9a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f9d:	0f b6 00             	movzbl (%eax),%eax
c0203fa0:	84 c0                	test   %al,%al
c0203fa2:	75 07                	jne    c0203fab <strcmp+0x28>
			return 0;
c0203fa4:	b8 00 00 00 00       	mov    $0x0,%eax
c0203fa9:	eb 38                	jmp    c0203fe3 <strcmp+0x60>
		else if ((int)*str1>(int)*str2){
c0203fab:	8b 45 08             	mov    0x8(%ebp),%eax
c0203fae:	0f b6 10             	movzbl (%eax),%edx
c0203fb1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203fb4:	0f b6 00             	movzbl (%eax),%eax
c0203fb7:	38 c2                	cmp    %al,%dl
c0203fb9:	7e 07                	jle    c0203fc2 <strcmp+0x3f>
			return 1;
c0203fbb:	b8 01 00 00 00       	mov    $0x1,%eax
c0203fc0:	eb 21                	jmp    c0203fe3 <strcmp+0x60>
		}
		else if((int)*str1>(int)*str2){
c0203fc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0203fc5:	0f b6 10             	movzbl (%eax),%edx
c0203fc8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203fcb:	0f b6 00             	movzbl (%eax),%eax
c0203fce:	38 c2                	cmp    %al,%dl
c0203fd0:	7e 07                	jle    c0203fd9 <strcmp+0x56>
			return -1;
c0203fd2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0203fd7:	eb 0a                	jmp    c0203fe3 <strcmp+0x60>
		}
		else{
			str1++;
c0203fd9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
			str2++;
c0203fdd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		if (*str1=='\0'&&*str2=='\0')
c0203fe1:	eb ad                	jmp    c0203f90 <strcmp+0xd>
		}
	}
}
c0203fe3:	5d                   	pop    %ebp
c0203fe4:	c3                   	ret    

c0203fe5 <strlen>:

inline int strlen(const char *src)
{
c0203fe5:	55                   	push   %ebp
c0203fe6:	89 e5                	mov    %esp,%ebp
c0203fe8:	83 ec 10             	sub    $0x10,%esp
c0203feb:	e8 10 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203ff0:	05 10 40 00 00       	add    $0x4010,%eax
	int i=0;
c0203ff5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(*(src+i)!='\0')
c0203ffc:	eb 04                	jmp    c0204002 <strlen+0x1d>
		i++;
c0203ffe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while(*(src+i)!='\0')
c0204002:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204005:	8b 45 08             	mov    0x8(%ebp),%eax
c0204008:	01 d0                	add    %edx,%eax
c020400a:	0f b6 00             	movzbl (%eax),%eax
c020400d:	84 c0                	test   %al,%al
c020400f:	75 ed                	jne    c0203ffe <strlen+0x19>
	return i;
c0204011:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0204014:	c9                   	leave  
c0204015:	c3                   	ret    

c0204016 <strcpy>:

inline char *strcpy(char *dest, const char *src)
{
c0204016:	55                   	push   %ebp
c0204017:	89 e5                	mov    %esp,%ebp
c0204019:	83 ec 10             	sub    $0x10,%esp
c020401c:	e8 df 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204021:	05 df 3f 00 00       	add    $0x3fdf,%eax
	char *dest_head=dest;
c0204026:	8b 45 08             	mov    0x8(%ebp),%eax
c0204029:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(*(src)!='\0')
c020402c:	eb 13                	jmp    c0204041 <strcpy+0x2b>
	{
		*dest=*src;
c020402e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204031:	0f b6 10             	movzbl (%eax),%edx
c0204034:	8b 45 08             	mov    0x8(%ebp),%eax
c0204037:	88 10                	mov    %dl,(%eax)
		dest++;
c0204039:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c020403d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	while(*(src)!='\0')
c0204041:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204044:	0f b6 00             	movzbl (%eax),%eax
c0204047:	84 c0                	test   %al,%al
c0204049:	75 e3                	jne    c020402e <strcpy+0x18>
	}
	*dest='\0';
c020404b:	8b 45 08             	mov    0x8(%ebp),%eax
c020404e:	c6 00 00             	movb   $0x0,(%eax)
	dest=dest_head;
c0204051:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204054:	89 45 08             	mov    %eax,0x8(%ebp)
	return dest;
c0204057:	8b 45 08             	mov    0x8(%ebp),%eax
}
c020405a:	c9                   	leave  
c020405b:	c3                   	ret    

c020405c <strcat>:

inline char *strcat(char *dest, const char *src)
{
c020405c:	55                   	push   %ebp
c020405d:	89 e5                	mov    %esp,%ebp
c020405f:	83 ec 10             	sub    $0x10,%esp
c0204062:	e8 99 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204067:	05 99 3f 00 00       	add    $0x3f99,%eax
	char *pointer=dest;
c020406c:	8b 45 08             	mov    0x8(%ebp),%eax
c020406f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for(;*pointer!='\0';pointer++);
c0204072:	eb 04                	jmp    c0204078 <strcat+0x1c>
c0204074:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0204078:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020407b:	0f b6 00             	movzbl (%eax),%eax
c020407e:	84 c0                	test   %al,%al
c0204080:	75 f2                	jne    c0204074 <strcat+0x18>
	strcpy(pointer,src);
c0204082:	ff 75 0c             	pushl  0xc(%ebp)
c0204085:	ff 75 fc             	pushl  -0x4(%ebp)
c0204088:	e8 89 ff ff ff       	call   c0204016 <strcpy>
c020408d:	83 c4 08             	add    $0x8,%esp
	return dest;		
c0204090:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0204093:	c9                   	leave  
c0204094:	c3                   	ret    

c0204095 <uintTostring>:

inline char *uintTostring(uint32_t num)
{
c0204095:	55                   	push   %ebp
c0204096:	89 e5                	mov    %esp,%ebp
c0204098:	83 ec 28             	sub    $0x28,%esp
c020409b:	e8 60 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02040a0:	05 60 3f 00 00       	add    $0x3f60,%eax
	char i2stable[10]={'0','1','2','3','4','5','6','7','8','9'};
c02040a5:	c6 45 da 30          	movb   $0x30,-0x26(%ebp)
c02040a9:	c6 45 db 31          	movb   $0x31,-0x25(%ebp)
c02040ad:	c6 45 dc 32          	movb   $0x32,-0x24(%ebp)
c02040b1:	c6 45 dd 33          	movb   $0x33,-0x23(%ebp)
c02040b5:	c6 45 de 34          	movb   $0x34,-0x22(%ebp)
c02040b9:	c6 45 df 35          	movb   $0x35,-0x21(%ebp)
c02040bd:	c6 45 e0 36          	movb   $0x36,-0x20(%ebp)
c02040c1:	c6 45 e1 37          	movb   $0x37,-0x1f(%ebp)
c02040c5:	c6 45 e2 38          	movb   $0x38,-0x1e(%ebp)
c02040c9:	c6 45 e3 39          	movb   $0x39,-0x1d(%ebp)
	static char m[32]={0};
	char *str_ptr=m;
c02040cd:	8d 80 40 91 08 00    	lea    0x89140(%eax),%eax
c02040d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char *head=str_ptr;
c02040d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02040d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int i=0;
c02040dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(;num>=10;i++)
c02040e3:	eb 46                	jmp    c020412b <uintTostring+0x96>
	{
		uint32_t num_=num/10;
c02040e5:	8b 45 08             	mov    0x8(%ebp),%eax
c02040e8:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c02040ed:	f7 e2                	mul    %edx
c02040ef:	89 d0                	mov    %edx,%eax
c02040f1:	c1 e8 03             	shr    $0x3,%eax
c02040f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32_t index=num-(num_*10);
c02040f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02040fa:	89 d0                	mov    %edx,%eax
c02040fc:	c1 e0 02             	shl    $0x2,%eax
c02040ff:	01 d0                	add    %edx,%eax
c0204101:	01 c0                	add    %eax,%eax
c0204103:	89 c2                	mov    %eax,%edx
c0204105:	8b 45 08             	mov    0x8(%ebp),%eax
c0204108:	29 d0                	sub    %edx,%eax
c020410a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		num=num_;
c020410d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0204110:	89 45 08             	mov    %eax,0x8(%ebp)
		*str_ptr=i2stable[index];
c0204113:	8d 55 da             	lea    -0x26(%ebp),%edx
c0204116:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0204119:	01 d0                	add    %edx,%eax
c020411b:	0f b6 10             	movzbl (%eax),%edx
c020411e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204121:	88 10                	mov    %dl,(%eax)
		str_ptr++;
c0204123:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	for(;num>=10;i++)
c0204127:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020412b:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c020412f:	77 b4                	ja     c02040e5 <uintTostring+0x50>
	}
	*str_ptr=i2stable[num];
c0204131:	8d 55 da             	lea    -0x26(%ebp),%edx
c0204134:	8b 45 08             	mov    0x8(%ebp),%eax
c0204137:	01 d0                	add    %edx,%eax
c0204139:	0f b6 10             	movzbl (%eax),%edx
c020413c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020413f:	88 10                	mov    %dl,(%eax)
	*(str_ptr+1)='\0';
c0204141:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204144:	83 c0 01             	add    $0x1,%eax
c0204147:	c6 00 00             	movb   $0x0,(%eax)
	return strrevers(head);
c020414a:	83 ec 0c             	sub    $0xc,%esp
c020414d:	ff 75 ec             	pushl  -0x14(%ebp)
c0204150:	e8 05 00 00 00       	call   c020415a <strrevers>
c0204155:	83 c4 10             	add    $0x10,%esp
}
c0204158:	c9                   	leave  
c0204159:	c3                   	ret    

c020415a <strrevers>:

inline  char *strrevers(char *str)
{
c020415a:	55                   	push   %ebp
c020415b:	89 e5                	mov    %esp,%ebp
c020415d:	83 ec 20             	sub    $0x20,%esp
c0204160:	e8 9b 2e 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204165:	05 9b 3e 00 00       	add    $0x3e9b,%eax
	char *str_head=str;
c020416a:	8b 45 08             	mov    0x8(%ebp),%eax
c020416d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int lenth=strlen(str);
c0204170:	ff 75 08             	pushl  0x8(%ebp)
c0204173:	e8 6d fe ff ff       	call   c0203fe5 <strlen>
c0204178:	83 c4 04             	add    $0x4,%esp
c020417b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ptr_h=0;
c020417e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int ptr_t=--lenth;
c0204185:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0204189:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020418c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c020418f:	eb 39                	jmp    c02041ca <strrevers+0x70>
	{
		char temp=*(str_head+ptr_t);
c0204191:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204194:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204197:	01 d0                	add    %edx,%eax
c0204199:	0f b6 00             	movzbl (%eax),%eax
c020419c:	88 45 ef             	mov    %al,-0x11(%ebp)
		*(str_head+ptr_t)=*(str_head+ptr_h);
c020419f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02041a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02041a5:	01 d0                	add    %edx,%eax
c02041a7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c02041aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02041ad:	01 ca                	add    %ecx,%edx
c02041af:	0f b6 00             	movzbl (%eax),%eax
c02041b2:	88 02                	mov    %al,(%edx)
		*(str_head+ptr_h)=temp;
c02041b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02041b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02041ba:	01 c2                	add    %eax,%edx
c02041bc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c02041c0:	88 02                	mov    %al,(%edx)
		ptr_h++;
c02041c2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		ptr_t--;
c02041c6:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c02041ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02041cd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c02041d0:	7c bf                	jl     c0204191 <strrevers+0x37>
	}
	return str_head;
c02041d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c02041d5:	c9                   	leave  
c02041d6:	c3                   	ret    

c02041d7 <_8259A_init>:
static uint16_t m_control_port = 0x20;     //主片控制端口号  main
static uint16_t m_data_port = 0x21;	       //从片数据端口号
static uint16_t o_control_port = 0xA0;     //从片控制端口号  other
static uint16_t o_data_port = 0xA1;        //从片数据端口号

void _8259A_init(){
c02041d7:	55                   	push   %ebp
c02041d8:	89 e5                	mov    %esp,%ebp
c02041da:	53                   	push   %ebx
c02041db:	83 ec 04             	sub    $0x4,%esp
c02041de:	e8 21 2e 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02041e3:	81 c3 1d 3e 00 00    	add    $0x3e1d,%ebx
	//主片初始化
	outb(m_control_port,0x11);
c02041e9:	0f b7 83 20 f0 ff ff 	movzwl -0xfe0(%ebx),%eax
c02041f0:	0f b7 c0             	movzwl %ax,%eax
c02041f3:	83 ec 08             	sub    $0x8,%esp
c02041f6:	6a 11                	push   $0x11
c02041f8:	50                   	push   %eax
c02041f9:	e8 4d f5 ff ff       	call   c020374b <outb>
c02041fe:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x20);
c0204201:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204208:	0f b7 c0             	movzwl %ax,%eax
c020420b:	83 ec 08             	sub    $0x8,%esp
c020420e:	6a 20                	push   $0x20
c0204210:	50                   	push   %eax
c0204211:	e8 35 f5 ff ff       	call   c020374b <outb>
c0204216:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x04);
c0204219:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204220:	0f b7 c0             	movzwl %ax,%eax
c0204223:	83 ec 08             	sub    $0x8,%esp
c0204226:	6a 04                	push   $0x4
c0204228:	50                   	push   %eax
c0204229:	e8 1d f5 ff ff       	call   c020374b <outb>
c020422e:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x01);
c0204231:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204238:	0f b7 c0             	movzwl %ax,%eax
c020423b:	83 ec 08             	sub    $0x8,%esp
c020423e:	6a 01                	push   $0x1
c0204240:	50                   	push   %eax
c0204241:	e8 05 f5 ff ff       	call   c020374b <outb>
c0204246:	83 c4 10             	add    $0x10,%esp
	//从片初始化
	outb(o_control_port,0x11);
c0204249:	0f b7 83 24 f0 ff ff 	movzwl -0xfdc(%ebx),%eax
c0204250:	0f b7 c0             	movzwl %ax,%eax
c0204253:	83 ec 08             	sub    $0x8,%esp
c0204256:	6a 11                	push   $0x11
c0204258:	50                   	push   %eax
c0204259:	e8 ed f4 ff ff       	call   c020374b <outb>
c020425e:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x28);
c0204261:	0f b7 83 26 f0 ff ff 	movzwl -0xfda(%ebx),%eax
c0204268:	0f b7 c0             	movzwl %ax,%eax
c020426b:	83 ec 08             	sub    $0x8,%esp
c020426e:	6a 28                	push   $0x28
c0204270:	50                   	push   %eax
c0204271:	e8 d5 f4 ff ff       	call   c020374b <outb>
c0204276:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x02);
c0204279:	0f b7 83 26 f0 ff ff 	movzwl -0xfda(%ebx),%eax
c0204280:	0f b7 c0             	movzwl %ax,%eax
c0204283:	83 ec 08             	sub    $0x8,%esp
c0204286:	6a 02                	push   $0x2
c0204288:	50                   	push   %eax
c0204289:	e8 bd f4 ff ff       	call   c020374b <outb>
c020428e:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x01);
c0204291:	0f b7 83 26 f0 ff ff 	movzwl -0xfda(%ebx),%eax
c0204298:	0f b7 c0             	movzwl %ax,%eax
c020429b:	83 ec 08             	sub    $0x8,%esp
c020429e:	6a 01                	push   $0x1
c02042a0:	50                   	push   %eax
c02042a1:	e8 a5 f4 ff ff       	call   c020374b <outb>
c02042a6:	83 c4 10             	add    $0x10,%esp
c02042a9:	90                   	nop
c02042aa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02042ad:	c9                   	leave  
c02042ae:	c3                   	ret    

c02042af <kern_entry>:
void kputc(char);
void screen_uproll_once();
uint32_t get_eflags();
extern TCB_t * cur_tcb;
extern TCB_t main_TCB;
void kern_entry(){
c02042af:	55                   	push   %ebp
c02042b0:	89 e5                	mov    %esp,%ebp
c02042b2:	53                   	push   %ebx
c02042b3:	83 ec 14             	sub    $0x14,%esp
c02042b6:	e8 49 2d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02042bb:	81 c3 45 3d 00 00    	add    $0x3d45,%ebx
	void func(void* args);
	vga_init();	
c02042c1:	e8 6d f4 ff ff       	call   c0203733 <vga_init>
	pmm_init();
c02042c6:	e8 a5 16 00 00       	call   c0205970 <pmm_init>
	idt_init();
c02042cb:	e8 7c 19 00 00       	call   c0205c4c <idt_init>
	asm volatile("sti");
c02042d0:	fb                   	sti    
	vmm_init();
c02042d1:	e8 aa 25 00 00       	call   c0206880 <vmm_init>
	vmm_test();
c02042d6:	e8 59 28 00 00       	call   c0206b34 <vmm_test>
	while (1){
		asm volatile("hlt");
c02042db:	f4                   	hlt    
c02042dc:	eb fd                	jmp    c02042db <kern_entry+0x2c>

c02042de <func>:
	 }
     while(True)
     	asm volatile ("hlt");
}

void func(void* args){
c02042de:	55                   	push   %ebp
c02042df:	89 e5                	mov    %esp,%ebp
c02042e1:	53                   	push   %ebx
c02042e2:	83 ec 04             	sub    $0x4,%esp
c02042e5:	e8 1a 2d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02042ea:	81 c3 16 3d 00 00    	add    $0x3d16,%ebx
	while(True){
		asm volatile("cli");
c02042f0:	fa                   	cli    
		printk_color("B",15,0);
c02042f1:	83 ec 04             	sub    $0x4,%esp
c02042f4:	6a 00                	push   $0x0
c02042f6:	6a 0f                	push   $0xf
c02042f8:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c02042fe:	50                   	push   %eax
c02042ff:	e8 d6 f7 ff ff       	call   c0203ada <printk_color>
c0204304:	83 c4 10             	add    $0x10,%esp
		asm volatile("sti");
c0204307:	fb                   	sti    
		asm volatile("cli");
c0204308:	eb e6                	jmp    c02042f0 <func+0x12>

c020430a <bitmap_init_mem>:
#include "bitmap.h"
#include "types.h"
//4KB为一个页来管理

//初始化目标bitmap的内存区域
void bitmap_init_mem(bitmap bm){
c020430a:	55                   	push   %ebp
c020430b:	89 e5                	mov    %esp,%ebp
c020430d:	83 ec 10             	sub    $0x10,%esp
c0204310:	e8 eb 2c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204315:	05 eb 3c 00 00       	add    $0x3ceb,%eax
    uint32_t lenght = bm.length;
c020431a:	8b 45 0c             	mov    0xc(%ebp),%eax
c020431d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0204320:	8b 45 08             	mov    0x8(%ebp),%eax
c0204323:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(uint32_t i = 0;i<lenght;i++){
c0204326:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c020432d:	eb 0f                	jmp    c020433e <bitmap_init_mem+0x34>
        *((byte*)(vaddr_header+i)) = 255;   //11111111b
c020432f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204332:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204335:	01 d0                	add    %edx,%eax
c0204337:	c6 00 ff             	movb   $0xff,(%eax)
    for(uint32_t i = 0;i<lenght;i++){
c020433a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c020433e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204341:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0204344:	72 e9                	jb     c020432f <bitmap_init_mem+0x25>
    }
}
c0204346:	90                   	nop
c0204347:	c9                   	leave  
c0204348:	c3                   	ret    

c0204349 <bitmap_alloc_one_page>:


//指定分配目标页
//分配成功：返回目标页起始地址
//分配失败：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc_one_page(bitmap bm,uint32_t target){
c0204349:	55                   	push   %ebp
c020434a:	89 e5                	mov    %esp,%ebp
c020434c:	83 ec 20             	sub    $0x20,%esp
c020434f:	e8 ac 2c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204354:	05 ac 3c 00 00       	add    $0x3cac,%eax
    uint32_t lenght = bm.length;
c0204359:	8b 45 0c             	mov    0xc(%ebp),%eax
c020435c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c020435f:	8b 45 08             	mov    0x8(%ebp),%eax
c0204362:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c0204365:	8b 45 10             	mov    0x10(%ebp),%eax
c0204368:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c020436b:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;   //必须要-1 否则可能造成max_addr溢出为0
c0204372:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204375:	c1 e0 0f             	shl    $0xf,%eax
c0204378:	89 c2                	mov    %eax,%edx
c020437a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020437d:	01 d0                	add    %edx,%eax
c020437f:	83 e8 01             	sub    $0x1,%eax
c0204382:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c0204385:	8b 45 14             	mov    0x14(%ebp),%eax
c0204388:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c020438b:	0f 82 8e 00 00 00    	jb     c020441f <bitmap_alloc_one_page+0xd6>
c0204391:	8b 45 14             	mov    0x14(%ebp),%eax
c0204394:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0204397:	0f 83 82 00 00 00    	jae    c020441f <bitmap_alloc_one_page+0xd6>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c020439d:	8b 45 14             	mov    0x14(%ebp),%eax
c02043a0:	2b 45 f4             	sub    -0xc(%ebp),%eax
c02043a3:	c1 e8 0c             	shr    $0xc,%eax
c02043a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c02043a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02043ac:	8d 50 07             	lea    0x7(%eax),%edx
c02043af:	85 c0                	test   %eax,%eax
c02043b1:	0f 48 c2             	cmovs  %edx,%eax
c02043b4:	c1 f8 03             	sar    $0x3,%eax
c02043b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c02043ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02043bd:	99                   	cltd   
c02043be:	c1 ea 1d             	shr    $0x1d,%edx
c02043c1:	01 d0                	add    %edx,%eax
c02043c3:	83 e0 07             	and    $0x7,%eax
c02043c6:	29 d0                	sub    %edx,%eax
c02043c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c02043cb:	b8 07 00 00 00       	mov    $0x7,%eax
c02043d0:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c02043d3:	ba 01 00 00 00       	mov    $0x1,%edx
c02043d8:	89 c1                	mov    %eax,%ecx
c02043da:	d3 e2                	shl    %cl,%edx
c02043dc:	89 d0                	mov    %edx,%eax
c02043de:	88 45 e3             	mov    %al,-0x1d(%ebp)
        byte target_byte = *((byte*)(vaddr_header+i));
c02043e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02043e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02043e7:	01 d0                	add    %edx,%eax
c02043e9:	0f b6 00             	movzbl (%eax),%eax
c02043ec:	88 45 e2             	mov    %al,-0x1e(%ebp)
        if(target_byte== (target_byte| byte_mask)){
c02043ef:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
c02043f3:	0a 45 e3             	or     -0x1d(%ebp),%al
c02043f6:	38 45 e2             	cmp    %al,-0x1e(%ebp)
c02043f9:	75 1d                	jne    c0204418 <bitmap_alloc_one_page+0xcf>
            //此时目标bit为1 空闲状态
            *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) - byte_mask;
c02043fb:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02043fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204401:	01 d0                	add    %edx,%eax
c0204403:	0f b6 00             	movzbl (%eax),%eax
c0204406:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0204409:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020440c:	01 ca                	add    %ecx,%edx
c020440e:	2a 45 e3             	sub    -0x1d(%ebp),%al
c0204411:	88 02                	mov    %al,(%edx)
            return target;    
c0204413:	8b 45 14             	mov    0x14(%ebp),%eax
c0204416:	eb 0c                	jmp    c0204424 <bitmap_alloc_one_page+0xdb>
        }
        else{
            //此时目标bit为0     忙碌状态
            return BITMAP_RETURN_ERRO;
c0204418:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020441d:	eb 05                	jmp    c0204424 <bitmap_alloc_one_page+0xdb>
        }   
    }
    else{
        return BITMAP_RETURN_ERRO;
c020441f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c0204424:	c9                   	leave  
c0204425:	c3                   	ret    

c0204426 <bitmap_release_one_page>:

//释放指定的目标页
//释放成功或者失败都不会返回信息
void bitmap_release_one_page(bitmap bm,uint32_t target){
c0204426:	55                   	push   %ebp
c0204427:	89 e5                	mov    %esp,%ebp
c0204429:	83 ec 20             	sub    $0x20,%esp
c020442c:	e8 cf 2b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204431:	05 cf 3b 00 00       	add    $0x3bcf,%eax
    uint32_t lenght = bm.length;
c0204436:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204439:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c020443c:	8b 45 08             	mov    0x8(%ebp),%eax
c020443f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c0204442:	8b 45 10             	mov    0x10(%ebp),%eax
c0204445:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0204448:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;
c020444f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204452:	c1 e0 0f             	shl    $0xf,%eax
c0204455:	89 c2                	mov    %eax,%edx
c0204457:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020445a:	01 d0                	add    %edx,%eax
c020445c:	83 e8 01             	sub    $0x1,%eax
c020445f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c0204462:	8b 45 14             	mov    0x14(%ebp),%eax
c0204465:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0204468:	72 64                	jb     c02044ce <bitmap_release_one_page+0xa8>
c020446a:	8b 45 14             	mov    0x14(%ebp),%eax
c020446d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0204470:	73 5c                	jae    c02044ce <bitmap_release_one_page+0xa8>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c0204472:	8b 45 14             	mov    0x14(%ebp),%eax
c0204475:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0204478:	c1 e8 0c             	shr    $0xc,%eax
c020447b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c020447e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204481:	8d 50 07             	lea    0x7(%eax),%edx
c0204484:	85 c0                	test   %eax,%eax
c0204486:	0f 48 c2             	cmovs  %edx,%eax
c0204489:	c1 f8 03             	sar    $0x3,%eax
c020448c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c020448f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204492:	99                   	cltd   
c0204493:	c1 ea 1d             	shr    $0x1d,%edx
c0204496:	01 d0                	add    %edx,%eax
c0204498:	83 e0 07             	and    $0x7,%eax
c020449b:	29 d0                	sub    %edx,%eax
c020449d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c02044a0:	b8 07 00 00 00       	mov    $0x7,%eax
c02044a5:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c02044a8:	ba 01 00 00 00       	mov    $0x1,%edx
c02044ad:	89 c1                	mov    %eax,%ecx
c02044af:	d3 e2                	shl    %cl,%edx
c02044b1:	89 d0                	mov    %edx,%eax
c02044b3:	88 45 e3             	mov    %al,-0x1d(%ebp)
        *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) | byte_mask;
c02044b6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02044b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02044bc:	01 d0                	add    %edx,%eax
c02044be:	0f b6 00             	movzbl (%eax),%eax
c02044c1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c02044c4:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02044c7:	01 ca                	add    %ecx,%edx
c02044c9:	0a 45 e3             	or     -0x1d(%ebp),%al
c02044cc:	88 02                	mov    %al,(%edx)
    }
}
c02044ce:	90                   	nop
c02044cf:	c9                   	leave  
c02044d0:	c3                   	ret    

c02044d1 <bitmap_alloc>:

//任意分配 未指定分配的目标
//分配成功：返回目标页起始地址
//没有可用页：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc(bitmap bm){      
c02044d1:	55                   	push   %ebp
c02044d2:	89 e5                	mov    %esp,%ebp
c02044d4:	83 ec 30             	sub    $0x30,%esp
c02044d7:	e8 24 2b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02044dc:	05 24 3b 00 00       	add    $0x3b24,%eax
    uint32_t lenght = bm.length;
c02044e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c02044e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02044e7:	8b 45 08             	mov    0x8(%ebp),%eax
c02044ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c02044ed:	8b 45 10             	mov    0x10(%ebp),%eax
c02044f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(uint32_t i =0;i<lenght;i++){
c02044f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c02044fa:	e9 97 00 00 00       	jmp    c0204596 <bitmap_alloc+0xc5>
        byte byte_now = *((byte*)(vaddr_header+i)) ;
c02044ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0204502:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204505:	01 d0                	add    %edx,%eax
c0204507:	0f b6 00             	movzbl (%eax),%eax
c020450a:	88 45 fb             	mov    %al,-0x5(%ebp)
        if(byte_now != 0){
c020450d:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0204511:	74 7f                	je     c0204592 <bitmap_alloc+0xc1>
            int pos;     //在本字节中目标bit所在位置（从左往右 从0开始）
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0204513:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020451a:	eb 21                	jmp    c020453d <bitmap_alloc+0x6c>
                byte temp_byte = byte_now<<1;
c020451c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0204520:	01 c0                	add    %eax,%eax
c0204522:	88 45 e3             	mov    %al,-0x1d(%ebp)
                if(byte_now>temp_byte){
c0204525:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0204529:	3a 45 e3             	cmp    -0x1d(%ebp),%al
c020452c:	76 08                	jbe    c0204536 <bitmap_alloc+0x65>
                    pos = j;
c020452e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204531:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    break;
c0204534:	eb 0d                	jmp    c0204543 <bitmap_alloc+0x72>
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0204536:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020453a:	d0 65 fb             	shlb   -0x5(%ebp)
c020453d:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c0204541:	7e d9                	jle    c020451c <bitmap_alloc+0x4b>
                }
            }
            byte byte_sub = 1<<(7-pos);     //1=00000001b
c0204543:	b8 07 00 00 00       	mov    $0x7,%eax
c0204548:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020454b:	ba 01 00 00 00       	mov    $0x1,%edx
c0204550:	89 c1                	mov    %eax,%ecx
c0204552:	d3 e2                	shl    %cl,%edx
c0204554:	89 d0                	mov    %edx,%eax
c0204556:	88 45 e2             	mov    %al,-0x1e(%ebp)
            *((byte*)(vaddr_header+i)) = *((byte*)(vaddr_header+i))-byte_sub;
c0204559:	8b 55 e8             	mov    -0x18(%ebp),%edx
c020455c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020455f:	01 d0                	add    %edx,%eax
c0204561:	0f b6 00             	movzbl (%eax),%eax
c0204564:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0204567:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020456a:	01 ca                	add    %ecx,%edx
c020456c:	2a 45 e2             	sub    -0x1e(%ebp),%al
c020456f:	88 02                	mov    %al,(%edx)
            int page_no = i*8+pos;
c0204571:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204574:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c020457b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020457e:	01 d0                	add    %edx,%eax
c0204580:	89 45 dc             	mov    %eax,-0x24(%ebp)
            return page_no*PAGE_SIZE+target_addr_header;
c0204583:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0204586:	c1 e0 0c             	shl    $0xc,%eax
c0204589:	89 c2                	mov    %eax,%edx
c020458b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c020458e:	01 d0                	add    %edx,%eax
c0204590:	eb 15                	jmp    c02045a7 <bitmap_alloc+0xd6>
    for(uint32_t i =0;i<lenght;i++){
c0204592:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0204596:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204599:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c020459c:	0f 82 5d ff ff ff    	jb     c02044ff <bitmap_alloc+0x2e>
        }
    }
    return BITMAP_RETURN_ERRO;
c02045a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c02045a7:	c9                   	leave  
c02045a8:	c3                   	ret    

c02045a9 <bitmap_test>:

//测试bitmap相关函数
void bitmap_test(){
c02045a9:	55                   	push   %ebp
c02045aa:	89 e5                	mov    %esp,%ebp
c02045ac:	53                   	push   %ebx
c02045ad:	83 ec 24             	sub    $0x24,%esp
c02045b0:	e8 4f 2a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02045b5:	81 c3 4b 3a 00 00    	add    $0x3a4b,%ebx
#include "printk.h"
extern uint32_t kern_bitmap;
    bitmap bm;
    bm.length =2 ;
c02045bb:	c7 45 e8 02 00 00 00 	movl   $0x2,-0x18(%ebp)
    bm.vaddr_header = kern_bitmap;
c02045c2:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c02045c8:	8b 00                	mov    (%eax),%eax
c02045ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    bm.target_addr_header = 0x00000000;
c02045cd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    bitmap_init_mem(bm);
c02045d4:	ff 75 ec             	pushl  -0x14(%ebp)
c02045d7:	ff 75 e8             	pushl  -0x18(%ebp)
c02045da:	ff 75 e4             	pushl  -0x1c(%ebp)
c02045dd:	e8 28 fd ff ff       	call   c020430a <bitmap_init_mem>
c02045e2:	83 c4 0c             	add    $0xc,%esp
    for(int i = 0;i<8;i++){
c02045e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02045ec:	eb 3b                	jmp    c0204629 <bitmap_test+0x80>
        printk("mem:0x%h\n",bitmap_alloc(bm));
c02045ee:	ff 75 ec             	pushl  -0x14(%ebp)
c02045f1:	ff 75 e8             	pushl  -0x18(%ebp)
c02045f4:	ff 75 e4             	pushl  -0x1c(%ebp)
c02045f7:	e8 d5 fe ff ff       	call   c02044d1 <bitmap_alloc>
c02045fc:	83 c4 0c             	add    $0xc,%esp
c02045ff:	83 ec 08             	sub    $0x8,%esp
c0204602:	50                   	push   %eax
c0204603:	8d 83 36 00 00 00    	lea    0x36(%ebx),%eax
c0204609:	50                   	push   %eax
c020460a:	e8 57 f2 ff ff       	call   c0203866 <printk>
c020460f:	83 c4 10             	add    $0x10,%esp
        bitmap_release_one_page(bm,0x0);
c0204612:	6a 00                	push   $0x0
c0204614:	ff 75 ec             	pushl  -0x14(%ebp)
c0204617:	ff 75 e8             	pushl  -0x18(%ebp)
c020461a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020461d:	e8 04 fe ff ff       	call   c0204426 <bitmap_release_one_page>
c0204622:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<8;i++){
c0204625:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0204629:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c020462d:	7e bf                	jle    c02045ee <bitmap_test+0x45>
    }
    printk("alloc_page:0x%h\n",bitmap_alloc_one_page(bm,0xf010));
c020462f:	68 10 f0 00 00       	push   $0xf010
c0204634:	ff 75 ec             	pushl  -0x14(%ebp)
c0204637:	ff 75 e8             	pushl  -0x18(%ebp)
c020463a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020463d:	e8 07 fd ff ff       	call   c0204349 <bitmap_alloc_one_page>
c0204642:	83 c4 10             	add    $0x10,%esp
c0204645:	83 ec 08             	sub    $0x8,%esp
c0204648:	50                   	push   %eax
c0204649:	8d 83 40 00 00 00    	lea    0x40(%ebx),%eax
c020464f:	50                   	push   %eax
c0204650:	e8 11 f2 ff ff       	call   c0203866 <printk>
c0204655:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<16;i++){
c0204658:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020465f:	eb 2b                	jmp    c020468c <bitmap_test+0xe3>
        printk("mem:0x%h\n",bitmap_alloc(bm));
c0204661:	83 ec 04             	sub    $0x4,%esp
c0204664:	ff 75 ec             	pushl  -0x14(%ebp)
c0204667:	ff 75 e8             	pushl  -0x18(%ebp)
c020466a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020466d:	e8 5f fe ff ff       	call   c02044d1 <bitmap_alloc>
c0204672:	83 c4 10             	add    $0x10,%esp
c0204675:	83 ec 08             	sub    $0x8,%esp
c0204678:	50                   	push   %eax
c0204679:	8d 83 36 00 00 00    	lea    0x36(%ebx),%eax
c020467f:	50                   	push   %eax
c0204680:	e8 e1 f1 ff ff       	call   c0203866 <printk>
c0204685:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<16;i++){
c0204688:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020468c:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c0204690:	7e cf                	jle    c0204661 <bitmap_test+0xb8>
    }
c0204692:	90                   	nop
c0204693:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0204696:	c9                   	leave  
c0204697:	c3                   	ret    

c0204698 <pmm_page_no_to_addr>:
pm_page_t *page_array = (pm_page_t*)0xC0000100;       
pm_multi_link_t * MULTI_LINK;   //用大写来表示很重要 并且定义为结构体指针，用->更加美观了～
pm_multi_link_t multi_link_struct={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
pm_page_t * SINGLE_LINK = NULL ;
//获取page编号对应的addr
static uint32_t pmm_page_no_to_addr(uint32_t page_no){
c0204698:	55                   	push   %ebp
c0204699:	89 e5                	mov    %esp,%ebp
c020469b:	e8 60 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046a0:	05 60 39 00 00       	add    $0x3960,%eax
	return (page_no<<12)+pmm_page_start;
c02046a5:	8b 55 08             	mov    0x8(%ebp),%edx
c02046a8:	c1 e2 0c             	shl    $0xc,%edx
c02046ab:	8b 80 d0 91 08 00    	mov    0x891d0(%eax),%eax
c02046b1:	01 d0                	add    %edx,%eax
}
c02046b3:	5d                   	pop    %ebp
c02046b4:	c3                   	ret    

c02046b5 <addr_to_pmm_page_no>:

//addr转为page_no
static uint32_t addr_to_pmm_page_no(uint32_t addr){
c02046b5:	55                   	push   %ebp
c02046b6:	89 e5                	mov    %esp,%ebp
c02046b8:	e8 43 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046bd:	05 43 39 00 00       	add    $0x3943,%eax
	return (addr-pmm_page_start)>>12;
c02046c2:	8b 80 d0 91 08 00    	mov    0x891d0(%eax),%eax
c02046c8:	8b 55 08             	mov    0x8(%ebp),%edx
c02046cb:	29 c2                	sub    %eax,%edx
c02046cd:	89 d0                	mov    %edx,%eax
c02046cf:	c1 e8 0c             	shr    $0xc,%eax
}
c02046d2:	5d                   	pop    %ebp
c02046d3:	c3                   	ret    

c02046d4 <c_to_uint32>:

//将 page_c_t枚举类型转化为对应的块大小 如 (page_c_t)_256——> (uint32_t)256
static uint32_t c_to_uint32(page_c_t ph){
c02046d4:	55                   	push   %ebp
c02046d5:	89 e5                	mov    %esp,%ebp
c02046d7:	83 ec 10             	sub    $0x10,%esp
c02046da:	e8 21 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046df:	05 21 39 00 00       	add    $0x3921,%eax
	uint32_t re = 1;
c02046e4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
	re = re<<ph;
c02046eb:	8b 45 08             	mov    0x8(%ebp),%eax
c02046ee:	89 c1                	mov    %eax,%ecx
c02046f0:	d3 65 fc             	shll   %cl,-0x4(%ebp)
	return re;
c02046f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c02046f6:	c9                   	leave  
c02046f7:	c3                   	ret    

c02046f8 <get_partner_page_no>:

static uint32_t get_partner_page_no(uint32_t page_no,page_c_t type){
c02046f8:	55                   	push   %ebp
c02046f9:	89 e5                	mov    %esp,%ebp
c02046fb:	83 ec 10             	sub    $0x10,%esp
c02046fe:	e8 fd 28 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204703:	05 fd 38 00 00       	add    $0x38fd,%eax
	//--|--|--|--|--|--| 如图 必须整数倍或者0
	uint32_t v1 = c_to_uint32(type);
c0204708:	ff 75 0c             	pushl  0xc(%ebp)
c020470b:	e8 c4 ff ff ff       	call   c02046d4 <c_to_uint32>
c0204710:	83 c4 04             	add    $0x4,%esp
c0204713:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t v2 = 2*v1;
c0204716:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204719:	01 c0                	add    %eax,%eax
c020471b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if((page_no - v1)%v2 == 0)
c020471e:	8b 45 08             	mov    0x8(%ebp),%eax
c0204721:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0204724:	ba 00 00 00 00       	mov    $0x0,%edx
c0204729:	f7 75 f8             	divl   -0x8(%ebp)
c020472c:	89 d0                	mov    %edx,%eax
c020472e:	85 c0                	test   %eax,%eax
c0204730:	75 08                	jne    c020473a <get_partner_page_no+0x42>
		return page_no-v1;
c0204732:	8b 45 08             	mov    0x8(%ebp),%eax
c0204735:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0204738:	eb 08                	jmp    c0204742 <get_partner_page_no+0x4a>
	else
		return page_no+v1;
c020473a:	8b 55 08             	mov    0x8(%ebp),%edx
c020473d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204740:	01 d0                	add    %edx,%eax
}
c0204742:	c9                   	leave  
c0204743:	c3                   	ret    

c0204744 <append_block>:


//向链表添加块（用于初始化链表以及free后添加块）
//此处可以使用##连接宏（但是我偏不）
static void append_block(int page_no,page_c_t c){
c0204744:	55                   	push   %ebp
c0204745:	89 e5                	mov    %esp,%ebp
c0204747:	53                   	push   %ebx
c0204748:	83 ec 10             	sub    $0x10,%esp
c020474b:	e8 b0 28 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204750:	05 b0 38 00 00       	add    $0x38b0,%eax
	page_array[page_no].next = NULL ;     //一定要设置 新加入块的下个指针为NULL
c0204755:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c020475b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020475e:	89 ca                	mov    %ecx,%edx
c0204760:	01 d2                	add    %edx,%edx
c0204762:	01 ca                	add    %ecx,%edx
c0204764:	c1 e2 02             	shl    $0x2,%edx
c0204767:	01 da                	add    %ebx,%edx
c0204769:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	pm_page_t * header;
	switch(c){
c0204770:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204774:	0f 87 cd 02 00 00    	ja     c0204a47 <.L39+0x22>
c020477a:	8b 55 0c             	mov    0xc(%ebp),%edx
c020477d:	c1 e2 02             	shl    $0x2,%edx
c0204780:	8b 94 02 54 00 00 00 	mov    0x54(%edx,%eax,1),%edx
c0204787:	01 c2                	add    %eax,%edx
c0204789:	ff e2                	jmp    *%edx

c020478b <.L12>:
		case _1:
			header = MULTI_LINK ->_1;
c020478b:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204791:	8b 12                	mov    (%edx),%edx
c0204793:	8b 12                	mov    (%edx),%edx
c0204795:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204798:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020479c:	0f 85 86 02 00 00    	jne    c0204a28 <.L39+0x3>
				MULTI_LINK ->_1 = &(page_array[page_no]);
c02047a2:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c02047a8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02047ab:	89 ca                	mov    %ecx,%edx
c02047ad:	01 d2                	add    %edx,%edx
c02047af:	01 ca                	add    %ecx,%edx
c02047b1:	c1 e2 02             	shl    $0x2,%edx
c02047b4:	89 d1                	mov    %edx,%ecx
c02047b6:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047bc:	8b 12                	mov    (%edx),%edx
c02047be:	01 d9                	add    %ebx,%ecx
c02047c0:	89 0a                	mov    %ecx,(%edx)
			break;
c02047c2:	e9 61 02 00 00       	jmp    c0204a28 <.L39+0x3>

c02047c7 <.L14>:
		case _2:
			header = MULTI_LINK ->_2;
c02047c7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047cd:	8b 12                	mov    (%edx),%edx
c02047cf:	8b 52 04             	mov    0x4(%edx),%edx
c02047d2:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02047d5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02047d9:	0f 85 4c 02 00 00    	jne    c0204a2b <.L39+0x6>
				MULTI_LINK ->_2 = &(page_array[page_no]);
c02047df:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c02047e5:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02047e8:	89 ca                	mov    %ecx,%edx
c02047ea:	01 d2                	add    %edx,%edx
c02047ec:	01 ca                	add    %ecx,%edx
c02047ee:	c1 e2 02             	shl    $0x2,%edx
c02047f1:	89 d1                	mov    %edx,%ecx
c02047f3:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047f9:	8b 12                	mov    (%edx),%edx
c02047fb:	01 d9                	add    %ebx,%ecx
c02047fd:	89 4a 04             	mov    %ecx,0x4(%edx)
			break;
c0204800:	e9 26 02 00 00       	jmp    c0204a2b <.L39+0x6>

c0204805 <.L15>:
		case _4:
			header = MULTI_LINK ->_4;
c0204805:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020480b:	8b 12                	mov    (%edx),%edx
c020480d:	8b 52 08             	mov    0x8(%edx),%edx
c0204810:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204813:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204817:	0f 85 11 02 00 00    	jne    c0204a2e <.L39+0x9>
				MULTI_LINK ->_4 = &(page_array[page_no]);
c020481d:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c0204823:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204826:	89 ca                	mov    %ecx,%edx
c0204828:	01 d2                	add    %edx,%edx
c020482a:	01 ca                	add    %ecx,%edx
c020482c:	c1 e2 02             	shl    $0x2,%edx
c020482f:	89 d1                	mov    %edx,%ecx
c0204831:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204837:	8b 12                	mov    (%edx),%edx
c0204839:	01 d9                	add    %ebx,%ecx
c020483b:	89 4a 08             	mov    %ecx,0x8(%edx)
			break;
c020483e:	e9 eb 01 00 00       	jmp    c0204a2e <.L39+0x9>

c0204843 <.L16>:
		case _8:
			header = MULTI_LINK ->_8;
c0204843:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204849:	8b 12                	mov    (%edx),%edx
c020484b:	8b 52 0c             	mov    0xc(%edx),%edx
c020484e:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204851:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204855:	0f 85 d6 01 00 00    	jne    c0204a31 <.L39+0xc>
				MULTI_LINK ->_8 = &(page_array[page_no]);
c020485b:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c0204861:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204864:	89 ca                	mov    %ecx,%edx
c0204866:	01 d2                	add    %edx,%edx
c0204868:	01 ca                	add    %ecx,%edx
c020486a:	c1 e2 02             	shl    $0x2,%edx
c020486d:	89 d1                	mov    %edx,%ecx
c020486f:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204875:	8b 12                	mov    (%edx),%edx
c0204877:	01 d9                	add    %ebx,%ecx
c0204879:	89 4a 0c             	mov    %ecx,0xc(%edx)
			break;
c020487c:	e9 b0 01 00 00       	jmp    c0204a31 <.L39+0xc>

c0204881 <.L17>:
		case _16:
			header = MULTI_LINK ->_16;
c0204881:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204887:	8b 12                	mov    (%edx),%edx
c0204889:	8b 52 10             	mov    0x10(%edx),%edx
c020488c:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020488f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204893:	0f 85 9b 01 00 00    	jne    c0204a34 <.L39+0xf>
				MULTI_LINK ->_16 = &(page_array[page_no]);
c0204899:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c020489f:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02048a2:	89 ca                	mov    %ecx,%edx
c02048a4:	01 d2                	add    %edx,%edx
c02048a6:	01 ca                	add    %ecx,%edx
c02048a8:	c1 e2 02             	shl    $0x2,%edx
c02048ab:	89 d1                	mov    %edx,%ecx
c02048ad:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048b3:	8b 12                	mov    (%edx),%edx
c02048b5:	01 d9                	add    %ebx,%ecx
c02048b7:	89 4a 10             	mov    %ecx,0x10(%edx)
			break;
c02048ba:	e9 75 01 00 00       	jmp    c0204a34 <.L39+0xf>

c02048bf <.L18>:
		case _32:
			header = MULTI_LINK ->_32;
c02048bf:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048c5:	8b 12                	mov    (%edx),%edx
c02048c7:	8b 52 14             	mov    0x14(%edx),%edx
c02048ca:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02048cd:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02048d1:	0f 85 60 01 00 00    	jne    c0204a37 <.L39+0x12>
				MULTI_LINK ->_32 = &(page_array[page_no]);
c02048d7:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c02048dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02048e0:	89 ca                	mov    %ecx,%edx
c02048e2:	01 d2                	add    %edx,%edx
c02048e4:	01 ca                	add    %ecx,%edx
c02048e6:	c1 e2 02             	shl    $0x2,%edx
c02048e9:	89 d1                	mov    %edx,%ecx
c02048eb:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048f1:	8b 12                	mov    (%edx),%edx
c02048f3:	01 d9                	add    %ebx,%ecx
c02048f5:	89 4a 14             	mov    %ecx,0x14(%edx)
			break;
c02048f8:	e9 3a 01 00 00       	jmp    c0204a37 <.L39+0x12>

c02048fd <.L19>:
		case _64:
			header = MULTI_LINK ->_64;
c02048fd:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204903:	8b 12                	mov    (%edx),%edx
c0204905:	8b 52 18             	mov    0x18(%edx),%edx
c0204908:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020490b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020490f:	0f 85 25 01 00 00    	jne    c0204a3a <.L39+0x15>
				MULTI_LINK ->_64 = &(page_array[page_no]);
c0204915:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c020491b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020491e:	89 ca                	mov    %ecx,%edx
c0204920:	01 d2                	add    %edx,%edx
c0204922:	01 ca                	add    %ecx,%edx
c0204924:	c1 e2 02             	shl    $0x2,%edx
c0204927:	89 d1                	mov    %edx,%ecx
c0204929:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020492f:	8b 12                	mov    (%edx),%edx
c0204931:	01 d9                	add    %ebx,%ecx
c0204933:	89 4a 18             	mov    %ecx,0x18(%edx)
			break;
c0204936:	e9 ff 00 00 00       	jmp    c0204a3a <.L39+0x15>

c020493b <.L20>:
		case _128:
			header = MULTI_LINK ->_128;
c020493b:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204941:	8b 12                	mov    (%edx),%edx
c0204943:	8b 52 1c             	mov    0x1c(%edx),%edx
c0204946:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204949:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020494d:	0f 85 ea 00 00 00    	jne    c0204a3d <.L39+0x18>
				MULTI_LINK ->_128 = &(page_array[page_no]);
c0204953:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c0204959:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020495c:	89 ca                	mov    %ecx,%edx
c020495e:	01 d2                	add    %edx,%edx
c0204960:	01 ca                	add    %ecx,%edx
c0204962:	c1 e2 02             	shl    $0x2,%edx
c0204965:	89 d1                	mov    %edx,%ecx
c0204967:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020496d:	8b 12                	mov    (%edx),%edx
c020496f:	01 d9                	add    %ebx,%ecx
c0204971:	89 4a 1c             	mov    %ecx,0x1c(%edx)
			break;
c0204974:	e9 c4 00 00 00       	jmp    c0204a3d <.L39+0x18>

c0204979 <.L21>:
		case _256:
			header = MULTI_LINK ->_256;
c0204979:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020497f:	8b 12                	mov    (%edx),%edx
c0204981:	8b 52 20             	mov    0x20(%edx),%edx
c0204984:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204987:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020498b:	0f 85 af 00 00 00    	jne    c0204a40 <.L39+0x1b>
				MULTI_LINK ->_256 = &(page_array[page_no]);
c0204991:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c0204997:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020499a:	89 ca                	mov    %ecx,%edx
c020499c:	01 d2                	add    %edx,%edx
c020499e:	01 ca                	add    %ecx,%edx
c02049a0:	c1 e2 02             	shl    $0x2,%edx
c02049a3:	89 d1                	mov    %edx,%ecx
c02049a5:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049ab:	8b 12                	mov    (%edx),%edx
c02049ad:	01 d9                	add    %ebx,%ecx
c02049af:	89 4a 20             	mov    %ecx,0x20(%edx)
			break;
c02049b2:	e9 89 00 00 00       	jmp    c0204a40 <.L39+0x1b>

c02049b7 <.L22>:
		case _512:
			header = MULTI_LINK ->_512;
c02049b7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049bd:	8b 12                	mov    (%edx),%edx
c02049bf:	8b 52 24             	mov    0x24(%edx),%edx
c02049c2:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02049c5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02049c9:	75 78                	jne    c0204a43 <.L39+0x1e>
				MULTI_LINK ->_512 = &(page_array[page_no]);
c02049cb:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c02049d1:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02049d4:	89 ca                	mov    %ecx,%edx
c02049d6:	01 d2                	add    %edx,%edx
c02049d8:	01 ca                	add    %ecx,%edx
c02049da:	c1 e2 02             	shl    $0x2,%edx
c02049dd:	89 d1                	mov    %edx,%ecx
c02049df:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049e5:	8b 12                	mov    (%edx),%edx
c02049e7:	01 d9                	add    %ebx,%ecx
c02049e9:	89 4a 24             	mov    %ecx,0x24(%edx)
			break;
c02049ec:	eb 55                	jmp    c0204a43 <.L39+0x1e>

c02049ee <.L23>:
		case _1024:
			header = MULTI_LINK ->_1024;
c02049ee:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049f4:	8b 12                	mov    (%edx),%edx
c02049f6:	8b 52 28             	mov    0x28(%edx),%edx
c02049f9:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02049fc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204a00:	75 44                	jne    c0204a46 <.L39+0x21>
				MULTI_LINK ->_1024 = &(page_array[page_no]);
c0204a02:	8b 98 28 f0 ff ff    	mov    -0xfd8(%eax),%ebx
c0204a08:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204a0b:	89 ca                	mov    %ecx,%edx
c0204a0d:	01 d2                	add    %edx,%edx
c0204a0f:	01 ca                	add    %ecx,%edx
c0204a11:	c1 e2 02             	shl    $0x2,%edx
c0204a14:	89 d1                	mov    %edx,%ecx
c0204a16:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204a1c:	8b 12                	mov    (%edx),%edx
c0204a1e:	01 d9                	add    %ebx,%ecx
c0204a20:	89 4a 28             	mov    %ecx,0x28(%edx)
			break;
c0204a23:	eb 21                	jmp    c0204a46 <.L39+0x21>

c0204a25 <.L39>:
		case _erro:
			break;
c0204a25:	90                   	nop
c0204a26:	eb 1f                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a28:	90                   	nop
c0204a29:	eb 1c                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a2b:	90                   	nop
c0204a2c:	eb 19                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a2e:	90                   	nop
c0204a2f:	eb 16                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a31:	90                   	nop
c0204a32:	eb 13                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a34:	90                   	nop
c0204a35:	eb 10                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a37:	90                   	nop
c0204a38:	eb 0d                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a3a:	90                   	nop
c0204a3b:	eb 0a                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a3d:	90                   	nop
c0204a3e:	eb 07                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a40:	90                   	nop
c0204a41:	eb 04                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a43:	90                   	nop
c0204a44:	eb 01                	jmp    c0204a47 <.L39+0x22>
			break;
c0204a46:	90                   	nop
	}
	if(header!=NULL){
c0204a47:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204a4b:	74 36                	je     c0204a83 <.L39+0x5e>
		pm_page_t * probe = header;
c0204a4d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204a50:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;(probe->next)!=NULL;probe = probe->next)
c0204a53:	eb 09                	jmp    c0204a5e <.L39+0x39>
c0204a55:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204a58:	8b 52 04             	mov    0x4(%edx),%edx
c0204a5b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0204a5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204a61:	8b 52 04             	mov    0x4(%edx),%edx
c0204a64:	85 d2                	test   %edx,%edx
c0204a66:	75 ed                	jne    c0204a55 <.L39+0x30>
			;
		(probe -> next)=&(page_array[page_no]);
c0204a68:	8b 88 28 f0 ff ff    	mov    -0xfd8(%eax),%ecx
c0204a6e:	8b 55 08             	mov    0x8(%ebp),%edx
c0204a71:	89 d0                	mov    %edx,%eax
c0204a73:	01 c0                	add    %eax,%eax
c0204a75:	01 d0                	add    %edx,%eax
c0204a77:	c1 e0 02             	shl    $0x2,%eax
c0204a7a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204a80:	89 50 04             	mov    %edx,0x4(%eax)
	}
}
c0204a83:	90                   	nop
c0204a84:	83 c4 10             	add    $0x10,%esp
c0204a87:	5b                   	pop    %ebx
c0204a88:	5d                   	pop    %ebp
c0204a89:	c3                   	ret    

c0204a8a <pop_block>:

//从链表中取出一个块 链表为空返回ERRO_POP_BLOCK
static uint32_t pop_block(page_c_t c){
c0204a8a:	55                   	push   %ebp
c0204a8b:	89 e5                	mov    %esp,%ebp
c0204a8d:	83 ec 10             	sub    $0x10,%esp
c0204a90:	e8 6b 25 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204a95:	05 6b 35 00 00       	add    $0x356b,%eax
	pm_page_t * header;
	switch(c){
c0204a9a:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0204a9e:	0f 87 1e 03 00 00    	ja     c0204dc2 <.L66+0x26>
c0204aa4:	8b 55 08             	mov    0x8(%ebp),%edx
c0204aa7:	c1 e2 02             	shl    $0x2,%edx
c0204aaa:	8b 94 02 84 00 00 00 	mov    0x84(%edx,%eax,1),%edx
c0204ab1:	01 c2                	add    %eax,%edx
c0204ab3:	ff e2                	jmp    *%edx

c0204ab5 <.L54>:
		case _1:
			header = MULTI_LINK ->_1;
c0204ab5:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204abb:	8b 12                	mov    (%edx),%edx
c0204abd:	8b 12                	mov    (%edx),%edx
c0204abf:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204ac2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ac6:	75 0a                	jne    c0204ad2 <.L54+0x1d>
				return ERRO_POP_BLOCK;
c0204ac8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204acd:	e9 26 03 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204ad2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204ad5:	8b 52 04             	mov    0x4(%edx),%edx
c0204ad8:	85 d2                	test   %edx,%edx
c0204ada:	0f 85 c3 02 00 00    	jne    c0204da3 <.L66+0x7>
				MULTI_LINK ->_1 =NULL;
c0204ae0:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ae6:	8b 00                	mov    (%eax),%eax
c0204ae8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				return header->page_no;
c0204aee:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204af1:	8b 00                	mov    (%eax),%eax
c0204af3:	e9 00 03 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204af8 <.L56>:
			}
			break;
		case _2:
			header = MULTI_LINK ->_2;
c0204af8:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204afe:	8b 12                	mov    (%edx),%edx
c0204b00:	8b 52 04             	mov    0x4(%edx),%edx
c0204b03:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b06:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b0a:	75 0a                	jne    c0204b16 <.L56+0x1e>
				return ERRO_POP_BLOCK;
c0204b0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b11:	e9 e2 02 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204b16:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204b19:	8b 52 04             	mov    0x4(%edx),%edx
c0204b1c:	85 d2                	test   %edx,%edx
c0204b1e:	0f 85 82 02 00 00    	jne    c0204da6 <.L66+0xa>
				MULTI_LINK ->_2 = NULL;
c0204b24:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b2a:	8b 00                	mov    (%eax),%eax
c0204b2c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
				return header->page_no;
c0204b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b36:	8b 00                	mov    (%eax),%eax
c0204b38:	e9 bb 02 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204b3d <.L57>:
			}
			break;
		case _4:
			header = MULTI_LINK ->_4;
c0204b3d:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204b43:	8b 12                	mov    (%edx),%edx
c0204b45:	8b 52 08             	mov    0x8(%edx),%edx
c0204b48:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b4b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b4f:	75 0a                	jne    c0204b5b <.L57+0x1e>
				return ERRO_POP_BLOCK;
c0204b51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b56:	e9 9d 02 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204b5b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204b5e:	8b 52 04             	mov    0x4(%edx),%edx
c0204b61:	85 d2                	test   %edx,%edx
c0204b63:	0f 85 40 02 00 00    	jne    c0204da9 <.L66+0xd>
				MULTI_LINK ->_4 = NULL;
c0204b69:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b6f:	8b 00                	mov    (%eax),%eax
c0204b71:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				return header->page_no;
c0204b78:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b7b:	8b 00                	mov    (%eax),%eax
c0204b7d:	e9 76 02 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204b82 <.L58>:
			}
			break;
		case _8:
			header = MULTI_LINK ->_8;
c0204b82:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204b88:	8b 12                	mov    (%edx),%edx
c0204b8a:	8b 52 0c             	mov    0xc(%edx),%edx
c0204b8d:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b90:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b94:	75 0a                	jne    c0204ba0 <.L58+0x1e>
				return ERRO_POP_BLOCK;
c0204b96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b9b:	e9 58 02 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204ba0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204ba3:	8b 52 04             	mov    0x4(%edx),%edx
c0204ba6:	85 d2                	test   %edx,%edx
c0204ba8:	0f 85 fe 01 00 00    	jne    c0204dac <.L66+0x10>
				MULTI_LINK ->_8 = NULL;
c0204bae:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204bb4:	8b 00                	mov    (%eax),%eax
c0204bb6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				return header->page_no;
c0204bbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204bc0:	8b 00                	mov    (%eax),%eax
c0204bc2:	e9 31 02 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204bc7 <.L59>:
			}
			break;
		case _16:
			header = MULTI_LINK ->_16;
c0204bc7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204bcd:	8b 12                	mov    (%edx),%edx
c0204bcf:	8b 52 10             	mov    0x10(%edx),%edx
c0204bd2:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204bd5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204bd9:	75 0a                	jne    c0204be5 <.L59+0x1e>
				return ERRO_POP_BLOCK;
c0204bdb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204be0:	e9 13 02 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204be5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204be8:	8b 52 04             	mov    0x4(%edx),%edx
c0204beb:	85 d2                	test   %edx,%edx
c0204bed:	0f 85 bc 01 00 00    	jne    c0204daf <.L66+0x13>
				MULTI_LINK ->_16 = NULL;
c0204bf3:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204bf9:	8b 00                	mov    (%eax),%eax
c0204bfb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
				return header->page_no;
c0204c02:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c05:	8b 00                	mov    (%eax),%eax
c0204c07:	e9 ec 01 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204c0c <.L60>:
			}
			break;
		case _32:
			header = MULTI_LINK ->_32;
c0204c0c:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c12:	8b 12                	mov    (%edx),%edx
c0204c14:	8b 52 14             	mov    0x14(%edx),%edx
c0204c17:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204c1a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204c1e:	75 0a                	jne    c0204c2a <.L60+0x1e>
				return ERRO_POP_BLOCK;
c0204c20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c25:	e9 ce 01 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204c2a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c2d:	8b 52 04             	mov    0x4(%edx),%edx
c0204c30:	85 d2                	test   %edx,%edx
c0204c32:	0f 85 7a 01 00 00    	jne    c0204db2 <.L66+0x16>
				MULTI_LINK ->_32 = NULL;
c0204c38:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204c3e:	8b 00                	mov    (%eax),%eax
c0204c40:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
				return header->page_no;
c0204c47:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c4a:	8b 00                	mov    (%eax),%eax
c0204c4c:	e9 a7 01 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204c51 <.L61>:
			}
			break;
		case _64:
			header = MULTI_LINK ->_64;
c0204c51:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c57:	8b 12                	mov    (%edx),%edx
c0204c59:	8b 52 18             	mov    0x18(%edx),%edx
c0204c5c:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204c5f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204c63:	75 0a                	jne    c0204c6f <.L61+0x1e>
				return ERRO_POP_BLOCK;
c0204c65:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c6a:	e9 89 01 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204c6f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c72:	8b 52 04             	mov    0x4(%edx),%edx
c0204c75:	85 d2                	test   %edx,%edx
c0204c77:	0f 85 38 01 00 00    	jne    c0204db5 <.L66+0x19>
				MULTI_LINK ->_64 = NULL;
c0204c7d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204c83:	8b 00                	mov    (%eax),%eax
c0204c85:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
				return header->page_no;
c0204c8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c8f:	8b 00                	mov    (%eax),%eax
c0204c91:	e9 62 01 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204c96 <.L62>:
			}
			break;
		case _128:
			header = MULTI_LINK ->_128;
c0204c96:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c9c:	8b 12                	mov    (%edx),%edx
c0204c9e:	8b 52 1c             	mov    0x1c(%edx),%edx
c0204ca1:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204ca4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ca8:	75 0a                	jne    c0204cb4 <.L62+0x1e>
				return ERRO_POP_BLOCK;
c0204caa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204caf:	e9 44 01 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204cb4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204cb7:	8b 52 04             	mov    0x4(%edx),%edx
c0204cba:	85 d2                	test   %edx,%edx
c0204cbc:	0f 85 f6 00 00 00    	jne    c0204db8 <.L66+0x1c>
				MULTI_LINK ->_128 = NULL;
c0204cc2:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204cc8:	8b 00                	mov    (%eax),%eax
c0204cca:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
				return header->page_no;
c0204cd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204cd4:	8b 00                	mov    (%eax),%eax
c0204cd6:	e9 1d 01 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204cdb <.L63>:
			}
			break;
		case _256:
			header = MULTI_LINK ->_256;
c0204cdb:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204ce1:	8b 12                	mov    (%edx),%edx
c0204ce3:	8b 52 20             	mov    0x20(%edx),%edx
c0204ce6:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204ce9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ced:	75 0a                	jne    c0204cf9 <.L63+0x1e>
				return ERRO_POP_BLOCK;
c0204cef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204cf4:	e9 ff 00 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204cf9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204cfc:	8b 52 04             	mov    0x4(%edx),%edx
c0204cff:	85 d2                	test   %edx,%edx
c0204d01:	0f 85 b4 00 00 00    	jne    c0204dbb <.L66+0x1f>
				MULTI_LINK ->_256 = NULL;
c0204d07:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d0d:	8b 00                	mov    (%eax),%eax
c0204d0f:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				return header->page_no;
c0204d16:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d19:	8b 00                	mov    (%eax),%eax
c0204d1b:	e9 d8 00 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204d20 <.L64>:
			}
			break;
		case _512:
			header = MULTI_LINK ->_512;
c0204d20:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204d26:	8b 12                	mov    (%edx),%edx
c0204d28:	8b 52 24             	mov    0x24(%edx),%edx
c0204d2b:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204d2e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204d32:	75 0a                	jne    c0204d3e <.L64+0x1e>
				return ERRO_POP_BLOCK;
c0204d34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d39:	e9 ba 00 00 00       	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204d3e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204d41:	8b 52 04             	mov    0x4(%edx),%edx
c0204d44:	85 d2                	test   %edx,%edx
c0204d46:	75 76                	jne    c0204dbe <.L66+0x22>
				MULTI_LINK ->_512 = NULL;
c0204d48:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d4e:	8b 00                	mov    (%eax),%eax
c0204d50:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
				return header->page_no;
c0204d57:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d5a:	8b 00                	mov    (%eax),%eax
c0204d5c:	e9 97 00 00 00       	jmp    c0204df8 <.L66+0x5c>

c0204d61 <.L65>:
			}
			break;
		case _1024:
			header = MULTI_LINK ->_1024;
c0204d61:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204d67:	8b 12                	mov    (%edx),%edx
c0204d69:	8b 52 28             	mov    0x28(%edx),%edx
c0204d6c:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204d6f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204d73:	75 07                	jne    c0204d7c <.L65+0x1b>
				return ERRO_POP_BLOCK;
c0204d75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d7a:	eb 7c                	jmp    c0204df8 <.L66+0x5c>
			if(header->next==NULL){
c0204d7c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204d7f:	8b 52 04             	mov    0x4(%edx),%edx
c0204d82:	85 d2                	test   %edx,%edx
c0204d84:	75 3b                	jne    c0204dc1 <.L66+0x25>
				MULTI_LINK ->_1024 = NULL;
c0204d86:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d8c:	8b 00                	mov    (%eax),%eax
c0204d8e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
				return header->page_no;
c0204d95:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d98:	8b 00                	mov    (%eax),%eax
c0204d9a:	eb 5c                	jmp    c0204df8 <.L66+0x5c>

c0204d9c <.L66>:
			}
			break;
		case _erro:
			return ERRO_POP_BLOCK; 
c0204d9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204da1:	eb 55                	jmp    c0204df8 <.L66+0x5c>
			break;
c0204da3:	90                   	nop
c0204da4:	eb 1c                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204da6:	90                   	nop
c0204da7:	eb 19                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204da9:	90                   	nop
c0204daa:	eb 16                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204dac:	90                   	nop
c0204dad:	eb 13                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204daf:	90                   	nop
c0204db0:	eb 10                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204db2:	90                   	nop
c0204db3:	eb 0d                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204db5:	90                   	nop
c0204db6:	eb 0a                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204db8:	90                   	nop
c0204db9:	eb 07                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204dbb:	90                   	nop
c0204dbc:	eb 04                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204dbe:	90                   	nop
c0204dbf:	eb 01                	jmp    c0204dc2 <.L66+0x26>
			break;
c0204dc1:	90                   	nop
			break;
	}
	pm_page_t * probe = header;
c0204dc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204dc5:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;probe->next->next!=NULL;probe = probe->next)
c0204dc8:	eb 09                	jmp    c0204dd3 <.L66+0x37>
c0204dca:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204dcd:	8b 40 04             	mov    0x4(%eax),%eax
c0204dd0:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204dd3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204dd6:	8b 40 04             	mov    0x4(%eax),%eax
c0204dd9:	8b 40 04             	mov    0x4(%eax),%eax
c0204ddc:	85 c0                	test   %eax,%eax
c0204dde:	75 ea                	jne    c0204dca <.L66+0x2e>
		;
	uint32_t return_page_no = probe->next->page_no;
c0204de0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204de3:	8b 40 04             	mov    0x4(%eax),%eax
c0204de6:	8b 00                	mov    (%eax),%eax
c0204de8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	probe->next=NULL;
c0204deb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204dee:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	return return_page_no;
c0204df5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204df8:	c9                   	leave  
c0204df9:	c3                   	ret    

c0204dfa <find_and_pop_block>:
 
//free合并块使用函数
//如果链表中没有 返回ERRO_POP_BLOCK 否则返回对应page_no
static uint32_t find_and_pop_block(uint32_t target_page_no,page_c_t ph){
c0204dfa:	55                   	push   %ebp
c0204dfb:	89 e5                	mov    %esp,%ebp
c0204dfd:	83 ec 10             	sub    $0x10,%esp
c0204e00:	e8 fb 21 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204e05:	05 fb 31 00 00       	add    $0x31fb,%eax
	pm_page_t * header;
	switch(ph){
c0204e0a:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204e0e:	0f 87 d3 00 00 00    	ja     c0204ee7 <.L117+0xa>
c0204e14:	8b 55 0c             	mov    0xc(%ebp),%edx
c0204e17:	c1 e2 02             	shl    $0x2,%edx
c0204e1a:	8b 94 02 b4 00 00 00 	mov    0xb4(%edx,%eax,1),%edx
c0204e21:	01 c2                	add    %eax,%edx
c0204e23:	ff e2                	jmp    *%edx

c0204e25 <.L105>:
		case _1:
			header = MULTI_LINK -> _1;
c0204e25:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e2b:	8b 00                	mov    (%eax),%eax
c0204e2d:	8b 00                	mov    (%eax),%eax
c0204e2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e32:	e9 b0 00 00 00       	jmp    c0204ee7 <.L117+0xa>

c0204e37 <.L107>:
		case _2:
			header = MULTI_LINK -> _2;
c0204e37:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e3d:	8b 00                	mov    (%eax),%eax
c0204e3f:	8b 40 04             	mov    0x4(%eax),%eax
c0204e42:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e45:	e9 9d 00 00 00       	jmp    c0204ee7 <.L117+0xa>

c0204e4a <.L108>:
		case _4:
			header = MULTI_LINK -> _4;
c0204e4a:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e50:	8b 00                	mov    (%eax),%eax
c0204e52:	8b 40 08             	mov    0x8(%eax),%eax
c0204e55:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e58:	e9 8a 00 00 00       	jmp    c0204ee7 <.L117+0xa>

c0204e5d <.L109>:
		case _8:
			header = MULTI_LINK -> _8;
c0204e5d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e63:	8b 00                	mov    (%eax),%eax
c0204e65:	8b 40 0c             	mov    0xc(%eax),%eax
c0204e68:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e6b:	eb 7a                	jmp    c0204ee7 <.L117+0xa>

c0204e6d <.L110>:
		case _16:
			header = MULTI_LINK -> _16;
c0204e6d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e73:	8b 00                	mov    (%eax),%eax
c0204e75:	8b 40 10             	mov    0x10(%eax),%eax
c0204e78:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e7b:	eb 6a                	jmp    c0204ee7 <.L117+0xa>

c0204e7d <.L111>:
		case _32:
			header = MULTI_LINK -> _32;
c0204e7d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e83:	8b 00                	mov    (%eax),%eax
c0204e85:	8b 40 14             	mov    0x14(%eax),%eax
c0204e88:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e8b:	eb 5a                	jmp    c0204ee7 <.L117+0xa>

c0204e8d <.L112>:
		case _64:
			header = MULTI_LINK -> _64;
c0204e8d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e93:	8b 00                	mov    (%eax),%eax
c0204e95:	8b 40 18             	mov    0x18(%eax),%eax
c0204e98:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e9b:	eb 4a                	jmp    c0204ee7 <.L117+0xa>

c0204e9d <.L113>:
		case _128:
			header = MULTI_LINK -> _128;
c0204e9d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ea3:	8b 00                	mov    (%eax),%eax
c0204ea5:	8b 40 1c             	mov    0x1c(%eax),%eax
c0204ea8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204eab:	eb 3a                	jmp    c0204ee7 <.L117+0xa>

c0204ead <.L114>:
		case _256:
			header = MULTI_LINK -> _256;
c0204ead:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204eb3:	8b 00                	mov    (%eax),%eax
c0204eb5:	8b 40 20             	mov    0x20(%eax),%eax
c0204eb8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204ebb:	eb 2a                	jmp    c0204ee7 <.L117+0xa>

c0204ebd <.L115>:
		case _512:
			header = MULTI_LINK -> _512;
c0204ebd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ec3:	8b 00                	mov    (%eax),%eax
c0204ec5:	8b 40 24             	mov    0x24(%eax),%eax
c0204ec8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204ecb:	eb 1a                	jmp    c0204ee7 <.L117+0xa>

c0204ecd <.L116>:
		case _1024:
			header = MULTI_LINK -> _1024;
c0204ecd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ed3:	8b 00                	mov    (%eax),%eax
c0204ed5:	8b 40 28             	mov    0x28(%eax),%eax
c0204ed8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204edb:	eb 0a                	jmp    c0204ee7 <.L117+0xa>

c0204edd <.L117>:
		case _erro:
			return ERRO_POP_BLOCK;
c0204edd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204ee2:	e9 8c 00 00 00       	jmp    c0204f73 <.L117+0x96>
	}
	if(header == NULL)
c0204ee7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204eeb:	75 07                	jne    c0204ef4 <.L117+0x17>
		return ERRO_POP_BLOCK;
c0204eed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204ef2:	eb 7f                	jmp    c0204f73 <.L117+0x96>
	if(header->next==NULL){
c0204ef4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204ef7:	8b 40 04             	mov    0x4(%eax),%eax
c0204efa:	85 c0                	test   %eax,%eax
c0204efc:	75 1a                	jne    c0204f18 <.L117+0x3b>
		if(header->page_no==target_page_no){
c0204efe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204f01:	8b 00                	mov    (%eax),%eax
c0204f03:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f06:	75 10                	jne    c0204f18 <.L117+0x3b>
			pop_block(ph);
c0204f08:	ff 75 0c             	pushl  0xc(%ebp)
c0204f0b:	e8 7a fb ff ff       	call   c0204a8a <pop_block>
c0204f10:	83 c4 04             	add    $0x4,%esp
			return target_page_no;
c0204f13:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f16:	eb 5b                	jmp    c0204f73 <.L117+0x96>
		}
	}
	pm_page_t * probe = header ;
c0204f18:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204f1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(; probe->next!=NULL;probe=probe->next){
c0204f1e:	eb 2a                	jmp    c0204f4a <.L117+0x6d>
		if(probe->next->page_no == target_page_no){
c0204f20:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f23:	8b 40 04             	mov    0x4(%eax),%eax
c0204f26:	8b 00                	mov    (%eax),%eax
c0204f28:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f2b:	75 14                	jne    c0204f41 <.L117+0x64>
			probe->next = probe->next->next;
c0204f2d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f30:	8b 40 04             	mov    0x4(%eax),%eax
c0204f33:	8b 50 04             	mov    0x4(%eax),%edx
c0204f36:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f39:	89 50 04             	mov    %edx,0x4(%eax)
			return target_page_no;
c0204f3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f3f:	eb 32                	jmp    c0204f73 <.L117+0x96>
	for(; probe->next!=NULL;probe=probe->next){
c0204f41:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f44:	8b 40 04             	mov    0x4(%eax),%eax
c0204f47:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204f4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f4d:	8b 40 04             	mov    0x4(%eax),%eax
c0204f50:	85 c0                	test   %eax,%eax
c0204f52:	75 cc                	jne    c0204f20 <.L117+0x43>
		}
	}
	if(probe->page_no == target_page_no){
c0204f54:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f57:	8b 00                	mov    (%eax),%eax
c0204f59:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f5c:	75 10                	jne    c0204f6e <.L117+0x91>
		pop_block(ph);
c0204f5e:	ff 75 0c             	pushl  0xc(%ebp)
c0204f61:	e8 24 fb ff ff       	call   c0204a8a <pop_block>
c0204f66:	83 c4 04             	add    $0x4,%esp
		return target_page_no;
c0204f69:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f6c:	eb 05                	jmp    c0204f73 <.L117+0x96>
	}

	return ERRO_POP_BLOCK;
c0204f6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0204f73:	c9                   	leave  
c0204f74:	c3                   	ret    

c0204f75 <get_max_pm_addr>:

//从multi_boot结构体中取出需要管理的地址空间大小 
static uint32_t get_max_pm_addr(){          //qemu默认为128M
c0204f75:	55                   	push   %ebp
c0204f76:	89 e5                	mov    %esp,%ebp
c0204f78:	56                   	push   %esi
c0204f79:	53                   	push   %ebx
c0204f7a:	83 ec 10             	sub    $0x10,%esp
c0204f7d:	e8 82 20 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0204f82:	81 c3 7e 30 00 00    	add    $0x307e,%ebx
	uint32_t max_addr=0;
c0204f88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204f8f:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c0204f95:	8b 00                	mov    (%eax),%eax
c0204f97:	8b 40 30             	mov    0x30(%eax),%eax
c0204f9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0204f9d:	eb 6a                	jmp    c0205009 <get_max_pm_addr+0x94>
		printk("0x%h-0x%h-0x%h-%d\n",pm_entry_cur->base_addr_low,pm_entry_cur->length_low,pm_entry_cur->base_addr_low+pm_entry_cur->length_low,pm_entry_cur->type);
c0204f9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fa2:	8b 48 14             	mov    0x14(%eax),%ecx
c0204fa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fa8:	8b 50 04             	mov    0x4(%eax),%edx
c0204fab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fae:	8b 40 0c             	mov    0xc(%eax),%eax
c0204fb1:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0204fb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fb7:	8b 50 0c             	mov    0xc(%eax),%edx
c0204fba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fbd:	8b 40 04             	mov    0x4(%eax),%eax
c0204fc0:	83 ec 0c             	sub    $0xc,%esp
c0204fc3:	51                   	push   %ecx
c0204fc4:	56                   	push   %esi
c0204fc5:	52                   	push   %edx
c0204fc6:	50                   	push   %eax
c0204fc7:	8d 83 e4 00 00 00    	lea    0xe4(%ebx),%eax
c0204fcd:	50                   	push   %eax
c0204fce:	e8 93 e8 ff ff       	call   c0203866 <printk>
c0204fd3:	83 c4 20             	add    $0x20,%esp
		if(pm_entry_cur->type==1&&max_addr<pm_entry_cur->base_addr_low+pm_entry_cur->length_low)
c0204fd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fd9:	8b 40 14             	mov    0x14(%eax),%eax
c0204fdc:	83 f8 01             	cmp    $0x1,%eax
c0204fdf:	75 24                	jne    c0205005 <get_max_pm_addr+0x90>
c0204fe1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fe4:	8b 50 04             	mov    0x4(%eax),%edx
c0204fe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fea:	8b 40 0c             	mov    0xc(%eax),%eax
c0204fed:	01 d0                	add    %edx,%eax
c0204fef:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0204ff2:	73 11                	jae    c0205005 <get_max_pm_addr+0x90>
			max_addr=pm_entry_cur->base_addr_low+pm_entry_cur->length_low;		
c0204ff4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ff7:	8b 50 04             	mov    0x4(%eax),%edx
c0204ffa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ffd:	8b 40 0c             	mov    0xc(%eax),%eax
c0205000:	01 d0                	add    %edx,%eax
c0205002:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0205005:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
c0205009:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c020500f:	8b 00                	mov    (%eax),%eax
c0205011:	8b 50 30             	mov    0x30(%eax),%edx
c0205014:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c020501a:	8b 00                	mov    (%eax),%eax
c020501c:	8b 40 2c             	mov    0x2c(%eax),%eax
c020501f:	01 d0                	add    %edx,%eax
c0205021:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0205024:	0f 82 75 ff ff ff    	jb     c0204f9f <get_max_pm_addr+0x2a>
	}
	return max_addr;
c020502a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c020502d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0205030:	5b                   	pop    %ebx
c0205031:	5e                   	pop    %esi
c0205032:	5d                   	pop    %ebp
c0205033:	c3                   	ret    

c0205034 <pmm_page_init>:

//初始化页描述结构体以及装载链表
static void pmm_page_init(){  //初始化链表结构体并且填充链表
c0205034:	55                   	push   %ebp
c0205035:	89 e5                	mov    %esp,%ebp
c0205037:	53                   	push   %ebx
c0205038:	83 ec 14             	sub    $0x14,%esp
c020503b:	e8 c4 1f 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205040:	81 c3 c0 2f 00 00    	add    $0x2fc0,%ebx
	MULTI_LINK=&multi_link_struct;
c0205046:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020504c:	8d 93 a0 91 08 00    	lea    0x891a0(%ebx),%edx
c0205052:	89 10                	mov    %edx,(%eax)
	MULTI_LINK->_1=NULL;
c0205054:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020505a:	8b 00                	mov    (%eax),%eax
c020505c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	MULTI_LINK->_2=NULL;
c0205062:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205068:	8b 00                	mov    (%eax),%eax
c020506a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	MULTI_LINK->_4=NULL;
c0205071:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205077:	8b 00                	mov    (%eax),%eax
c0205079:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	MULTI_LINK->_8=NULL;
c0205080:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205086:	8b 00                	mov    (%eax),%eax
c0205088:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	MULTI_LINK->_16=NULL;
c020508f:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205095:	8b 00                	mov    (%eax),%eax
c0205097:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	MULTI_LINK->_32=NULL;
c020509e:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050a4:	8b 00                	mov    (%eax),%eax
c02050a6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	MULTI_LINK->_64=NULL;
c02050ad:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050b3:	8b 00                	mov    (%eax),%eax
c02050b5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	MULTI_LINK->_128=NULL;
c02050bc:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050c2:	8b 00                	mov    (%eax),%eax
c02050c4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	MULTI_LINK->_256=NULL;
c02050cb:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050d1:	8b 00                	mov    (%eax),%eax
c02050d3:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	MULTI_LINK->_512=NULL;
c02050da:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050e0:	8b 00                	mov    (%eax),%eax
c02050e2:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	MULTI_LINK->_1024=NULL;
c02050e9:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050ef:	8b 00                	mov    (%eax),%eax
c02050f1:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	//我们将要余出至多1023页来作为单页分配的一个缓冲区 这个缓冲区是与伙伴算法独立的 便于快速分配单页
	for(int i=0;i<pmm_max_page_no;i++){
c02050f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02050ff:	eb 51                	jmp    c0205152 <pmm_page_init+0x11e>
		page_array[i].page_no = i;
c0205101:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c0205107:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020510a:	89 d0                	mov    %edx,%eax
c020510c:	01 c0                	add    %eax,%eax
c020510e:	01 d0                	add    %edx,%eax
c0205110:	c1 e0 02             	shl    $0x2,%eax
c0205113:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0205116:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205119:	89 02                	mov    %eax,(%edx)
		page_array[i].state = 1;
c020511b:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c0205121:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205124:	89 d0                	mov    %edx,%eax
c0205126:	01 c0                	add    %eax,%eax
c0205128:	01 d0                	add    %edx,%eax
c020512a:	c1 e0 02             	shl    $0x2,%eax
c020512d:	01 c8                	add    %ecx,%eax
c020512f:	c6 40 08 01          	movb   $0x1,0x8(%eax)
		page_array[i].next = NULL;
c0205133:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c0205139:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020513c:	89 d0                	mov    %edx,%eax
c020513e:	01 c0                	add    %eax,%eax
c0205140:	01 d0                	add    %edx,%eax
c0205142:	c1 e0 02             	shl    $0x2,%eax
c0205145:	01 c8                	add    %ecx,%eax
c0205147:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	for(int i=0;i<pmm_max_page_no;i++){
c020514e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0205152:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205155:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c020515b:	39 c2                	cmp    %eax,%edx
c020515d:	72 a2                	jb     c0205101 <pmm_page_init+0xcd>
	}
	//装载链表
	append_block(0,_1);    //1页链表
c020515f:	6a 00                	push   $0x0
c0205161:	6a 00                	push   $0x0
c0205163:	e8 dc f5 ff ff       	call   c0204744 <append_block>
c0205168:	83 c4 08             	add    $0x8,%esp
	append_block(1,_1);
c020516b:	6a 00                	push   $0x0
c020516d:	6a 01                	push   $0x1
c020516f:	e8 d0 f5 ff ff       	call   c0204744 <append_block>
c0205174:	83 c4 08             	add    $0x8,%esp

	append_block(2,_2);    //2页链表
c0205177:	6a 01                	push   $0x1
c0205179:	6a 02                	push   $0x2
c020517b:	e8 c4 f5 ff ff       	call   c0204744 <append_block>
c0205180:	83 c4 08             	add    $0x8,%esp

	append_block(4,_4);
c0205183:	6a 02                	push   $0x2
c0205185:	6a 04                	push   $0x4
c0205187:	e8 b8 f5 ff ff       	call   c0204744 <append_block>
c020518c:	83 c4 08             	add    $0x8,%esp

	append_block(8,_8);
c020518f:	6a 03                	push   $0x3
c0205191:	6a 08                	push   $0x8
c0205193:	e8 ac f5 ff ff       	call   c0204744 <append_block>
c0205198:	83 c4 08             	add    $0x8,%esp

	append_block(16,_16);
c020519b:	6a 04                	push   $0x4
c020519d:	6a 10                	push   $0x10
c020519f:	e8 a0 f5 ff ff       	call   c0204744 <append_block>
c02051a4:	83 c4 08             	add    $0x8,%esp

	append_block(32,_32);
c02051a7:	6a 05                	push   $0x5
c02051a9:	6a 20                	push   $0x20
c02051ab:	e8 94 f5 ff ff       	call   c0204744 <append_block>
c02051b0:	83 c4 08             	add    $0x8,%esp

	append_block(64,_64);
c02051b3:	6a 06                	push   $0x6
c02051b5:	6a 40                	push   $0x40
c02051b7:	e8 88 f5 ff ff       	call   c0204744 <append_block>
c02051bc:	83 c4 08             	add    $0x8,%esp

	append_block(128,_128);
c02051bf:	6a 07                	push   $0x7
c02051c1:	68 80 00 00 00       	push   $0x80
c02051c6:	e8 79 f5 ff ff       	call   c0204744 <append_block>
c02051cb:	83 c4 08             	add    $0x8,%esp

	append_block(256,_256);
c02051ce:	6a 08                	push   $0x8
c02051d0:	68 00 01 00 00       	push   $0x100
c02051d5:	e8 6a f5 ff ff       	call   c0204744 <append_block>
c02051da:	83 c4 08             	add    $0x8,%esp

	append_block(512,_512);
c02051dd:	6a 09                	push   $0x9
c02051df:	68 00 02 00 00       	push   $0x200
c02051e4:	e8 5b f5 ff ff       	call   c0204744 <append_block>
c02051e9:	83 c4 08             	add    $0x8,%esp

	append_block(1024,_1024);
c02051ec:	6a 0a                	push   $0xa
c02051ee:	68 00 04 00 00       	push   $0x400
c02051f3:	e8 4c f5 ff ff       	call   c0204744 <append_block>
c02051f8:	83 c4 08             	add    $0x8,%esp


	int temp_page_no=2048;
c02051fb:	c7 45 f0 00 08 00 00 	movl   $0x800,-0x10(%ebp)
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0205202:	eb 14                	jmp    c0205218 <pmm_page_init+0x1e4>
		append_block(temp_page_no,_1024);
c0205204:	6a 0a                	push   $0xa
c0205206:	ff 75 f0             	pushl  -0x10(%ebp)
c0205209:	e8 36 f5 ff ff       	call   c0204744 <append_block>
c020520e:	83 c4 08             	add    $0x8,%esp
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0205211:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c0205218:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c020521e:	8d 90 00 fc ff ff    	lea    -0x400(%eax),%edx
c0205224:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0205227:	39 c2                	cmp    %eax,%edx
c0205229:	77 d9                	ja     c0205204 <pmm_page_init+0x1d0>
	}
	singel_page_first_no = temp_page_no;   //将第一个单页缓冲区的编号存放好
c020522b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020522e:	89 83 dc 91 08 00    	mov    %eax,0x891dc(%ebx)

	printk("we have %d pages for singel page alloc!\n",pmm_max_page_no-temp_page_no);
c0205234:	8b 93 d8 91 08 00    	mov    0x891d8(%ebx),%edx
c020523a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020523d:	29 c2                	sub    %eax,%edx
c020523f:	89 d0                	mov    %edx,%eax
c0205241:	83 ec 08             	sub    $0x8,%esp
c0205244:	50                   	push   %eax
c0205245:	8d 83 f8 00 00 00    	lea    0xf8(%ebx),%eax
c020524b:	50                   	push   %eax
c020524c:	e8 15 e6 ff ff       	call   c0203866 <printk>
c0205251:	83 c4 10             	add    $0x10,%esp
	pm_page_t * temp_single_probe = NULL;
c0205254:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c020525b:	eb 57                	jmp    c02052b4 <pmm_page_init+0x280>
		if(SINGLE_LINK == NULL){
c020525d:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205263:	85 c0                	test   %eax,%eax
c0205265:	75 25                	jne    c020528c <pmm_page_init+0x258>
			SINGLE_LINK=&(page_array[temp_page_no]);
c0205267:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c020526d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205270:	89 d0                	mov    %edx,%eax
c0205272:	01 c0                	add    %eax,%eax
c0205274:	01 d0                	add    %edx,%eax
c0205276:	c1 e0 02             	shl    $0x2,%eax
c0205279:	01 c8                	add    %ecx,%eax
c020527b:	89 83 cc 91 08 00    	mov    %eax,0x891cc(%ebx)
			temp_single_probe = SINGLE_LINK ;
c0205281:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205287:	89 45 ec             	mov    %eax,-0x14(%ebp)
c020528a:	eb 24                	jmp    c02052b0 <pmm_page_init+0x27c>
		}
		else{
			temp_single_probe->next = &(page_array[temp_page_no]);
c020528c:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c0205292:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205295:	89 d0                	mov    %edx,%eax
c0205297:	01 c0                	add    %eax,%eax
c0205299:	01 d0                	add    %edx,%eax
c020529b:	c1 e0 02             	shl    $0x2,%eax
c020529e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c02052a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02052a4:	89 50 04             	mov    %edx,0x4(%eax)
			temp_single_probe = temp_single_probe -> next;
c02052a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02052aa:	8b 40 04             	mov    0x4(%eax),%eax
c02052ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c02052b0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02052b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02052b7:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c02052bd:	39 c2                	cmp    %eax,%edx
c02052bf:	72 9c                	jb     c020525d <pmm_page_init+0x229>
		}
	}
}
c02052c1:	90                   	nop
c02052c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02052c5:	c9                   	leave  
c02052c6:	c3                   	ret    

c02052c7 <alloc_helper>:





static uint32_t alloc_helper(page_c_t target_ph,page_c_t pop_ph,uint32_t pop_page_no){
c02052c7:	55                   	push   %ebp
c02052c8:	89 e5                	mov    %esp,%ebp
c02052ca:	83 ec 10             	sub    $0x10,%esp
c02052cd:	e8 2e 1d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02052d2:	05 2e 2d 00 00       	add    $0x2d2e,%eax
	for(;pop_ph!=target_ph;pop_ph--){
c02052d7:	eb 2e                	jmp    c0205307 <alloc_helper+0x40>
		uint32_t append_page_no = pop_page_no+(c_to_uint32(pop_ph)/2);
c02052d9:	ff 75 0c             	pushl  0xc(%ebp)
c02052dc:	e8 f3 f3 ff ff       	call   c02046d4 <c_to_uint32>
c02052e1:	83 c4 04             	add    $0x4,%esp
c02052e4:	d1 e8                	shr    %eax
c02052e6:	89 c2                	mov    %eax,%edx
c02052e8:	8b 45 10             	mov    0x10(%ebp),%eax
c02052eb:	01 d0                	add    %edx,%eax
c02052ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
		append_block(append_page_no,pop_page_no-1);
c02052f0:	8b 45 10             	mov    0x10(%ebp),%eax
c02052f3:	8d 50 ff             	lea    -0x1(%eax),%edx
c02052f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02052f9:	52                   	push   %edx
c02052fa:	50                   	push   %eax
c02052fb:	e8 44 f4 ff ff       	call   c0204744 <append_block>
c0205300:	83 c4 08             	add    $0x8,%esp
	for(;pop_ph!=target_ph;pop_ph--){
c0205303:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0205307:	8b 45 0c             	mov    0xc(%ebp),%eax
c020530a:	3b 45 08             	cmp    0x8(%ebp),%eax
c020530d:	75 ca                	jne    c02052d9 <alloc_helper+0x12>
	}
	return pop_page_no;
c020530f:	8b 45 10             	mov    0x10(%ebp),%eax
}
c0205312:	c9                   	leave  
c0205313:	c3                   	ret    

c0205314 <pmm_alloc_pages>:



//伙伴算法多页分配
pm_alloc_t pmm_alloc_pages(uint32_t page_count){
c0205314:	55                   	push   %ebp
c0205315:	89 e5                	mov    %esp,%ebp
c0205317:	83 ec 30             	sub    $0x30,%esp
c020531a:	e8 e1 1c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020531f:	05 e1 2c 00 00       	add    $0x2ce1,%eax
	pm_alloc_t return_struct = {0,_erro,0}; 
c0205324:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c020532b:	c7 45 dc 0b 00 00 00 	movl   $0xb,-0x24(%ebp)
c0205332:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
	if (page_count>1024||page_count==0)
c0205336:	81 7d 0c 00 04 00 00 	cmpl   $0x400,0xc(%ebp)
c020533d:	77 06                	ja     c0205345 <pmm_alloc_pages+0x31>
c020533f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0205343:	75 19                	jne    c020535e <pmm_alloc_pages+0x4a>
		return return_struct;    //分配失败
c0205345:	8b 45 08             	mov    0x8(%ebp),%eax
c0205348:	8b 55 d8             	mov    -0x28(%ebp),%edx
c020534b:	89 10                	mov    %edx,(%eax)
c020534d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0205350:	89 50 04             	mov    %edx,0x4(%eax)
c0205353:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0205356:	89 50 08             	mov    %edx,0x8(%eax)
c0205359:	e9 ce 00 00 00       	jmp    c020542c <pmm_alloc_pages+0x118>
	//来点骚操作
	//获取需要分配的页数
	uint32_t page_count_probe=page_count;
c020535e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0205361:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter1 = 0;
c0205364:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;page_count_probe!=0 ;counter1++,page_count_probe=page_count_probe>>1)
c020536b:	eb 07                	jmp    c0205374 <pmm_alloc_pages+0x60>
c020536d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0205371:	d1 6d fc             	shrl   -0x4(%ebp)
c0205374:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0205378:	75 f3                	jne    c020536d <pmm_alloc_pages+0x59>
		;
	uint32_t counter2= counter1-1;
c020537a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020537d:	83 e8 01             	sub    $0x1,%eax
c0205380:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(page_count==(1<<counter2))
c0205383:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0205386:	ba 01 00 00 00       	mov    $0x1,%edx
c020538b:	89 c1                	mov    %eax,%ecx
c020538d:	d3 e2                	shl    %cl,%edx
c020538f:	89 d0                	mov    %edx,%eax
c0205391:	39 45 0c             	cmp    %eax,0xc(%ebp)
c0205394:	75 04                	jne    c020539a <pmm_alloc_pages+0x86>
		counter1--;
c0205396:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	//此时的counter1即为pm_c_t枚举的对应值
	page_c_t ph = counter1;
c020539a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020539d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	page_c_t origin_ph = ph;    //存放原始ph
c02053a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02053a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pop_page_no = ERRO_POP_BLOCK;
c02053a6:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	for(;ph<_erro;ph++){
c02053ad:	eb 18                	jmp    c02053c7 <pmm_alloc_pages+0xb3>
		pop_page_no = pop_block(ph);
c02053af:	ff 75 f4             	pushl  -0xc(%ebp)
c02053b2:	e8 d3 f6 ff ff       	call   c0204a8a <pop_block>
c02053b7:	83 c4 04             	add    $0x4,%esp
c02053ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(pop_page_no!=ERRO_POP_BLOCK)
c02053bd:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c02053c1:	75 0c                	jne    c02053cf <pmm_alloc_pages+0xbb>
	for(;ph<_erro;ph++){
c02053c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02053c7:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
c02053cb:	76 e2                	jbe    c02053af <pmm_alloc_pages+0x9b>
c02053cd:	eb 01                	jmp    c02053d0 <pmm_alloc_pages+0xbc>
			break;
c02053cf:	90                   	nop
	}
	if(pop_page_no==ERRO_POP_BLOCK){
c02053d0:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c02053d4:	75 16                	jne    c02053ec <pmm_alloc_pages+0xd8>
		return return_struct;    //分配失败
c02053d6:	8b 45 08             	mov    0x8(%ebp),%eax
c02053d9:	8b 55 d8             	mov    -0x28(%ebp),%edx
c02053dc:	89 10                	mov    %edx,(%eax)
c02053de:	8b 55 dc             	mov    -0x24(%ebp),%edx
c02053e1:	89 50 04             	mov    %edx,0x4(%eax)
c02053e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
c02053e7:	89 50 08             	mov    %edx,0x8(%eax)
c02053ea:	eb 40                	jmp    c020542c <pmm_alloc_pages+0x118>
	}
	else{
		uint32_t target_page_no = alloc_helper(origin_ph,ph,pop_page_no);
c02053ec:	ff 75 f0             	pushl  -0x10(%ebp)
c02053ef:	ff 75 f4             	pushl  -0xc(%ebp)
c02053f2:	ff 75 e8             	pushl  -0x18(%ebp)
c02053f5:	e8 cd fe ff ff       	call   c02052c7 <alloc_helper>
c02053fa:	83 c4 0c             	add    $0xc,%esp
c02053fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return_struct.addr = pmm_page_no_to_addr(target_page_no);
c0205400:	ff 75 e4             	pushl  -0x1c(%ebp)
c0205403:	e8 90 f2 ff ff       	call   c0204698 <pmm_page_no_to_addr>
c0205408:	83 c4 04             	add    $0x4,%esp
c020540b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		return_struct.state = 1;
c020540e:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
		return_struct.size = origin_ph;
c0205412:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0205415:	89 45 dc             	mov    %eax,-0x24(%ebp)
		return return_struct;
c0205418:	8b 45 08             	mov    0x8(%ebp),%eax
c020541b:	8b 55 d8             	mov    -0x28(%ebp),%edx
c020541e:	89 10                	mov    %edx,(%eax)
c0205420:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0205423:	89 50 04             	mov    %edx,0x4(%eax)
c0205426:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0205429:	89 50 08             	mov    %edx,0x8(%eax)
	}
}
c020542c:	8b 45 08             	mov    0x8(%ebp),%eax
c020542f:	c9                   	leave  
c0205430:	c2 04 00             	ret    $0x4

c0205433 <pmm_alloc_one_page>:

//缓冲区及伙伴算法单页分配
//当缓冲区没有页的时候会调用伙伴算法分配一页
pm_alloc_t pmm_alloc_one_page(){
c0205433:	55                   	push   %ebp
c0205434:	89 e5                	mov    %esp,%ebp
c0205436:	83 ec 20             	sub    $0x20,%esp
c0205439:	e8 c2 1b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020543e:	05 c2 2b 00 00       	add    $0x2bc2,%eax
	pm_alloc_t return_struct = {0,_erro,0};
c0205443:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c020544a:	c7 45 f0 0b 00 00 00 	movl   $0xb,-0x10(%ebp)
c0205451:	c6 45 f4 00          	movb   $0x0,-0xc(%ebp)
	if(SINGLE_LINK!=NULL){
c0205455:	8b 90 cc 91 08 00    	mov    0x891cc(%eax),%edx
c020545b:	85 d2                	test   %edx,%edx
c020545d:	0f 84 ac 00 00 00    	je     c020550f <pmm_alloc_one_page+0xdc>
		pm_page_t * header = SINGLE_LINK;
c0205463:	8b 90 cc 91 08 00    	mov    0x891cc(%eax),%edx
c0205469:	89 55 f8             	mov    %edx,-0x8(%ebp)
		if(header->next==NULL){
c020546c:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020546f:	8b 52 04             	mov    0x4(%edx),%edx
c0205472:	85 d2                	test   %edx,%edx
c0205474:	75 3c                	jne    c02054b2 <pmm_alloc_one_page+0x7f>
			SINGLE_LINK = NULL;
c0205476:	c7 80 cc 91 08 00 00 	movl   $0x0,0x891cc(%eax)
c020547d:	00 00 00 
			return_struct.state = 1;
c0205480:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c0205484:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(header->page_no);
c020548b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020548e:	8b 00                	mov    (%eax),%eax
c0205490:	50                   	push   %eax
c0205491:	e8 02 f2 ff ff       	call   c0204698 <pmm_page_no_to_addr>
c0205496:	83 c4 04             	add    $0x4,%esp
c0205499:	89 45 ec             	mov    %eax,-0x14(%ebp)
			return return_struct;
c020549c:	8b 45 08             	mov    0x8(%ebp),%eax
c020549f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c02054a2:	89 10                	mov    %edx,(%eax)
c02054a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02054a7:	89 50 04             	mov    %edx,0x4(%eax)
c02054aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02054ad:	89 50 08             	mov    %edx,0x8(%eax)
c02054b0:	eb 6b                	jmp    c020551d <pmm_alloc_one_page+0xea>
		}
		else{
			pm_page_t * probe = header;
c02054b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02054b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
			for(;probe->next->next!=NULL;probe=probe->next){
c02054b8:	eb 09                	jmp    c02054c3 <pmm_alloc_one_page+0x90>
c02054ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054bd:	8b 40 04             	mov    0x4(%eax),%eax
c02054c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c02054c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054c6:	8b 40 04             	mov    0x4(%eax),%eax
c02054c9:	8b 40 04             	mov    0x4(%eax),%eax
c02054cc:	85 c0                	test   %eax,%eax
c02054ce:	75 ea                	jne    c02054ba <pmm_alloc_one_page+0x87>
				//printk("%d\n",probe->page_no);
				//if(probe->page_no==0){
				//	while(1);
				//}
			}
			return_struct.state = 1;
c02054d0:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c02054d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(probe->next->page_no);
c02054db:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054de:	8b 40 04             	mov    0x4(%eax),%eax
c02054e1:	8b 00                	mov    (%eax),%eax
c02054e3:	50                   	push   %eax
c02054e4:	e8 af f1 ff ff       	call   c0204698 <pmm_page_no_to_addr>
c02054e9:	83 c4 04             	add    $0x4,%esp
c02054ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
			probe->next = NULL;
c02054ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054f2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		}
		return return_struct;
c02054f9:	8b 45 08             	mov    0x8(%ebp),%eax
c02054fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c02054ff:	89 10                	mov    %edx,(%eax)
c0205501:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205504:	89 50 04             	mov    %edx,0x4(%eax)
c0205507:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020550a:	89 50 08             	mov    %edx,0x8(%eax)
c020550d:	eb 0e                	jmp    c020551d <pmm_alloc_one_page+0xea>
	}
	else{
		return pmm_alloc_pages(1);
c020550f:	8b 45 08             	mov    0x8(%ebp),%eax
c0205512:	6a 01                	push   $0x1
c0205514:	50                   	push   %eax
c0205515:	e8 fa fd ff ff       	call   c0205314 <pmm_alloc_pages>
c020551a:	83 c4 04             	add    $0x4,%esp
	}
}
c020551d:	8b 45 08             	mov    0x8(%ebp),%eax
c0205520:	c9                   	leave  
c0205521:	c2 04 00             	ret    $0x4

c0205524 <free_helper>:

static void free_helper(uint32_t page_no,page_c_t size){
c0205524:	55                   	push   %ebp
c0205525:	89 e5                	mov    %esp,%ebp
c0205527:	53                   	push   %ebx
c0205528:	83 ec 14             	sub    $0x14,%esp
c020552b:	e8 d4 1a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205530:	81 c3 d0 2a 00 00    	add    $0x2ad0,%ebx
	printk("free size : %d\n",c_to_uint32(size));
c0205536:	ff 75 0c             	pushl  0xc(%ebp)
c0205539:	e8 96 f1 ff ff       	call   c02046d4 <c_to_uint32>
c020553e:	83 c4 04             	add    $0x4,%esp
c0205541:	83 ec 08             	sub    $0x8,%esp
c0205544:	50                   	push   %eax
c0205545:	8d 83 21 01 00 00    	lea    0x121(%ebx),%eax
c020554b:	50                   	push   %eax
c020554c:	e8 15 e3 ff ff       	call   c0203866 <printk>
c0205551:	83 c4 10             	add    $0x10,%esp
	uint32_t partner_page_no = get_partner_page_no(page_no,size);
c0205554:	83 ec 08             	sub    $0x8,%esp
c0205557:	ff 75 0c             	pushl  0xc(%ebp)
c020555a:	ff 75 08             	pushl  0x8(%ebp)
c020555d:	e8 96 f1 ff ff       	call   c02046f8 <get_partner_page_no>
c0205562:	83 c4 10             	add    $0x10,%esp
c0205565:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(find_and_pop_block(partner_page_no,size)!=ERRO_POP_BLOCK){
c0205568:	83 ec 08             	sub    $0x8,%esp
c020556b:	ff 75 0c             	pushl  0xc(%ebp)
c020556e:	ff 75 f4             	pushl  -0xc(%ebp)
c0205571:	e8 84 f8 ff ff       	call   c0204dfa <find_and_pop_block>
c0205576:	83 c4 10             	add    $0x10,%esp
c0205579:	83 f8 ff             	cmp    $0xffffffff,%eax
c020557c:	74 1f                	je     c020559d <free_helper+0x79>
		//合并
		free_helper(partner_page_no<page_no?partner_page_no:page_no,size+1);
c020557e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0205581:	8d 50 01             	lea    0x1(%eax),%edx
c0205584:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205587:	39 45 08             	cmp    %eax,0x8(%ebp)
c020558a:	0f 46 45 08          	cmovbe 0x8(%ebp),%eax
c020558e:	83 ec 08             	sub    $0x8,%esp
c0205591:	52                   	push   %edx
c0205592:	50                   	push   %eax
c0205593:	e8 8c ff ff ff       	call   c0205524 <free_helper>
c0205598:	83 c4 10             	add    $0x10,%esp
	}
	else{
		append_block(page_no,size);
	}
}
c020559b:	eb 12                	jmp    c02055af <free_helper+0x8b>
		append_block(page_no,size);
c020559d:	8b 45 08             	mov    0x8(%ebp),%eax
c02055a0:	83 ec 08             	sub    $0x8,%esp
c02055a3:	ff 75 0c             	pushl  0xc(%ebp)
c02055a6:	50                   	push   %eax
c02055a7:	e8 98 f1 ff ff       	call   c0204744 <append_block>
c02055ac:	83 c4 10             	add    $0x10,%esp
}
c02055af:	90                   	nop
c02055b0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02055b3:	c9                   	leave  
c02055b4:	c3                   	ret    

c02055b5 <pmm_free_page>:

//free页 返回bool型（定义在typs.h中） True-成功free False-失败
bool pmm_free_page(pm_alloc_t block_disc){
c02055b5:	55                   	push   %ebp
c02055b6:	89 e5                	mov    %esp,%ebp
c02055b8:	53                   	push   %ebx
c02055b9:	83 ec 14             	sub    $0x14,%esp
c02055bc:	e8 43 1a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02055c1:	81 c3 3f 2a 00 00    	add    $0x2a3f,%ebx
	//检查页是否在页编号范围内
	uint32_t page_no = addr_to_pmm_page_no(block_disc.addr);
c02055c7:	8b 45 08             	mov    0x8(%ebp),%eax
c02055ca:	50                   	push   %eax
c02055cb:	e8 e5 f0 ff ff       	call   c02046b5 <addr_to_pmm_page_no>
c02055d0:	83 c4 04             	add    $0x4,%esp
c02055d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(page_no<pmm_max_page_no){
c02055d6:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c02055dc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c02055df:	73 7f                	jae    c0205660 <pmm_free_page+0xab>
		if(page_no<singel_page_first_no)
c02055e1:	8b 83 dc 91 08 00    	mov    0x891dc(%ebx),%eax
c02055e7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c02055ea:	73 14                	jae    c0205600 <pmm_free_page+0x4b>
			free_helper(page_no,block_disc.size);
c02055ec:	8b 45 0c             	mov    0xc(%ebp),%eax
c02055ef:	83 ec 08             	sub    $0x8,%esp
c02055f2:	50                   	push   %eax
c02055f3:	ff 75 f0             	pushl  -0x10(%ebp)
c02055f6:	e8 29 ff ff ff       	call   c0205524 <free_helper>
c02055fb:	83 c4 10             	add    $0x10,%esp
c02055fe:	eb 59                	jmp    c0205659 <pmm_free_page+0xa4>
		else{
			pm_page_t *probe = SINGLE_LINK;
c0205600:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205606:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if(probe==NULL){
c0205609:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c020560d:	75 25                	jne    c0205634 <pmm_free_page+0x7f>
				SINGLE_LINK=&page_array[page_no];
c020560f:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c0205615:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205618:	89 d0                	mov    %edx,%eax
c020561a:	01 c0                	add    %eax,%eax
c020561c:	01 d0                	add    %edx,%eax
c020561e:	c1 e0 02             	shl    $0x2,%eax
c0205621:	01 c8                	add    %ecx,%eax
c0205623:	89 83 cc 91 08 00    	mov    %eax,0x891cc(%ebx)
c0205629:	eb 2e                	jmp    c0205659 <pmm_free_page+0xa4>
			}
			else{
				for(;probe->next!=NULL;probe=probe->next)
c020562b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020562e:	8b 40 04             	mov    0x4(%eax),%eax
c0205631:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0205634:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205637:	8b 40 04             	mov    0x4(%eax),%eax
c020563a:	85 c0                	test   %eax,%eax
c020563c:	75 ed                	jne    c020562b <pmm_free_page+0x76>
					;
				probe->next = &page_array[page_no];
c020563e:	8b 8b 28 f0 ff ff    	mov    -0xfd8(%ebx),%ecx
c0205644:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205647:	89 d0                	mov    %edx,%eax
c0205649:	01 c0                	add    %eax,%eax
c020564b:	01 d0                	add    %edx,%eax
c020564d:	c1 e0 02             	shl    $0x2,%eax
c0205650:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0205653:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205656:	89 50 04             	mov    %edx,0x4(%eax)
			}
		}
		return True;
c0205659:	b8 01 00 00 00       	mov    $0x1,%eax
c020565e:	eb 05                	jmp    c0205665 <pmm_free_page+0xb0>
	}
	else
		return False;
c0205660:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0205665:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205668:	c9                   	leave  
c0205669:	c3                   	ret    

c020566a <counte_helper>:

static uint32_t counte_helper(pm_page_t * probe){
c020566a:	55                   	push   %ebp
c020566b:	89 e5                	mov    %esp,%ebp
c020566d:	83 ec 10             	sub    $0x10,%esp
c0205670:	e8 8b 19 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205675:	05 8b 29 00 00       	add    $0x298b,%eax
	uint32_t counter = 0;
c020567a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205681:	eb 0d                	jmp    c0205690 <counte_helper+0x26>
		counter++;
c0205683:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205687:	8b 45 08             	mov    0x8(%ebp),%eax
c020568a:	8b 40 04             	mov    0x4(%eax),%eax
c020568d:	89 45 08             	mov    %eax,0x8(%ebp)
c0205690:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0205694:	75 ed                	jne    c0205683 <counte_helper+0x19>
	return counter;
c0205696:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0205699:	c9                   	leave  
c020569a:	c3                   	ret    

c020569b <get_block_count>:

uint32_t * get_block_count(){
c020569b:	55                   	push   %ebp
c020569c:	89 e5                	mov    %esp,%ebp
c020569e:	53                   	push   %ebx
c020569f:	e8 60 19 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02056a4:	81 c3 5c 29 00 00    	add    $0x295c,%ebx
	block_count_array[_1]=counte_helper(MULTI_LINK->_1);
c02056aa:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056b0:	8b 00                	mov    (%eax),%eax
c02056b2:	8b 00                	mov    (%eax),%eax
c02056b4:	50                   	push   %eax
c02056b5:	e8 b0 ff ff ff       	call   c020566a <counte_helper>
c02056ba:	83 c4 04             	add    $0x4,%esp
c02056bd:	89 83 60 91 08 00    	mov    %eax,0x89160(%ebx)
	block_count_array[_2]=counte_helper(MULTI_LINK->_2);
c02056c3:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056c9:	8b 00                	mov    (%eax),%eax
c02056cb:	8b 40 04             	mov    0x4(%eax),%eax
c02056ce:	50                   	push   %eax
c02056cf:	e8 96 ff ff ff       	call   c020566a <counte_helper>
c02056d4:	83 c4 04             	add    $0x4,%esp
c02056d7:	89 83 64 91 08 00    	mov    %eax,0x89164(%ebx)
	block_count_array[_4]=counte_helper(MULTI_LINK->_4);
c02056dd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056e3:	8b 00                	mov    (%eax),%eax
c02056e5:	8b 40 08             	mov    0x8(%eax),%eax
c02056e8:	50                   	push   %eax
c02056e9:	e8 7c ff ff ff       	call   c020566a <counte_helper>
c02056ee:	83 c4 04             	add    $0x4,%esp
c02056f1:	89 83 68 91 08 00    	mov    %eax,0x89168(%ebx)
	block_count_array[_8]=counte_helper(MULTI_LINK->_8);
c02056f7:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056fd:	8b 00                	mov    (%eax),%eax
c02056ff:	8b 40 0c             	mov    0xc(%eax),%eax
c0205702:	50                   	push   %eax
c0205703:	e8 62 ff ff ff       	call   c020566a <counte_helper>
c0205708:	83 c4 04             	add    $0x4,%esp
c020570b:	89 83 6c 91 08 00    	mov    %eax,0x8916c(%ebx)
	block_count_array[_16]=counte_helper(MULTI_LINK->_16);
c0205711:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205717:	8b 00                	mov    (%eax),%eax
c0205719:	8b 40 10             	mov    0x10(%eax),%eax
c020571c:	50                   	push   %eax
c020571d:	e8 48 ff ff ff       	call   c020566a <counte_helper>
c0205722:	83 c4 04             	add    $0x4,%esp
c0205725:	89 83 70 91 08 00    	mov    %eax,0x89170(%ebx)
	block_count_array[_32]=counte_helper(MULTI_LINK->_32);
c020572b:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205731:	8b 00                	mov    (%eax),%eax
c0205733:	8b 40 14             	mov    0x14(%eax),%eax
c0205736:	50                   	push   %eax
c0205737:	e8 2e ff ff ff       	call   c020566a <counte_helper>
c020573c:	83 c4 04             	add    $0x4,%esp
c020573f:	89 83 74 91 08 00    	mov    %eax,0x89174(%ebx)
	block_count_array[_64]=counte_helper(MULTI_LINK->_64);
c0205745:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020574b:	8b 00                	mov    (%eax),%eax
c020574d:	8b 40 18             	mov    0x18(%eax),%eax
c0205750:	50                   	push   %eax
c0205751:	e8 14 ff ff ff       	call   c020566a <counte_helper>
c0205756:	83 c4 04             	add    $0x4,%esp
c0205759:	89 83 78 91 08 00    	mov    %eax,0x89178(%ebx)
	block_count_array[_128]=counte_helper(MULTI_LINK->_128);
c020575f:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205765:	8b 00                	mov    (%eax),%eax
c0205767:	8b 40 1c             	mov    0x1c(%eax),%eax
c020576a:	50                   	push   %eax
c020576b:	e8 fa fe ff ff       	call   c020566a <counte_helper>
c0205770:	83 c4 04             	add    $0x4,%esp
c0205773:	89 83 7c 91 08 00    	mov    %eax,0x8917c(%ebx)
	block_count_array[_256]=counte_helper(MULTI_LINK->_256);
c0205779:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020577f:	8b 00                	mov    (%eax),%eax
c0205781:	8b 40 20             	mov    0x20(%eax),%eax
c0205784:	50                   	push   %eax
c0205785:	e8 e0 fe ff ff       	call   c020566a <counte_helper>
c020578a:	83 c4 04             	add    $0x4,%esp
c020578d:	89 83 80 91 08 00    	mov    %eax,0x89180(%ebx)
	block_count_array[_512]=counte_helper(MULTI_LINK->_512);
c0205793:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205799:	8b 00                	mov    (%eax),%eax
c020579b:	8b 40 24             	mov    0x24(%eax),%eax
c020579e:	50                   	push   %eax
c020579f:	e8 c6 fe ff ff       	call   c020566a <counte_helper>
c02057a4:	83 c4 04             	add    $0x4,%esp
c02057a7:	89 83 84 91 08 00    	mov    %eax,0x89184(%ebx)
	block_count_array[_1024]=counte_helper(MULTI_LINK->_1024);
c02057ad:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02057b3:	8b 00                	mov    (%eax),%eax
c02057b5:	8b 40 28             	mov    0x28(%eax),%eax
c02057b8:	50                   	push   %eax
c02057b9:	e8 ac fe ff ff       	call   c020566a <counte_helper>
c02057be:	83 c4 04             	add    $0x4,%esp
c02057c1:	89 83 88 91 08 00    	mov    %eax,0x89188(%ebx)
	block_count_array[_erro]=0;
c02057c7:	c7 83 8c 91 08 00 00 	movl   $0x0,0x8918c(%ebx)
c02057ce:	00 00 00 
	return block_count_array;
c02057d1:	8d 83 60 91 08 00    	lea    0x89160(%ebx),%eax
}
c02057d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02057da:	c9                   	leave  
c02057db:	c3                   	ret    

c02057dc <get_single_count>:

uint32_t get_single_count(){
c02057dc:	55                   	push   %ebp
c02057dd:	89 e5                	mov    %esp,%ebp
c02057df:	83 ec 10             	sub    $0x10,%esp
c02057e2:	e8 19 18 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02057e7:	05 19 28 00 00       	add    $0x2819,%eax
	pm_page_t * probe =SINGLE_LINK;
c02057ec:	8b 80 cc 91 08 00    	mov    0x891cc(%eax),%eax
c02057f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter = 0;
c02057f5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02057fc:	eb 0d                	jmp    c020580b <get_single_count+0x2f>
		counter++;
c02057fe:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205802:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205805:	8b 40 04             	mov    0x4(%eax),%eax
c0205808:	89 45 fc             	mov    %eax,-0x4(%ebp)
c020580b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020580f:	75 ed                	jne    c02057fe <get_single_count+0x22>
	return counter;	
c0205811:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0205814:	c9                   	leave  
c0205815:	c3                   	ret    

c0205816 <pmm_show_page_count>:

//打印块使用情况的函数 
//懒得挨个写 用宏来解决
// #表示字符串化 ##表示连接生成符号操作
#define MACRO_PMM_1(number) printk("_"#number":%d blocks\n",block_count_array[_##number])
void pmm_show_page_count(){
c0205816:	55                   	push   %ebp
c0205817:	89 e5                	mov    %esp,%ebp
c0205819:	53                   	push   %ebx
c020581a:	83 ec 04             	sub    $0x4,%esp
c020581d:	e8 e2 17 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205822:	81 c3 de 27 00 00    	add    $0x27de,%ebx
	get_block_count();
c0205828:	e8 6e fe ff ff       	call   c020569b <get_block_count>
	printk("Partner:\n");
c020582d:	83 ec 0c             	sub    $0xc,%esp
c0205830:	8d 83 31 01 00 00    	lea    0x131(%ebx),%eax
c0205836:	50                   	push   %eax
c0205837:	e8 2a e0 ff ff       	call   c0203866 <printk>
c020583c:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1);
c020583f:	8b 83 60 91 08 00    	mov    0x89160(%ebx),%eax
c0205845:	83 ec 08             	sub    $0x8,%esp
c0205848:	50                   	push   %eax
c0205849:	8d 83 3b 01 00 00    	lea    0x13b(%ebx),%eax
c020584f:	50                   	push   %eax
c0205850:	e8 11 e0 ff ff       	call   c0203866 <printk>
c0205855:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(2);
c0205858:	8b 83 64 91 08 00    	mov    0x89164(%ebx),%eax
c020585e:	83 ec 08             	sub    $0x8,%esp
c0205861:	50                   	push   %eax
c0205862:	8d 83 49 01 00 00    	lea    0x149(%ebx),%eax
c0205868:	50                   	push   %eax
c0205869:	e8 f8 df ff ff       	call   c0203866 <printk>
c020586e:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(4);
c0205871:	8b 83 68 91 08 00    	mov    0x89168(%ebx),%eax
c0205877:	83 ec 08             	sub    $0x8,%esp
c020587a:	50                   	push   %eax
c020587b:	8d 83 57 01 00 00    	lea    0x157(%ebx),%eax
c0205881:	50                   	push   %eax
c0205882:	e8 df df ff ff       	call   c0203866 <printk>
c0205887:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(8);
c020588a:	8b 83 6c 91 08 00    	mov    0x8916c(%ebx),%eax
c0205890:	83 ec 08             	sub    $0x8,%esp
c0205893:	50                   	push   %eax
c0205894:	8d 83 65 01 00 00    	lea    0x165(%ebx),%eax
c020589a:	50                   	push   %eax
c020589b:	e8 c6 df ff ff       	call   c0203866 <printk>
c02058a0:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(16);
c02058a3:	8b 83 70 91 08 00    	mov    0x89170(%ebx),%eax
c02058a9:	83 ec 08             	sub    $0x8,%esp
c02058ac:	50                   	push   %eax
c02058ad:	8d 83 73 01 00 00    	lea    0x173(%ebx),%eax
c02058b3:	50                   	push   %eax
c02058b4:	e8 ad df ff ff       	call   c0203866 <printk>
c02058b9:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(32);
c02058bc:	8b 83 74 91 08 00    	mov    0x89174(%ebx),%eax
c02058c2:	83 ec 08             	sub    $0x8,%esp
c02058c5:	50                   	push   %eax
c02058c6:	8d 83 82 01 00 00    	lea    0x182(%ebx),%eax
c02058cc:	50                   	push   %eax
c02058cd:	e8 94 df ff ff       	call   c0203866 <printk>
c02058d2:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(64);
c02058d5:	8b 83 78 91 08 00    	mov    0x89178(%ebx),%eax
c02058db:	83 ec 08             	sub    $0x8,%esp
c02058de:	50                   	push   %eax
c02058df:	8d 83 91 01 00 00    	lea    0x191(%ebx),%eax
c02058e5:	50                   	push   %eax
c02058e6:	e8 7b df ff ff       	call   c0203866 <printk>
c02058eb:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(128);
c02058ee:	8b 83 7c 91 08 00    	mov    0x8917c(%ebx),%eax
c02058f4:	83 ec 08             	sub    $0x8,%esp
c02058f7:	50                   	push   %eax
c02058f8:	8d 83 a0 01 00 00    	lea    0x1a0(%ebx),%eax
c02058fe:	50                   	push   %eax
c02058ff:	e8 62 df ff ff       	call   c0203866 <printk>
c0205904:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(256);
c0205907:	8b 83 80 91 08 00    	mov    0x89180(%ebx),%eax
c020590d:	83 ec 08             	sub    $0x8,%esp
c0205910:	50                   	push   %eax
c0205911:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0205917:	50                   	push   %eax
c0205918:	e8 49 df ff ff       	call   c0203866 <printk>
c020591d:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(512);
c0205920:	8b 83 84 91 08 00    	mov    0x89184(%ebx),%eax
c0205926:	83 ec 08             	sub    $0x8,%esp
c0205929:	50                   	push   %eax
c020592a:	8d 83 c0 01 00 00    	lea    0x1c0(%ebx),%eax
c0205930:	50                   	push   %eax
c0205931:	e8 30 df ff ff       	call   c0203866 <printk>
c0205936:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1024);
c0205939:	8b 83 88 91 08 00    	mov    0x89188(%ebx),%eax
c020593f:	83 ec 08             	sub    $0x8,%esp
c0205942:	50                   	push   %eax
c0205943:	8d 83 d0 01 00 00    	lea    0x1d0(%ebx),%eax
c0205949:	50                   	push   %eax
c020594a:	e8 17 df ff ff       	call   c0203866 <printk>
c020594f:	83 c4 10             	add    $0x10,%esp
	printk("singel buffer have:%d pages!\n",get_single_count());
c0205952:	e8 85 fe ff ff       	call   c02057dc <get_single_count>
c0205957:	83 ec 08             	sub    $0x8,%esp
c020595a:	50                   	push   %eax
c020595b:	8d 83 e1 01 00 00    	lea    0x1e1(%ebx),%eax
c0205961:	50                   	push   %eax
c0205962:	e8 ff de ff ff       	call   c0203866 <printk>
c0205967:	83 c4 10             	add    $0x10,%esp
}
c020596a:	90                   	nop
c020596b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020596e:	c9                   	leave  
c020596f:	c3                   	ret    

c0205970 <pmm_init>:
//取消此宏定义 将宏定义范围限制在此函数中
#undef MACRO_PMM_1(number)

//为内核entry使用的pmm管理模块初始化函数
void pmm_init(){
c0205970:	55                   	push   %ebp
c0205971:	89 e5                	mov    %esp,%ebp
c0205973:	53                   	push   %ebx
c0205974:	83 ec 04             	sub    $0x4,%esp
c0205977:	e8 88 16 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020597c:	81 c3 84 26 00 00    	add    $0x2684,%ebx
	printk("kern_start:0x%h\n",kern_start);
c0205982:	83 ec 08             	sub    $0x8,%esp
c0205985:	c7 c0 00 00 10 00    	mov    $0x100000,%eax
c020598b:	50                   	push   %eax
c020598c:	8d 83 ff 01 00 00    	lea    0x1ff(%ebx),%eax
c0205992:	50                   	push   %eax
c0205993:	e8 ce de ff ff       	call   c0203866 <printk>
c0205998:	83 c4 10             	add    $0x10,%esp
	printk("kern_end:0x%h\n",kern_end);
c020599b:	83 ec 08             	sub    $0x8,%esp
c020599e:	c7 c0 00 e0 29 00    	mov    $0x29e000,%eax
c02059a4:	50                   	push   %eax
c02059a5:	8d 83 10 02 00 00    	lea    0x210(%ebx),%eax
c02059ab:	50                   	push   %eax
c02059ac:	e8 b5 de ff ff       	call   c0203866 <printk>
c02059b1:	83 c4 10             	add    $0x10,%esp

	//一定要注意 由于分页必须4k对齐 所以此处的物理页管理必须与虚拟页相同 都要4K对齐
	pmm_page_start = ((((uint32_t)kern_end >> 12))+1)<<12;
c02059b4:	c7 c0 00 e0 29 00    	mov    $0x29e000,%eax
c02059ba:	c1 e8 0c             	shr    $0xc,%eax
c02059bd:	83 c0 01             	add    $0x1,%eax
c02059c0:	c1 e0 0c             	shl    $0xc,%eax
c02059c3:	89 83 d0 91 08 00    	mov    %eax,0x891d0(%ebx)
	pmm_page_end = (((get_max_pm_addr() >> 12)))<<12;
c02059c9:	e8 a7 f5 ff ff       	call   c0204f75 <get_max_pm_addr>
c02059ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02059d3:	89 83 d4 91 08 00    	mov    %eax,0x891d4(%ebx)
	pmm_max_page_no = ((pmm_page_end - pmm_page_start)>>12);
c02059d9:	8b 93 d4 91 08 00    	mov    0x891d4(%ebx),%edx
c02059df:	8b 83 d0 91 08 00    	mov    0x891d0(%ebx),%eax
c02059e5:	29 c2                	sub    %eax,%edx
c02059e7:	89 d0                	mov    %edx,%eax
c02059e9:	c1 e8 0c             	shr    $0xc,%eax
c02059ec:	89 83 d8 91 08 00    	mov    %eax,0x891d8(%ebx)
	printk("0x%h\n",pmm_page_start);
c02059f2:	8b 83 d0 91 08 00    	mov    0x891d0(%ebx),%eax
c02059f8:	83 ec 08             	sub    $0x8,%esp
c02059fb:	50                   	push   %eax
c02059fc:	8d 83 1f 02 00 00    	lea    0x21f(%ebx),%eax
c0205a02:	50                   	push   %eax
c0205a03:	e8 5e de ff ff       	call   c0203866 <printk>
c0205a08:	83 c4 10             	add    $0x10,%esp
	printk("0x%h\n",pmm_page_end);
c0205a0b:	8b 83 d4 91 08 00    	mov    0x891d4(%ebx),%eax
c0205a11:	83 ec 08             	sub    $0x8,%esp
c0205a14:	50                   	push   %eax
c0205a15:	8d 83 1f 02 00 00    	lea    0x21f(%ebx),%eax
c0205a1b:	50                   	push   %eax
c0205a1c:	e8 45 de ff ff       	call   c0203866 <printk>
c0205a21:	83 c4 10             	add    $0x10,%esp
	printk("%d\n",pmm_max_page_no);
c0205a24:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c0205a2a:	83 ec 08             	sub    $0x8,%esp
c0205a2d:	50                   	push   %eax
c0205a2e:	8d 83 25 02 00 00    	lea    0x225(%ebx),%eax
c0205a34:	50                   	push   %eax
c0205a35:	e8 2c de ff ff       	call   c0203866 <printk>
c0205a3a:	83 c4 10             	add    $0x10,%esp
	printk("page0:0x%h\n",pmm_page_no_to_addr(32000));
c0205a3d:	83 ec 0c             	sub    $0xc,%esp
c0205a40:	68 00 7d 00 00       	push   $0x7d00
c0205a45:	e8 4e ec ff ff       	call   c0204698 <pmm_page_no_to_addr>
c0205a4a:	83 c4 10             	add    $0x10,%esp
c0205a4d:	83 ec 08             	sub    $0x8,%esp
c0205a50:	50                   	push   %eax
c0205a51:	8d 83 29 02 00 00    	lea    0x229(%ebx),%eax
c0205a57:	50                   	push   %eax
c0205a58:	e8 09 de ff ff       	call   c0203866 <printk>
c0205a5d:	83 c4 10             	add    $0x10,%esp
	pmm_page_init();
c0205a60:	e8 cf f5 ff ff       	call   c0205034 <pmm_page_init>
	printk("page_no:%d\n",SINGLE_LINK->next->page_no);
c0205a65:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205a6b:	8b 40 04             	mov    0x4(%eax),%eax
c0205a6e:	8b 00                	mov    (%eax),%eax
c0205a70:	83 ec 08             	sub    $0x8,%esp
c0205a73:	50                   	push   %eax
c0205a74:	8d 83 35 02 00 00    	lea    0x235(%ebx),%eax
c0205a7a:	50                   	push   %eax
c0205a7b:	e8 e6 dd ff ff       	call   c0203866 <printk>
c0205a80:	83 c4 10             	add    $0x10,%esp
	printk("***%d***",get_partner_page_no(4,_2));
c0205a83:	83 ec 08             	sub    $0x8,%esp
c0205a86:	6a 01                	push   $0x1
c0205a88:	6a 04                	push   $0x4
c0205a8a:	e8 69 ec ff ff       	call   c02046f8 <get_partner_page_no>
c0205a8f:	83 c4 10             	add    $0x10,%esp
c0205a92:	83 ec 08             	sub    $0x8,%esp
c0205a95:	50                   	push   %eax
c0205a96:	8d 83 41 02 00 00    	lea    0x241(%ebx),%eax
c0205a9c:	50                   	push   %eax
c0205a9d:	e8 c4 dd ff ff       	call   c0203866 <printk>
c0205aa2:	83 c4 10             	add    $0x10,%esp
c0205aa5:	90                   	nop
c0205aa6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205aa9:	c9                   	leave  
c0205aaa:	c3                   	ret    

c0205aab <set_int_disc>:
int_server_func_t int_server_func_list[256];
interrupt_discripter_t idt_entries[256];    //中断描述符表 idt_entries为表首指针
lidt_target_t lidt_target;
static uint8_t default_inf=0x8E;
static uint16_t kern_cs=0x08; 
static void set_int_disc(int int_no, uint32_t offset, uint16_t selector, uint8_t inf){
c0205aab:	55                   	push   %ebp
c0205aac:	89 e5                	mov    %esp,%ebp
c0205aae:	53                   	push   %ebx
c0205aaf:	83 ec 08             	sub    $0x8,%esp
c0205ab2:	e8 49 15 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205ab7:	05 49 25 00 00       	add    $0x2549,%eax
c0205abc:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0205abf:	8b 55 14             	mov    0x14(%ebp),%edx
c0205ac2:	66 89 4d f8          	mov    %cx,-0x8(%ebp)
c0205ac6:	88 55 f4             	mov    %dl,-0xc(%ebp)
	idt_entries[int_no].offset_low=(uint16_t)offset;
c0205ac9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0205acc:	89 d3                	mov    %edx,%ebx
c0205ace:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205ad4:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205ad7:	66 89 1c ca          	mov    %bx,(%edx,%ecx,8)
	idt_entries[int_no].offset_high=(uint16_t)(offset>>16);
c0205adb:	8b 55 0c             	mov    0xc(%ebp),%edx
c0205ade:	c1 ea 10             	shr    $0x10,%edx
c0205ae1:	89 d3                	mov    %edx,%ebx
c0205ae3:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205ae9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205aec:	66 89 5c ca 06       	mov    %bx,0x6(%edx,%ecx,8)
	idt_entries[int_no].selector=selector;
c0205af1:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205af7:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205afa:	0f b7 5d f8          	movzwl -0x8(%ebp),%ebx
c0205afe:	66 89 5c ca 02       	mov    %bx,0x2(%edx,%ecx,8)
	idt_entries[int_no].inf=inf;
c0205b03:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205b09:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205b0c:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0205b10:	88 5c ca 05          	mov    %bl,0x5(%edx,%ecx,8)
	idt_entries[int_no].default_bit8=0;
c0205b14:	c7 c0 40 24 29 c0    	mov    $0xc0292440,%eax
c0205b1a:	8b 55 08             	mov    0x8(%ebp),%edx
c0205b1d:	c6 44 d0 04 00       	movb   $0x0,0x4(%eax,%edx,8)
}
c0205b22:	90                   	nop
c0205b23:	83 c4 08             	add    $0x8,%esp
c0205b26:	5b                   	pop    %ebx
c0205b27:	5d                   	pop    %ebp
c0205b28:	c3                   	ret    

c0205b29 <timer_init>:
static void timer_init(uint32_t frequency){
c0205b29:	55                   	push   %ebp
c0205b2a:	89 e5                	mov    %esp,%ebp
c0205b2c:	53                   	push   %ebx
c0205b2d:	83 ec 14             	sub    $0x14,%esp
c0205b30:	e8 cf 14 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205b35:	81 c3 cb 24 00 00    	add    $0x24cb,%ebx
	// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h
    // 输入频率为 1193180，frequency 即每秒中断次数
    uint32_t divisor = 1193180 / frequency;
c0205b3b:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0205b40:	ba 00 00 00 00       	mov    $0x0,%edx
c0205b45:	f7 75 08             	divl   0x8(%ebp)
c0205b48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    // D7 D6 D5 D4 D3 D2 D1 D0
    // 0  0  1  1  0  1  1  0
    // 即就是 36 H
    // 设置 8253/8254 芯片工作在模式 3 下
    outb(0x43, 0x36);
c0205b4b:	83 ec 08             	sub    $0x8,%esp
c0205b4e:	6a 36                	push   $0x36
c0205b50:	6a 43                	push   $0x43
c0205b52:	e8 f4 db ff ff       	call   c020374b <outb>
c0205b57:	83 c4 10             	add    $0x10,%esp

    // 拆分低字节和高字节
    uint8_t low = (uint8_t)(divisor & 0xFF);
c0205b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205b5d:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t hign = (uint8_t)((divisor >> 8) & 0xFF);
c0205b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205b63:	c1 e8 08             	shr    $0x8,%eax
c0205b66:	88 45 f2             	mov    %al,-0xe(%ebp)
    
    // 分别写入低字节和高字节
    outb(0x40, low);
c0205b69:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0205b6d:	83 ec 08             	sub    $0x8,%esp
c0205b70:	50                   	push   %eax
c0205b71:	6a 40                	push   $0x40
c0205b73:	e8 d3 db ff ff       	call   c020374b <outb>
c0205b78:	83 c4 10             	add    $0x10,%esp
    outb(0x40, hign);
c0205b7b:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
c0205b7f:	83 ec 08             	sub    $0x8,%esp
c0205b82:	50                   	push   %eax
c0205b83:	6a 40                	push   $0x40
c0205b85:	e8 c1 db ff ff       	call   c020374b <outb>
c0205b8a:	83 c4 10             	add    $0x10,%esp
}
c0205b8d:	90                   	nop
c0205b8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205b91:	c9                   	leave  
c0205b92:	c3                   	ret    

c0205b93 <registe_interrupt>:

static void registe_interrupt(int int_no,int_server_func_t target_func){
c0205b93:	55                   	push   %ebp
c0205b94:	89 e5                	mov    %esp,%ebp
c0205b96:	e8 65 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205b9b:	05 65 24 00 00       	add    $0x2465,%eax
	int_server_func_list[int_no] = target_func;
c0205ba0:	c7 c0 20 20 29 c0    	mov    $0xc0292020,%eax
c0205ba6:	8b 55 08             	mov    0x8(%ebp),%edx
c0205ba9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0205bac:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
}
c0205baf:	90                   	nop
c0205bb0:	5d                   	pop    %ebp
c0205bb1:	c3                   	ret    

c0205bb2 <default_server_func>:

void default_server_func(void *args){
c0205bb2:	55                   	push   %ebp
c0205bb3:	89 e5                	mov    %esp,%ebp
c0205bb5:	e8 46 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205bba:	05 46 24 00 00       	add    $0x2446,%eax
	//printk("Default Int server function!\n");
}
c0205bbf:	90                   	nop
c0205bc0:	5d                   	pop    %ebp
c0205bc1:	c3                   	ret    

c0205bc2 <timer_server_func>:


extern TCB_t * cur_tcb; 

//时钟中断函数 主要用于线程调度
void timer_server_func(void *args){
c0205bc2:	55                   	push   %ebp
c0205bc3:	89 e5                	mov    %esp,%ebp
c0205bc5:	53                   	push   %ebx
c0205bc6:	83 ec 04             	sub    $0x4,%esp
c0205bc9:	e8 32 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205bce:	05 32 24 00 00       	add    $0x2432,%eax
	if(cur_tcb->time_left!=0){
c0205bd3:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0205bd9:	8b 12                	mov    (%edx),%edx
c0205bdb:	8b 52 0c             	mov    0xc(%edx),%edx
c0205bde:	85 d2                	test   %edx,%edx
c0205be0:	74 24                	je     c0205c06 <timer_server_func+0x44>
		(cur_tcb->time_left)--;
c0205be2:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0205be8:	8b 12                	mov    (%edx),%edx
c0205bea:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0205bed:	83 e9 01             	sub    $0x1,%ecx
c0205bf0:	89 4a 0c             	mov    %ecx,0xc(%edx)
		(cur_tcb->time_counter)++;
c0205bf3:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0205bf9:	8b 00                	mov    (%eax),%eax
c0205bfb:	8b 50 08             	mov    0x8(%eax),%edx
c0205bfe:	83 c2 01             	add    $0x1,%edx
c0205c01:	89 50 08             	mov    %edx,0x8(%eax)
	}
	else{
		schedule();
	}
}
c0205c04:	eb 07                	jmp    c0205c0d <timer_server_func+0x4b>
		schedule();
c0205c06:	89 c3                	mov    %eax,%ebx
c0205c08:	e8 02 0a 00 00       	call   c020660f <schedule>
}
c0205c0d:	90                   	nop
c0205c0e:	83 c4 04             	add    $0x4,%esp
c0205c11:	5b                   	pop    %ebx
c0205c12:	5d                   	pop    %ebp
c0205c13:	c3                   	ret    

c0205c14 <page_fault_func>:

//cr2 保存引起缺页的线性地址
void get_cr2();
extern uint32_t _CR2;
void page_fault_func(){
c0205c14:	55                   	push   %ebp
c0205c15:	89 e5                	mov    %esp,%ebp
c0205c17:	53                   	push   %ebx
c0205c18:	83 ec 04             	sub    $0x4,%esp
c0205c1b:	e8 e4 13 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205c20:	81 c3 e0 23 00 00    	add    $0x23e0,%ebx
	get_cr2();
c0205c26:	e8 2e d6 ff ff       	call   c0203259 <get_cr2>
	printk("INT 14:Page Fault---0x%h\n",_CR2);
c0205c2b:	c7 c0 62 32 20 c0    	mov    $0xc0203262,%eax
c0205c31:	8b 00                	mov    (%eax),%eax
c0205c33:	83 ec 08             	sub    $0x8,%esp
c0205c36:	50                   	push   %eax
c0205c37:	8d 83 4a 02 00 00    	lea    0x24a(%ebx),%eax
c0205c3d:	50                   	push   %eax
c0205c3e:	e8 23 dc ff ff       	call   c0203866 <printk>
c0205c43:	83 c4 10             	add    $0x10,%esp
}
c0205c46:	90                   	nop
c0205c47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205c4a:	c9                   	leave  
c0205c4b:	c3                   	ret    

c0205c4c <idt_init>:
void isr30();
void isr31();

void isr32();

void idt_init(){
c0205c4c:	55                   	push   %ebp
c0205c4d:	89 e5                	mov    %esp,%ebp
c0205c4f:	53                   	push   %ebx
c0205c50:	83 ec 04             	sub    $0x4,%esp
c0205c53:	e8 ac 13 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205c58:	81 c3 a8 23 00 00    	add    $0x23a8,%ebx
	_8259A_init();   //初始化中断控制器
c0205c5e:	e8 74 e5 ff ff       	call   c02041d7 <_8259A_init>
	set_int_disc(0,(uint32_t)isr0,kern_cs,default_inf);
c0205c63:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205c6a:	0f b6 d0             	movzbl %al,%edx
c0205c6d:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205c74:	0f b7 c0             	movzwl %ax,%eax
c0205c77:	c7 c1 ff 30 20 c0    	mov    $0xc02030ff,%ecx
c0205c7d:	52                   	push   %edx
c0205c7e:	50                   	push   %eax
c0205c7f:	51                   	push   %ecx
c0205c80:	6a 00                	push   $0x0
c0205c82:	e8 24 fe ff ff       	call   c0205aab <set_int_disc>
c0205c87:	83 c4 10             	add    $0x10,%esp
	set_int_disc(1,(uint32_t)isr1,kern_cs,default_inf);
c0205c8a:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205c91:	0f b6 d0             	movzbl %al,%edx
c0205c94:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205c9b:	0f b7 c0             	movzwl %ax,%eax
c0205c9e:	c7 c1 07 31 20 c0    	mov    $0xc0203107,%ecx
c0205ca4:	52                   	push   %edx
c0205ca5:	50                   	push   %eax
c0205ca6:	51                   	push   %ecx
c0205ca7:	6a 01                	push   $0x1
c0205ca9:	e8 fd fd ff ff       	call   c0205aab <set_int_disc>
c0205cae:	83 c4 10             	add    $0x10,%esp
	set_int_disc(2,(uint32_t)isr2,kern_cs,default_inf);
c0205cb1:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205cb8:	0f b6 d0             	movzbl %al,%edx
c0205cbb:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205cc2:	0f b7 c0             	movzwl %ax,%eax
c0205cc5:	c7 c1 0f 31 20 c0    	mov    $0xc020310f,%ecx
c0205ccb:	52                   	push   %edx
c0205ccc:	50                   	push   %eax
c0205ccd:	51                   	push   %ecx
c0205cce:	6a 02                	push   $0x2
c0205cd0:	e8 d6 fd ff ff       	call   c0205aab <set_int_disc>
c0205cd5:	83 c4 10             	add    $0x10,%esp
	set_int_disc(3,(uint32_t)isr3,kern_cs,default_inf);
c0205cd8:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205cdf:	0f b6 d0             	movzbl %al,%edx
c0205ce2:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205ce9:	0f b7 c0             	movzwl %ax,%eax
c0205cec:	c7 c1 17 31 20 c0    	mov    $0xc0203117,%ecx
c0205cf2:	52                   	push   %edx
c0205cf3:	50                   	push   %eax
c0205cf4:	51                   	push   %ecx
c0205cf5:	6a 03                	push   $0x3
c0205cf7:	e8 af fd ff ff       	call   c0205aab <set_int_disc>
c0205cfc:	83 c4 10             	add    $0x10,%esp
	set_int_disc(4,(uint32_t)isr4,kern_cs,default_inf);
c0205cff:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205d06:	0f b6 d0             	movzbl %al,%edx
c0205d09:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205d10:	0f b7 c0             	movzwl %ax,%eax
c0205d13:	c7 c1 1f 31 20 c0    	mov    $0xc020311f,%ecx
c0205d19:	52                   	push   %edx
c0205d1a:	50                   	push   %eax
c0205d1b:	51                   	push   %ecx
c0205d1c:	6a 04                	push   $0x4
c0205d1e:	e8 88 fd ff ff       	call   c0205aab <set_int_disc>
c0205d23:	83 c4 10             	add    $0x10,%esp
	set_int_disc(5,(uint32_t)isr5,kern_cs,default_inf);
c0205d26:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205d2d:	0f b6 d0             	movzbl %al,%edx
c0205d30:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205d37:	0f b7 c0             	movzwl %ax,%eax
c0205d3a:	c7 c1 27 31 20 c0    	mov    $0xc0203127,%ecx
c0205d40:	52                   	push   %edx
c0205d41:	50                   	push   %eax
c0205d42:	51                   	push   %ecx
c0205d43:	6a 05                	push   $0x5
c0205d45:	e8 61 fd ff ff       	call   c0205aab <set_int_disc>
c0205d4a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(6,(uint32_t)isr6,kern_cs,default_inf);
c0205d4d:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205d54:	0f b6 d0             	movzbl %al,%edx
c0205d57:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205d5e:	0f b7 c0             	movzwl %ax,%eax
c0205d61:	c7 c1 2f 31 20 c0    	mov    $0xc020312f,%ecx
c0205d67:	52                   	push   %edx
c0205d68:	50                   	push   %eax
c0205d69:	51                   	push   %ecx
c0205d6a:	6a 06                	push   $0x6
c0205d6c:	e8 3a fd ff ff       	call   c0205aab <set_int_disc>
c0205d71:	83 c4 10             	add    $0x10,%esp
	set_int_disc(7,(uint32_t)isr7,kern_cs,default_inf);
c0205d74:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205d7b:	0f b6 d0             	movzbl %al,%edx
c0205d7e:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205d85:	0f b7 c0             	movzwl %ax,%eax
c0205d88:	c7 c1 3a 31 20 c0    	mov    $0xc020313a,%ecx
c0205d8e:	52                   	push   %edx
c0205d8f:	50                   	push   %eax
c0205d90:	51                   	push   %ecx
c0205d91:	6a 07                	push   $0x7
c0205d93:	e8 13 fd ff ff       	call   c0205aab <set_int_disc>
c0205d98:	83 c4 10             	add    $0x10,%esp
	set_int_disc(8,(uint32_t)isr8,kern_cs,default_inf);
c0205d9b:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205da2:	0f b6 d0             	movzbl %al,%edx
c0205da5:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205dac:	0f b7 c0             	movzwl %ax,%eax
c0205daf:	c7 c1 45 31 20 c0    	mov    $0xc0203145,%ecx
c0205db5:	52                   	push   %edx
c0205db6:	50                   	push   %eax
c0205db7:	51                   	push   %ecx
c0205db8:	6a 08                	push   $0x8
c0205dba:	e8 ec fc ff ff       	call   c0205aab <set_int_disc>
c0205dbf:	83 c4 10             	add    $0x10,%esp
	set_int_disc(9,(uint32_t)isr9,kern_cs,default_inf);
c0205dc2:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205dc9:	0f b6 d0             	movzbl %al,%edx
c0205dcc:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205dd3:	0f b7 c0             	movzwl %ax,%eax
c0205dd6:	c7 c1 4f 31 20 c0    	mov    $0xc020314f,%ecx
c0205ddc:	52                   	push   %edx
c0205ddd:	50                   	push   %eax
c0205dde:	51                   	push   %ecx
c0205ddf:	6a 09                	push   $0x9
c0205de1:	e8 c5 fc ff ff       	call   c0205aab <set_int_disc>
c0205de6:	83 c4 10             	add    $0x10,%esp
	set_int_disc(10,(uint32_t)isr10,kern_cs,default_inf);
c0205de9:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205df0:	0f b6 d0             	movzbl %al,%edx
c0205df3:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205dfa:	0f b7 c0             	movzwl %ax,%eax
c0205dfd:	c7 c1 5a 31 20 c0    	mov    $0xc020315a,%ecx
c0205e03:	52                   	push   %edx
c0205e04:	50                   	push   %eax
c0205e05:	51                   	push   %ecx
c0205e06:	6a 0a                	push   $0xa
c0205e08:	e8 9e fc ff ff       	call   c0205aab <set_int_disc>
c0205e0d:	83 c4 10             	add    $0x10,%esp
	set_int_disc(11,(uint32_t)isr11,kern_cs,default_inf);
c0205e10:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205e17:	0f b6 d0             	movzbl %al,%edx
c0205e1a:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205e21:	0f b7 c0             	movzwl %ax,%eax
c0205e24:	c7 c1 64 31 20 c0    	mov    $0xc0203164,%ecx
c0205e2a:	52                   	push   %edx
c0205e2b:	50                   	push   %eax
c0205e2c:	51                   	push   %ecx
c0205e2d:	6a 0b                	push   $0xb
c0205e2f:	e8 77 fc ff ff       	call   c0205aab <set_int_disc>
c0205e34:	83 c4 10             	add    $0x10,%esp
	set_int_disc(12,(uint32_t)isr12,kern_cs,default_inf);
c0205e37:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205e3e:	0f b6 d0             	movzbl %al,%edx
c0205e41:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205e48:	0f b7 c0             	movzwl %ax,%eax
c0205e4b:	c7 c1 6e 31 20 c0    	mov    $0xc020316e,%ecx
c0205e51:	52                   	push   %edx
c0205e52:	50                   	push   %eax
c0205e53:	51                   	push   %ecx
c0205e54:	6a 0c                	push   $0xc
c0205e56:	e8 50 fc ff ff       	call   c0205aab <set_int_disc>
c0205e5b:	83 c4 10             	add    $0x10,%esp
	set_int_disc(13,(uint32_t)isr13,kern_cs,default_inf);
c0205e5e:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205e65:	0f b6 d0             	movzbl %al,%edx
c0205e68:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205e6f:	0f b7 c0             	movzwl %ax,%eax
c0205e72:	c7 c1 78 31 20 c0    	mov    $0xc0203178,%ecx
c0205e78:	52                   	push   %edx
c0205e79:	50                   	push   %eax
c0205e7a:	51                   	push   %ecx
c0205e7b:	6a 0d                	push   $0xd
c0205e7d:	e8 29 fc ff ff       	call   c0205aab <set_int_disc>
c0205e82:	83 c4 10             	add    $0x10,%esp
	set_int_disc(14,(uint32_t)isr14,kern_cs,default_inf);
c0205e85:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205e8c:	0f b6 d0             	movzbl %al,%edx
c0205e8f:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205e96:	0f b7 c0             	movzwl %ax,%eax
c0205e99:	c7 c1 82 31 20 c0    	mov    $0xc0203182,%ecx
c0205e9f:	52                   	push   %edx
c0205ea0:	50                   	push   %eax
c0205ea1:	51                   	push   %ecx
c0205ea2:	6a 0e                	push   $0xe
c0205ea4:	e8 02 fc ff ff       	call   c0205aab <set_int_disc>
c0205ea9:	83 c4 10             	add    $0x10,%esp
	set_int_disc(15,(uint32_t)isr15,kern_cs,default_inf);
c0205eac:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205eb3:	0f b6 d0             	movzbl %al,%edx
c0205eb6:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205ebd:	0f b7 c0             	movzwl %ax,%eax
c0205ec0:	c7 c1 8c 31 20 c0    	mov    $0xc020318c,%ecx
c0205ec6:	52                   	push   %edx
c0205ec7:	50                   	push   %eax
c0205ec8:	51                   	push   %ecx
c0205ec9:	6a 0f                	push   $0xf
c0205ecb:	e8 db fb ff ff       	call   c0205aab <set_int_disc>
c0205ed0:	83 c4 10             	add    $0x10,%esp
	set_int_disc(16,(uint32_t)isr16,kern_cs,default_inf);
c0205ed3:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205eda:	0f b6 d0             	movzbl %al,%edx
c0205edd:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205ee4:	0f b7 c0             	movzwl %ax,%eax
c0205ee7:	c7 c1 97 31 20 c0    	mov    $0xc0203197,%ecx
c0205eed:	52                   	push   %edx
c0205eee:	50                   	push   %eax
c0205eef:	51                   	push   %ecx
c0205ef0:	6a 10                	push   $0x10
c0205ef2:	e8 b4 fb ff ff       	call   c0205aab <set_int_disc>
c0205ef7:	83 c4 10             	add    $0x10,%esp
	set_int_disc(17,(uint32_t)isr17,kern_cs,default_inf);
c0205efa:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205f01:	0f b6 d0             	movzbl %al,%edx
c0205f04:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205f0b:	0f b7 c0             	movzwl %ax,%eax
c0205f0e:	c7 c1 a2 31 20 c0    	mov    $0xc02031a2,%ecx
c0205f14:	52                   	push   %edx
c0205f15:	50                   	push   %eax
c0205f16:	51                   	push   %ecx
c0205f17:	6a 11                	push   $0x11
c0205f19:	e8 8d fb ff ff       	call   c0205aab <set_int_disc>
c0205f1e:	83 c4 10             	add    $0x10,%esp
	set_int_disc(18,(uint32_t)isr18,kern_cs,default_inf);
c0205f21:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205f28:	0f b6 d0             	movzbl %al,%edx
c0205f2b:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205f32:	0f b7 c0             	movzwl %ax,%eax
c0205f35:	c7 c1 ac 31 20 c0    	mov    $0xc02031ac,%ecx
c0205f3b:	52                   	push   %edx
c0205f3c:	50                   	push   %eax
c0205f3d:	51                   	push   %ecx
c0205f3e:	6a 12                	push   $0x12
c0205f40:	e8 66 fb ff ff       	call   c0205aab <set_int_disc>
c0205f45:	83 c4 10             	add    $0x10,%esp
	set_int_disc(19,(uint32_t)isr19,kern_cs,default_inf);
c0205f48:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205f4f:	0f b6 d0             	movzbl %al,%edx
c0205f52:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205f59:	0f b7 c0             	movzwl %ax,%eax
c0205f5c:	c7 c1 b7 31 20 c0    	mov    $0xc02031b7,%ecx
c0205f62:	52                   	push   %edx
c0205f63:	50                   	push   %eax
c0205f64:	51                   	push   %ecx
c0205f65:	6a 13                	push   $0x13
c0205f67:	e8 3f fb ff ff       	call   c0205aab <set_int_disc>
c0205f6c:	83 c4 10             	add    $0x10,%esp
	set_int_disc(20,(uint32_t)isr20,kern_cs,default_inf);
c0205f6f:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205f76:	0f b6 d0             	movzbl %al,%edx
c0205f79:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205f80:	0f b7 c0             	movzwl %ax,%eax
c0205f83:	c7 c1 c2 31 20 c0    	mov    $0xc02031c2,%ecx
c0205f89:	52                   	push   %edx
c0205f8a:	50                   	push   %eax
c0205f8b:	51                   	push   %ecx
c0205f8c:	6a 14                	push   $0x14
c0205f8e:	e8 18 fb ff ff       	call   c0205aab <set_int_disc>
c0205f93:	83 c4 10             	add    $0x10,%esp
	set_int_disc(21,(uint32_t)isr21,kern_cs,default_inf);
c0205f96:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205f9d:	0f b6 d0             	movzbl %al,%edx
c0205fa0:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205fa7:	0f b7 c0             	movzwl %ax,%eax
c0205faa:	c7 c1 cd 31 20 c0    	mov    $0xc02031cd,%ecx
c0205fb0:	52                   	push   %edx
c0205fb1:	50                   	push   %eax
c0205fb2:	51                   	push   %ecx
c0205fb3:	6a 15                	push   $0x15
c0205fb5:	e8 f1 fa ff ff       	call   c0205aab <set_int_disc>
c0205fba:	83 c4 10             	add    $0x10,%esp
	set_int_disc(22,(uint32_t)isr22,kern_cs,default_inf);
c0205fbd:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205fc4:	0f b6 d0             	movzbl %al,%edx
c0205fc7:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205fce:	0f b7 c0             	movzwl %ax,%eax
c0205fd1:	c7 c1 d8 31 20 c0    	mov    $0xc02031d8,%ecx
c0205fd7:	52                   	push   %edx
c0205fd8:	50                   	push   %eax
c0205fd9:	51                   	push   %ecx
c0205fda:	6a 16                	push   $0x16
c0205fdc:	e8 ca fa ff ff       	call   c0205aab <set_int_disc>
c0205fe1:	83 c4 10             	add    $0x10,%esp
	set_int_disc(23,(uint32_t)isr23,kern_cs,default_inf);
c0205fe4:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0205feb:	0f b6 d0             	movzbl %al,%edx
c0205fee:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0205ff5:	0f b7 c0             	movzwl %ax,%eax
c0205ff8:	c7 c1 e3 31 20 c0    	mov    $0xc02031e3,%ecx
c0205ffe:	52                   	push   %edx
c0205fff:	50                   	push   %eax
c0206000:	51                   	push   %ecx
c0206001:	6a 17                	push   $0x17
c0206003:	e8 a3 fa ff ff       	call   c0205aab <set_int_disc>
c0206008:	83 c4 10             	add    $0x10,%esp
	set_int_disc(24,(uint32_t)isr24,kern_cs,default_inf);
c020600b:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0206012:	0f b6 d0             	movzbl %al,%edx
c0206015:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c020601c:	0f b7 c0             	movzwl %ax,%eax
c020601f:	c7 c1 ee 31 20 c0    	mov    $0xc02031ee,%ecx
c0206025:	52                   	push   %edx
c0206026:	50                   	push   %eax
c0206027:	51                   	push   %ecx
c0206028:	6a 18                	push   $0x18
c020602a:	e8 7c fa ff ff       	call   c0205aab <set_int_disc>
c020602f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(25,(uint32_t)isr25,kern_cs,default_inf);
c0206032:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0206039:	0f b6 d0             	movzbl %al,%edx
c020603c:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206043:	0f b7 c0             	movzwl %ax,%eax
c0206046:	c7 c1 f9 31 20 c0    	mov    $0xc02031f9,%ecx
c020604c:	52                   	push   %edx
c020604d:	50                   	push   %eax
c020604e:	51                   	push   %ecx
c020604f:	6a 19                	push   $0x19
c0206051:	e8 55 fa ff ff       	call   c0205aab <set_int_disc>
c0206056:	83 c4 10             	add    $0x10,%esp
	set_int_disc(26,(uint32_t)isr26,kern_cs,default_inf);
c0206059:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0206060:	0f b6 d0             	movzbl %al,%edx
c0206063:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c020606a:	0f b7 c0             	movzwl %ax,%eax
c020606d:	c7 c1 04 32 20 c0    	mov    $0xc0203204,%ecx
c0206073:	52                   	push   %edx
c0206074:	50                   	push   %eax
c0206075:	51                   	push   %ecx
c0206076:	6a 1a                	push   $0x1a
c0206078:	e8 2e fa ff ff       	call   c0205aab <set_int_disc>
c020607d:	83 c4 10             	add    $0x10,%esp
	set_int_disc(27,(uint32_t)isr27,kern_cs,default_inf);
c0206080:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0206087:	0f b6 d0             	movzbl %al,%edx
c020608a:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206091:	0f b7 c0             	movzwl %ax,%eax
c0206094:	c7 c1 0f 32 20 c0    	mov    $0xc020320f,%ecx
c020609a:	52                   	push   %edx
c020609b:	50                   	push   %eax
c020609c:	51                   	push   %ecx
c020609d:	6a 1b                	push   $0x1b
c020609f:	e8 07 fa ff ff       	call   c0205aab <set_int_disc>
c02060a4:	83 c4 10             	add    $0x10,%esp
	set_int_disc(28,(uint32_t)isr28,kern_cs,default_inf);
c02060a7:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c02060ae:	0f b6 d0             	movzbl %al,%edx
c02060b1:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c02060b8:	0f b7 c0             	movzwl %ax,%eax
c02060bb:	c7 c1 1a 32 20 c0    	mov    $0xc020321a,%ecx
c02060c1:	52                   	push   %edx
c02060c2:	50                   	push   %eax
c02060c3:	51                   	push   %ecx
c02060c4:	6a 1c                	push   $0x1c
c02060c6:	e8 e0 f9 ff ff       	call   c0205aab <set_int_disc>
c02060cb:	83 c4 10             	add    $0x10,%esp
	set_int_disc(29,(uint32_t)isr29,kern_cs,default_inf);
c02060ce:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c02060d5:	0f b6 d0             	movzbl %al,%edx
c02060d8:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c02060df:	0f b7 c0             	movzwl %ax,%eax
c02060e2:	c7 c1 25 32 20 c0    	mov    $0xc0203225,%ecx
c02060e8:	52                   	push   %edx
c02060e9:	50                   	push   %eax
c02060ea:	51                   	push   %ecx
c02060eb:	6a 1d                	push   $0x1d
c02060ed:	e8 b9 f9 ff ff       	call   c0205aab <set_int_disc>
c02060f2:	83 c4 10             	add    $0x10,%esp
	set_int_disc(30,(uint32_t)isr30,kern_cs,default_inf);
c02060f5:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c02060fc:	0f b6 d0             	movzbl %al,%edx
c02060ff:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206106:	0f b7 c0             	movzwl %ax,%eax
c0206109:	c7 c1 30 32 20 c0    	mov    $0xc0203230,%ecx
c020610f:	52                   	push   %edx
c0206110:	50                   	push   %eax
c0206111:	51                   	push   %ecx
c0206112:	6a 1e                	push   $0x1e
c0206114:	e8 92 f9 ff ff       	call   c0205aab <set_int_disc>
c0206119:	83 c4 10             	add    $0x10,%esp
	set_int_disc(31,(uint32_t)isr31,kern_cs,default_inf);
c020611c:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c0206123:	0f b6 d0             	movzbl %al,%edx
c0206126:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c020612d:	0f b7 c0             	movzwl %ax,%eax
c0206130:	c7 c1 3b 32 20 c0    	mov    $0xc020323b,%ecx
c0206136:	52                   	push   %edx
c0206137:	50                   	push   %eax
c0206138:	51                   	push   %ecx
c0206139:	6a 1f                	push   $0x1f
c020613b:	e8 6b f9 ff ff       	call   c0205aab <set_int_disc>
c0206140:	83 c4 10             	add    $0x10,%esp
	set_int_disc(32,(uint32_t)isr32,kern_cs,default_inf);
c0206143:	0f b6 83 2c f0 ff ff 	movzbl -0xfd4(%ebx),%eax
c020614a:	0f b6 d0             	movzbl %al,%edx
c020614d:	0f b7 83 2e f0 ff ff 	movzwl -0xfd2(%ebx),%eax
c0206154:	0f b7 c0             	movzwl %ax,%eax
c0206157:	c7 c1 46 32 20 c0    	mov    $0xc0203246,%ecx
c020615d:	52                   	push   %edx
c020615e:	50                   	push   %eax
c020615f:	51                   	push   %ecx
c0206160:	6a 20                	push   $0x20
c0206162:	e8 44 f9 ff ff       	call   c0205aab <set_int_disc>
c0206167:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(0,default_server_func);
c020616a:	83 ec 08             	sub    $0x8,%esp
c020616d:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206173:	50                   	push   %eax
c0206174:	6a 00                	push   $0x0
c0206176:	e8 18 fa ff ff       	call   c0205b93 <registe_interrupt>
c020617b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(1,default_server_func);
c020617e:	83 ec 08             	sub    $0x8,%esp
c0206181:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206187:	50                   	push   %eax
c0206188:	6a 01                	push   $0x1
c020618a:	e8 04 fa ff ff       	call   c0205b93 <registe_interrupt>
c020618f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(2,default_server_func);
c0206192:	83 ec 08             	sub    $0x8,%esp
c0206195:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020619b:	50                   	push   %eax
c020619c:	6a 02                	push   $0x2
c020619e:	e8 f0 f9 ff ff       	call   c0205b93 <registe_interrupt>
c02061a3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(3,default_server_func);
c02061a6:	83 ec 08             	sub    $0x8,%esp
c02061a9:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02061af:	50                   	push   %eax
c02061b0:	6a 03                	push   $0x3
c02061b2:	e8 dc f9 ff ff       	call   c0205b93 <registe_interrupt>
c02061b7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(4,default_server_func);
c02061ba:	83 ec 08             	sub    $0x8,%esp
c02061bd:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02061c3:	50                   	push   %eax
c02061c4:	6a 04                	push   $0x4
c02061c6:	e8 c8 f9 ff ff       	call   c0205b93 <registe_interrupt>
c02061cb:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(5,default_server_func);
c02061ce:	83 ec 08             	sub    $0x8,%esp
c02061d1:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02061d7:	50                   	push   %eax
c02061d8:	6a 05                	push   $0x5
c02061da:	e8 b4 f9 ff ff       	call   c0205b93 <registe_interrupt>
c02061df:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(6,default_server_func);
c02061e2:	83 ec 08             	sub    $0x8,%esp
c02061e5:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02061eb:	50                   	push   %eax
c02061ec:	6a 06                	push   $0x6
c02061ee:	e8 a0 f9 ff ff       	call   c0205b93 <registe_interrupt>
c02061f3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(7,default_server_func);
c02061f6:	83 ec 08             	sub    $0x8,%esp
c02061f9:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02061ff:	50                   	push   %eax
c0206200:	6a 07                	push   $0x7
c0206202:	e8 8c f9 ff ff       	call   c0205b93 <registe_interrupt>
c0206207:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(8,default_server_func);
c020620a:	83 ec 08             	sub    $0x8,%esp
c020620d:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206213:	50                   	push   %eax
c0206214:	6a 08                	push   $0x8
c0206216:	e8 78 f9 ff ff       	call   c0205b93 <registe_interrupt>
c020621b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(9,default_server_func);
c020621e:	83 ec 08             	sub    $0x8,%esp
c0206221:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206227:	50                   	push   %eax
c0206228:	6a 09                	push   $0x9
c020622a:	e8 64 f9 ff ff       	call   c0205b93 <registe_interrupt>
c020622f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(10,default_server_func);
c0206232:	83 ec 08             	sub    $0x8,%esp
c0206235:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020623b:	50                   	push   %eax
c020623c:	6a 0a                	push   $0xa
c020623e:	e8 50 f9 ff ff       	call   c0205b93 <registe_interrupt>
c0206243:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(11,default_server_func);
c0206246:	83 ec 08             	sub    $0x8,%esp
c0206249:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020624f:	50                   	push   %eax
c0206250:	6a 0b                	push   $0xb
c0206252:	e8 3c f9 ff ff       	call   c0205b93 <registe_interrupt>
c0206257:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(12,default_server_func);
c020625a:	83 ec 08             	sub    $0x8,%esp
c020625d:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206263:	50                   	push   %eax
c0206264:	6a 0c                	push   $0xc
c0206266:	e8 28 f9 ff ff       	call   c0205b93 <registe_interrupt>
c020626b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(13,default_server_func);
c020626e:	83 ec 08             	sub    $0x8,%esp
c0206271:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206277:	50                   	push   %eax
c0206278:	6a 0d                	push   $0xd
c020627a:	e8 14 f9 ff ff       	call   c0205b93 <registe_interrupt>
c020627f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(14,default_server_func);
c0206282:	83 ec 08             	sub    $0x8,%esp
c0206285:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020628b:	50                   	push   %eax
c020628c:	6a 0e                	push   $0xe
c020628e:	e8 00 f9 ff ff       	call   c0205b93 <registe_interrupt>
c0206293:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(15,default_server_func);
c0206296:	83 ec 08             	sub    $0x8,%esp
c0206299:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020629f:	50                   	push   %eax
c02062a0:	6a 0f                	push   $0xf
c02062a2:	e8 ec f8 ff ff       	call   c0205b93 <registe_interrupt>
c02062a7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(16,default_server_func);
c02062aa:	83 ec 08             	sub    $0x8,%esp
c02062ad:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02062b3:	50                   	push   %eax
c02062b4:	6a 10                	push   $0x10
c02062b6:	e8 d8 f8 ff ff       	call   c0205b93 <registe_interrupt>
c02062bb:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(17,default_server_func);
c02062be:	83 ec 08             	sub    $0x8,%esp
c02062c1:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02062c7:	50                   	push   %eax
c02062c8:	6a 11                	push   $0x11
c02062ca:	e8 c4 f8 ff ff       	call   c0205b93 <registe_interrupt>
c02062cf:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(18,default_server_func);
c02062d2:	83 ec 08             	sub    $0x8,%esp
c02062d5:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02062db:	50                   	push   %eax
c02062dc:	6a 12                	push   $0x12
c02062de:	e8 b0 f8 ff ff       	call   c0205b93 <registe_interrupt>
c02062e3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(19,default_server_func);
c02062e6:	83 ec 08             	sub    $0x8,%esp
c02062e9:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02062ef:	50                   	push   %eax
c02062f0:	6a 13                	push   $0x13
c02062f2:	e8 9c f8 ff ff       	call   c0205b93 <registe_interrupt>
c02062f7:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(20,default_server_func);
c02062fa:	83 ec 08             	sub    $0x8,%esp
c02062fd:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206303:	50                   	push   %eax
c0206304:	6a 14                	push   $0x14
c0206306:	e8 88 f8 ff ff       	call   c0205b93 <registe_interrupt>
c020630b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(21,default_server_func);
c020630e:	83 ec 08             	sub    $0x8,%esp
c0206311:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206317:	50                   	push   %eax
c0206318:	6a 15                	push   $0x15
c020631a:	e8 74 f8 ff ff       	call   c0205b93 <registe_interrupt>
c020631f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(22,default_server_func);
c0206322:	83 ec 08             	sub    $0x8,%esp
c0206325:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020632b:	50                   	push   %eax
c020632c:	6a 16                	push   $0x16
c020632e:	e8 60 f8 ff ff       	call   c0205b93 <registe_interrupt>
c0206333:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(23,default_server_func);
c0206336:	83 ec 08             	sub    $0x8,%esp
c0206339:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020633f:	50                   	push   %eax
c0206340:	6a 17                	push   $0x17
c0206342:	e8 4c f8 ff ff       	call   c0205b93 <registe_interrupt>
c0206347:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(24,default_server_func);
c020634a:	83 ec 08             	sub    $0x8,%esp
c020634d:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206353:	50                   	push   %eax
c0206354:	6a 18                	push   $0x18
c0206356:	e8 38 f8 ff ff       	call   c0205b93 <registe_interrupt>
c020635b:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(25,default_server_func);
c020635e:	83 ec 08             	sub    $0x8,%esp
c0206361:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c0206367:	50                   	push   %eax
c0206368:	6a 19                	push   $0x19
c020636a:	e8 24 f8 ff ff       	call   c0205b93 <registe_interrupt>
c020636f:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(26,default_server_func);
c0206372:	83 ec 08             	sub    $0x8,%esp
c0206375:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020637b:	50                   	push   %eax
c020637c:	6a 1a                	push   $0x1a
c020637e:	e8 10 f8 ff ff       	call   c0205b93 <registe_interrupt>
c0206383:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(27,default_server_func);
c0206386:	83 ec 08             	sub    $0x8,%esp
c0206389:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c020638f:	50                   	push   %eax
c0206390:	6a 1b                	push   $0x1b
c0206392:	e8 fc f7 ff ff       	call   c0205b93 <registe_interrupt>
c0206397:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(28,default_server_func);
c020639a:	83 ec 08             	sub    $0x8,%esp
c020639d:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02063a3:	50                   	push   %eax
c02063a4:	6a 1c                	push   $0x1c
c02063a6:	e8 e8 f7 ff ff       	call   c0205b93 <registe_interrupt>
c02063ab:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(29,default_server_func);
c02063ae:	83 ec 08             	sub    $0x8,%esp
c02063b1:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02063b7:	50                   	push   %eax
c02063b8:	6a 1d                	push   $0x1d
c02063ba:	e8 d4 f7 ff ff       	call   c0205b93 <registe_interrupt>
c02063bf:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(30,default_server_func);
c02063c2:	83 ec 08             	sub    $0x8,%esp
c02063c5:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02063cb:	50                   	push   %eax
c02063cc:	6a 1e                	push   $0x1e
c02063ce:	e8 c0 f7 ff ff       	call   c0205b93 <registe_interrupt>
c02063d3:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(31,default_server_func);
c02063d6:	83 ec 08             	sub    $0x8,%esp
c02063d9:	8d 83 b2 db ff ff    	lea    -0x244e(%ebx),%eax
c02063df:	50                   	push   %eax
c02063e0:	6a 1f                	push   $0x1f
c02063e2:	e8 ac f7 ff ff       	call   c0205b93 <registe_interrupt>
c02063e7:	83 c4 10             	add    $0x10,%esp
	//registe_interrupt(32,default_server_func);
	
	registe_interrupt(14,page_fault_func);
c02063ea:	83 ec 08             	sub    $0x8,%esp
c02063ed:	8d 83 14 dc ff ff    	lea    -0x23ec(%ebx),%eax
c02063f3:	50                   	push   %eax
c02063f4:	6a 0e                	push   $0xe
c02063f6:	e8 98 f7 ff ff       	call   c0205b93 <registe_interrupt>
c02063fb:	83 c4 10             	add    $0x10,%esp
	registe_interrupt(32,timer_server_func);
c02063fe:	83 ec 08             	sub    $0x8,%esp
c0206401:	8d 83 c2 db ff ff    	lea    -0x243e(%ebx),%eax
c0206407:	50                   	push   %eax
c0206408:	6a 20                	push   $0x20
c020640a:	e8 84 f7 ff ff       	call   c0205b93 <registe_interrupt>
c020640f:	83 c4 10             	add    $0x10,%esp
	lidt_target.limit = sizeof(interrupt_discripter_t)*256;
c0206412:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c0206418:	66 c7 00 00 08       	movw   $0x800,(%eax)
	lidt_target.base = (uint32_t)&idt_entries;
c020641d:	c7 c0 40 24 29 c0    	mov    $0xc0292440,%eax
c0206423:	89 c2                	mov    %eax,%edx
c0206425:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c020642b:	89 50 02             	mov    %edx,0x2(%eax)
	timer_init(1000);        
c020642e:	83 ec 0c             	sub    $0xc,%esp
c0206431:	68 e8 03 00 00       	push   $0x3e8
c0206436:	e8 ee f6 ff ff       	call   c0205b29 <timer_init>
c020643b:	83 c4 10             	add    $0x10,%esp
	load_idt((uint32_t)&lidt_target);
c020643e:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c0206444:	83 ec 0c             	sub    $0xc,%esp
c0206447:	50                   	push   %eax
c0206448:	e8 04 ce ff ff       	call   c0203251 <load_idt>
c020644d:	83 c4 10             	add    $0x10,%esp
}
c0206450:	90                   	nop
c0206451:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206454:	c9                   	leave  
c0206455:	c3                   	ret    

c0206456 <int_func_route>:
void int_func_route(int int_no,void * args){
c0206456:	55                   	push   %ebp
c0206457:	89 e5                	mov    %esp,%ebp
c0206459:	83 ec 08             	sub    $0x8,%esp
c020645c:	e8 9f 0b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206461:	05 9f 1b 00 00       	add    $0x1b9f,%eax
	int_server_func_list[int_no](args);
c0206466:	c7 c0 20 20 29 c0    	mov    $0xc0292020,%eax
c020646c:	8b 55 08             	mov    0x8(%ebp),%edx
c020646f:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0206472:	83 ec 0c             	sub    $0xc,%esp
c0206475:	ff 75 0c             	pushl  0xc(%ebp)
c0206478:	ff d0                	call   *%eax
c020647a:	83 c4 10             	add    $0x10,%esp
}
c020647d:	90                   	nop
c020647e:	c9                   	leave  
c020647f:	c3                   	ret    

c0206480 <threads_init>:
#include "printk.h"
#define TIME_CONT  2 //默认时间片计数
TCB_t main_TCB;    //内核主线程TCB
TCB_t* cur_tcb;

void threads_init(){
c0206480:	55                   	push   %ebp
c0206481:	89 e5                	mov    %esp,%ebp
c0206483:	83 ec 10             	sub    $0x10,%esp
c0206486:	e8 75 0b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020648b:	05 75 1b 00 00       	add    $0x1b75,%eax
	TCB_t *tcb_buffer_addr = &main_TCB;
c0206490:	c7 c2 60 2c 29 c0    	mov    $0xc0292c60,%edx
c0206496:	89 55 fc             	mov    %edx,-0x4(%ebp)
	tcb_buffer_addr->tid = 0;        //主线程的编号为0  
c0206499:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020649c:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
	tcb_buffer_addr->time_counter=0;
c02064a3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064a6:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	tcb_buffer_addr->time_left=TIME_CONT;
c02064ad:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064b0:	c7 42 0c 02 00 00 00 	movl   $0x2,0xc(%edx)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c02064b7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064ba:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	tcb_buffer_addr->page_counte=0;   //主线程不会被回收内存 所以可以任意赋值
c02064c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064c4:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	tcb_buffer_addr->page_addr=0;
c02064cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064ce:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	tcb_buffer_addr->next = tcb_buffer_addr;
c02064d5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064d8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c02064db:	89 4a 10             	mov    %ecx,0x10(%edx)
	tcb_buffer_addr->kern_stack_top=0;
c02064de:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064e1:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	cur_tcb = tcb_buffer_addr;
c02064e7:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02064ed:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02064f0:	89 10                	mov    %edx,(%eax)
}
c02064f2:	90                   	nop
c02064f3:	c9                   	leave  
c02064f4:	c3                   	ret    

c02064f5 <create_TCB>:

uint32_t create_TCB(uint32_t tid,uint32_t page_addr,uint32_t page_counte){
c02064f5:	55                   	push   %ebp
c02064f6:	89 e5                	mov    %esp,%ebp
c02064f8:	83 ec 10             	sub    $0x10,%esp
c02064fb:	e8 00 0b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206500:	05 00 1b 00 00       	add    $0x1b00,%eax
	TCB_t * tcb_buffer_addr = (TCB_t*)page_addr;
c0206505:	8b 45 0c             	mov    0xc(%ebp),%eax
c0206508:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = tid;         
c020650b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020650e:	8b 55 08             	mov    0x8(%ebp),%edx
c0206511:	89 50 14             	mov    %edx,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c0206514:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206517:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c020651e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206521:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c0206528:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020652b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=page_counte; 
c0206532:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206535:	8b 55 10             	mov    0x10(%ebp),%edx
c0206538:	89 50 18             	mov    %edx,0x18(%eax)
	tcb_buffer_addr->page_addr=page_addr;
c020653b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020653e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0206541:	89 50 1c             	mov    %edx,0x1c(%eax)
	tcb_buffer_addr->kern_stack_top=page_addr+page_counte*4096;
c0206544:	8b 45 10             	mov    0x10(%ebp),%eax
c0206547:	c1 e0 0c             	shl    $0xc,%eax
c020654a:	89 c2                	mov    %eax,%edx
c020654c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020654f:	01 d0                	add    %edx,%eax
c0206551:	89 c2                	mov    %eax,%edx
c0206553:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206556:	89 10                	mov    %edx,(%eax)
	return page_addr;
c0206558:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c020655b:	c9                   	leave  
c020655c:	c3                   	ret    

c020655d <create_thread>:

void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte){	
c020655d:	55                   	push   %ebp
c020655e:	89 e5                	mov    %esp,%ebp
c0206560:	53                   	push   %ebx
c0206561:	83 ec 10             	sub    $0x10,%esp
c0206564:	e8 9b 0a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206569:	81 c3 97 1a 00 00    	add    $0x1a97,%ebx
	asm volatile("cli");  //由于创建过程会使用到共享的数据 不使用锁的话会造成临界区错误 所以我们在此处关闭中断
c020656f:	fa                   	cli    
	TCB_t * new_tcb = create_TCB(tid,addr,page_counte);
c0206570:	ff 75 18             	pushl  0x18(%ebp)
c0206573:	ff 75 14             	pushl  0x14(%ebp)
c0206576:	ff 75 08             	pushl  0x8(%ebp)
c0206579:	e8 77 ff ff ff       	call   c02064f5 <create_TCB>
c020657e:	83 c4 0c             	add    $0xc,%esp
c0206581:	89 45 f8             	mov    %eax,-0x8(%ebp)
	TCB_t * temp_next = cur_tcb->next;
c0206584:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020658a:	8b 00                	mov    (%eax),%eax
c020658c:	8b 40 10             	mov    0x10(%eax),%eax
c020658f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cur_tcb->next = new_tcb;
c0206592:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206598:	8b 00                	mov    (%eax),%eax
c020659a:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020659d:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->next = temp_next;
c02065a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02065a6:	89 50 10             	mov    %edx,0x10(%eax)
	*(--new_tcb->kern_stack_top)=args;     //压入初始化的参数与线程执行函数
c02065a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065ac:	8b 00                	mov    (%eax),%eax
c02065ae:	8d 50 fc             	lea    -0x4(%eax),%edx
c02065b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065b4:	89 10                	mov    %edx,(%eax)
c02065b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065b9:	8b 00                	mov    (%eax),%eax
c02065bb:	8b 55 10             	mov    0x10(%ebp),%edx
c02065be:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=exit;
c02065c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065c3:	8b 00                	mov    (%eax),%eax
c02065c5:	8d 50 fc             	lea    -0x4(%eax),%edx
c02065c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065cb:	89 10                	mov    %edx,(%eax)
c02065cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065d0:	8b 00                	mov    (%eax),%eax
c02065d2:	8d 93 10 e7 ff ff    	lea    -0x18f0(%ebx),%edx
c02065d8:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=func;
c02065da:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065dd:	8b 00                	mov    (%eax),%eax
c02065df:	8d 50 fc             	lea    -0x4(%eax),%edx
c02065e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065e5:	89 10                	mov    %edx,(%eax)
c02065e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065ea:	8b 00                	mov    (%eax),%eax
c02065ec:	8b 55 0c             	mov    0xc(%ebp),%edx
c02065ef:	89 10                	mov    %edx,(%eax)
	new_tcb->context.eflags = 0x200;
c02065f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065f4:	c7 40 38 00 02 00 00 	movl   $0x200,0x38(%eax)
	new_tcb->context.esp =new_tcb->kern_stack_top;
c02065fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02065fe:	8b 00                	mov    (%eax),%eax
c0206600:	89 c2                	mov    %eax,%edx
c0206602:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206605:	89 50 3c             	mov    %edx,0x3c(%eax)
	asm volatile("sti");	
c0206608:	fb                   	sti    
}
c0206609:	90                   	nop
c020660a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020660d:	c9                   	leave  
c020660e:	c3                   	ret    

c020660f <schedule>:

void schedule(){      //调度函数  检测时间片为0时调用此函数
c020660f:	55                   	push   %ebp
c0206610:	89 e5                	mov    %esp,%ebp
c0206612:	53                   	push   %ebx
c0206613:	83 ec 14             	sub    $0x14,%esp
c0206616:	e8 e9 09 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020661b:	81 c3 e5 19 00 00    	add    $0x19e5,%ebx
	if(cur_tcb->next==cur_tcb){
c0206621:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206627:	8b 00                	mov    (%eax),%eax
c0206629:	8b 50 10             	mov    0x10(%eax),%edx
c020662c:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206632:	8b 00                	mov    (%eax),%eax
c0206634:	39 c2                	cmp    %eax,%edx
c0206636:	75 11                	jne    c0206649 <schedule+0x3a>
		cur_tcb->time_left = TIME_CONT;    //如果只有一个线程 就再次给此线程添加时间片
c0206638:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020663e:	8b 00                	mov    (%eax),%eax
c0206640:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
		return ;
c0206647:	eb 4c                	jmp    c0206695 <schedule+0x86>
	}
	TCB_t *now = cur_tcb;
c0206649:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020664f:	8b 00                	mov    (%eax),%eax
c0206651:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0206654:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020665a:	8b 00                	mov    (%eax),%eax
c020665c:	8b 40 10             	mov    0x10(%eax),%eax
c020665f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0206662:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206665:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	cur_tcb = next_tcb;
c020666c:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206672:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206675:	89 10                	mov    %edx,(%eax)
	get_esp();      //有一个隐藏bug 需要call刷新寄存器
c0206677:	e8 f4 cb ff ff       	call   c0203270 <get_esp>
	switch_to(&(now->context),&(next_tcb->context));      
c020667c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020667f:	8d 50 20             	lea    0x20(%eax),%edx
c0206682:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206685:	83 c0 20             	add    $0x20,%eax
c0206688:	83 ec 08             	sub    $0x8,%esp
c020668b:	52                   	push   %edx
c020668c:	50                   	push   %eax
c020668d:	e8 e4 cb ff ff       	call   c0203276 <switch_to>
c0206692:	83 c4 10             	add    $0x10,%esp
}
c0206695:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206698:	c9                   	leave  
c0206699:	c3                   	ret    

c020669a <remove_thread>:

void remove_thread(){
c020669a:	55                   	push   %ebp
c020669b:	89 e5                	mov    %esp,%ebp
c020669d:	53                   	push   %ebx
c020669e:	83 ec 14             	sub    $0x14,%esp
c02066a1:	e8 5a 09 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02066a6:	05 5a 19 00 00       	add    $0x195a,%eax
	asm volatile("cli");
c02066ab:	fa                   	cli    
	if(cur_tcb->tid==0)
c02066ac:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c02066b2:	8b 12                	mov    (%edx),%edx
c02066b4:	8b 52 14             	mov    0x14(%edx),%edx
c02066b7:	85 d2                	test   %edx,%edx
c02066b9:	75 16                	jne    c02066d1 <remove_thread+0x37>
		printk("ERRO:main thread can`t use function exit\n");
c02066bb:	83 ec 0c             	sub    $0xc,%esp
c02066be:	8d 90 64 02 00 00    	lea    0x264(%eax),%edx
c02066c4:	52                   	push   %edx
c02066c5:	89 c3                	mov    %eax,%ebx
c02066c7:	e8 9a d1 ff ff       	call   c0203866 <printk>
c02066cc:	83 c4 10             	add    $0x10,%esp
		TCB_t *temp = cur_tcb;
		for(;temp->next!=cur_tcb;temp=temp->next)
			;
		temp->next = cur_tcb->next;
	}
}
c02066cf:	eb 39                	jmp    c020670a <remove_thread+0x70>
		TCB_t *temp = cur_tcb;
c02066d1:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c02066d7:	8b 12                	mov    (%edx),%edx
c02066d9:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;temp->next!=cur_tcb;temp=temp->next)
c02066dc:	eb 09                	jmp    c02066e7 <remove_thread+0x4d>
c02066de:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02066e1:	8b 52 10             	mov    0x10(%edx),%edx
c02066e4:	89 55 f4             	mov    %edx,-0xc(%ebp)
c02066e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02066ea:	8b 4a 10             	mov    0x10(%edx),%ecx
c02066ed:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c02066f3:	8b 12                	mov    (%edx),%edx
c02066f5:	39 d1                	cmp    %edx,%ecx
c02066f7:	75 e5                	jne    c02066de <remove_thread+0x44>
		temp->next = cur_tcb->next;
c02066f9:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02066ff:	8b 00                	mov    (%eax),%eax
c0206701:	8b 50 10             	mov    0x10(%eax),%edx
c0206704:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206707:	89 50 10             	mov    %edx,0x10(%eax)
}
c020670a:	90                   	nop
c020670b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020670e:	c9                   	leave  
c020670f:	c3                   	ret    

c0206710 <exit>:

void exit(){
c0206710:	55                   	push   %ebp
c0206711:	89 e5                	mov    %esp,%ebp
c0206713:	53                   	push   %ebx
c0206714:	83 ec 14             	sub    $0x14,%esp
c0206717:	e8 e8 08 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020671c:	81 c3 e4 18 00 00    	add    $0x18e4,%ebx
	remove_thread();
c0206722:	e8 73 ff ff ff       	call   c020669a <remove_thread>
	TCB_t *now = cur_tcb;
c0206727:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020672d:	8b 00                	mov    (%eax),%eax
c020672f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0206732:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206738:	8b 00                	mov    (%eax),%eax
c020673a:	8b 40 10             	mov    0x10(%eax),%eax
c020673d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0206740:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206743:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	cur_tcb = cur_tcb->next;
c020674a:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206750:	8b 00                	mov    (%eax),%eax
c0206752:	8b 50 10             	mov    0x10(%eax),%edx
c0206755:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020675b:	89 10                	mov    %edx,(%eax)
	switch_to(&(now->context),&(next_tcb->context));
c020675d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206760:	8d 50 20             	lea    0x20(%eax),%edx
c0206763:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206766:	83 c0 20             	add    $0x20,%eax
c0206769:	83 ec 08             	sub    $0x8,%esp
c020676c:	52                   	push   %edx
c020676d:	50                   	push   %eax
c020676e:	e8 03 cb ff ff       	call   c0203276 <switch_to>
c0206773:	83 c4 10             	add    $0x10,%esp
	//注意 暂时没有回收此线程页
}
c0206776:	90                   	nop
c0206777:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020677a:	c9                   	leave  
c020677b:	c3                   	ret    

c020677c <get_kern_used_page_count>:
//内核已使用的页数量(1MB以下也是已使用的部分)

bitmap kern_vmm_pool;


static int get_kern_used_page_count(){
c020677c:	55                   	push   %ebp
c020677d:	89 e5                	mov    %esp,%ebp
c020677f:	83 ec 10             	sub    $0x10,%esp
c0206782:	e8 79 08 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206787:	05 79 18 00 00       	add    $0x1879,%eax
    uint32_t size_bytes = kern_end-0;
c020678c:	c7 c0 00 e0 29 00    	mov    $0x29e000,%eax
c0206792:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (size_bytes+PAGE_SIZE-1)/PAGE_SIZE;     //向上取整
c0206795:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206798:	05 ff 0f 00 00       	add    $0xfff,%eax
c020679d:	c1 e8 0c             	shr    $0xc,%eax
}
c02067a0:	c9                   	leave  
c02067a1:	c3                   	ret    

c02067a2 <vmm_kern_init>:

//初始化内核虚拟空间
//预分配已使用内核空间
static void vmm_kern_init(){    
c02067a2:	55                   	push   %ebp
c02067a3:	89 e5                	mov    %esp,%ebp
c02067a5:	53                   	push   %ebx
c02067a6:	83 ec 24             	sub    $0x24,%esp
c02067a9:	e8 56 08 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02067ae:	81 c3 52 18 00 00    	add    $0x1852,%ebx
    kern_vmm_pool.target_addr_header = 0xC0000000;   //内核空间起始地址
c02067b4:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02067ba:	c7 40 08 00 00 00 c0 	movl   $0xc0000000,0x8(%eax)
    kern_vmm_pool.length = 0x8000;     //总共1GB空间
c02067c1:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02067c7:	c7 40 04 00 80 00 00 	movl   $0x8000,0x4(%eax)
    kern_vmm_pool.vaddr_header = kern_bitmap;
c02067ce:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c02067d4:	8b 10                	mov    (%eax),%edx
c02067d6:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02067dc:	89 10                	mov    %edx,(%eax)

    bitmap_init_mem(kern_vmm_pool);
c02067de:	83 ec 04             	sub    $0x4,%esp
c02067e1:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02067e7:	ff 70 08             	pushl  0x8(%eax)
c02067ea:	ff 70 04             	pushl  0x4(%eax)
c02067ed:	ff 30                	pushl  (%eax)
c02067ef:	e8 16 db ff ff       	call   c020430a <bitmap_init_mem>
c02067f4:	83 c4 10             	add    $0x10,%esp
    int page_used = get_kern_used_page_count();
c02067f7:	e8 80 ff ff ff       	call   c020677c <get_kern_used_page_count>
c02067fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(page_used>1024){
c02067ff:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
c0206806:	7e 14                	jle    c020681c <vmm_kern_init+0x7a>
        printk("\nERRO!don`t have enough vm page for kernel when init!\n");
c0206808:	83 ec 0c             	sub    $0xc,%esp
c020680b:	8d 83 90 02 00 00    	lea    0x290(%ebx),%eax
c0206811:	50                   	push   %eax
c0206812:	e8 4f d0 ff ff       	call   c0203866 <printk>
c0206817:	83 c4 10             	add    $0x10,%esp
        while (True){
c020681a:	eb fe                	jmp    c020681a <vmm_kern_init+0x78>
            //内核暂停
        }
    }
    for(int i = 0; i<page_used ;i++){
c020681c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0206823:	eb 20                	jmp    c0206845 <vmm_kern_init+0xa3>
        uint32_t rem = bitmap_alloc(kern_vmm_pool); //将内核空间在内存池中置为繁忙   此处可做性能优化
c0206825:	83 ec 04             	sub    $0x4,%esp
c0206828:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020682e:	ff 70 08             	pushl  0x8(%eax)
c0206831:	ff 70 04             	pushl  0x4(%eax)
c0206834:	ff 30                	pushl  (%eax)
c0206836:	e8 96 dc ff ff       	call   c02044d1 <bitmap_alloc>
c020683b:	83 c4 10             	add    $0x10,%esp
c020683e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(int i = 0; i<page_used ;i++){
c0206841:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206845:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206848:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c020684b:	7c d8                	jl     c0206825 <vmm_kern_init+0x83>
    }    
    //将内核虚拟内存管理页（最后1024页）在内存池中置为繁忙
    //1024页占用128字节 所以要将bitmap最后128字节清零
    int temp_cnt =0;
c020684d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c0206854:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c020685a:	8b 00                	mov    (%eax),%eax
c020685c:	05 ff 7f 00 00       	add    $0x7fff,%eax
c0206861:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0206864:	eb 0e                	jmp    c0206874 <vmm_kern_init+0xd2>
        *((byte*)probe) = 0;
c0206866:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206869:	c6 00 00             	movb   $0x0,(%eax)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c020686c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0206870:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c0206874:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
c0206878:	7e ec                	jle    c0206866 <vmm_kern_init+0xc4>
    }
}
c020687a:	90                   	nop
c020687b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020687e:	c9                   	leave  
c020687f:	c3                   	ret    

c0206880 <vmm_init>:

void vmm_init(){
c0206880:	55                   	push   %ebp
c0206881:	89 e5                	mov    %esp,%ebp
c0206883:	83 ec 08             	sub    $0x8,%esp
c0206886:	e8 75 07 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020688b:	05 75 17 00 00       	add    $0x1775,%eax
       vmm_kern_init(); 
c0206890:	e8 0d ff ff ff       	call   c02067a2 <vmm_kern_init>
}
c0206895:	90                   	nop
c0206896:	c9                   	leave  
c0206897:	c3                   	ret    

c0206898 <get_pte>:

//通过虚拟地址 获取对应的页表项虚拟地址
static uint32_t get_pte(uint32_t target){
c0206898:	55                   	push   %ebp
c0206899:	89 e5                	mov    %esp,%ebp
c020689b:	83 ec 10             	sub    $0x10,%esp
c020689e:	e8 5d 07 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02068a3:	05 5d 17 00 00       	add    $0x175d,%eax
    target = target&0xFFFFF000;
c02068a8:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = (0x3FF<<22);     //高10位
c02068af:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = (target>>10) & 0x003FF000;//中间10位为target高10位
c02068b6:	8b 45 08             	mov    0x8(%ebp),%eax
c02068b9:	c1 e8 0a             	shr    $0xa,%eax
c02068bc:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c02068c1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t addr_low12 = (((target>>12)&0x3FF)*4)&0x00000FFF;//低12位为target中间10位×4
c02068c4:	8b 45 08             	mov    0x8(%ebp),%eax
c02068c7:	c1 e8 0c             	shr    $0xc,%eax
c02068ca:	25 ff 03 00 00       	and    $0x3ff,%eax
c02068cf:	c1 e0 02             	shl    $0x2,%eax
c02068d2:	25 fc 0f 00 00       	and    $0xffc,%eax
c02068d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c02068da:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02068dd:	0b 45 f8             	or     -0x8(%ebp),%eax
c02068e0:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c02068e3:	c9                   	leave  
c02068e4:	c3                   	ret    

c02068e5 <get_pde>:

//通过虚拟地址 获取对应的页目录项虚拟地址
static uint32_t get_pde(uint32_t target){
c02068e5:	55                   	push   %ebp
c02068e6:	89 e5                	mov    %esp,%ebp
c02068e8:	83 ec 10             	sub    $0x10,%esp
c02068eb:	e8 10 07 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02068f0:	05 10 17 00 00       	add    $0x1710,%eax
    target = target&0xFFFFF000;
c02068f5:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = (0x3FF<<22);     //高10位
c02068fc:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = 0x003FF000;//中间10位为最后一个页目录项 也就是1023 （1111111111b）
c0206903:	c7 45 f8 00 f0 3f 00 	movl   $0x3ff000,-0x8(%ebp)
    uint32_t addr_low12 = (((target>>22)&0x3FF)*4)&0x00000FFF;//低12位为target中间10位×4
c020690a:	8b 45 08             	mov    0x8(%ebp),%eax
c020690d:	c1 e8 16             	shr    $0x16,%eax
c0206910:	c1 e0 02             	shl    $0x2,%eax
c0206913:	25 fc 0f 00 00       	and    $0xffc,%eax
c0206918:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c020691b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020691e:	0b 45 f8             	or     -0x8(%ebp),%eax
c0206921:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c0206924:	c9                   	leave  
c0206925:	c3                   	ret    

c0206926 <vmm_kern_alloc_one_page>:
//修改页表时的地址结构：
//      1111111111_xxxxxxxxxx_xxxxxxxxxx
//前十位为1表示页目录表最后一项 指向页目录表起始地址
// 中间十位表示在1024项页目录表中的索引
//最后12位表示在页表中的索引（每张页表1024项 共4096B 也就是12位可表达的最大范围）
uint32_t vmm_kern_alloc_one_page(uint32_t target){
c0206926:	55                   	push   %ebp
c0206927:	89 e5                	mov    %esp,%ebp
c0206929:	53                   	push   %ebx
c020692a:	83 ec 24             	sub    $0x24,%esp
c020692d:	e8 d2 06 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206932:	81 c3 ce 16 00 00    	add    $0x16ce,%ebx
    uint32_t vaddr_get=bitmap_alloc_one_page(kern_vmm_pool,target);
c0206938:	ff 75 08             	pushl  0x8(%ebp)
c020693b:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c0206941:	ff 70 08             	pushl  0x8(%eax)
c0206944:	ff 70 04             	pushl  0x4(%eax)
c0206947:	ff 30                	pushl  (%eax)
c0206949:	e8 fb d9 ff ff       	call   c0204349 <bitmap_alloc_one_page>
c020694e:	83 c4 10             	add    $0x10,%esp
c0206951:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c0206954:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0206958:	75 07                	jne    c0206961 <vmm_kern_alloc_one_page+0x3b>
        return VMM_ALLOC_ERRO;
c020695a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020695f:	eb 52                	jmp    c02069b3 <vmm_kern_alloc_one_page+0x8d>
    }            
    else{
        uint32_t page_desc_vaddr = get_pte(target);
c0206961:	83 ec 0c             	sub    $0xc,%esp
c0206964:	ff 75 08             	pushl  0x8(%ebp)
c0206967:	e8 2c ff ff ff       	call   c0206898 <get_pte>
c020696c:	83 c4 10             	add    $0x10,%esp
c020696f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206972:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0206975:	83 ec 0c             	sub    $0xc,%esp
c0206978:	50                   	push   %eax
c0206979:	e8 b5 ea ff ff       	call   c0205433 <pmm_alloc_one_page>
c020697e:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c0206981:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0206985:	84 c0                	test   %al,%al
c0206987:	75 07                	jne    c0206990 <vmm_kern_alloc_one_page+0x6a>
            //没有可用的物理页
            return VMM_ALLOC_ERRO;
c0206989:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020698e:	eb 23                	jmp    c02069b3 <vmm_kern_alloc_one_page+0x8d>
        }
        //修改页表
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c0206990:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0206993:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206998:	89 c2                	mov    %eax,%edx
c020699a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020699d:	81 c2 03 01 00 00    	add    $0x103,%edx
c02069a3:	89 10                	mov    %edx,(%eax)
        asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c02069a5:	8b 45 08             	mov    0x8(%ebp),%eax
c02069a8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02069ad:	0f 01 38             	invlpg (%eax)
        //reload_kern_page();
        return target;
c02069b0:	8b 45 08             	mov    0x8(%ebp),%eax
    }
}
c02069b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02069b6:	c9                   	leave  
c02069b7:	c3                   	ret    

c02069b8 <vmm_kern_alloc>:

uint32_t vmm_kern_alloc(){
c02069b8:	55                   	push   %ebp
c02069b9:	89 e5                	mov    %esp,%ebp
c02069bb:	53                   	push   %ebx
c02069bc:	83 ec 24             	sub    $0x24,%esp
c02069bf:	e8 40 06 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02069c4:	81 c3 3c 16 00 00    	add    $0x163c,%ebx
    uint32_t target = bitmap_alloc(kern_vmm_pool);
c02069ca:	83 ec 04             	sub    $0x4,%esp
c02069cd:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02069d3:	ff 70 08             	pushl  0x8(%eax)
c02069d6:	ff 70 04             	pushl  0x4(%eax)
c02069d9:	ff 30                	pushl  (%eax)
c02069db:	e8 f1 da ff ff       	call   c02044d1 <bitmap_alloc>
c02069e0:	83 c4 10             	add    $0x10,%esp
c02069e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (target == BITMAP_RETURN_ERRO){
c02069e6:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c02069ea:	75 0a                	jne    c02069f6 <vmm_kern_alloc+0x3e>
        return VMM_ALLOC_ERRO;
c02069ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02069f1:	e9 8e 00 00 00       	jmp    c0206a84 <vmm_kern_alloc+0xcc>
    }
    uint32_t vaddr_get = target;
c02069f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02069f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c02069fc:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0206a00:	75 19                	jne    c0206a1b <vmm_kern_alloc+0x63>
        printk("1\n");
c0206a02:	83 ec 0c             	sub    $0xc,%esp
c0206a05:	8d 83 c7 02 00 00    	lea    0x2c7(%ebx),%eax
c0206a0b:	50                   	push   %eax
c0206a0c:	e8 55 ce ff ff       	call   c0203866 <printk>
c0206a11:	83 c4 10             	add    $0x10,%esp
        return VMM_ALLOC_ERRO;
c0206a14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0206a19:	eb 69                	jmp    c0206a84 <vmm_kern_alloc+0xcc>
    }            
    else{
        uint32_t page_desc_vaddr = get_pte(target);
c0206a1b:	83 ec 0c             	sub    $0xc,%esp
c0206a1e:	ff 75 f4             	pushl  -0xc(%ebp)
c0206a21:	e8 72 fe ff ff       	call   c0206898 <get_pte>
c0206a26:	83 c4 10             	add    $0x10,%esp
c0206a29:	89 45 ec             	mov    %eax,-0x14(%ebp)
        pm_alloc_t phy_page = pmm_alloc_one_page();
c0206a2c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0206a2f:	83 ec 0c             	sub    $0xc,%esp
c0206a32:	50                   	push   %eax
c0206a33:	e8 fb e9 ff ff       	call   c0205433 <pmm_alloc_one_page>
c0206a38:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c0206a3b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0206a3f:	84 c0                	test   %al,%al
c0206a41:	75 19                	jne    c0206a5c <vmm_kern_alloc+0xa4>
            //没有可用的物理页
        printk("2\n"); 
c0206a43:	83 ec 0c             	sub    $0xc,%esp
c0206a46:	8d 83 ca 02 00 00    	lea    0x2ca(%ebx),%eax
c0206a4c:	50                   	push   %eax
c0206a4d:	e8 14 ce ff ff       	call   c0203866 <printk>
c0206a52:	83 c4 10             	add    $0x10,%esp
            return VMM_ALLOC_ERRO;
c0206a55:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0206a5a:	eb 28                	jmp    c0206a84 <vmm_kern_alloc+0xcc>
        }
        //修改页表
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c0206a5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0206a5f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206a64:	89 c2                	mov    %eax,%edx
c0206a66:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206a69:	81 c2 03 01 00 00    	add    $0x103,%edx
c0206a6f:	89 10                	mov    %edx,(%eax)
        asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c0206a71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206a74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206a79:	0f 01 38             	invlpg (%eax)
        reload_kern_page();
c0206a7c:	e8 c8 95 ef 3f       	call   100049 <reload_kern_page>
        return target;
c0206a81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0206a84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206a87:	c9                   	leave  
c0206a88:	c3                   	ret    

c0206a89 <vmm_kern_release_one_page>:

//释放制定内核虚拟页的空间
//内核的释放与用户的释放要分开 否则用户程序可以使用系统调用指定将内核虚拟页释放掉
void vmm_kern_release_one_page(uint32_t target){
c0206a89:	55                   	push   %ebp
c0206a8a:	89 e5                	mov    %esp,%ebp
c0206a8c:	53                   	push   %ebx
c0206a8d:	83 ec 24             	sub    $0x24,%esp
c0206a90:	e8 6f 05 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206a95:	81 c3 6b 15 00 00    	add    $0x156b,%ebx
    //判定是否是内核页
    if(target<0xC0000000){
c0206a9b:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0206aa2:	76 7a                	jbe    c0206b1e <vmm_kern_release_one_page+0x95>
        //不是内核页 直接退出执行
        return ;
    }
    bitmap_release_one_page(kern_vmm_pool,target);
c0206aa4:	ff 75 08             	pushl  0x8(%ebp)
c0206aa7:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c0206aad:	ff 70 08             	pushl  0x8(%eax)
c0206ab0:	ff 70 04             	pushl  0x4(%eax)
c0206ab3:	ff 30                	pushl  (%eax)
c0206ab5:	e8 6c d9 ff ff       	call   c0204426 <bitmap_release_one_page>
c0206aba:	83 c4 10             	add    $0x10,%esp
    uint32_t desc_vaddr = get_pte(target);
c0206abd:	83 ec 0c             	sub    $0xc,%esp
c0206ac0:	ff 75 08             	pushl  0x8(%ebp)
c0206ac3:	e8 d0 fd ff ff       	call   c0206898 <get_pte>
c0206ac8:	83 c4 10             	add    $0x10,%esp
c0206acb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t desc_inf = *((uint32_t*)desc_vaddr);
c0206ace:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206ad1:	8b 00                	mov    (%eax),%eax
c0206ad3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *((uint32_t*)desc_vaddr) =  desc_inf&0xFFFFFFFE;    //最低位置为0 表示P位为0 不存在(直接访问会造成page_fault中断)   
c0206ad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206ad9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0206adc:	83 e2 fe             	and    $0xfffffffe,%edx
c0206adf:	89 10                	mov    %edx,(%eax)
    uint32_t phy_page_addr = desc_inf&0xFFFFF000;
c0206ae1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206ae4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206ae9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    
    pm_alloc_t release_page;
    release_page.addr = phy_page_addr;
c0206aec:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206aef:	89 45 e0             	mov    %eax,-0x20(%ebp)
    release_page.size =1;
c0206af2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    release_page.state = 1;
c0206af9:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)
    pmm_free_page(release_page);
c0206afd:	83 ec 04             	sub    $0x4,%esp
c0206b00:	ff 75 e8             	pushl  -0x18(%ebp)
c0206b03:	ff 75 e4             	pushl  -0x1c(%ebp)
c0206b06:	ff 75 e0             	pushl  -0x20(%ebp)
c0206b09:	e8 a7 ea ff ff       	call   c02055b5 <pmm_free_page>
c0206b0e:	83 c4 10             	add    $0x10,%esp
/*此处有bug   虽然设置了页不缓存 但是系统还是会自动缓存 所以此处使用嵌入汇编invlpg重载目标页的TLB缓存*/
    asm volatile ("invlpg (%0)" : : "a" (target&0xFFFFF000));
c0206b11:	8b 45 08             	mov    0x8(%ebp),%eax
c0206b14:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206b19:	0f 01 38             	invlpg (%eax)
c0206b1c:	eb 01                	jmp    c0206b1f <vmm_kern_release_one_page+0x96>
        return ;
c0206b1e:	90                   	nop
    //reload_kern_page();
}
c0206b1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206b22:	c9                   	leave  
c0206b23:	c3                   	ret    

c0206b24 <vmm_user_init>:

static void vmm_user_init(){
c0206b24:	55                   	push   %ebp
c0206b25:	89 e5                	mov    %esp,%ebp
c0206b27:	e8 d4 04 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206b2c:	05 d4 14 00 00       	add    $0x14d4,%eax

}
c0206b31:	90                   	nop
c0206b32:	5d                   	pop    %ebp
c0206b33:	c3                   	ret    

c0206b34 <vmm_test>:
//6(0110)3(0011)
void vmm_test(){
c0206b34:	55                   	push   %ebp
c0206b35:	89 e5                	mov    %esp,%ebp
c0206b37:	56                   	push   %esi
c0206b38:	53                   	push   %ebx
c0206b39:	e8 c6 04 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206b3e:	81 c3 c2 14 00 00    	add    $0x14c2,%ebx
    //vmm_kern_release_one_page(0xC0000000);
    //*((char*)0xC0000000) = 1;   
    printk("\nkern_dir:0x%h\n",kern_dir_table_paddr);
c0206b44:	c7 c0 10 70 20 c0    	mov    $0xc0207010,%eax
c0206b4a:	8b 00                	mov    (%eax),%eax
c0206b4c:	83 ec 08             	sub    $0x8,%esp
c0206b4f:	50                   	push   %eax
c0206b50:	8d 83 cd 02 00 00    	lea    0x2cd(%ebx),%eax
c0206b56:	50                   	push   %eax
c0206b57:	e8 0a cd ff ff       	call   c0203866 <printk>
c0206b5c:	83 c4 10             	add    $0x10,%esp
    printk("\nkern_page:0x%h\n",kern_page_table_paddr);
c0206b5f:	c7 c0 14 70 20 c0    	mov    $0xc0207014,%eax
c0206b65:	8b 00                	mov    (%eax),%eax
c0206b67:	83 ec 08             	sub    $0x8,%esp
c0206b6a:	50                   	push   %eax
c0206b6b:	8d 83 dd 02 00 00    	lea    0x2dd(%ebx),%eax
c0206b71:	50                   	push   %eax
c0206b72:	e8 ef cc ff ff       	call   c0203866 <printk>
c0206b77:	83 c4 10             	add    $0x10,%esp
    printk("\nlast_pde:0x%h\n",*((uint32_t*)(kern_dir_table_paddr+0xC00+255*4)));
c0206b7a:	c7 c0 10 70 20 c0    	mov    $0xc0207010,%eax
c0206b80:	8b 00                	mov    (%eax),%eax
c0206b82:	05 fc 0f 00 00       	add    $0xffc,%eax
c0206b87:	8b 00                	mov    (%eax),%eax
c0206b89:	83 ec 08             	sub    $0x8,%esp
c0206b8c:	50                   	push   %eax
c0206b8d:	8d 83 ee 02 00 00    	lea    0x2ee(%ebx),%eax
c0206b93:	50                   	push   %eax
c0206b94:	e8 cd cc ff ff       	call   c0203866 <printk>
c0206b99:	83 c4 10             	add    $0x10,%esp
    printk("\nresult:0x%h---%h\n",*((uint32_t*) get_pte(0xC0000000)),*((uint32_t*)kern_page_table_paddr));
c0206b9c:	c7 c0 14 70 20 c0    	mov    $0xc0207014,%eax
c0206ba2:	8b 00                	mov    (%eax),%eax
c0206ba4:	8b 30                	mov    (%eax),%esi
c0206ba6:	83 ec 0c             	sub    $0xc,%esp
c0206ba9:	68 00 00 00 c0       	push   $0xc0000000
c0206bae:	e8 e5 fc ff ff       	call   c0206898 <get_pte>
c0206bb3:	83 c4 10             	add    $0x10,%esp
c0206bb6:	8b 00                	mov    (%eax),%eax
c0206bb8:	83 ec 04             	sub    $0x4,%esp
c0206bbb:	56                   	push   %esi
c0206bbc:	50                   	push   %eax
c0206bbd:	8d 83 fe 02 00 00    	lea    0x2fe(%ebx),%eax
c0206bc3:	50                   	push   %eax
c0206bc4:	e8 9d cc ff ff       	call   c0203866 <printk>
c0206bc9:	83 c4 10             	add    $0x10,%esp
//正常分配情况会导致两次page_fault
    *((char*)0xC1000000) = 'a';
c0206bcc:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206bd1:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_alloc_one_page(0xC1000000);
c0206bd4:	83 ec 0c             	sub    $0xc,%esp
c0206bd7:	68 00 00 00 c1       	push   $0xc1000000
c0206bdc:	e8 45 fd ff ff       	call   c0206926 <vmm_kern_alloc_one_page>
c0206be1:	83 c4 10             	add    $0x10,%esp
    *((char*)0xC1000000) = 'a';
c0206be4:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206be9:	c6 00 61             	movb   $0x61,(%eax)
    vmm_kern_release_one_page(0xC1000000);
c0206bec:	83 ec 0c             	sub    $0xc,%esp
c0206bef:	68 00 00 00 c1       	push   $0xc1000000
c0206bf4:	e8 90 fe ff ff       	call   c0206a89 <vmm_kern_release_one_page>
c0206bf9:	83 c4 10             	add    $0x10,%esp
    *((char*)0xC1000000) = 'a';
c0206bfc:	b8 00 00 00 c1       	mov    $0xc1000000,%eax
c0206c01:	c6 00 61             	movb   $0x61,(%eax)
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0000000))));
c0206c04:	83 ec 0c             	sub    $0xc,%esp
c0206c07:	68 00 00 00 c0       	push   $0xc0000000
c0206c0c:	e8 d4 fc ff ff       	call   c02068e5 <get_pde>
c0206c11:	83 c4 10             	add    $0x10,%esp
c0206c14:	8b 00                	mov    (%eax),%eax
c0206c16:	83 ec 08             	sub    $0x8,%esp
c0206c19:	50                   	push   %eax
c0206c1a:	8d 83 11 03 00 00    	lea    0x311(%ebx),%eax
c0206c20:	50                   	push   %eax
c0206c21:	e8 40 cc ff ff       	call   c0203866 <printk>
c0206c26:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0400000))));
c0206c29:	83 ec 0c             	sub    $0xc,%esp
c0206c2c:	68 00 00 40 c0       	push   $0xc0400000
c0206c31:	e8 af fc ff ff       	call   c02068e5 <get_pde>
c0206c36:	83 c4 10             	add    $0x10,%esp
c0206c39:	8b 00                	mov    (%eax),%eax
c0206c3b:	83 ec 08             	sub    $0x8,%esp
c0206c3e:	50                   	push   %eax
c0206c3f:	8d 83 11 03 00 00    	lea    0x311(%ebx),%eax
c0206c45:	50                   	push   %eax
c0206c46:	e8 1b cc ff ff       	call   c0203866 <printk>
c0206c4b:	83 c4 10             	add    $0x10,%esp
    printk("\n0x%h\n",*((uint32_t*)(get_pde(0xC0800000))));
c0206c4e:	83 ec 0c             	sub    $0xc,%esp
c0206c51:	68 00 00 80 c0       	push   $0xc0800000
c0206c56:	e8 8a fc ff ff       	call   c02068e5 <get_pde>
c0206c5b:	83 c4 10             	add    $0x10,%esp
c0206c5e:	8b 00                	mov    (%eax),%eax
c0206c60:	83 ec 08             	sub    $0x8,%esp
c0206c63:	50                   	push   %eax
c0206c64:	8d 83 11 03 00 00    	lea    0x311(%ebx),%eax
c0206c6a:	50                   	push   %eax
c0206c6b:	e8 f6 cb ff ff       	call   c0203866 <printk>
c0206c70:	83 c4 10             	add    $0x10,%esp
c0206c73:	90                   	nop
c0206c74:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0206c77:	5b                   	pop    %ebx
c0206c78:	5e                   	pop    %esi
c0206c79:	5d                   	pop    %ebp
c0206c7a:	c3                   	ret    
c0206c7b:	66 90                	xchg   %ax,%ax
c0206c7d:	66 90                	xchg   %ax,%ax
c0206c7f:	66 90                	xchg   %ax,%ax
c0206c81:	66 90                	xchg   %ax,%ax
c0206c83:	66 90                	xchg   %ax,%ax
c0206c85:	66 90                	xchg   %ax,%ax
c0206c87:	66 90                	xchg   %ax,%ax
c0206c89:	66 90                	xchg   %ax,%ax
c0206c8b:	66 90                	xchg   %ax,%ax
c0206c8d:	66 90                	xchg   %ax,%ax
c0206c8f:	66 90                	xchg   %ax,%ax
c0206c91:	66 90                	xchg   %ax,%ax
c0206c93:	66 90                	xchg   %ax,%ax
c0206c95:	66 90                	xchg   %ax,%ax
c0206c97:	66 90                	xchg   %ax,%ax
c0206c99:	66 90                	xchg   %ax,%ax
c0206c9b:	66 90                	xchg   %ax,%ax
c0206c9d:	66 90                	xchg   %ax,%ax
c0206c9f:	66 90                	xchg   %ax,%ax
c0206ca1:	66 90                	xchg   %ax,%ax
c0206ca3:	66 90                	xchg   %ax,%ax
c0206ca5:	66 90                	xchg   %ax,%ax
c0206ca7:	66 90                	xchg   %ax,%ax
c0206ca9:	66 90                	xchg   %ax,%ax
c0206cab:	66 90                	xchg   %ax,%ax
c0206cad:	66 90                	xchg   %ax,%ax
c0206caf:	66 90                	xchg   %ax,%ax
c0206cb1:	66 90                	xchg   %ax,%ax
c0206cb3:	66 90                	xchg   %ax,%ax
c0206cb5:	66 90                	xchg   %ax,%ax
c0206cb7:	66 90                	xchg   %ax,%ax
c0206cb9:	66 90                	xchg   %ax,%ax
c0206cbb:	66 90                	xchg   %ax,%ax
c0206cbd:	66 90                	xchg   %ax,%ax
c0206cbf:	66 90                	xchg   %ax,%ax
c0206cc1:	66 90                	xchg   %ax,%ax
c0206cc3:	66 90                	xchg   %ax,%ax
c0206cc5:	66 90                	xchg   %ax,%ax
c0206cc7:	66 90                	xchg   %ax,%ax
c0206cc9:	66 90                	xchg   %ax,%ax
c0206ccb:	66 90                	xchg   %ax,%ax
c0206ccd:	66 90                	xchg   %ax,%ax
c0206ccf:	66 90                	xchg   %ax,%ax
c0206cd1:	66 90                	xchg   %ax,%ax
c0206cd3:	66 90                	xchg   %ax,%ax
c0206cd5:	66 90                	xchg   %ax,%ax
c0206cd7:	66 90                	xchg   %ax,%ax
c0206cd9:	66 90                	xchg   %ax,%ax
c0206cdb:	66 90                	xchg   %ax,%ax
c0206cdd:	66 90                	xchg   %ax,%ax
c0206cdf:	66 90                	xchg   %ax,%ax
c0206ce1:	66 90                	xchg   %ax,%ax
c0206ce3:	66 90                	xchg   %ax,%ax
c0206ce5:	66 90                	xchg   %ax,%ax
c0206ce7:	66 90                	xchg   %ax,%ax
c0206ce9:	66 90                	xchg   %ax,%ax
c0206ceb:	66 90                	xchg   %ax,%ax
c0206ced:	66 90                	xchg   %ax,%ax
c0206cef:	66 90                	xchg   %ax,%ax
c0206cf1:	66 90                	xchg   %ax,%ax
c0206cf3:	66 90                	xchg   %ax,%ax
c0206cf5:	66 90                	xchg   %ax,%ax
c0206cf7:	66 90                	xchg   %ax,%ax
c0206cf9:	66 90                	xchg   %ax,%ax
c0206cfb:	66 90                	xchg   %ax,%ax
c0206cfd:	66 90                	xchg   %ax,%ax
c0206cff:	66 90                	xchg   %ax,%ax
c0206d01:	66 90                	xchg   %ax,%ax
c0206d03:	66 90                	xchg   %ax,%ax
c0206d05:	66 90                	xchg   %ax,%ax
c0206d07:	66 90                	xchg   %ax,%ax
c0206d09:	66 90                	xchg   %ax,%ax
c0206d0b:	66 90                	xchg   %ax,%ax
c0206d0d:	66 90                	xchg   %ax,%ax
c0206d0f:	66 90                	xchg   %ax,%ax
c0206d11:	66 90                	xchg   %ax,%ax
c0206d13:	66 90                	xchg   %ax,%ax
c0206d15:	66 90                	xchg   %ax,%ax
c0206d17:	66 90                	xchg   %ax,%ax
c0206d19:	66 90                	xchg   %ax,%ax
c0206d1b:	66 90                	xchg   %ax,%ax
c0206d1d:	66 90                	xchg   %ax,%ax
c0206d1f:	66 90                	xchg   %ax,%ax
c0206d21:	66 90                	xchg   %ax,%ax
c0206d23:	66 90                	xchg   %ax,%ax
c0206d25:	66 90                	xchg   %ax,%ax
c0206d27:	66 90                	xchg   %ax,%ax
c0206d29:	66 90                	xchg   %ax,%ax
c0206d2b:	66 90                	xchg   %ax,%ax
c0206d2d:	66 90                	xchg   %ax,%ax
c0206d2f:	66 90                	xchg   %ax,%ax
c0206d31:	66 90                	xchg   %ax,%ax
c0206d33:	66 90                	xchg   %ax,%ax
c0206d35:	66 90                	xchg   %ax,%ax
c0206d37:	66 90                	xchg   %ax,%ax
c0206d39:	66 90                	xchg   %ax,%ax
c0206d3b:	66 90                	xchg   %ax,%ax
c0206d3d:	66 90                	xchg   %ax,%ax
c0206d3f:	66 90                	xchg   %ax,%ax
c0206d41:	66 90                	xchg   %ax,%ax
c0206d43:	66 90                	xchg   %ax,%ax
c0206d45:	66 90                	xchg   %ax,%ax
c0206d47:	66 90                	xchg   %ax,%ax
c0206d49:	66 90                	xchg   %ax,%ax
c0206d4b:	66 90                	xchg   %ax,%ax
c0206d4d:	66 90                	xchg   %ax,%ax
c0206d4f:	66 90                	xchg   %ax,%ax
c0206d51:	66 90                	xchg   %ax,%ax
c0206d53:	66 90                	xchg   %ax,%ax
c0206d55:	66 90                	xchg   %ax,%ax
c0206d57:	66 90                	xchg   %ax,%ax
c0206d59:	66 90                	xchg   %ax,%ax
c0206d5b:	66 90                	xchg   %ax,%ax
c0206d5d:	66 90                	xchg   %ax,%ax
c0206d5f:	66 90                	xchg   %ax,%ax
c0206d61:	66 90                	xchg   %ax,%ax
c0206d63:	66 90                	xchg   %ax,%ax
c0206d65:	66 90                	xchg   %ax,%ax
c0206d67:	66 90                	xchg   %ax,%ax
c0206d69:	66 90                	xchg   %ax,%ax
c0206d6b:	66 90                	xchg   %ax,%ax
c0206d6d:	66 90                	xchg   %ax,%ax
c0206d6f:	66 90                	xchg   %ax,%ax
c0206d71:	66 90                	xchg   %ax,%ax
c0206d73:	66 90                	xchg   %ax,%ax
c0206d75:	66 90                	xchg   %ax,%ax
c0206d77:	66 90                	xchg   %ax,%ax
c0206d79:	66 90                	xchg   %ax,%ax
c0206d7b:	66 90                	xchg   %ax,%ax
c0206d7d:	66 90                	xchg   %ax,%ax
c0206d7f:	66 90                	xchg   %ax,%ax
c0206d81:	66 90                	xchg   %ax,%ax
c0206d83:	66 90                	xchg   %ax,%ax
c0206d85:	66 90                	xchg   %ax,%ax
c0206d87:	66 90                	xchg   %ax,%ax
c0206d89:	66 90                	xchg   %ax,%ax
c0206d8b:	66 90                	xchg   %ax,%ax
c0206d8d:	66 90                	xchg   %ax,%ax
c0206d8f:	66 90                	xchg   %ax,%ax
c0206d91:	66 90                	xchg   %ax,%ax
c0206d93:	66 90                	xchg   %ax,%ax
c0206d95:	66 90                	xchg   %ax,%ax
c0206d97:	66 90                	xchg   %ax,%ax
c0206d99:	66 90                	xchg   %ax,%ax
c0206d9b:	66 90                	xchg   %ax,%ax
c0206d9d:	66 90                	xchg   %ax,%ax
c0206d9f:	66 90                	xchg   %ax,%ax
c0206da1:	66 90                	xchg   %ax,%ax
c0206da3:	66 90                	xchg   %ax,%ax
c0206da5:	66 90                	xchg   %ax,%ax
c0206da7:	66 90                	xchg   %ax,%ax
c0206da9:	66 90                	xchg   %ax,%ax
c0206dab:	66 90                	xchg   %ax,%ax
c0206dad:	66 90                	xchg   %ax,%ax
c0206daf:	66 90                	xchg   %ax,%ax
c0206db1:	66 90                	xchg   %ax,%ax
c0206db3:	66 90                	xchg   %ax,%ax
c0206db5:	66 90                	xchg   %ax,%ax
c0206db7:	66 90                	xchg   %ax,%ax
c0206db9:	66 90                	xchg   %ax,%ax
c0206dbb:	66 90                	xchg   %ax,%ax
c0206dbd:	66 90                	xchg   %ax,%ax
c0206dbf:	66 90                	xchg   %ax,%ax
c0206dc1:	66 90                	xchg   %ax,%ax
c0206dc3:	66 90                	xchg   %ax,%ax
c0206dc5:	66 90                	xchg   %ax,%ax
c0206dc7:	66 90                	xchg   %ax,%ax
c0206dc9:	66 90                	xchg   %ax,%ax
c0206dcb:	66 90                	xchg   %ax,%ax
c0206dcd:	66 90                	xchg   %ax,%ax
c0206dcf:	66 90                	xchg   %ax,%ax
c0206dd1:	66 90                	xchg   %ax,%ax
c0206dd3:	66 90                	xchg   %ax,%ax
c0206dd5:	66 90                	xchg   %ax,%ax
c0206dd7:	66 90                	xchg   %ax,%ax
c0206dd9:	66 90                	xchg   %ax,%ax
c0206ddb:	66 90                	xchg   %ax,%ax
c0206ddd:	66 90                	xchg   %ax,%ax
c0206ddf:	66 90                	xchg   %ax,%ax
c0206de1:	66 90                	xchg   %ax,%ax
c0206de3:	66 90                	xchg   %ax,%ax
c0206de5:	66 90                	xchg   %ax,%ax
c0206de7:	66 90                	xchg   %ax,%ax
c0206de9:	66 90                	xchg   %ax,%ax
c0206deb:	66 90                	xchg   %ax,%ax
c0206ded:	66 90                	xchg   %ax,%ax
c0206def:	66 90                	xchg   %ax,%ax
c0206df1:	66 90                	xchg   %ax,%ax
c0206df3:	66 90                	xchg   %ax,%ax
c0206df5:	66 90                	xchg   %ax,%ax
c0206df7:	66 90                	xchg   %ax,%ax
c0206df9:	66 90                	xchg   %ax,%ax
c0206dfb:	66 90                	xchg   %ax,%ax
c0206dfd:	66 90                	xchg   %ax,%ax
c0206dff:	66 90                	xchg   %ax,%ax
c0206e01:	66 90                	xchg   %ax,%ax
c0206e03:	66 90                	xchg   %ax,%ax
c0206e05:	66 90                	xchg   %ax,%ax
c0206e07:	66 90                	xchg   %ax,%ax
c0206e09:	66 90                	xchg   %ax,%ax
c0206e0b:	66 90                	xchg   %ax,%ax
c0206e0d:	66 90                	xchg   %ax,%ax
c0206e0f:	66 90                	xchg   %ax,%ax
c0206e11:	66 90                	xchg   %ax,%ax
c0206e13:	66 90                	xchg   %ax,%ax
c0206e15:	66 90                	xchg   %ax,%ax
c0206e17:	66 90                	xchg   %ax,%ax
c0206e19:	66 90                	xchg   %ax,%ax
c0206e1b:	66 90                	xchg   %ax,%ax
c0206e1d:	66 90                	xchg   %ax,%ax
c0206e1f:	66 90                	xchg   %ax,%ax
c0206e21:	66 90                	xchg   %ax,%ax
c0206e23:	66 90                	xchg   %ax,%ax
c0206e25:	66 90                	xchg   %ax,%ax
c0206e27:	66 90                	xchg   %ax,%ax
c0206e29:	66 90                	xchg   %ax,%ax
c0206e2b:	66 90                	xchg   %ax,%ax
c0206e2d:	66 90                	xchg   %ax,%ax
c0206e2f:	66 90                	xchg   %ax,%ax
c0206e31:	66 90                	xchg   %ax,%ax
c0206e33:	66 90                	xchg   %ax,%ax
c0206e35:	66 90                	xchg   %ax,%ax
c0206e37:	66 90                	xchg   %ax,%ax
c0206e39:	66 90                	xchg   %ax,%ax
c0206e3b:	66 90                	xchg   %ax,%ax
c0206e3d:	66 90                	xchg   %ax,%ax
c0206e3f:	66 90                	xchg   %ax,%ax
c0206e41:	66 90                	xchg   %ax,%ax
c0206e43:	66 90                	xchg   %ax,%ax
c0206e45:	66 90                	xchg   %ax,%ax
c0206e47:	66 90                	xchg   %ax,%ax
c0206e49:	66 90                	xchg   %ax,%ax
c0206e4b:	66 90                	xchg   %ax,%ax
c0206e4d:	66 90                	xchg   %ax,%ax
c0206e4f:	66 90                	xchg   %ax,%ax
c0206e51:	66 90                	xchg   %ax,%ax
c0206e53:	66 90                	xchg   %ax,%ax
c0206e55:	66 90                	xchg   %ax,%ax
c0206e57:	66 90                	xchg   %ax,%ax
c0206e59:	66 90                	xchg   %ax,%ax
c0206e5b:	66 90                	xchg   %ax,%ax
c0206e5d:	66 90                	xchg   %ax,%ax
c0206e5f:	66 90                	xchg   %ax,%ax
c0206e61:	66 90                	xchg   %ax,%ax
c0206e63:	66 90                	xchg   %ax,%ax
c0206e65:	66 90                	xchg   %ax,%ax
c0206e67:	66 90                	xchg   %ax,%ax
c0206e69:	66 90                	xchg   %ax,%ax
c0206e6b:	66 90                	xchg   %ax,%ax
c0206e6d:	66 90                	xchg   %ax,%ax
c0206e6f:	66 90                	xchg   %ax,%ax
c0206e71:	66 90                	xchg   %ax,%ax
c0206e73:	66 90                	xchg   %ax,%ax
c0206e75:	66 90                	xchg   %ax,%ax
c0206e77:	66 90                	xchg   %ax,%ax
c0206e79:	66 90                	xchg   %ax,%ax
c0206e7b:	66 90                	xchg   %ax,%ax
c0206e7d:	66 90                	xchg   %ax,%ax
c0206e7f:	66 90                	xchg   %ax,%ax
c0206e81:	66 90                	xchg   %ax,%ax
c0206e83:	66 90                	xchg   %ax,%ax
c0206e85:	66 90                	xchg   %ax,%ax
c0206e87:	66 90                	xchg   %ax,%ax
c0206e89:	66 90                	xchg   %ax,%ax
c0206e8b:	66 90                	xchg   %ax,%ax
c0206e8d:	66 90                	xchg   %ax,%ax
c0206e8f:	66 90                	xchg   %ax,%ax
c0206e91:	66 90                	xchg   %ax,%ax
c0206e93:	66 90                	xchg   %ax,%ax
c0206e95:	66 90                	xchg   %ax,%ax
c0206e97:	66 90                	xchg   %ax,%ax
c0206e99:	66 90                	xchg   %ax,%ax
c0206e9b:	66 90                	xchg   %ax,%ax
c0206e9d:	66 90                	xchg   %ax,%ax
c0206e9f:	66 90                	xchg   %ax,%ax
c0206ea1:	66 90                	xchg   %ax,%ax
c0206ea3:	66 90                	xchg   %ax,%ax
c0206ea5:	66 90                	xchg   %ax,%ax
c0206ea7:	66 90                	xchg   %ax,%ax
c0206ea9:	66 90                	xchg   %ax,%ax
c0206eab:	66 90                	xchg   %ax,%ax
c0206ead:	66 90                	xchg   %ax,%ax
c0206eaf:	66 90                	xchg   %ax,%ax
c0206eb1:	66 90                	xchg   %ax,%ax
c0206eb3:	66 90                	xchg   %ax,%ax
c0206eb5:	66 90                	xchg   %ax,%ax
c0206eb7:	66 90                	xchg   %ax,%ax
c0206eb9:	66 90                	xchg   %ax,%ax
c0206ebb:	66 90                	xchg   %ax,%ax
c0206ebd:	66 90                	xchg   %ax,%ax
c0206ebf:	66 90                	xchg   %ax,%ax
c0206ec1:	66 90                	xchg   %ax,%ax
c0206ec3:	66 90                	xchg   %ax,%ax
c0206ec5:	66 90                	xchg   %ax,%ax
c0206ec7:	66 90                	xchg   %ax,%ax
c0206ec9:	66 90                	xchg   %ax,%ax
c0206ecb:	66 90                	xchg   %ax,%ax
c0206ecd:	66 90                	xchg   %ax,%ax
c0206ecf:	66 90                	xchg   %ax,%ax
c0206ed1:	66 90                	xchg   %ax,%ax
c0206ed3:	66 90                	xchg   %ax,%ax
c0206ed5:	66 90                	xchg   %ax,%ax
c0206ed7:	66 90                	xchg   %ax,%ax
c0206ed9:	66 90                	xchg   %ax,%ax
c0206edb:	66 90                	xchg   %ax,%ax
c0206edd:	66 90                	xchg   %ax,%ax
c0206edf:	66 90                	xchg   %ax,%ax
c0206ee1:	66 90                	xchg   %ax,%ax
c0206ee3:	66 90                	xchg   %ax,%ax
c0206ee5:	66 90                	xchg   %ax,%ax
c0206ee7:	66 90                	xchg   %ax,%ax
c0206ee9:	66 90                	xchg   %ax,%ax
c0206eeb:	66 90                	xchg   %ax,%ax
c0206eed:	66 90                	xchg   %ax,%ax
c0206eef:	66 90                	xchg   %ax,%ax
c0206ef1:	66 90                	xchg   %ax,%ax
c0206ef3:	66 90                	xchg   %ax,%ax
c0206ef5:	66 90                	xchg   %ax,%ax
c0206ef7:	66 90                	xchg   %ax,%ax
c0206ef9:	66 90                	xchg   %ax,%ax
c0206efb:	66 90                	xchg   %ax,%ax
c0206efd:	66 90                	xchg   %ax,%ax
c0206eff:	66 90                	xchg   %ax,%ax
c0206f01:	66 90                	xchg   %ax,%ax
c0206f03:	66 90                	xchg   %ax,%ax
c0206f05:	66 90                	xchg   %ax,%ax
c0206f07:	66 90                	xchg   %ax,%ax
c0206f09:	66 90                	xchg   %ax,%ax
c0206f0b:	66 90                	xchg   %ax,%ax
c0206f0d:	66 90                	xchg   %ax,%ax
c0206f0f:	66 90                	xchg   %ax,%ax
c0206f11:	66 90                	xchg   %ax,%ax
c0206f13:	66 90                	xchg   %ax,%ax
c0206f15:	66 90                	xchg   %ax,%ax
c0206f17:	66 90                	xchg   %ax,%ax
c0206f19:	66 90                	xchg   %ax,%ax
c0206f1b:	66 90                	xchg   %ax,%ax
c0206f1d:	66 90                	xchg   %ax,%ax
c0206f1f:	66 90                	xchg   %ax,%ax
c0206f21:	66 90                	xchg   %ax,%ax
c0206f23:	66 90                	xchg   %ax,%ax
c0206f25:	66 90                	xchg   %ax,%ax
c0206f27:	66 90                	xchg   %ax,%ax
c0206f29:	66 90                	xchg   %ax,%ax
c0206f2b:	66 90                	xchg   %ax,%ax
c0206f2d:	66 90                	xchg   %ax,%ax
c0206f2f:	66 90                	xchg   %ax,%ax
c0206f31:	66 90                	xchg   %ax,%ax
c0206f33:	66 90                	xchg   %ax,%ax
c0206f35:	66 90                	xchg   %ax,%ax
c0206f37:	66 90                	xchg   %ax,%ax
c0206f39:	66 90                	xchg   %ax,%ax
c0206f3b:	66 90                	xchg   %ax,%ax
c0206f3d:	66 90                	xchg   %ax,%ax
c0206f3f:	66 90                	xchg   %ax,%ax
c0206f41:	66 90                	xchg   %ax,%ax
c0206f43:	66 90                	xchg   %ax,%ax
c0206f45:	66 90                	xchg   %ax,%ax
c0206f47:	66 90                	xchg   %ax,%ax
c0206f49:	66 90                	xchg   %ax,%ax
c0206f4b:	66 90                	xchg   %ax,%ax
c0206f4d:	66 90                	xchg   %ax,%ax
c0206f4f:	66 90                	xchg   %ax,%ax
c0206f51:	66 90                	xchg   %ax,%ax
c0206f53:	66 90                	xchg   %ax,%ax
c0206f55:	66 90                	xchg   %ax,%ax
c0206f57:	66 90                	xchg   %ax,%ax
c0206f59:	66 90                	xchg   %ax,%ax
c0206f5b:	66 90                	xchg   %ax,%ax
c0206f5d:	66 90                	xchg   %ax,%ax
c0206f5f:	66 90                	xchg   %ax,%ax
c0206f61:	66 90                	xchg   %ax,%ax
c0206f63:	66 90                	xchg   %ax,%ax
c0206f65:	66 90                	xchg   %ax,%ax
c0206f67:	66 90                	xchg   %ax,%ax
c0206f69:	66 90                	xchg   %ax,%ax
c0206f6b:	66 90                	xchg   %ax,%ax
c0206f6d:	66 90                	xchg   %ax,%ax
c0206f6f:	66 90                	xchg   %ax,%ax
c0206f71:	66 90                	xchg   %ax,%ax
c0206f73:	66 90                	xchg   %ax,%ax
c0206f75:	66 90                	xchg   %ax,%ax
c0206f77:	66 90                	xchg   %ax,%ax
c0206f79:	66 90                	xchg   %ax,%ax
c0206f7b:	66 90                	xchg   %ax,%ax
c0206f7d:	66 90                	xchg   %ax,%ax
c0206f7f:	66 90                	xchg   %ax,%ax
c0206f81:	66 90                	xchg   %ax,%ax
c0206f83:	66 90                	xchg   %ax,%ax
c0206f85:	66 90                	xchg   %ax,%ax
c0206f87:	66 90                	xchg   %ax,%ax
c0206f89:	66 90                	xchg   %ax,%ax
c0206f8b:	66 90                	xchg   %ax,%ax
c0206f8d:	66 90                	xchg   %ax,%ax
c0206f8f:	66 90                	xchg   %ax,%ax
c0206f91:	66 90                	xchg   %ax,%ax
c0206f93:	66 90                	xchg   %ax,%ax
c0206f95:	66 90                	xchg   %ax,%ax
c0206f97:	66 90                	xchg   %ax,%ax
c0206f99:	66 90                	xchg   %ax,%ax
c0206f9b:	66 90                	xchg   %ax,%ax
c0206f9d:	66 90                	xchg   %ax,%ax
c0206f9f:	66 90                	xchg   %ax,%ax
c0206fa1:	66 90                	xchg   %ax,%ax
c0206fa3:	66 90                	xchg   %ax,%ax
c0206fa5:	66 90                	xchg   %ax,%ax
c0206fa7:	66 90                	xchg   %ax,%ax
c0206fa9:	66 90                	xchg   %ax,%ax
c0206fab:	66 90                	xchg   %ax,%ax
c0206fad:	66 90                	xchg   %ax,%ax
c0206faf:	66 90                	xchg   %ax,%ax
c0206fb1:	66 90                	xchg   %ax,%ax
c0206fb3:	66 90                	xchg   %ax,%ax
c0206fb5:	66 90                	xchg   %ax,%ax
c0206fb7:	66 90                	xchg   %ax,%ax
c0206fb9:	66 90                	xchg   %ax,%ax
c0206fbb:	66 90                	xchg   %ax,%ax
c0206fbd:	66 90                	xchg   %ax,%ax
c0206fbf:	66 90                	xchg   %ax,%ax
c0206fc1:	66 90                	xchg   %ax,%ax
c0206fc3:	66 90                	xchg   %ax,%ax
c0206fc5:	66 90                	xchg   %ax,%ax
c0206fc7:	66 90                	xchg   %ax,%ax
c0206fc9:	66 90                	xchg   %ax,%ax
c0206fcb:	66 90                	xchg   %ax,%ax
c0206fcd:	66 90                	xchg   %ax,%ax
c0206fcf:	66 90                	xchg   %ax,%ax
c0206fd1:	66 90                	xchg   %ax,%ax
c0206fd3:	66 90                	xchg   %ax,%ax
c0206fd5:	66 90                	xchg   %ax,%ax
c0206fd7:	66 90                	xchg   %ax,%ax
c0206fd9:	66 90                	xchg   %ax,%ax
c0206fdb:	66 90                	xchg   %ax,%ax
c0206fdd:	66 90                	xchg   %ax,%ax
c0206fdf:	66 90                	xchg   %ax,%ax
c0206fe1:	66 90                	xchg   %ax,%ax
c0206fe3:	66 90                	xchg   %ax,%ax
c0206fe5:	66 90                	xchg   %ax,%ax
c0206fe7:	66 90                	xchg   %ax,%ax
c0206fe9:	66 90                	xchg   %ax,%ax
c0206feb:	66 90                	xchg   %ax,%ax
c0206fed:	66 90                	xchg   %ax,%ax
c0206fef:	66 90                	xchg   %ax,%ax
c0206ff1:	66 90                	xchg   %ax,%ax
c0206ff3:	66 90                	xchg   %ax,%ax
c0206ff5:	66 90                	xchg   %ax,%ax
c0206ff7:	66 90                	xchg   %ax,%ax
c0206ff9:	66 90                	xchg   %ax,%ax
c0206ffb:	66 90                	xchg   %ax,%ax
c0206ffd:	66 90                	xchg   %ax,%ax
c0206fff:	90                   	nop

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0207000 <__x86.get_pc_thunk.ax>:
c0207000:	8b 04 24             	mov    (%esp),%eax
c0207003:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c0207004 <__x86.get_pc_thunk.bx>:
c0207004:	8b 1c 24             	mov    (%esp),%ebx
c0207007:	c3                   	ret    
