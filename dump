
kernel.elf：     文件格式 elf32-i386


Disassembly of section .text:

c0203000 <GDT_BASE>:
	...

c0203008 <CODE_DESC>:
section .text    
[EXTERN kern_entry]
   GDT_BASE:   dd    0x00000000 
           	   dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
c0203008:	ff ff 00 00 00 98 cf 00                             ........

c0203010 <DATA_STACK_DESC>:
               dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
c0203010:	ff ff 00 00 00 92 cf 00                             ........

c0203018 <VIDEO_DESC>:
                     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007        ; limit=(0xbffff-0xb8000)/4k=0x7
c0203018:	07 00 00 80 0b 92 c0 00                             ........

c0203020 <USER_CODE_DESC>:
               dd    DESC_VIDEO_HIGH4  ; 此时dpl为0

    ;---------新增段描述符-----------
    ;用户代码段与数据段
    USER_CODE_DESC: dd 0x0000FFFF
c0203020:	ff ff 00 00 00 f8 cf 00                             ........

c0203028 <USER_DATA_DESC>:
                dd   DESC_USER_CODE_HIGH4

    USER_DATA_DESC: dd 0x0000FFFF
c0203028:	ff ff 00 00 00 f2 cf 00                             ........

c0203030 <total_mem_bytes>:
   SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0     ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
   SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0     ; 同上
   SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0    ; 同上 
   ;SELECTOR_USER_CODE equ (0x004<<3) + TI_GDT + RPL3
   ;SELECTOR_USER_DATA equ (0x005<<3) + TI_GDT + RPL3
   total_mem_bytes dd 0                  
c0203030:	00 00 00 00                                         ....

c0203034 <gdt_ptr>:
   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址
   gdt_ptr  dw  GDT_LIMIT 
c0203034:	2f 00 00 30 20 c0                                   /..0 .

c020303a <boot_start_after_set_paging>:
        	dd  GDT_BASE
;boot开始！
boot_start_after_set_paging:        ;此处修改了函数名     在设置好页表后调用此函数
    mov ebx,[temp_mboot_ptr]     ;此处将暂存的mboot信息取出    但是一定要注意：必须要前4MB的物理-虚拟内存映射才能够使用
c020303a:	8b 1d 0c 00 10 00    	mov    0x10000c,%ebx
    mov [mboot_ptr], ebx ; GRUB加载内核后会将mutiboot信息地址存放在ebx中
c0203040:	89 1d 0c 70 20 c0    	mov    %ebx,0xc020700c
    ;-----------------   准备进入保护模式   -------------------
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1
   ;-----------------  打开A20  ----------------
    in al,0x92
c0203046:	e4 92                	in     $0x92,%al
    or al,0000_0010B
c0203048:	0c 02                	or     $0x2,%al
    out 0x92,al
c020304a:	e6 92                	out    %al,$0x92
   ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]
c020304c:	0f 01 15 34 30 20 c0 	lgdtl  0xc0203034
   ;-----------------  cr0第0位置1  ----------------
    mov eax, cr0
c0203053:	0f 20 c0             	mov    %cr0,%eax
    or eax, 0x00000001
c0203056:	83 c8 01             	or     $0x1,%eax
    mov cr0, eax
c0203059:	0f 22 c0             	mov    %eax,%cr0
    jmp dword SELECTOR_CODE:far_jmp_target      ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
c020305c:	ea 63 30 20 c0 08 00 	ljmp   $0x8,$0xc0203063

c0203063 <far_jmp_target>:

;初始化段寄存器以及栈结构
    far_jmp_target:
    mov ax,SELECTOR_DATA
c0203063:	66 b8 10 00          	mov    $0x10,%ax
    mov ss,ax
c0203067:	8e d0                	mov    %eax,%ss
    mov ds,ax
c0203069:	8e d8                	mov    %eax,%ds
  	mov ax,SELECTOR_VIDEO
c020306b:	66 b8 18 00          	mov    $0x18,%ax
  	mov gs,ax
c020306f:	8e e8                	mov    %eax,%gs
    mov esp, STACK_TOP      
c0203071:	bc 03 10 29 c0       	mov    $0xc0291003,%esp
    and esp, 0xFFFFFFF0  ;16字节对齐
c0203076:	83 e4 f0             	and    $0xfffffff0,%esp
    mov ebp, 0         
c0203079:	bd 00 00 00 00       	mov    $0x0,%ebp
    mov eax,kern_bitmap_block
c020307e:	b8 00 90 20 c0       	mov    $0xc0209000,%eax
    mov [kern_bitmap],eax
c0203083:	a3 08 70 20 c0       	mov    %eax,0xc0207008
;进入内核主函数    
    call kern_entry                    
c0203088:	e8 12 12 00 00       	call   c020429f <kern_entry>
    jmp dword $          ;防止意外退出内核
c020308d:	e9 fb ff ff ff       	jmp    c020308d <far_jmp_target+0x2a>
c0203092:	66 90                	xchg   %ax,%ax
c0203094:	66 90                	xchg   %ax,%ax
c0203096:	66 90                	xchg   %ax,%ax
c0203098:	66 90                	xchg   %ax,%ax
c020309a:	66 90                	xchg   %ax,%ax
c020309c:	66 90                	xchg   %ax,%ax
c020309e:	66 90                	xchg   %ax,%ax

c02030a0 <pre_handle>:
%endmacro


[EXTERN int_func_route]
pre_handle:
	pushad               ;压入八个32位
c02030a0:	60                   	pusha  
	mov ecx,[ss:esp+32]
c02030a1:	36 8b 4c 24 20       	mov    %ss:0x20(%esp),%ecx
	mov ebx,eax
c02030a6:	89 c3                	mov    %eax,%ebx
	mov ax,es          ;进入时ss已经被切换了
c02030a8:	66 8c c0             	mov    %es,%ax
	and eax,0x0000FFFF
c02030ab:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030b0:	50                   	push   %eax
	mov ax,fs          
c02030b1:	66 8c e0             	mov    %fs,%ax
	and eax,0x0000FFFF
c02030b4:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030b9:	50                   	push   %eax
	mov ax,gs
c02030ba:	66 8c e8             	mov    %gs,%ax
	and eax,0x0000FFFF
c02030bd:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030c2:	50                   	push   %eax
	mov ax,KERN_DATA_SELECTOR    ;不包含ss
c02030c3:	66 b8 10 00          	mov    $0x10,%ax
	mov es,ax
c02030c7:	8e c0                	mov    %eax,%es
	mov fs,ax
c02030c9:	8e e0                	mov    %eax,%fs
	mov ax,KERN_VGA_SELECTOR
c02030cb:	66 b8 18 00          	mov    $0x18,%ax
	mov gs,ax
c02030cf:	8e e8                	mov    %eax,%gs
	push ebx     ;传入void *
c02030d1:	53                   	push   %ebx
	push ecx     ;传入int类型中断号
c02030d2:	51                   	push   %ecx
	call int_func_route
c02030d3:	e8 25 31 00 00       	call   c02061fd <int_func_route>
	add esp,8
c02030d8:	83 c4 08             	add    $0x8,%esp
	pop eax
c02030db:	58                   	pop    %eax
	mov gs,ax
c02030dc:	8e e8                	mov    %eax,%gs
	pop eax
c02030de:	58                   	pop    %eax
	mov fs,ax
c02030df:	8e e0                	mov    %eax,%fs
	pop eax
c02030e1:	58                   	pop    %eax
	mov es,ax
c02030e2:	8e c0                	mov    %eax,%es
	popad
c02030e4:	61                   	popa   
	add esp,8
c02030e5:	83 c4 08             	add    $0x8,%esp
	mov al,0x20
c02030e8:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02030ea:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02030ec:	e6 20                	out    %al,$0x20
	iret
c02030ee:	cf                   	iret   

c02030ef <isr0>:


NO_ERROCODE 0
c02030ef:	89 e0                	mov    %esp,%eax
c02030f1:	6a 00                	push   $0x0
c02030f3:	6a 00                	push   $0x0
c02030f5:	eb a9                	jmp    c02030a0 <pre_handle>

c02030f7 <isr1>:
NO_ERROCODE 1
c02030f7:	89 e0                	mov    %esp,%eax
c02030f9:	6a 00                	push   $0x0
c02030fb:	6a 01                	push   $0x1
c02030fd:	eb a1                	jmp    c02030a0 <pre_handle>

c02030ff <isr2>:
NO_ERROCODE 2
c02030ff:	89 e0                	mov    %esp,%eax
c0203101:	6a 00                	push   $0x0
c0203103:	6a 02                	push   $0x2
c0203105:	eb 99                	jmp    c02030a0 <pre_handle>

c0203107 <isr3>:
NO_ERROCODE 3
c0203107:	89 e0                	mov    %esp,%eax
c0203109:	6a 00                	push   $0x0
c020310b:	6a 03                	push   $0x3
c020310d:	eb 91                	jmp    c02030a0 <pre_handle>

c020310f <isr4>:
NO_ERROCODE 4
c020310f:	89 e0                	mov    %esp,%eax
c0203111:	6a 00                	push   $0x0
c0203113:	6a 04                	push   $0x4
c0203115:	eb 89                	jmp    c02030a0 <pre_handle>

c0203117 <isr5>:
NO_ERROCODE 5
c0203117:	89 e0                	mov    %esp,%eax
c0203119:	6a 00                	push   $0x0
c020311b:	6a 05                	push   $0x5
c020311d:	eb 81                	jmp    c02030a0 <pre_handle>

c020311f <isr6>:
NO_ERROCODE 6
c020311f:	89 e0                	mov    %esp,%eax
c0203121:	6a 00                	push   $0x0
c0203123:	6a 06                	push   $0x6
c0203125:	e9 76 ff ff ff       	jmp    c02030a0 <pre_handle>

c020312a <isr7>:
NO_ERROCODE 7
c020312a:	89 e0                	mov    %esp,%eax
c020312c:	6a 00                	push   $0x0
c020312e:	6a 07                	push   $0x7
c0203130:	e9 6b ff ff ff       	jmp    c02030a0 <pre_handle>

c0203135 <isr8>:
HAVE_ERROCODE 8
c0203135:	89 e0                	mov    %esp,%eax
c0203137:	90                   	nop
c0203138:	6a 08                	push   $0x8
c020313a:	e9 61 ff ff ff       	jmp    c02030a0 <pre_handle>

c020313f <isr9>:
NO_ERROCODE 9
c020313f:	89 e0                	mov    %esp,%eax
c0203141:	6a 00                	push   $0x0
c0203143:	6a 09                	push   $0x9
c0203145:	e9 56 ff ff ff       	jmp    c02030a0 <pre_handle>

c020314a <isr10>:
HAVE_ERROCODE 10
c020314a:	89 e0                	mov    %esp,%eax
c020314c:	90                   	nop
c020314d:	6a 0a                	push   $0xa
c020314f:	e9 4c ff ff ff       	jmp    c02030a0 <pre_handle>

c0203154 <isr11>:
HAVE_ERROCODE 11
c0203154:	89 e0                	mov    %esp,%eax
c0203156:	90                   	nop
c0203157:	6a 0b                	push   $0xb
c0203159:	e9 42 ff ff ff       	jmp    c02030a0 <pre_handle>

c020315e <isr12>:
HAVE_ERROCODE 12 
c020315e:	89 e0                	mov    %esp,%eax
c0203160:	90                   	nop
c0203161:	6a 0c                	push   $0xc
c0203163:	e9 38 ff ff ff       	jmp    c02030a0 <pre_handle>

c0203168 <isr13>:
HAVE_ERROCODE 13 
c0203168:	89 e0                	mov    %esp,%eax
c020316a:	90                   	nop
c020316b:	6a 0d                	push   $0xd
c020316d:	e9 2e ff ff ff       	jmp    c02030a0 <pre_handle>

c0203172 <isr14>:
HAVE_ERROCODE 14
c0203172:	89 e0                	mov    %esp,%eax
c0203174:	90                   	nop
c0203175:	6a 0e                	push   $0xe
c0203177:	e9 24 ff ff ff       	jmp    c02030a0 <pre_handle>

c020317c <isr15>:
NO_ERROCODE 15
c020317c:	89 e0                	mov    %esp,%eax
c020317e:	6a 00                	push   $0x0
c0203180:	6a 0f                	push   $0xf
c0203182:	e9 19 ff ff ff       	jmp    c02030a0 <pre_handle>

c0203187 <isr16>:
NO_ERROCODE 16
c0203187:	89 e0                	mov    %esp,%eax
c0203189:	6a 00                	push   $0x0
c020318b:	6a 10                	push   $0x10
c020318d:	e9 0e ff ff ff       	jmp    c02030a0 <pre_handle>

c0203192 <isr17>:
HAVE_ERROCODE 17
c0203192:	89 e0                	mov    %esp,%eax
c0203194:	90                   	nop
c0203195:	6a 11                	push   $0x11
c0203197:	e9 04 ff ff ff       	jmp    c02030a0 <pre_handle>

c020319c <isr18>:
NO_ERROCODE 18
c020319c:	89 e0                	mov    %esp,%eax
c020319e:	6a 00                	push   $0x0
c02031a0:	6a 12                	push   $0x12
c02031a2:	e9 f9 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031a7 <isr19>:
NO_ERROCODE 19
c02031a7:	89 e0                	mov    %esp,%eax
c02031a9:	6a 00                	push   $0x0
c02031ab:	6a 13                	push   $0x13
c02031ad:	e9 ee fe ff ff       	jmp    c02030a0 <pre_handle>

c02031b2 <isr20>:

NO_ERROCODE 20
c02031b2:	89 e0                	mov    %esp,%eax
c02031b4:	6a 00                	push   $0x0
c02031b6:	6a 14                	push   $0x14
c02031b8:	e9 e3 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031bd <isr21>:
NO_ERROCODE 21
c02031bd:	89 e0                	mov    %esp,%eax
c02031bf:	6a 00                	push   $0x0
c02031c1:	6a 15                	push   $0x15
c02031c3:	e9 d8 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031c8 <isr22>:
NO_ERROCODE 22
c02031c8:	89 e0                	mov    %esp,%eax
c02031ca:	6a 00                	push   $0x0
c02031cc:	6a 16                	push   $0x16
c02031ce:	e9 cd fe ff ff       	jmp    c02030a0 <pre_handle>

c02031d3 <isr23>:
NO_ERROCODE 23
c02031d3:	89 e0                	mov    %esp,%eax
c02031d5:	6a 00                	push   $0x0
c02031d7:	6a 17                	push   $0x17
c02031d9:	e9 c2 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031de <isr24>:
NO_ERROCODE 24
c02031de:	89 e0                	mov    %esp,%eax
c02031e0:	6a 00                	push   $0x0
c02031e2:	6a 18                	push   $0x18
c02031e4:	e9 b7 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031e9 <isr25>:
NO_ERROCODE 25
c02031e9:	89 e0                	mov    %esp,%eax
c02031eb:	6a 00                	push   $0x0
c02031ed:	6a 19                	push   $0x19
c02031ef:	e9 ac fe ff ff       	jmp    c02030a0 <pre_handle>

c02031f4 <isr26>:
NO_ERROCODE 26
c02031f4:	89 e0                	mov    %esp,%eax
c02031f6:	6a 00                	push   $0x0
c02031f8:	6a 1a                	push   $0x1a
c02031fa:	e9 a1 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031ff <isr27>:
NO_ERROCODE 27
c02031ff:	89 e0                	mov    %esp,%eax
c0203201:	6a 00                	push   $0x0
c0203203:	6a 1b                	push   $0x1b
c0203205:	e9 96 fe ff ff       	jmp    c02030a0 <pre_handle>

c020320a <isr28>:
NO_ERROCODE 28
c020320a:	89 e0                	mov    %esp,%eax
c020320c:	6a 00                	push   $0x0
c020320e:	6a 1c                	push   $0x1c
c0203210:	e9 8b fe ff ff       	jmp    c02030a0 <pre_handle>

c0203215 <isr29>:
NO_ERROCODE 29
c0203215:	89 e0                	mov    %esp,%eax
c0203217:	6a 00                	push   $0x0
c0203219:	6a 1d                	push   $0x1d
c020321b:	e9 80 fe ff ff       	jmp    c02030a0 <pre_handle>

c0203220 <isr30>:
NO_ERROCODE 30
c0203220:	89 e0                	mov    %esp,%eax
c0203222:	6a 00                	push   $0x0
c0203224:	6a 1e                	push   $0x1e
c0203226:	e9 75 fe ff ff       	jmp    c02030a0 <pre_handle>

c020322b <isr31>:
NO_ERROCODE 31
c020322b:	89 e0                	mov    %esp,%eax
c020322d:	6a 00                	push   $0x0
c020322f:	6a 1f                	push   $0x1f
c0203231:	e9 6a fe ff ff       	jmp    c02030a0 <pre_handle>

c0203236 <isr32>:
NO_ERROCODE 32
c0203236:	89 e0                	mov    %esp,%eax
c0203238:	6a 00                	push   $0x0
c020323a:	6a 20                	push   $0x20
c020323c:	e9 5f fe ff ff       	jmp    c02030a0 <pre_handle>

c0203241 <load_idt>:


[GLOBAL load_idt]
load_idt:
	mov eax, [esp+4]  ; 参数存入 eax 寄存器
c0203241:	8b 44 24 04          	mov    0x4(%esp),%eax
    lidt [eax]        ; 加载到 IDTR
c0203245:	0f 01 18             	lidtl  (%eax)
    ret
c0203248:	c3                   	ret    

c0203249 <get_cr2>:

[GLOBAL get_cr2]
[GLOBAL _CR2]
get_cr2:
	mov eax,cr2
c0203249:	0f 20 d0             	mov    %cr2,%eax
	mov [_CR2],eax
c020324c:	a3 52 32 20 c0       	mov    %eax,0xc0203252
	ret
c0203251:	c3                   	ret    

c0203252 <_CR2>:
_CR2:
c0203252:	00 00                	add    %al,(%eax)
c0203254:	00 00                	add    %al,(%eax)
c0203256:	66 90                	xchg   %ax,%ax
c0203258:	66 90                	xchg   %ax,%ax
c020325a:	66 90                	xchg   %ax,%ax
c020325c:	66 90                	xchg   %ax,%ax
c020325e:	66 90                	xchg   %ax,%ax

c0203260 <get_esp>:
;内核线程模块的汇编函数文件
[bits 32]
[GLOBAL get_esp]
get_esp:
	mov eax,esp
c0203260:	89 e0                	mov    %esp,%eax
	ret
c0203262:	c3                   	ret    

c0203263 <get_eflags>:
[GLOBAL get_eflags]
get_eflags:
	pushf
c0203263:	9c                   	pushf  
	pop eax
c0203264:	58                   	pop    %eax
	ret
c0203265:	c3                   	ret    

c0203266 <switch_to>:
[GLOBAL switch_to]
switch_to:
	;保存上下文
	mov [eax+28],esp
c0203266:	89 60 1c             	mov    %esp,0x1c(%eax)
	mov eax,[esp+4]     ;第一个参数 
c0203269:	8b 44 24 04          	mov    0x4(%esp),%eax
	mov [eax],ebp
c020326d:	89 28                	mov    %ebp,(%eax)
	mov [eax+4],ebx
c020326f:	89 58 04             	mov    %ebx,0x4(%eax)
	mov [eax+8],ecx
c0203272:	89 48 08             	mov    %ecx,0x8(%eax)
	mov [eax+12],edx
c0203275:	89 50 0c             	mov    %edx,0xc(%eax)
	mov [eax+16],esi
c0203278:	89 70 10             	mov    %esi,0x10(%eax)
	mov [eax+20],edi
c020327b:	89 78 14             	mov    %edi,0x14(%eax)
	push ebx
c020327e:	53                   	push   %ebx
	mov ebx,eax
c020327f:	89 c3                	mov    %eax,%ebx
	pushf
c0203281:	9c                   	pushf  
	pop eax
c0203282:	58                   	pop    %eax
	mov [ebx+24],eax
c0203283:	89 43 18             	mov    %eax,0x18(%ebx)
	mov eax,ebx
c0203286:	89 d8                	mov    %ebx,%eax
	pop ebx
c0203288:	5b                   	pop    %ebx

	;加载上下文
	mov eax,[esp+8]      ;第二个参数
c0203289:	8b 44 24 08          	mov    0x8(%esp),%eax
	mov esp,[eax+28]
c020328d:	8b 60 1c             	mov    0x1c(%eax),%esp
	mov ebp,[eax]
c0203290:	8b 28                	mov    (%eax),%ebp
	mov ebx,[eax+4]
c0203292:	8b 58 04             	mov    0x4(%eax),%ebx
	mov ecx,[eax+8]
c0203295:	8b 48 08             	mov    0x8(%eax),%ecx
	mov edx,[eax+12]
c0203298:	8b 50 0c             	mov    0xc(%eax),%edx
	mov esi,[eax+16]
c020329b:	8b 70 10             	mov    0x10(%eax),%esi
	mov edi,[eax+20]
c020329e:	8b 78 14             	mov    0x14(%eax),%edi
	add eax,24
c02032a1:	83 c0 18             	add    $0x18,%eax
	push dword [eax] ;eflags
c02032a4:	ff 30                	pushl  (%eax)
	popf	
c02032a6:	9d                   	popf   

	;由于8259a设置的手动模式 所以必须给主片与从片发送信号 否则8259a会暂停
	;这个bug找了一下午才找到 顺便吐槽下 内核级的代码debug太难了(GDB在多线程与汇编级会失效 只有print调试法) 
	mov al,0x20         
c02032a7:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02032a9:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02032ab:	e6 20                	out    %al,$0x20
	
	ret                  ;执行下一个函数
c02032ad:	c3                   	ret    

c02032ae <move_cursor>:
static uint8_t *video_memory = (uint8_t *)0xC00B8000;
//光标位置
static uint8_t cursor_x = 0;
static uint8_t cursor_y = 0;
static void move_cursor()
{
c02032ae:	55                   	push   %ebp
c02032af:	89 e5                	mov    %esp,%ebp
c02032b1:	53                   	push   %ebx
c02032b2:	83 ec 14             	sub    $0x14,%esp
c02032b5:	e8 4a 3d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02032ba:	81 c3 46 4d 00 00    	add    $0x4d46,%ebx
// 屏幕是 80 字节宽
    uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c02032c0:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c02032c7:	0f b6 d0             	movzbl %al,%edx
c02032ca:	89 d0                	mov    %edx,%eax
c02032cc:	c1 e0 02             	shl    $0x2,%eax
c02032cf:	01 d0                	add    %edx,%eax
c02032d1:	c1 e0 04             	shl    $0x4,%eax
c02032d4:	89 c2                	mov    %eax,%edx
c02032d6:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c02032dd:	0f b6 c0             	movzbl %al,%eax
c02032e0:	01 d0                	add    %edx,%eax
c02032e2:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    // 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置
    // 的高8位与低8位。
    outb(0x3D4, 14);                    // 告诉 VGA 我们要设置光标的高字节
c02032e6:	83 ec 08             	sub    $0x8,%esp
c02032e9:	6a 0e                	push   $0xe
c02032eb:	68 d4 03 00 00       	push   $0x3d4
c02032f0:	e8 46 04 00 00       	call   c020373b <outb>
c02032f5:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation >> 8);   // 发送高 8 位
c02032f8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c02032fc:	66 c1 e8 08          	shr    $0x8,%ax
c0203300:	0f b6 c0             	movzbl %al,%eax
c0203303:	83 ec 08             	sub    $0x8,%esp
c0203306:	50                   	push   %eax
c0203307:	68 d5 03 00 00       	push   $0x3d5
c020330c:	e8 2a 04 00 00       	call   c020373b <outb>
c0203311:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4, 15);                    // 告诉 VGA 我们要设置光标的低字节
c0203314:	83 ec 08             	sub    $0x8,%esp
c0203317:	6a 0f                	push   $0xf
c0203319:	68 d4 03 00 00       	push   $0x3d4
c020331e:	e8 18 04 00 00       	call   c020373b <outb>
c0203323:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation);        // 发送低 8 位
c0203326:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c020332a:	0f b6 c0             	movzbl %al,%eax
c020332d:	83 ec 08             	sub    $0x8,%esp
c0203330:	50                   	push   %eax
c0203331:	68 d5 03 00 00       	push   $0x3d5
c0203336:	e8 00 04 00 00       	call   c020373b <outb>
c020333b:	83 c4 10             	add    $0x10,%esp
}
c020333e:	90                   	nop
c020333f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203342:	c9                   	leave  
c0203343:	c3                   	ret    

c0203344 <move_cursor_by_XY>:

void move_cursor_by_XY(uint8_t x,uint8_t y){
c0203344:	55                   	push   %ebp
c0203345:	89 e5                	mov    %esp,%ebp
c0203347:	83 ec 18             	sub    $0x18,%esp
c020334a:	e8 b1 3c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020334f:	05 b1 4c 00 00       	add    $0x4cb1,%eax
c0203354:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0203357:	8b 55 0c             	mov    0xc(%ebp),%edx
c020335a:	88 4d f4             	mov    %cl,-0xc(%ebp)
c020335d:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if(x>79||y>24)
c0203360:	80 7d f4 4f          	cmpb   $0x4f,-0xc(%ebp)
c0203364:	77 21                	ja     c0203387 <move_cursor_by_XY+0x43>
c0203366:	80 7d f0 18          	cmpb   $0x18,-0x10(%ebp)
c020336a:	77 1b                	ja     c0203387 <move_cursor_by_XY+0x43>
		return ;
	cursor_x=x;
c020336c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0203370:	88 90 04 90 08 00    	mov    %dl,0x89004(%eax)
	cursor_y=y;
c0203376:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c020337a:	88 90 05 90 08 00    	mov    %dl,0x89005(%eax)
	move_cursor();
c0203380:	e8 29 ff ff ff       	call   c02032ae <move_cursor>
c0203385:	eb 01                	jmp    c0203388 <move_cursor_by_XY+0x44>
		return ;
c0203387:	90                   	nop
}
c0203388:	c9                   	leave  
c0203389:	c3                   	ret    

c020338a <clear_screen>:

void clear_screen(){
c020338a:	55                   	push   %ebp
c020338b:	89 e5                	mov    %esp,%ebp
c020338d:	53                   	push   %ebx
c020338e:	83 ec 14             	sub    $0x14,%esp
c0203391:	e8 6e 3c 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203396:	81 c3 6a 4c 00 00    	add    $0x4c6a,%ebx
	cursor_x=0;
c020339c:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
	cursor_y=0;
c02033a3:	c6 83 05 90 08 00 00 	movb   $0x0,0x89005(%ebx)
	for(int j=0;j<25;j++){
c02033aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02033b1:	eb 28                	jmp    c02033db <clear_screen+0x51>
		for(int i=0;i<80;i++)
c02033b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c02033ba:	eb 15                	jmp    c02033d1 <clear_screen+0x47>
			vga_putc('\0',black,white);
c02033bc:	83 ec 04             	sub    $0x4,%esp
c02033bf:	6a 0f                	push   $0xf
c02033c1:	6a 00                	push   $0x0
c02033c3:	6a 00                	push   $0x0
c02033c5:	e8 2b 01 00 00       	call   c02034f5 <vga_putc>
c02033ca:	83 c4 10             	add    $0x10,%esp
		for(int i=0;i<80;i++)
c02033cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02033d1:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c02033d5:	7e e5                	jle    c02033bc <clear_screen+0x32>
	for(int j=0;j<25;j++){
c02033d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02033db:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c02033df:	7e d2                	jle    c02033b3 <clear_screen+0x29>
	}
	cursor_x=0;
c02033e1:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
	cursor_y=0;
c02033e8:	c6 83 05 90 08 00 00 	movb   $0x0,0x89005(%ebx)
	move_cursor();
c02033ef:	e8 ba fe ff ff       	call   c02032ae <move_cursor>
}
c02033f4:	90                   	nop
c02033f5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02033f8:	c9                   	leave  
c02033f9:	c3                   	ret    

c02033fa <screen_uproll_once>:

void screen_uproll_once(){     //光标是会变化的
c02033fa:	55                   	push   %ebp
c02033fb:	89 e5                	mov    %esp,%ebp
c02033fd:	53                   	push   %ebx
c02033fe:	83 ec 24             	sub    $0x24,%esp
c0203401:	e8 fa 3b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203406:	05 fa 4b 00 00       	add    $0x4bfa,%eax
	for(int j=1;j<25;j++){
c020340b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0203412:	eb 70                	jmp    c0203484 <screen_uproll_once+0x8a>
		for(int i=0;i<80;i++){
c0203414:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020341b:	eb 5d                	jmp    c020347a <screen_uproll_once+0x80>
			uint16_t cursorLocation = j * 80 + i;
c020341d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203420:	89 d1                	mov    %edx,%ecx
c0203422:	89 ca                	mov    %ecx,%edx
c0203424:	c1 e2 02             	shl    $0x2,%edx
c0203427:	01 ca                	add    %ecx,%edx
c0203429:	c1 e2 04             	shl    $0x4,%edx
c020342c:	89 d1                	mov    %edx,%ecx
c020342e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0203431:	01 ca                	add    %ecx,%edx
c0203433:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
			uint16_t targetCursorLocation = (j-1) * 80 + i;
c0203437:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020343a:	83 ea 01             	sub    $0x1,%edx
c020343d:	89 d1                	mov    %edx,%ecx
c020343f:	89 ca                	mov    %ecx,%edx
c0203441:	c1 e2 02             	shl    $0x2,%edx
c0203444:	01 ca                	add    %ecx,%edx
c0203446:	c1 e2 04             	shl    $0x4,%edx
c0203449:	89 d1                	mov    %edx,%ecx
c020344b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c020344e:	01 ca                	add    %ecx,%edx
c0203450:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
			*((uint16_t *)video_memory+targetCursorLocation)=*((uint16_t *)video_memory+cursorLocation);										
c0203454:	8b 90 18 f0 ff ff    	mov    -0xfe8(%eax),%edx
c020345a:	0f b7 4d e8          	movzwl -0x18(%ebp),%ecx
c020345e:	01 c9                	add    %ecx,%ecx
c0203460:	01 ca                	add    %ecx,%edx
c0203462:	8b 88 18 f0 ff ff    	mov    -0xfe8(%eax),%ecx
c0203468:	0f b7 5d e6          	movzwl -0x1a(%ebp),%ebx
c020346c:	01 db                	add    %ebx,%ebx
c020346e:	01 d9                	add    %ebx,%ecx
c0203470:	0f b7 12             	movzwl (%edx),%edx
c0203473:	66 89 11             	mov    %dx,(%ecx)
		for(int i=0;i<80;i++){
c0203476:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020347a:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c020347e:	7e 9d                	jle    c020341d <screen_uproll_once+0x23>
	for(int j=1;j<25;j++){
c0203480:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203484:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0203488:	7e 8a                	jle    c0203414 <screen_uproll_once+0x1a>
		}
	}
	for(int i=0;i<80;i++){
c020348a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0203491:	eb 35                	jmp    c02034c8 <screen_uproll_once+0xce>
		uint16_t lastRowCur=24*80+i;
c0203493:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0203496:	66 81 c2 80 07       	add    $0x780,%dx
c020349b:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
		*((char *)video_memory+2*lastRowCur)='\0';
c020349f:	8b 90 18 f0 ff ff    	mov    -0xfe8(%eax),%edx
c02034a5:	0f b7 4d ea          	movzwl -0x16(%ebp),%ecx
c02034a9:	01 c9                	add    %ecx,%ecx
c02034ab:	01 ca                	add    %ecx,%edx
c02034ad:	c6 02 00             	movb   $0x0,(%edx)
		*((char *)video_memory+2*lastRowCur+1)=0x0F;									
c02034b0:	8b 90 18 f0 ff ff    	mov    -0xfe8(%eax),%edx
c02034b6:	0f b7 4d ea          	movzwl -0x16(%ebp),%ecx
c02034ba:	01 c9                	add    %ecx,%ecx
c02034bc:	83 c1 01             	add    $0x1,%ecx
c02034bf:	01 ca                	add    %ecx,%edx
c02034c1:	c6 02 0f             	movb   $0xf,(%edx)
	for(int i=0;i<80;i++){
c02034c4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c02034c8:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
c02034cc:	7e c5                	jle    c0203493 <screen_uproll_once+0x99>

	}
	if(cursor_y!=0){
c02034ce:	0f b6 90 05 90 08 00 	movzbl 0x89005(%eax),%edx
c02034d5:	84 d2                	test   %dl,%dl
c02034d7:	74 15                	je     c02034ee <screen_uproll_once+0xf4>
		cursor_y--;
c02034d9:	0f b6 90 05 90 08 00 	movzbl 0x89005(%eax),%edx
c02034e0:	83 ea 01             	sub    $0x1,%edx
c02034e3:	88 90 05 90 08 00    	mov    %dl,0x89005(%eax)
		move_cursor();
c02034e9:	e8 c0 fd ff ff       	call   c02032ae <move_cursor>
	}
}
c02034ee:	90                   	nop
c02034ef:	83 c4 24             	add    $0x24,%esp
c02034f2:	5b                   	pop    %ebx
c02034f3:	5d                   	pop    %ebp
c02034f4:	c3                   	ret    

c02034f5 <vga_putc>:
void vga_putc(char input,vga_color_t back,vga_color_t fore){
c02034f5:	55                   	push   %ebp
c02034f6:	89 e5                	mov    %esp,%ebp
c02034f8:	53                   	push   %ebx
c02034f9:	83 ec 24             	sub    $0x24,%esp
c02034fc:	e8 03 3b 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203501:	81 c3 ff 4a 00 00    	add    $0x4aff,%ebx
c0203507:	8b 45 08             	mov    0x8(%ebp),%eax
c020350a:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c020350d:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c0203514:	0f b6 d0             	movzbl %al,%edx
c0203517:	89 d0                	mov    %edx,%eax
c0203519:	c1 e0 02             	shl    $0x2,%eax
c020351c:	01 d0                	add    %edx,%eax
c020351e:	c1 e0 04             	shl    $0x4,%eax
c0203521:	89 c2                	mov    %eax,%edx
c0203523:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c020352a:	0f b6 c0             	movzbl %al,%eax
c020352d:	01 d0                	add    %edx,%eax
c020352f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	*((char *)video_memory+2*cursorLocation)=input;
c0203533:	8b 83 18 f0 ff ff    	mov    -0xfe8(%ebx),%eax
c0203539:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c020353d:	01 d2                	add    %edx,%edx
c020353f:	01 c2                	add    %eax,%edx
c0203541:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0203545:	88 02                	mov    %al,(%edx)
	*((char *)video_memory+2*cursorLocation+1)=(back<<4)|(fore&0x0F);
c0203547:	8b 45 0c             	mov    0xc(%ebp),%eax
c020354a:	c1 e0 04             	shl    $0x4,%eax
c020354d:	89 c2                	mov    %eax,%edx
c020354f:	8b 45 10             	mov    0x10(%ebp),%eax
c0203552:	83 e0 0f             	and    $0xf,%eax
c0203555:	89 d1                	mov    %edx,%ecx
c0203557:	09 c1                	or     %eax,%ecx
c0203559:	8b 83 18 f0 ff ff    	mov    -0xfe8(%ebx),%eax
c020355f:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0203563:	01 d2                	add    %edx,%edx
c0203565:	83 c2 01             	add    $0x1,%edx
c0203568:	01 d0                	add    %edx,%eax
c020356a:	89 ca                	mov    %ecx,%edx
c020356c:	88 10                	mov    %dl,(%eax)
	if(cursor_x==79){
c020356e:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c0203575:	3c 4f                	cmp    $0x4f,%al
c0203577:	75 39                	jne    c02035b2 <vga_putc+0xbd>
		if(cursor_y==24){
c0203579:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c0203580:	3c 18                	cmp    $0x18,%al
c0203582:	75 15                	jne    c0203599 <vga_putc+0xa4>
			screen_uproll_once();
c0203584:	e8 71 fe ff ff       	call   c02033fa <screen_uproll_once>
			cursor_x=0;
c0203589:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
			cursor_y=24;
c0203590:	c6 83 05 90 08 00 18 	movb   $0x18,0x89005(%ebx)
c0203597:	eb 29                	jmp    c02035c2 <vga_putc+0xcd>
		}
		else{
			cursor_x=0;
c0203599:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
			cursor_y++;
c02035a0:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c02035a7:	83 c0 01             	add    $0x1,%eax
c02035aa:	88 83 05 90 08 00    	mov    %al,0x89005(%ebx)
c02035b0:	eb 10                	jmp    c02035c2 <vga_putc+0xcd>
		}
	}
	else{
		cursor_x++;
c02035b2:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c02035b9:	83 c0 01             	add    $0x1,%eax
c02035bc:	88 83 04 90 08 00    	mov    %al,0x89004(%ebx)
	}
	move_cursor();
c02035c2:	e8 e7 fc ff ff       	call   c02032ae <move_cursor>
}
c02035c7:	90                   	nop
c02035c8:	83 c4 24             	add    $0x24,%esp
c02035cb:	5b                   	pop    %ebx
c02035cc:	5d                   	pop    %ebp
c02035cd:	c3                   	ret    

c02035ce <kputc_color>:
void kputc_color(char input,vga_color_t back,vga_color_t fore){
c02035ce:	55                   	push   %ebp
c02035cf:	89 e5                	mov    %esp,%ebp
c02035d1:	53                   	push   %ebx
c02035d2:	83 ec 24             	sub    $0x24,%esp
c02035d5:	e8 2a 3a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02035da:	81 c3 26 4a 00 00    	add    $0x4a26,%ebx
c02035e0:	8b 45 08             	mov    0x8(%ebp),%eax
c02035e3:	88 45 e4             	mov    %al,-0x1c(%ebp)
	switch (input)
c02035e6:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c02035ea:	83 f8 09             	cmp    $0x9,%eax
c02035ed:	74 07                	je     c02035f6 <kputc_color+0x28>
c02035ef:	83 f8 0a             	cmp    $0xa,%eax
c02035f2:	74 33                	je     c0203627 <kputc_color+0x59>
c02035f4:	eb 79                	jmp    c020366f <kputc_color+0xa1>
	{
		case '\t':{
			for(int i=0;i<tab_length;i++)
c02035f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02035fd:	eb 17                	jmp    c0203616 <kputc_color+0x48>
				vga_putc('\0',back,fore);
c02035ff:	83 ec 04             	sub    $0x4,%esp
c0203602:	ff 75 10             	pushl  0x10(%ebp)
c0203605:	ff 75 0c             	pushl  0xc(%ebp)
c0203608:	6a 00                	push   $0x0
c020360a:	e8 e6 fe ff ff       	call   c02034f5 <vga_putc>
c020360f:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<tab_length;i++)
c0203612:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203616:	0f b6 83 14 f0 ff ff 	movzbl -0xfec(%ebx),%eax
c020361d:	0f b6 c0             	movzbl %al,%eax
c0203620:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0203623:	7c da                	jl     c02035ff <kputc_color+0x31>
			break;
c0203625:	eb 5e                	jmp    c0203685 <kputc_color+0xb7>
		}
		case '\n':{
			uint8_t temp_num = 80-cursor_x;
c0203627:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c020362e:	ba 50 00 00 00       	mov    $0x50,%edx
c0203633:	29 c2                	sub    %eax,%edx
c0203635:	89 d0                	mov    %edx,%eax
c0203637:	88 45 f3             	mov    %al,-0xd(%ebp)
			if(temp_num==0)
c020363a:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c020363e:	75 04                	jne    c0203644 <kputc_color+0x76>
				temp_num=80;
c0203640:	c6 45 f3 50          	movb   $0x50,-0xd(%ebp)
			for(int i=0;i<temp_num;i++)
c0203644:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c020364b:	eb 17                	jmp    c0203664 <kputc_color+0x96>
			vga_putc('\0',back,fore);
c020364d:	83 ec 04             	sub    $0x4,%esp
c0203650:	ff 75 10             	pushl  0x10(%ebp)
c0203653:	ff 75 0c             	pushl  0xc(%ebp)
c0203656:	6a 00                	push   $0x0
c0203658:	e8 98 fe ff ff       	call   c02034f5 <vga_putc>
c020365d:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<temp_num;i++)
c0203660:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0203664:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0203668:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c020366b:	7c e0                	jl     c020364d <kputc_color+0x7f>
			break;
c020366d:	eb 16                	jmp    c0203685 <kputc_color+0xb7>
		}
		default:
			vga_putc(input,back,fore);	
c020366f:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0203673:	83 ec 04             	sub    $0x4,%esp
c0203676:	ff 75 10             	pushl  0x10(%ebp)
c0203679:	ff 75 0c             	pushl  0xc(%ebp)
c020367c:	50                   	push   %eax
c020367d:	e8 73 fe ff ff       	call   c02034f5 <vga_putc>
c0203682:	83 c4 10             	add    $0x10,%esp
	}
}
c0203685:	90                   	nop
c0203686:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203689:	c9                   	leave  
c020368a:	c3                   	ret    

c020368b <kputc>:

void kputc(char input){
c020368b:	55                   	push   %ebp
c020368c:	89 e5                	mov    %esp,%ebp
c020368e:	83 ec 18             	sub    $0x18,%esp
c0203691:	e8 6a 39 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203696:	05 6a 49 00 00       	add    $0x496a,%eax
c020369b:	8b 45 08             	mov    0x8(%ebp),%eax
c020369e:	88 45 f4             	mov    %al,-0xc(%ebp)
	kputc_color(input,black,white);
c02036a1:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c02036a5:	83 ec 04             	sub    $0x4,%esp
c02036a8:	6a 0f                	push   $0xf
c02036aa:	6a 00                	push   $0x0
c02036ac:	50                   	push   %eax
c02036ad:	e8 1c ff ff ff       	call   c02035ce <kputc_color>
c02036b2:	83 c4 10             	add    $0x10,%esp
}
c02036b5:	90                   	nop
c02036b6:	c9                   	leave  
c02036b7:	c3                   	ret    

c02036b8 <kputs_color>:

void kputs_color(char * input_str,vga_color_t back,vga_color_t fore){
c02036b8:	55                   	push   %ebp
c02036b9:	89 e5                	mov    %esp,%ebp
c02036bb:	83 ec 18             	sub    $0x18,%esp
c02036be:	e8 3d 39 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02036c3:	05 3d 49 00 00       	add    $0x493d,%eax
	char * probe=input_str;
c02036c8:	8b 45 08             	mov    0x8(%ebp),%eax
c02036cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(*probe!='\0')
c02036ce:	eb 21                	jmp    c02036f1 <kputs_color+0x39>
		kputc_color(*probe++,back,fore);
c02036d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02036d3:	8d 50 01             	lea    0x1(%eax),%edx
c02036d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c02036d9:	0f b6 00             	movzbl (%eax),%eax
c02036dc:	0f be c0             	movsbl %al,%eax
c02036df:	83 ec 04             	sub    $0x4,%esp
c02036e2:	ff 75 10             	pushl  0x10(%ebp)
c02036e5:	ff 75 0c             	pushl  0xc(%ebp)
c02036e8:	50                   	push   %eax
c02036e9:	e8 e0 fe ff ff       	call   c02035ce <kputc_color>
c02036ee:	83 c4 10             	add    $0x10,%esp
	while(*probe!='\0')
c02036f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02036f4:	0f b6 00             	movzbl (%eax),%eax
c02036f7:	84 c0                	test   %al,%al
c02036f9:	75 d5                	jne    c02036d0 <kputs_color+0x18>
}
c02036fb:	90                   	nop
c02036fc:	c9                   	leave  
c02036fd:	c3                   	ret    

c02036fe <kputs>:

void kputs(char *input_str){
c02036fe:	55                   	push   %ebp
c02036ff:	89 e5                	mov    %esp,%ebp
c0203701:	83 ec 08             	sub    $0x8,%esp
c0203704:	e8 f7 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203709:	05 f7 48 00 00       	add    $0x48f7,%eax
	kputs_color(input_str,black,white);
c020370e:	83 ec 04             	sub    $0x4,%esp
c0203711:	6a 0f                	push   $0xf
c0203713:	6a 00                	push   $0x0
c0203715:	ff 75 08             	pushl  0x8(%ebp)
c0203718:	e8 9b ff ff ff       	call   c02036b8 <kputs_color>
c020371d:	83 c4 10             	add    $0x10,%esp
}
c0203720:	90                   	nop
c0203721:	c9                   	leave  
c0203722:	c3                   	ret    

c0203723 <vga_init>:

void vga_init(){
c0203723:	55                   	push   %ebp
c0203724:	89 e5                	mov    %esp,%ebp
c0203726:	83 ec 08             	sub    $0x8,%esp
c0203729:	e8 d2 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020372e:	05 d2 48 00 00       	add    $0x48d2,%eax
	clear_screen();
c0203733:	e8 52 fc ff ff       	call   c020338a <clear_screen>
c0203738:	90                   	nop
c0203739:	c9                   	leave  
c020373a:	c3                   	ret    

c020373b <outb>:
#include "port.h"
// 端口写一个字节
inline void outb(uint16_t port, uint8_t value)
{
c020373b:	55                   	push   %ebp
c020373c:	89 e5                	mov    %esp,%ebp
c020373e:	83 ec 08             	sub    $0x8,%esp
c0203741:	e8 ba 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203746:	05 ba 48 00 00       	add    $0x48ba,%eax
c020374b:	8b 55 08             	mov    0x8(%ebp),%edx
c020374e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203751:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0203755:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
c0203758:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c020375c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0203760:	ee                   	out    %al,(%dx)
}
c0203761:	90                   	nop
c0203762:	c9                   	leave  
c0203763:	c3                   	ret    

c0203764 <inb>:

// 端口读一个字节
inline uint8_t inb(uint16_t port)
{
c0203764:	55                   	push   %ebp
c0203765:	89 e5                	mov    %esp,%ebp
c0203767:	83 ec 14             	sub    $0x14,%esp
c020376a:	e8 91 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020376f:	05 91 48 00 00       	add    $0x4891,%eax
c0203774:	8b 45 08             	mov    0x8(%ebp),%eax
c0203777:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint8_t ret;

    asm volatile("inb %1, %0" : "=a" (ret) : "dN" (port));
c020377b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c020377f:	89 c2                	mov    %eax,%edx
c0203781:	ec                   	in     (%dx),%al
c0203782:	88 45 ff             	mov    %al,-0x1(%ebp)

    return ret;
c0203785:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0203789:	c9                   	leave  
c020378a:	c3                   	ret    

c020378b <inw>:

// 端口读一个字
inline uint16_t inw(uint16_t port)
{
c020378b:	55                   	push   %ebp
c020378c:	89 e5                	mov    %esp,%ebp
c020378e:	83 ec 14             	sub    $0x14,%esp
c0203791:	e8 6a 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203796:	05 6a 48 00 00       	add    $0x486a,%eax
c020379b:	8b 45 08             	mov    0x8(%ebp),%eax
c020379e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint16_t ret;

    asm volatile ("inw %1, %0" : "=a" (ret) : "dN" (port));
c02037a2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c02037a6:	89 c2                	mov    %eax,%edx
c02037a8:	66 ed                	in     (%dx),%ax
c02037aa:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    return ret;
c02037ae:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c02037b2:	c9                   	leave  
c02037b3:	c3                   	ret    

c02037b4 <insert_str>:
#include "vga_basic.h"
#include "vargs.h"


void insert_str(char *inserted_str,char *inserting_str,uint32_t offset)  //插入辅助函数
{
c02037b4:	55                   	push   %ebp
c02037b5:	89 e5                	mov    %esp,%ebp
c02037b7:	57                   	push   %edi
c02037b8:	53                   	push   %ebx
c02037b9:	83 ec 70             	sub    $0x70,%esp
c02037bc:	e8 43 38 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02037c1:	81 c3 3f 48 00 00    	add    $0x483f,%ebx
	char m[100]={0};
c02037c7:	8d 55 90             	lea    -0x70(%ebp),%edx
c02037ca:	b8 00 00 00 00       	mov    $0x0,%eax
c02037cf:	b9 19 00 00 00       	mov    $0x19,%ecx
c02037d4:	89 d7                	mov    %edx,%edi
c02037d6:	f3 ab                	rep stos %eax,%es:(%edi)
	char *afterInsetedPositionStr=m;
c02037d8:	8d 45 90             	lea    -0x70(%ebp),%eax
c02037db:	89 45 f4             	mov    %eax,-0xc(%ebp)
	strcpy(afterInsetedPositionStr,inserted_str+offset+2);
c02037de:	8b 45 10             	mov    0x10(%ebp),%eax
c02037e1:	8d 50 02             	lea    0x2(%eax),%edx
c02037e4:	8b 45 08             	mov    0x8(%ebp),%eax
c02037e7:	01 d0                	add    %edx,%eax
c02037e9:	83 ec 08             	sub    $0x8,%esp
c02037ec:	50                   	push   %eax
c02037ed:	ff 75 f4             	pushl  -0xc(%ebp)
c02037f0:	e8 11 08 00 00       	call   c0204006 <strcpy>
c02037f5:	83 c4 10             	add    $0x10,%esp
	memcpy(inserted_str+offset,inserting_str,strlen(inserting_str));
c02037f8:	83 ec 0c             	sub    $0xc,%esp
c02037fb:	ff 75 0c             	pushl  0xc(%ebp)
c02037fe:	e8 d2 07 00 00       	call   c0203fd5 <strlen>
c0203803:	83 c4 10             	add    $0x10,%esp
c0203806:	89 c1                	mov    %eax,%ecx
c0203808:	8b 55 08             	mov    0x8(%ebp),%edx
c020380b:	8b 45 10             	mov    0x10(%ebp),%eax
c020380e:	01 d0                	add    %edx,%eax
c0203810:	83 ec 04             	sub    $0x4,%esp
c0203813:	51                   	push   %ecx
c0203814:	ff 75 0c             	pushl  0xc(%ebp)
c0203817:	50                   	push   %eax
c0203818:	e8 cd 06 00 00       	call   c0203eea <memcpy>
c020381d:	83 c4 10             	add    $0x10,%esp
	*(inserted_str+offset+strlen(inserting_str))='\0';
c0203820:	83 ec 0c             	sub    $0xc,%esp
c0203823:	ff 75 0c             	pushl  0xc(%ebp)
c0203826:	e8 aa 07 00 00       	call   c0203fd5 <strlen>
c020382b:	83 c4 10             	add    $0x10,%esp
c020382e:	89 c2                	mov    %eax,%edx
c0203830:	8b 45 10             	mov    0x10(%ebp),%eax
c0203833:	01 c2                	add    %eax,%edx
c0203835:	8b 45 08             	mov    0x8(%ebp),%eax
c0203838:	01 d0                	add    %edx,%eax
c020383a:	c6 00 00             	movb   $0x0,(%eax)
	strcat(inserted_str,afterInsetedPositionStr);
c020383d:	83 ec 08             	sub    $0x8,%esp
c0203840:	ff 75 f4             	pushl  -0xc(%ebp)
c0203843:	ff 75 08             	pushl  0x8(%ebp)
c0203846:	e8 01 08 00 00       	call   c020404c <strcat>
c020384b:	83 c4 10             	add    $0x10,%esp
	//memcpy(*(inserted_str+offset+1+strlen(inserting_str)),afterInsetedPositionStr,strlen(afterInsetedPositionStr));
	return inserted_str;
c020384e:	90                   	nop
}
c020384f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0203852:	5b                   	pop    %ebx
c0203853:	5f                   	pop    %edi
c0203854:	5d                   	pop    %ebp
c0203855:	c3                   	ret    

c0203856 <printk>:

void printk(char *input_str,...)
{	
c0203856:	55                   	push   %ebp
c0203857:	89 e5                	mov    %esp,%ebp
c0203859:	53                   	push   %ebx
c020385a:	83 ec 34             	sub    $0x34,%esp
c020385d:	e8 a2 37 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203862:	81 c3 9e 47 00 00    	add    $0x479e,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0203868:	8d 83 20 90 08 00    	lea    0x89020(%ebx),%eax
c020386e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0203871:	83 ec 08             	sub    $0x8,%esp
c0203874:	ff 75 08             	pushl  0x8(%ebp)
c0203877:	ff 75 f0             	pushl  -0x10(%ebp)
c020387a:	e8 87 07 00 00       	call   c0204006 <strcpy>
c020387f:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0203882:	8d 45 0c             	lea    0xc(%ebp),%eax
c0203885:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0203888:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c020388f:	e9 9e 01 00 00       	jmp    c0203a32 <printk+0x1dc>
	{
		char *charptr=output_str+offset;
c0203894:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203897:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020389a:	01 d0                	add    %edx,%eax
c020389c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c020389f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02038a2:	0f b6 00             	movzbl (%eax),%eax
c02038a5:	3c 25                	cmp    $0x25,%al
c02038a7:	0f 85 81 01 00 00    	jne    c0203a2e <printk+0x1d8>
		{
			if (*(charptr+1)=='s')
c02038ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02038b0:	83 c0 01             	add    $0x1,%eax
c02038b3:	0f b6 00             	movzbl (%eax),%eax
c02038b6:	3c 73                	cmp    $0x73,%al
c02038b8:	75 43                	jne    c02038fd <printk+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c02038ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02038bd:	8d 50 04             	lea    0x4(%eax),%edx
c02038c0:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02038c3:	8b 00                	mov    (%eax),%eax
c02038c5:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c02038c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02038cb:	83 ec 04             	sub    $0x4,%esp
c02038ce:	50                   	push   %eax
c02038cf:	ff 75 d0             	pushl  -0x30(%ebp)
c02038d2:	ff 75 f0             	pushl  -0x10(%ebp)
c02038d5:	e8 da fe ff ff       	call   c02037b4 <insert_str>
c02038da:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c02038dd:	83 ec 0c             	sub    $0xc,%esp
c02038e0:	ff 75 d0             	pushl  -0x30(%ebp)
c02038e3:	e8 ed 06 00 00       	call   c0203fd5 <strlen>
c02038e8:	83 c4 10             	add    $0x10,%esp
c02038eb:	89 c2                	mov    %eax,%edx
c02038ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02038f0:	01 d0                	add    %edx,%eax
c02038f2:	83 e8 01             	sub    $0x1,%eax
c02038f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02038f8:	e9 31 01 00 00       	jmp    c0203a2e <printk+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c02038fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203900:	83 c0 01             	add    $0x1,%eax
c0203903:	0f b6 00             	movzbl (%eax),%eax
c0203906:	3c 64                	cmp    $0x64,%al
c0203908:	75 55                	jne    c020395f <printk+0x109>
			{
				int arg_int=va_arg(ptr,int);
c020390a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020390d:	8d 50 04             	lea    0x4(%eax),%edx
c0203910:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203913:	8b 00                	mov    (%eax),%eax
c0203915:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0203918:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020391b:	83 ec 0c             	sub    $0xc,%esp
c020391e:	50                   	push   %eax
c020391f:	e8 61 07 00 00       	call   c0204085 <uintTostring>
c0203924:	83 c4 10             	add    $0x10,%esp
c0203927:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c020392a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020392d:	83 ec 04             	sub    $0x4,%esp
c0203930:	50                   	push   %eax
c0203931:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203934:	ff 75 f0             	pushl  -0x10(%ebp)
c0203937:	e8 78 fe ff ff       	call   c02037b4 <insert_str>
c020393c:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c020393f:	83 ec 0c             	sub    $0xc,%esp
c0203942:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203945:	e8 8b 06 00 00       	call   c0203fd5 <strlen>
c020394a:	83 c4 10             	add    $0x10,%esp
c020394d:	89 c2                	mov    %eax,%edx
c020394f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203952:	01 d0                	add    %edx,%eax
c0203954:	83 e8 01             	sub    $0x1,%eax
c0203957:	89 45 f4             	mov    %eax,-0xc(%ebp)
c020395a:	e9 cf 00 00 00       	jmp    c0203a2e <printk+0x1d8>
			}
			else if(*(charptr+1)=='c')
c020395f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203962:	83 c0 01             	add    $0x1,%eax
c0203965:	0f b6 00             	movzbl (%eax),%eax
c0203968:	3c 63                	cmp    $0x63,%al
c020396a:	0f 84 be 00 00 00    	je     c0203a2e <printk+0x1d8>
			{
				;
			}
			else if(*(charptr+1)=='H')
c0203970:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203973:	83 c0 01             	add    $0x1,%eax
c0203976:	0f b6 00             	movzbl (%eax),%eax
c0203979:	3c 48                	cmp    $0x48,%al
c020397b:	75 53                	jne    c02039d0 <printk+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c020397d:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203980:	8d 50 04             	lea    0x4(%eax),%edx
c0203983:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203986:	8b 00                	mov    (%eax),%eax
c0203988:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c020398b:	83 ec 08             	sub    $0x8,%esp
c020398e:	6a 01                	push   $0x1
c0203990:	ff 75 e0             	pushl  -0x20(%ebp)
c0203993:	e8 2c 04 00 00       	call   c0203dc4 <num2hexstr>
c0203998:	83 c4 10             	add    $0x10,%esp
c020399b:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c020399e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02039a1:	83 ec 04             	sub    $0x4,%esp
c02039a4:	50                   	push   %eax
c02039a5:	ff 75 dc             	pushl  -0x24(%ebp)
c02039a8:	ff 75 f0             	pushl  -0x10(%ebp)
c02039ab:	e8 04 fe ff ff       	call   c02037b4 <insert_str>
c02039b0:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c02039b3:	83 ec 0c             	sub    $0xc,%esp
c02039b6:	ff 75 dc             	pushl  -0x24(%ebp)
c02039b9:	e8 17 06 00 00       	call   c0203fd5 <strlen>
c02039be:	83 c4 10             	add    $0x10,%esp
c02039c1:	89 c2                	mov    %eax,%edx
c02039c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02039c6:	01 d0                	add    %edx,%eax
c02039c8:	83 e8 01             	sub    $0x1,%eax
c02039cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02039ce:	eb 5e                	jmp    c0203a2e <printk+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c02039d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02039d3:	83 c0 01             	add    $0x1,%eax
c02039d6:	0f b6 00             	movzbl (%eax),%eax
c02039d9:	3c 68                	cmp    $0x68,%al
c02039db:	75 51                	jne    c0203a2e <printk+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c02039dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02039e0:	8d 50 04             	lea    0x4(%eax),%edx
c02039e3:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02039e6:	8b 00                	mov    (%eax),%eax
c02039e8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c02039eb:	83 ec 08             	sub    $0x8,%esp
c02039ee:	6a 00                	push   $0x0
c02039f0:	ff 75 e8             	pushl  -0x18(%ebp)
c02039f3:	e8 cc 03 00 00       	call   c0203dc4 <num2hexstr>
c02039f8:	83 c4 10             	add    $0x10,%esp
c02039fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c02039fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a01:	83 ec 04             	sub    $0x4,%esp
c0203a04:	50                   	push   %eax
c0203a05:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a08:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a0b:	e8 a4 fd ff ff       	call   c02037b4 <insert_str>
c0203a10:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203a13:	83 ec 0c             	sub    $0xc,%esp
c0203a16:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a19:	e8 b7 05 00 00       	call   c0203fd5 <strlen>
c0203a1e:	83 c4 10             	add    $0x10,%esp
c0203a21:	89 c2                	mov    %eax,%edx
c0203a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a26:	01 d0                	add    %edx,%eax
c0203a28:	83 e8 01             	sub    $0x1,%eax
c0203a2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203a2e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203a32:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203a35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203a38:	01 d0                	add    %edx,%eax
c0203a3a:	0f b6 00             	movzbl (%eax),%eax
c0203a3d:	84 c0                	test   %al,%al
c0203a3f:	0f 85 4f fe ff ff    	jne    c0203894 <printk+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs(output_str);
c0203a45:	83 ec 0c             	sub    $0xc,%esp
c0203a48:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a4b:	e8 ae fc ff ff       	call   c02036fe <kputs>
c0203a50:	83 c4 10             	add    $0x10,%esp
}
c0203a53:	90                   	nop
c0203a54:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203a57:	c9                   	leave  
c0203a58:	c3                   	ret    

c0203a59 <printbasic>:


//输入uint32_t或者char*  使用%d或者%s
//wdnmd 这个可变参有问题！！
void printbasic(char *format_str,char *m)
{
c0203a59:	55                   	push   %ebp
c0203a5a:	89 e5                	mov    %esp,%ebp
c0203a5c:	83 ec 18             	sub    $0x18,%esp
c0203a5f:	e8 9c 35 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203a64:	05 9c 45 00 00       	add    $0x459c,%eax
	//va_list ptr_start=NULL;
	char *formatStr=format_str;
c0203a69:	8b 45 08             	mov    0x8(%ebp),%eax
c0203a6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//va_start(ptr_start,format_str);
	//kputs_color(va_arg(ptr_start,char *), rc_black, rc_green);	
	int i=0;
c0203a6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0203a76:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203a79:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0203a7c:	eb 3a                	jmp    c0203ab8 <printbasic+0x5f>
	{
		if (*(head+i)=='%'){
c0203a7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203a81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203a84:	01 d0                	add    %edx,%eax
c0203a86:	0f b6 00             	movzbl (%eax),%eax
c0203a89:	3c 25                	cmp    $0x25,%al
c0203a8b:	75 27                	jne    c0203ab4 <printbasic+0x5b>
			if(*(head+i+1)=='s')
c0203a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a90:	8d 50 01             	lea    0x1(%eax),%edx
c0203a93:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203a96:	01 d0                	add    %edx,%eax
c0203a98:	0f b6 00             	movzbl (%eax),%eax
c0203a9b:	3c 73                	cmp    $0x73,%al
c0203a9d:	75 15                	jne    c0203ab4 <printbasic+0x5b>
			{
				//char *str_head=va_arg(&ptr_start,char*);
				insert_str(format_str,m,i);
c0203a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203aa2:	83 ec 04             	sub    $0x4,%esp
c0203aa5:	50                   	push   %eax
c0203aa6:	ff 75 0c             	pushl  0xc(%ebp)
c0203aa9:	ff 75 08             	pushl  0x8(%ebp)
c0203aac:	e8 03 fd ff ff       	call   c02037b4 <insert_str>
c0203ab1:	83 c4 10             	add    $0x10,%esp
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0203ab4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203ab8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203abb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203abe:	01 d0                	add    %edx,%eax
c0203ac0:	0f b6 00             	movzbl (%eax),%eax
c0203ac3:	84 c0                	test   %al,%al
c0203ac5:	75 b7                	jne    c0203a7e <printbasic+0x25>
			else;
		}
	}
	//kputs_color(formatStr, black, white);
	
}
c0203ac7:	90                   	nop
c0203ac8:	c9                   	leave  
c0203ac9:	c3                   	ret    

c0203aca <printk_color>:



void printk_color(char *input_str,vga_color_t back,vga_color_t fore,...)
{
c0203aca:	55                   	push   %ebp
c0203acb:	89 e5                	mov    %esp,%ebp
c0203acd:	53                   	push   %ebx
c0203ace:	83 ec 34             	sub    $0x34,%esp
c0203ad1:	e8 2e 35 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203ad6:	81 c3 2a 45 00 00    	add    $0x452a,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0203adc:	8d 83 a0 90 08 00    	lea    0x890a0(%ebx),%eax
c0203ae2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0203ae5:	83 ec 08             	sub    $0x8,%esp
c0203ae8:	ff 75 08             	pushl  0x8(%ebp)
c0203aeb:	ff 75 f0             	pushl  -0x10(%ebp)
c0203aee:	e8 13 05 00 00       	call   c0204006 <strcpy>
c0203af3:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0203af6:	8d 45 14             	lea    0x14(%ebp),%eax
c0203af9:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0203afc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203b03:	e9 9e 01 00 00       	jmp    c0203ca6 <printk_color+0x1dc>
	{
		char *charptr=output_str+offset;
c0203b08:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203b0e:	01 d0                	add    %edx,%eax
c0203b10:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c0203b13:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b16:	0f b6 00             	movzbl (%eax),%eax
c0203b19:	3c 25                	cmp    $0x25,%al
c0203b1b:	0f 85 81 01 00 00    	jne    c0203ca2 <printk_color+0x1d8>
		{
			if (*(charptr+1)=='s')
c0203b21:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b24:	83 c0 01             	add    $0x1,%eax
c0203b27:	0f b6 00             	movzbl (%eax),%eax
c0203b2a:	3c 73                	cmp    $0x73,%al
c0203b2c:	75 43                	jne    c0203b71 <printk_color+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c0203b2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203b31:	8d 50 04             	lea    0x4(%eax),%edx
c0203b34:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203b37:	8b 00                	mov    (%eax),%eax
c0203b39:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c0203b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b3f:	83 ec 04             	sub    $0x4,%esp
c0203b42:	50                   	push   %eax
c0203b43:	ff 75 d0             	pushl  -0x30(%ebp)
c0203b46:	ff 75 f0             	pushl  -0x10(%ebp)
c0203b49:	e8 66 fc ff ff       	call   c02037b4 <insert_str>
c0203b4e:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c0203b51:	83 ec 0c             	sub    $0xc,%esp
c0203b54:	ff 75 d0             	pushl  -0x30(%ebp)
c0203b57:	e8 79 04 00 00       	call   c0203fd5 <strlen>
c0203b5c:	83 c4 10             	add    $0x10,%esp
c0203b5f:	89 c2                	mov    %eax,%edx
c0203b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b64:	01 d0                	add    %edx,%eax
c0203b66:	83 e8 01             	sub    $0x1,%eax
c0203b69:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203b6c:	e9 31 01 00 00       	jmp    c0203ca2 <printk_color+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c0203b71:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b74:	83 c0 01             	add    $0x1,%eax
c0203b77:	0f b6 00             	movzbl (%eax),%eax
c0203b7a:	3c 64                	cmp    $0x64,%al
c0203b7c:	75 55                	jne    c0203bd3 <printk_color+0x109>
			{
				int arg_int=va_arg(ptr,int);
c0203b7e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203b81:	8d 50 04             	lea    0x4(%eax),%edx
c0203b84:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203b87:	8b 00                	mov    (%eax),%eax
c0203b89:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0203b8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0203b8f:	83 ec 0c             	sub    $0xc,%esp
c0203b92:	50                   	push   %eax
c0203b93:	e8 ed 04 00 00       	call   c0204085 <uintTostring>
c0203b98:	83 c4 10             	add    $0x10,%esp
c0203b9b:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c0203b9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203ba1:	83 ec 04             	sub    $0x4,%esp
c0203ba4:	50                   	push   %eax
c0203ba5:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203ba8:	ff 75 f0             	pushl  -0x10(%ebp)
c0203bab:	e8 04 fc ff ff       	call   c02037b4 <insert_str>
c0203bb0:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c0203bb3:	83 ec 0c             	sub    $0xc,%esp
c0203bb6:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203bb9:	e8 17 04 00 00       	call   c0203fd5 <strlen>
c0203bbe:	83 c4 10             	add    $0x10,%esp
c0203bc1:	89 c2                	mov    %eax,%edx
c0203bc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203bc6:	01 d0                	add    %edx,%eax
c0203bc8:	83 e8 01             	sub    $0x1,%eax
c0203bcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203bce:	e9 cf 00 00 00       	jmp    c0203ca2 <printk_color+0x1d8>
			}
			else if(*(charptr+1)=='c')
c0203bd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203bd6:	83 c0 01             	add    $0x1,%eax
c0203bd9:	0f b6 00             	movzbl (%eax),%eax
c0203bdc:	3c 63                	cmp    $0x63,%al
c0203bde:	0f 84 be 00 00 00    	je     c0203ca2 <printk_color+0x1d8>
			{
			
			}
			else if(*(charptr+1)=='H')
c0203be4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203be7:	83 c0 01             	add    $0x1,%eax
c0203bea:	0f b6 00             	movzbl (%eax),%eax
c0203bed:	3c 48                	cmp    $0x48,%al
c0203bef:	75 53                	jne    c0203c44 <printk_color+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c0203bf1:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203bf4:	8d 50 04             	lea    0x4(%eax),%edx
c0203bf7:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203bfa:	8b 00                	mov    (%eax),%eax
c0203bfc:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c0203bff:	83 ec 08             	sub    $0x8,%esp
c0203c02:	6a 01                	push   $0x1
c0203c04:	ff 75 e0             	pushl  -0x20(%ebp)
c0203c07:	e8 b8 01 00 00       	call   c0203dc4 <num2hexstr>
c0203c0c:	83 c4 10             	add    $0x10,%esp
c0203c0f:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c15:	83 ec 04             	sub    $0x4,%esp
c0203c18:	50                   	push   %eax
c0203c19:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c1c:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c1f:	e8 90 fb ff ff       	call   c02037b4 <insert_str>
c0203c24:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203c27:	83 ec 0c             	sub    $0xc,%esp
c0203c2a:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c2d:	e8 a3 03 00 00       	call   c0203fd5 <strlen>
c0203c32:	83 c4 10             	add    $0x10,%esp
c0203c35:	89 c2                	mov    %eax,%edx
c0203c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c3a:	01 d0                	add    %edx,%eax
c0203c3c:	83 e8 01             	sub    $0x1,%eax
c0203c3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203c42:	eb 5e                	jmp    c0203ca2 <printk_color+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c0203c44:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203c47:	83 c0 01             	add    $0x1,%eax
c0203c4a:	0f b6 00             	movzbl (%eax),%eax
c0203c4d:	3c 68                	cmp    $0x68,%al
c0203c4f:	75 51                	jne    c0203ca2 <printk_color+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c0203c51:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203c54:	8d 50 04             	lea    0x4(%eax),%edx
c0203c57:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203c5a:	8b 00                	mov    (%eax),%eax
c0203c5c:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c0203c5f:	83 ec 08             	sub    $0x8,%esp
c0203c62:	6a 00                	push   $0x0
c0203c64:	ff 75 e8             	pushl  -0x18(%ebp)
c0203c67:	e8 58 01 00 00       	call   c0203dc4 <num2hexstr>
c0203c6c:	83 c4 10             	add    $0x10,%esp
c0203c6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c75:	83 ec 04             	sub    $0x4,%esp
c0203c78:	50                   	push   %eax
c0203c79:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203c7c:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c7f:	e8 30 fb ff ff       	call   c02037b4 <insert_str>
c0203c84:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203c87:	83 ec 0c             	sub    $0xc,%esp
c0203c8a:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203c8d:	e8 43 03 00 00       	call   c0203fd5 <strlen>
c0203c92:	83 c4 10             	add    $0x10,%esp
c0203c95:	89 c2                	mov    %eax,%edx
c0203c97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c9a:	01 d0                	add    %edx,%eax
c0203c9c:	83 e8 01             	sub    $0x1,%eax
c0203c9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203ca2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203ca6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203ca9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203cac:	01 d0                	add    %edx,%eax
c0203cae:	0f b6 00             	movzbl (%eax),%eax
c0203cb1:	84 c0                	test   %al,%al
c0203cb3:	0f 85 4f fe ff ff    	jne    c0203b08 <printk_color+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs_color(output_str,back,fore);
c0203cb9:	83 ec 04             	sub    $0x4,%esp
c0203cbc:	ff 75 10             	pushl  0x10(%ebp)
c0203cbf:	ff 75 0c             	pushl  0xc(%ebp)
c0203cc2:	ff 75 f0             	pushl  -0x10(%ebp)
c0203cc5:	e8 ee f9 ff ff       	call   c02036b8 <kputs_color>
c0203cca:	83 c4 10             	add    $0x10,%esp
}
c0203ccd:	90                   	nop
c0203cce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203cd1:	c9                   	leave  
c0203cd2:	c3                   	ret    

c0203cd3 <printkDebug>:

void printkDebug(){
c0203cd3:	55                   	push   %ebp
c0203cd4:	89 e5                	mov    %esp,%ebp
c0203cd6:	53                   	push   %ebx
c0203cd7:	83 ec 04             	sub    $0x4,%esp
c0203cda:	e8 25 33 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203cdf:	81 c3 21 43 00 00    	add    $0x4321,%ebx
	printk("wkawda----");
c0203ce5:	83 ec 0c             	sub    $0xc,%esp
c0203ce8:	8d 83 0c 00 00 00    	lea    0xc(%ebx),%eax
c0203cee:	50                   	push   %eax
c0203cef:	e8 62 fb ff ff       	call   c0203856 <printk>
c0203cf4:	83 c4 10             	add    $0x10,%esp
	printk_color("wkdaowd",black,white);
c0203cf7:	83 ec 04             	sub    $0x4,%esp
c0203cfa:	6a 0f                	push   $0xf
c0203cfc:	6a 00                	push   $0x0
c0203cfe:	8d 83 17 00 00 00    	lea    0x17(%ebx),%eax
c0203d04:	50                   	push   %eax
c0203d05:	e8 c0 fd ff ff       	call   c0203aca <printk_color>
c0203d0a:	83 c4 10             	add    $0x10,%esp
c0203d0d:	90                   	nop
c0203d0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203d11:	c9                   	leave  
c0203d12:	c3                   	ret    

c0203d13 <func>:
#include "string.h"

//进制转换的辅助函数
static int func(char *s,int n,uint32_t i)          //n表示输入的数 i表示转化的进制
{
c0203d13:	55                   	push   %ebp
c0203d14:	89 e5                	mov    %esp,%ebp
c0203d16:	83 ec 28             	sub    $0x28,%esp
c0203d19:	e8 e2 32 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203d1e:	05 e2 42 00 00       	add    $0x42e2,%eax
    char bit[]={"0123456789ABCDEF"};
c0203d23:	c7 45 e3 30 31 32 33 	movl   $0x33323130,-0x1d(%ebp)
c0203d2a:	c7 45 e7 34 35 36 37 	movl   $0x37363534,-0x19(%ebp)
c0203d31:	c7 45 eb 38 39 41 42 	movl   $0x42413938,-0x15(%ebp)
c0203d38:	c7 45 ef 43 44 45 46 	movl   $0x46454443,-0x11(%ebp)
c0203d3f:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int len;
    if(n==0)
c0203d43:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203d47:	75 1c                	jne    c0203d65 <func+0x52>
    {
        strcpy(s,"");
c0203d49:	83 ec 08             	sub    $0x8,%esp
c0203d4c:	8d 80 1f 00 00 00    	lea    0x1f(%eax),%eax
c0203d52:	50                   	push   %eax
c0203d53:	ff 75 08             	pushl  0x8(%ebp)
c0203d56:	e8 ab 02 00 00       	call   c0204006 <strcpy>
c0203d5b:	83 c4 10             	add    $0x10,%esp
        return 0;
c0203d5e:	b8 00 00 00 00       	mov    $0x0,%eax
c0203d63:	eb 5d                	jmp    c0203dc2 <func+0xaf>
    }
    func(s,n/i,i);
c0203d65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203d68:	ba 00 00 00 00       	mov    $0x0,%edx
c0203d6d:	f7 75 10             	divl   0x10(%ebp)
c0203d70:	83 ec 04             	sub    $0x4,%esp
c0203d73:	ff 75 10             	pushl  0x10(%ebp)
c0203d76:	50                   	push   %eax
c0203d77:	ff 75 08             	pushl  0x8(%ebp)
c0203d7a:	e8 94 ff ff ff       	call   c0203d13 <func>
c0203d7f:	83 c4 10             	add    $0x10,%esp
    len=strlen(s);
c0203d82:	83 ec 0c             	sub    $0xc,%esp
c0203d85:	ff 75 08             	pushl  0x8(%ebp)
c0203d88:	e8 48 02 00 00       	call   c0203fd5 <strlen>
c0203d8d:	83 c4 10             	add    $0x10,%esp
c0203d90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    s[len]=bit[n%i];
c0203d93:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203d96:	ba 00 00 00 00       	mov    $0x0,%edx
c0203d9b:	f7 75 10             	divl   0x10(%ebp)
c0203d9e:	89 d1                	mov    %edx,%ecx
c0203da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203da3:	8b 45 08             	mov    0x8(%ebp),%eax
c0203da6:	01 c2                	add    %eax,%edx
c0203da8:	0f b6 44 0d e3       	movzbl -0x1d(%ebp,%ecx,1),%eax
c0203dad:	88 02                	mov    %al,(%edx)
    s[len+1]='\0';
c0203daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203db2:	8d 50 01             	lea    0x1(%eax),%edx
c0203db5:	8b 45 08             	mov    0x8(%ebp),%eax
c0203db8:	01 d0                	add    %edx,%eax
c0203dba:	c6 00 00             	movb   $0x0,(%eax)
    return 1;
c0203dbd:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0203dc2:	c9                   	leave  
c0203dc3:	c3                   	ret    

c0203dc4 <num2hexstr>:

//32位的16进制数 使用0x+8位字符表示+\0   共11位字符
inline char *num2hexstr(int number,int need0x)
{	if (number!=0)
c0203dc4:	55                   	push   %ebp
c0203dc5:	89 e5                	mov    %esp,%ebp
c0203dc7:	53                   	push   %ebx
c0203dc8:	83 ec 34             	sub    $0x34,%esp
c0203dcb:	e8 34 32 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203dd0:	81 c3 30 42 00 00    	add    $0x4230,%ebx
c0203dd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0203dda:	0f 84 f1 00 00 00    	je     c0203ed1 <num2hexstr+0x10d>
	{
	static char static_hexstr[11]={0};
	static_hexstr[0]='0';
c0203de0:	c6 83 20 91 08 00 30 	movb   $0x30,0x89120(%ebx)
	static_hexstr[1]='x';
c0203de7:	c6 83 21 91 08 00 78 	movb   $0x78,0x89121(%ebx)
	char temp_arry[9]={0};
c0203dee:	c7 45 df 00 00 00 00 	movl   $0x0,-0x21(%ebp)
c0203df5:	c7 45 e3 00 00 00 00 	movl   $0x0,-0x1d(%ebp)
c0203dfc:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	char *temp_arry_ptr=temp_arry;
c0203e00:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203e03:	89 45 f0             	mov    %eax,-0x10(%ebp)
	func(temp_arry_ptr,number,16);
c0203e06:	83 ec 04             	sub    $0x4,%esp
c0203e09:	6a 10                	push   $0x10
c0203e0b:	ff 75 08             	pushl  0x8(%ebp)
c0203e0e:	ff 75 f0             	pushl  -0x10(%ebp)
c0203e11:	e8 fd fe ff ff       	call   c0203d13 <func>
c0203e16:	83 c4 10             	add    $0x10,%esp
	char temp_arry2[9]={0};
c0203e19:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
c0203e20:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
c0203e27:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	char *temp_arry2_ptr=temp_arry2;
c0203e2b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0203e2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	strcpy(temp_arry2_ptr,temp_arry_ptr);
c0203e31:	83 ec 08             	sub    $0x8,%esp
c0203e34:	ff 75 f0             	pushl  -0x10(%ebp)
c0203e37:	ff 75 ec             	pushl  -0x14(%ebp)
c0203e3a:	e8 c7 01 00 00       	call   c0204006 <strcpy>
c0203e3f:	83 c4 10             	add    $0x10,%esp
	int offset=8-strlen(temp_arry);
c0203e42:	83 ec 0c             	sub    $0xc,%esp
c0203e45:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203e48:	50                   	push   %eax
c0203e49:	e8 87 01 00 00       	call   c0203fd5 <strlen>
c0203e4e:	83 c4 10             	add    $0x10,%esp
c0203e51:	ba 08 00 00 00       	mov    $0x8,%edx
c0203e56:	29 c2                	sub    %eax,%edx
c0203e58:	89 d0                	mov    %edx,%eax
c0203e5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	strcpy(temp_arry+offset,temp_arry2);
c0203e5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203e60:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203e63:	01 c2                	add    %eax,%edx
c0203e65:	83 ec 08             	sub    $0x8,%esp
c0203e68:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0203e6b:	50                   	push   %eax
c0203e6c:	52                   	push   %edx
c0203e6d:	e8 94 01 00 00       	call   c0204006 <strcpy>
c0203e72:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<offset;i++)
c0203e75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0203e7c:	eb 0f                	jmp    c0203e8d <num2hexstr+0xc9>
		*(temp_arry+i)='0';
c0203e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203e81:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203e84:	01 d0                	add    %edx,%eax
c0203e86:	c6 00 30             	movb   $0x30,(%eax)
	for(int i=0;i<offset;i++)
c0203e89:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203e90:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0203e93:	7c e9                	jl     c0203e7e <num2hexstr+0xba>
	if(need0x)
c0203e95:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203e99:	74 18                	je     c0203eb3 <num2hexstr+0xef>
		strcpy(static_hexstr+2,temp_arry);
c0203e9b:	8d 83 22 91 08 00    	lea    0x89122(%ebx),%eax
c0203ea1:	83 ec 08             	sub    $0x8,%esp
c0203ea4:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203ea7:	52                   	push   %edx
c0203ea8:	50                   	push   %eax
c0203ea9:	e8 58 01 00 00       	call   c0204006 <strcpy>
c0203eae:	83 c4 10             	add    $0x10,%esp
c0203eb1:	eb 16                	jmp    c0203ec9 <num2hexstr+0x105>
	else
		strcpy(static_hexstr,temp_arry);
c0203eb3:	83 ec 08             	sub    $0x8,%esp
c0203eb6:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203eb9:	50                   	push   %eax
c0203eba:	8d 83 20 91 08 00    	lea    0x89120(%ebx),%eax
c0203ec0:	50                   	push   %eax
c0203ec1:	e8 40 01 00 00       	call   c0204006 <strcpy>
c0203ec6:	83 c4 10             	add    $0x10,%esp
	return static_hexstr;
c0203ec9:	8d 83 20 91 08 00    	lea    0x89120(%ebx),%eax
c0203ecf:	eb 14                	jmp    c0203ee5 <num2hexstr+0x121>
	}
	else 
	{
		if(need0x)
c0203ed1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203ed5:	74 08                	je     c0203edf <num2hexstr+0x11b>
			return "0x00000000";
c0203ed7:	8d 83 20 00 00 00    	lea    0x20(%ebx),%eax
c0203edd:	eb 06                	jmp    c0203ee5 <num2hexstr+0x121>
		else
			return "00000000";
c0203edf:	8d 83 2b 00 00 00    	lea    0x2b(%ebx),%eax
	}
}
c0203ee5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ee8:	c9                   	leave  
c0203ee9:	c3                   	ret    

c0203eea <memcpy>:


inline void memcpy(uint8_t *dest ,const uint8_t *src,uint32_t len)
{
c0203eea:	55                   	push   %ebp
c0203eeb:	89 e5                	mov    %esp,%ebp
c0203eed:	e8 0e 31 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203ef2:	05 0e 41 00 00       	add    $0x410e,%eax
	for(;len!=0;len--)
c0203ef7:	eb 17                	jmp    c0203f10 <memcpy+0x26>
	{
		*dest=*src;
c0203ef9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203efc:	0f b6 10             	movzbl (%eax),%edx
c0203eff:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f02:	88 10                	mov    %dl,(%eax)
		dest++;
c0203f04:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c0203f08:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	for(;len!=0;len--)
c0203f0c:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0203f10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0203f14:	75 e3                	jne    c0203ef9 <memcpy+0xf>
	}
}
c0203f16:	90                   	nop
c0203f17:	5d                   	pop    %ebp
c0203f18:	c3                   	ret    

c0203f19 <memset>:

inline void memset(void *dest,uint8_t val ,uint32_t len)
{
c0203f19:	55                   	push   %ebp
c0203f1a:	89 e5                	mov    %esp,%ebp
c0203f1c:	83 ec 14             	sub    $0x14,%esp
c0203f1f:	e8 dc 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f24:	05 dc 40 00 00       	add    $0x40dc,%eax
c0203f29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f2c:	88 45 ec             	mov    %al,-0x14(%ebp)
	uint8_t *dst = (uint8_t *)dest;
c0203f2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f32:	89 45 fc             	mov    %eax,-0x4(%ebp)

    for ( ; len != 0; len--) {
c0203f35:	eb 13                	jmp    c0203f4a <memset+0x31>
        *dst++ = val;
c0203f37:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203f3a:	8d 50 01             	lea    0x1(%eax),%edx
c0203f3d:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0203f40:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0203f44:	88 10                	mov    %dl,(%eax)
    for ( ; len != 0; len--) {
c0203f46:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0203f4a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0203f4e:	75 e7                	jne    c0203f37 <memset+0x1e>
    }
}
c0203f50:	90                   	nop
c0203f51:	c9                   	leave  
c0203f52:	c3                   	ret    

c0203f53 <bzero>:

inline void bzero(void *dest, uint32_t len)
{
c0203f53:	55                   	push   %ebp
c0203f54:	89 e5                	mov    %esp,%ebp
c0203f56:	e8 a5 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f5b:	05 a5 40 00 00       	add    $0x40a5,%eax
    memset(dest, 0, len);
c0203f60:	ff 75 0c             	pushl  0xc(%ebp)
c0203f63:	6a 00                	push   $0x0
c0203f65:	ff 75 08             	pushl  0x8(%ebp)
c0203f68:	e8 ac ff ff ff       	call   c0203f19 <memset>
c0203f6d:	83 c4 0c             	add    $0xc,%esp
}
c0203f70:	90                   	nop
c0203f71:	c9                   	leave  
c0203f72:	c3                   	ret    

c0203f73 <strcmp>:

inline int strcmp(const char *str1,const char *str2)
{
c0203f73:	55                   	push   %ebp
c0203f74:	89 e5                	mov    %esp,%ebp
c0203f76:	e8 85 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f7b:	05 85 40 00 00       	add    $0x4085,%eax
	while(1){
		if (*str1=='\0'&&*str2=='\0')
c0203f80:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f83:	0f b6 00             	movzbl (%eax),%eax
c0203f86:	84 c0                	test   %al,%al
c0203f88:	75 11                	jne    c0203f9b <strcmp+0x28>
c0203f8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f8d:	0f b6 00             	movzbl (%eax),%eax
c0203f90:	84 c0                	test   %al,%al
c0203f92:	75 07                	jne    c0203f9b <strcmp+0x28>
			return 0;
c0203f94:	b8 00 00 00 00       	mov    $0x0,%eax
c0203f99:	eb 38                	jmp    c0203fd3 <strcmp+0x60>
		else if ((int)*str1>(int)*str2){
c0203f9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f9e:	0f b6 10             	movzbl (%eax),%edx
c0203fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203fa4:	0f b6 00             	movzbl (%eax),%eax
c0203fa7:	38 c2                	cmp    %al,%dl
c0203fa9:	7e 07                	jle    c0203fb2 <strcmp+0x3f>
			return 1;
c0203fab:	b8 01 00 00 00       	mov    $0x1,%eax
c0203fb0:	eb 21                	jmp    c0203fd3 <strcmp+0x60>
		}
		else if((int)*str1>(int)*str2){
c0203fb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0203fb5:	0f b6 10             	movzbl (%eax),%edx
c0203fb8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203fbb:	0f b6 00             	movzbl (%eax),%eax
c0203fbe:	38 c2                	cmp    %al,%dl
c0203fc0:	7e 07                	jle    c0203fc9 <strcmp+0x56>
			return -1;
c0203fc2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0203fc7:	eb 0a                	jmp    c0203fd3 <strcmp+0x60>
		}
		else{
			str1++;
c0203fc9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
			str2++;
c0203fcd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		if (*str1=='\0'&&*str2=='\0')
c0203fd1:	eb ad                	jmp    c0203f80 <strcmp+0xd>
		}
	}
}
c0203fd3:	5d                   	pop    %ebp
c0203fd4:	c3                   	ret    

c0203fd5 <strlen>:

inline int strlen(const char *src)
{
c0203fd5:	55                   	push   %ebp
c0203fd6:	89 e5                	mov    %esp,%ebp
c0203fd8:	83 ec 10             	sub    $0x10,%esp
c0203fdb:	e8 20 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203fe0:	05 20 40 00 00       	add    $0x4020,%eax
	int i=0;
c0203fe5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(*(src+i)!='\0')
c0203fec:	eb 04                	jmp    c0203ff2 <strlen+0x1d>
		i++;
c0203fee:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while(*(src+i)!='\0')
c0203ff2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0203ff5:	8b 45 08             	mov    0x8(%ebp),%eax
c0203ff8:	01 d0                	add    %edx,%eax
c0203ffa:	0f b6 00             	movzbl (%eax),%eax
c0203ffd:	84 c0                	test   %al,%al
c0203fff:	75 ed                	jne    c0203fee <strlen+0x19>
	return i;
c0204001:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0204004:	c9                   	leave  
c0204005:	c3                   	ret    

c0204006 <strcpy>:

inline char *strcpy(char *dest, const char *src)
{
c0204006:	55                   	push   %ebp
c0204007:	89 e5                	mov    %esp,%ebp
c0204009:	83 ec 10             	sub    $0x10,%esp
c020400c:	e8 ef 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204011:	05 ef 3f 00 00       	add    $0x3fef,%eax
	char *dest_head=dest;
c0204016:	8b 45 08             	mov    0x8(%ebp),%eax
c0204019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(*(src)!='\0')
c020401c:	eb 13                	jmp    c0204031 <strcpy+0x2b>
	{
		*dest=*src;
c020401e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204021:	0f b6 10             	movzbl (%eax),%edx
c0204024:	8b 45 08             	mov    0x8(%ebp),%eax
c0204027:	88 10                	mov    %dl,(%eax)
		dest++;
c0204029:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c020402d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	while(*(src)!='\0')
c0204031:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204034:	0f b6 00             	movzbl (%eax),%eax
c0204037:	84 c0                	test   %al,%al
c0204039:	75 e3                	jne    c020401e <strcpy+0x18>
	}
	*dest='\0';
c020403b:	8b 45 08             	mov    0x8(%ebp),%eax
c020403e:	c6 00 00             	movb   $0x0,(%eax)
	dest=dest_head;
c0204041:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204044:	89 45 08             	mov    %eax,0x8(%ebp)
	return dest;
c0204047:	8b 45 08             	mov    0x8(%ebp),%eax
}
c020404a:	c9                   	leave  
c020404b:	c3                   	ret    

c020404c <strcat>:

inline char *strcat(char *dest, const char *src)
{
c020404c:	55                   	push   %ebp
c020404d:	89 e5                	mov    %esp,%ebp
c020404f:	83 ec 10             	sub    $0x10,%esp
c0204052:	e8 a9 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204057:	05 a9 3f 00 00       	add    $0x3fa9,%eax
	char *pointer=dest;
c020405c:	8b 45 08             	mov    0x8(%ebp),%eax
c020405f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for(;*pointer!='\0';pointer++);
c0204062:	eb 04                	jmp    c0204068 <strcat+0x1c>
c0204064:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0204068:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020406b:	0f b6 00             	movzbl (%eax),%eax
c020406e:	84 c0                	test   %al,%al
c0204070:	75 f2                	jne    c0204064 <strcat+0x18>
	strcpy(pointer,src);
c0204072:	ff 75 0c             	pushl  0xc(%ebp)
c0204075:	ff 75 fc             	pushl  -0x4(%ebp)
c0204078:	e8 89 ff ff ff       	call   c0204006 <strcpy>
c020407d:	83 c4 08             	add    $0x8,%esp
	return dest;		
c0204080:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0204083:	c9                   	leave  
c0204084:	c3                   	ret    

c0204085 <uintTostring>:

inline char *uintTostring(uint32_t num)
{
c0204085:	55                   	push   %ebp
c0204086:	89 e5                	mov    %esp,%ebp
c0204088:	83 ec 28             	sub    $0x28,%esp
c020408b:	e8 70 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204090:	05 70 3f 00 00       	add    $0x3f70,%eax
	char i2stable[10]={'0','1','2','3','4','5','6','7','8','9'};
c0204095:	c6 45 da 30          	movb   $0x30,-0x26(%ebp)
c0204099:	c6 45 db 31          	movb   $0x31,-0x25(%ebp)
c020409d:	c6 45 dc 32          	movb   $0x32,-0x24(%ebp)
c02040a1:	c6 45 dd 33          	movb   $0x33,-0x23(%ebp)
c02040a5:	c6 45 de 34          	movb   $0x34,-0x22(%ebp)
c02040a9:	c6 45 df 35          	movb   $0x35,-0x21(%ebp)
c02040ad:	c6 45 e0 36          	movb   $0x36,-0x20(%ebp)
c02040b1:	c6 45 e1 37          	movb   $0x37,-0x1f(%ebp)
c02040b5:	c6 45 e2 38          	movb   $0x38,-0x1e(%ebp)
c02040b9:	c6 45 e3 39          	movb   $0x39,-0x1d(%ebp)
	static char m[32]={0};
	char *str_ptr=m;
c02040bd:	8d 80 40 91 08 00    	lea    0x89140(%eax),%eax
c02040c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char *head=str_ptr;
c02040c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02040c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int i=0;
c02040cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(;num>=10;i++)
c02040d3:	eb 46                	jmp    c020411b <uintTostring+0x96>
	{
		uint32_t num_=num/10;
c02040d5:	8b 45 08             	mov    0x8(%ebp),%eax
c02040d8:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c02040dd:	f7 e2                	mul    %edx
c02040df:	89 d0                	mov    %edx,%eax
c02040e1:	c1 e8 03             	shr    $0x3,%eax
c02040e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32_t index=num-(num_*10);
c02040e7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02040ea:	89 d0                	mov    %edx,%eax
c02040ec:	c1 e0 02             	shl    $0x2,%eax
c02040ef:	01 d0                	add    %edx,%eax
c02040f1:	01 c0                	add    %eax,%eax
c02040f3:	89 c2                	mov    %eax,%edx
c02040f5:	8b 45 08             	mov    0x8(%ebp),%eax
c02040f8:	29 d0                	sub    %edx,%eax
c02040fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		num=num_;
c02040fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0204100:	89 45 08             	mov    %eax,0x8(%ebp)
		*str_ptr=i2stable[index];
c0204103:	8d 55 da             	lea    -0x26(%ebp),%edx
c0204106:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0204109:	01 d0                	add    %edx,%eax
c020410b:	0f b6 10             	movzbl (%eax),%edx
c020410e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204111:	88 10                	mov    %dl,(%eax)
		str_ptr++;
c0204113:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	for(;num>=10;i++)
c0204117:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020411b:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c020411f:	77 b4                	ja     c02040d5 <uintTostring+0x50>
	}
	*str_ptr=i2stable[num];
c0204121:	8d 55 da             	lea    -0x26(%ebp),%edx
c0204124:	8b 45 08             	mov    0x8(%ebp),%eax
c0204127:	01 d0                	add    %edx,%eax
c0204129:	0f b6 10             	movzbl (%eax),%edx
c020412c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020412f:	88 10                	mov    %dl,(%eax)
	*(str_ptr+1)='\0';
c0204131:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204134:	83 c0 01             	add    $0x1,%eax
c0204137:	c6 00 00             	movb   $0x0,(%eax)
	return strrevers(head);
c020413a:	83 ec 0c             	sub    $0xc,%esp
c020413d:	ff 75 ec             	pushl  -0x14(%ebp)
c0204140:	e8 05 00 00 00       	call   c020414a <strrevers>
c0204145:	83 c4 10             	add    $0x10,%esp
}
c0204148:	c9                   	leave  
c0204149:	c3                   	ret    

c020414a <strrevers>:

inline  char *strrevers(char *str)
{
c020414a:	55                   	push   %ebp
c020414b:	89 e5                	mov    %esp,%ebp
c020414d:	83 ec 20             	sub    $0x20,%esp
c0204150:	e8 ab 2e 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204155:	05 ab 3e 00 00       	add    $0x3eab,%eax
	char *str_head=str;
c020415a:	8b 45 08             	mov    0x8(%ebp),%eax
c020415d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int lenth=strlen(str);
c0204160:	ff 75 08             	pushl  0x8(%ebp)
c0204163:	e8 6d fe ff ff       	call   c0203fd5 <strlen>
c0204168:	83 c4 04             	add    $0x4,%esp
c020416b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ptr_h=0;
c020416e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int ptr_t=--lenth;
c0204175:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0204179:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020417c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c020417f:	eb 39                	jmp    c02041ba <strrevers+0x70>
	{
		char temp=*(str_head+ptr_t);
c0204181:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204184:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204187:	01 d0                	add    %edx,%eax
c0204189:	0f b6 00             	movzbl (%eax),%eax
c020418c:	88 45 ef             	mov    %al,-0x11(%ebp)
		*(str_head+ptr_t)=*(str_head+ptr_h);
c020418f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204192:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204195:	01 d0                	add    %edx,%eax
c0204197:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c020419a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020419d:	01 ca                	add    %ecx,%edx
c020419f:	0f b6 00             	movzbl (%eax),%eax
c02041a2:	88 02                	mov    %al,(%edx)
		*(str_head+ptr_h)=temp;
c02041a4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02041a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02041aa:	01 c2                	add    %eax,%edx
c02041ac:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c02041b0:	88 02                	mov    %al,(%edx)
		ptr_h++;
c02041b2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		ptr_t--;
c02041b6:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c02041ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02041bd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c02041c0:	7c bf                	jl     c0204181 <strrevers+0x37>
	}
	return str_head;
c02041c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c02041c5:	c9                   	leave  
c02041c6:	c3                   	ret    

c02041c7 <_8259A_init>:
static uint16_t m_control_port = 0x20;     //主片控制端口号  main
static uint16_t m_data_port = 0x21;	       //从片数据端口号
static uint16_t o_control_port = 0xA0;     //从片控制端口号  other
static uint16_t o_data_port = 0xA1;        //从片数据端口号

void _8259A_init(){
c02041c7:	55                   	push   %ebp
c02041c8:	89 e5                	mov    %esp,%ebp
c02041ca:	53                   	push   %ebx
c02041cb:	83 ec 04             	sub    $0x4,%esp
c02041ce:	e8 31 2e 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02041d3:	81 c3 2d 3e 00 00    	add    $0x3e2d,%ebx
	//主片初始化
	outb(m_control_port,0x11);
c02041d9:	0f b7 83 1c f0 ff ff 	movzwl -0xfe4(%ebx),%eax
c02041e0:	0f b7 c0             	movzwl %ax,%eax
c02041e3:	83 ec 08             	sub    $0x8,%esp
c02041e6:	6a 11                	push   $0x11
c02041e8:	50                   	push   %eax
c02041e9:	e8 4d f5 ff ff       	call   c020373b <outb>
c02041ee:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x20);
c02041f1:	0f b7 83 1e f0 ff ff 	movzwl -0xfe2(%ebx),%eax
c02041f8:	0f b7 c0             	movzwl %ax,%eax
c02041fb:	83 ec 08             	sub    $0x8,%esp
c02041fe:	6a 20                	push   $0x20
c0204200:	50                   	push   %eax
c0204201:	e8 35 f5 ff ff       	call   c020373b <outb>
c0204206:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x04);
c0204209:	0f b7 83 1e f0 ff ff 	movzwl -0xfe2(%ebx),%eax
c0204210:	0f b7 c0             	movzwl %ax,%eax
c0204213:	83 ec 08             	sub    $0x8,%esp
c0204216:	6a 04                	push   $0x4
c0204218:	50                   	push   %eax
c0204219:	e8 1d f5 ff ff       	call   c020373b <outb>
c020421e:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x01);
c0204221:	0f b7 83 1e f0 ff ff 	movzwl -0xfe2(%ebx),%eax
c0204228:	0f b7 c0             	movzwl %ax,%eax
c020422b:	83 ec 08             	sub    $0x8,%esp
c020422e:	6a 01                	push   $0x1
c0204230:	50                   	push   %eax
c0204231:	e8 05 f5 ff ff       	call   c020373b <outb>
c0204236:	83 c4 10             	add    $0x10,%esp
	//从片初始化
	outb(o_control_port,0x11);
c0204239:	0f b7 83 20 f0 ff ff 	movzwl -0xfe0(%ebx),%eax
c0204240:	0f b7 c0             	movzwl %ax,%eax
c0204243:	83 ec 08             	sub    $0x8,%esp
c0204246:	6a 11                	push   $0x11
c0204248:	50                   	push   %eax
c0204249:	e8 ed f4 ff ff       	call   c020373b <outb>
c020424e:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x28);
c0204251:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204258:	0f b7 c0             	movzwl %ax,%eax
c020425b:	83 ec 08             	sub    $0x8,%esp
c020425e:	6a 28                	push   $0x28
c0204260:	50                   	push   %eax
c0204261:	e8 d5 f4 ff ff       	call   c020373b <outb>
c0204266:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x02);
c0204269:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204270:	0f b7 c0             	movzwl %ax,%eax
c0204273:	83 ec 08             	sub    $0x8,%esp
c0204276:	6a 02                	push   $0x2
c0204278:	50                   	push   %eax
c0204279:	e8 bd f4 ff ff       	call   c020373b <outb>
c020427e:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x01);
c0204281:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204288:	0f b7 c0             	movzwl %ax,%eax
c020428b:	83 ec 08             	sub    $0x8,%esp
c020428e:	6a 01                	push   $0x1
c0204290:	50                   	push   %eax
c0204291:	e8 a5 f4 ff ff       	call   c020373b <outb>
c0204296:	83 c4 10             	add    $0x10,%esp
c0204299:	90                   	nop
c020429a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020429d:	c9                   	leave  
c020429e:	c3                   	ret    

c020429f <kern_entry>:
void kputc(char);
void screen_uproll_once();
uint32_t get_eflags();
extern TCB_t * cur_tcb;
extern TCB_t main_TCB;
void kern_entry(){
c020429f:	55                   	push   %ebp
c02042a0:	89 e5                	mov    %esp,%ebp
c02042a2:	53                   	push   %ebx
c02042a3:	83 ec 04             	sub    $0x4,%esp
c02042a6:	e8 59 2d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02042ab:	81 c3 55 3d 00 00    	add    $0x3d55,%ebx
	void func(void* args);
	idt_init();
c02042b1:	e8 d1 19 00 00       	call   c0205c87 <idt_init>
	asm volatile("sti");
c02042b6:	fb                   	sti    
	*((char*)(0x80111111)) = 'a';
c02042b7:	b8 11 11 11 80       	mov    $0x80111111,%eax
c02042bc:	c6 00 61             	movb   $0x61,(%eax)
	vga_init();
c02042bf:	e8 5f f4 ff ff       	call   c0203723 <vga_init>

	pmm_init();
c02042c4:	e8 c7 16 00 00       	call   c0205990 <pmm_init>

	printk("1");
c02042c9:	83 ec 0c             	sub    $0xc,%esp
c02042cc:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c02042d2:	50                   	push   %eax
c02042d3:	e8 7e f5 ff ff       	call   c0203856 <printk>
c02042d8:	83 c4 10             	add    $0x10,%esp
	printk("1");
c02042db:	83 ec 0c             	sub    $0xc,%esp
c02042de:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c02042e4:	50                   	push   %eax
c02042e5:	e8 6c f5 ff ff       	call   c0203856 <printk>
c02042ea:	83 c4 10             	add    $0x10,%esp

	printk("1");
c02042ed:	83 ec 0c             	sub    $0xc,%esp
c02042f0:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c02042f6:	50                   	push   %eax
c02042f7:	e8 5a f5 ff ff       	call   c0203856 <printk>
c02042fc:	83 c4 10             	add    $0x10,%esp
	printk("1");
c02042ff:	83 ec 0c             	sub    $0xc,%esp
c0204302:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c0204308:	50                   	push   %eax
c0204309:	e8 48 f5 ff ff       	call   c0203856 <printk>
c020430e:	83 c4 10             	add    $0x10,%esp
	printk("1");
c0204311:	83 ec 0c             	sub    $0xc,%esp
c0204314:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c020431a:	50                   	push   %eax
c020431b:	e8 36 f5 ff ff       	call   c0203856 <printk>
c0204320:	83 c4 10             	add    $0x10,%esp

	vmm_test();
c0204323:	e8 e8 24 00 00       	call   c0206810 <vmm_test>
	
	while (1)
c0204328:	eb fe                	jmp    c0204328 <kern_entry+0x89>

c020432a <bitmap_init_mem>:
#include "bitmap.h"
#include "types.h"
//4KB为一个页来管理

//初始化目标bitmap的内存区域
void bitmap_init_mem(bitmap bm){
c020432a:	55                   	push   %ebp
c020432b:	89 e5                	mov    %esp,%ebp
c020432d:	83 ec 10             	sub    $0x10,%esp
c0204330:	e8 cb 2c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204335:	05 cb 3c 00 00       	add    $0x3ccb,%eax
    uint32_t lenght = bm.length;
c020433a:	8b 45 0c             	mov    0xc(%ebp),%eax
c020433d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0204340:	8b 45 08             	mov    0x8(%ebp),%eax
c0204343:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(uint32_t i = 0;i<lenght;i++){
c0204346:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c020434d:	eb 0f                	jmp    c020435e <bitmap_init_mem+0x34>
        *((byte*)(vaddr_header+i)) = 255;   //11111111b
c020434f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204352:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204355:	01 d0                	add    %edx,%eax
c0204357:	c6 00 ff             	movb   $0xff,(%eax)
    for(uint32_t i = 0;i<lenght;i++){
c020435a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c020435e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204361:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c0204364:	72 e9                	jb     c020434f <bitmap_init_mem+0x25>
    }
}
c0204366:	90                   	nop
c0204367:	c9                   	leave  
c0204368:	c3                   	ret    

c0204369 <bitmap_alloc_one_page>:


//指定分配目标页
//分配成功：返回目标页起始地址
//分配失败：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc_one_page(bitmap bm,uint32_t target){
c0204369:	55                   	push   %ebp
c020436a:	89 e5                	mov    %esp,%ebp
c020436c:	83 ec 20             	sub    $0x20,%esp
c020436f:	e8 8c 2c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204374:	05 8c 3c 00 00       	add    $0x3c8c,%eax
    uint32_t lenght = bm.length;
c0204379:	8b 45 0c             	mov    0xc(%ebp),%eax
c020437c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c020437f:	8b 45 08             	mov    0x8(%ebp),%eax
c0204382:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c0204385:	8b 45 10             	mov    0x10(%ebp),%eax
c0204388:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c020438b:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;   //必须要-1 否则可能造成max_addr溢出为0
c0204392:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204395:	c1 e0 0f             	shl    $0xf,%eax
c0204398:	89 c2                	mov    %eax,%edx
c020439a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020439d:	01 d0                	add    %edx,%eax
c020439f:	83 e8 01             	sub    $0x1,%eax
c02043a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c02043a5:	8b 45 14             	mov    0x14(%ebp),%eax
c02043a8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c02043ab:	0f 82 8e 00 00 00    	jb     c020443f <bitmap_alloc_one_page+0xd6>
c02043b1:	8b 45 14             	mov    0x14(%ebp),%eax
c02043b4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c02043b7:	0f 83 82 00 00 00    	jae    c020443f <bitmap_alloc_one_page+0xd6>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c02043bd:	8b 45 14             	mov    0x14(%ebp),%eax
c02043c0:	2b 45 f4             	sub    -0xc(%ebp),%eax
c02043c3:	c1 e8 0c             	shr    $0xc,%eax
c02043c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c02043c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02043cc:	8d 50 07             	lea    0x7(%eax),%edx
c02043cf:	85 c0                	test   %eax,%eax
c02043d1:	0f 48 c2             	cmovs  %edx,%eax
c02043d4:	c1 f8 03             	sar    $0x3,%eax
c02043d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c02043da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02043dd:	99                   	cltd   
c02043de:	c1 ea 1d             	shr    $0x1d,%edx
c02043e1:	01 d0                	add    %edx,%eax
c02043e3:	83 e0 07             	and    $0x7,%eax
c02043e6:	29 d0                	sub    %edx,%eax
c02043e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c02043eb:	b8 07 00 00 00       	mov    $0x7,%eax
c02043f0:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c02043f3:	ba 01 00 00 00       	mov    $0x1,%edx
c02043f8:	89 c1                	mov    %eax,%ecx
c02043fa:	d3 e2                	shl    %cl,%edx
c02043fc:	89 d0                	mov    %edx,%eax
c02043fe:	88 45 e3             	mov    %al,-0x1d(%ebp)
        byte target_byte = *((byte*)(vaddr_header+i));
c0204401:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0204404:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204407:	01 d0                	add    %edx,%eax
c0204409:	0f b6 00             	movzbl (%eax),%eax
c020440c:	88 45 e2             	mov    %al,-0x1e(%ebp)
        if(target_byte== (target_byte| byte_mask)){
c020440f:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
c0204413:	0a 45 e3             	or     -0x1d(%ebp),%al
c0204416:	38 45 e2             	cmp    %al,-0x1e(%ebp)
c0204419:	75 1d                	jne    c0204438 <bitmap_alloc_one_page+0xcf>
            //此时目标bit为1 空闲状态
            *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) - byte_mask;
c020441b:	8b 55 e8             	mov    -0x18(%ebp),%edx
c020441e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204421:	01 d0                	add    %edx,%eax
c0204423:	0f b6 00             	movzbl (%eax),%eax
c0204426:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0204429:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020442c:	01 ca                	add    %ecx,%edx
c020442e:	2a 45 e3             	sub    -0x1d(%ebp),%al
c0204431:	88 02                	mov    %al,(%edx)
            return target;    
c0204433:	8b 45 14             	mov    0x14(%ebp),%eax
c0204436:	eb 0c                	jmp    c0204444 <bitmap_alloc_one_page+0xdb>
        }
        else{
            //此时目标bit为0     忙碌状态
            return BITMAP_RETURN_ERRO;
c0204438:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020443d:	eb 05                	jmp    c0204444 <bitmap_alloc_one_page+0xdb>
        }   
    }
    else{
        return BITMAP_RETURN_ERRO;
c020443f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c0204444:	c9                   	leave  
c0204445:	c3                   	ret    

c0204446 <bitmap_release_one_page>:

//释放指定的目标页
//释放成功或者失败都不会返回信息
void bitmap_release_one_page(bitmap bm,uint32_t target){
c0204446:	55                   	push   %ebp
c0204447:	89 e5                	mov    %esp,%ebp
c0204449:	83 ec 20             	sub    $0x20,%esp
c020444c:	e8 af 2b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204451:	05 af 3b 00 00       	add    $0x3baf,%eax
    uint32_t lenght = bm.length;
c0204456:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204459:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c020445c:	8b 45 08             	mov    0x8(%ebp),%eax
c020445f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c0204462:	8b 45 10             	mov    0x10(%ebp),%eax
c0204465:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0204468:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;
c020446f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204472:	c1 e0 0f             	shl    $0xf,%eax
c0204475:	89 c2                	mov    %eax,%edx
c0204477:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020447a:	01 d0                	add    %edx,%eax
c020447c:	83 e8 01             	sub    $0x1,%eax
c020447f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c0204482:	8b 45 14             	mov    0x14(%ebp),%eax
c0204485:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0204488:	72 64                	jb     c02044ee <bitmap_release_one_page+0xa8>
c020448a:	8b 45 14             	mov    0x14(%ebp),%eax
c020448d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0204490:	73 5c                	jae    c02044ee <bitmap_release_one_page+0xa8>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c0204492:	8b 45 14             	mov    0x14(%ebp),%eax
c0204495:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0204498:	c1 e8 0c             	shr    $0xc,%eax
c020449b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c020449e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02044a1:	8d 50 07             	lea    0x7(%eax),%edx
c02044a4:	85 c0                	test   %eax,%eax
c02044a6:	0f 48 c2             	cmovs  %edx,%eax
c02044a9:	c1 f8 03             	sar    $0x3,%eax
c02044ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c02044af:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02044b2:	99                   	cltd   
c02044b3:	c1 ea 1d             	shr    $0x1d,%edx
c02044b6:	01 d0                	add    %edx,%eax
c02044b8:	83 e0 07             	and    $0x7,%eax
c02044bb:	29 d0                	sub    %edx,%eax
c02044bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c02044c0:	b8 07 00 00 00       	mov    $0x7,%eax
c02044c5:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c02044c8:	ba 01 00 00 00       	mov    $0x1,%edx
c02044cd:	89 c1                	mov    %eax,%ecx
c02044cf:	d3 e2                	shl    %cl,%edx
c02044d1:	89 d0                	mov    %edx,%eax
c02044d3:	88 45 e3             	mov    %al,-0x1d(%ebp)
        *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) | byte_mask;
c02044d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02044d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02044dc:	01 d0                	add    %edx,%eax
c02044de:	0f b6 00             	movzbl (%eax),%eax
c02044e1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c02044e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02044e7:	01 ca                	add    %ecx,%edx
c02044e9:	0a 45 e3             	or     -0x1d(%ebp),%al
c02044ec:	88 02                	mov    %al,(%edx)
    }
}
c02044ee:	90                   	nop
c02044ef:	c9                   	leave  
c02044f0:	c3                   	ret    

c02044f1 <bitmap_alloc>:

//任意分配 未指定分配的目标
//分配成功：返回目标页起始地址
//没有可用页：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc(bitmap bm){      
c02044f1:	55                   	push   %ebp
c02044f2:	89 e5                	mov    %esp,%ebp
c02044f4:	83 ec 30             	sub    $0x30,%esp
c02044f7:	e8 04 2b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02044fc:	05 04 3b 00 00       	add    $0x3b04,%eax
    uint32_t lenght = bm.length;
c0204501:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204504:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0204507:	8b 45 08             	mov    0x8(%ebp),%eax
c020450a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c020450d:	8b 45 10             	mov    0x10(%ebp),%eax
c0204510:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(uint32_t i =0;i<lenght;i++){
c0204513:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c020451a:	e9 97 00 00 00       	jmp    c02045b6 <bitmap_alloc+0xc5>
        byte byte_now = *((byte*)(vaddr_header+i)) ;
c020451f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0204522:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204525:	01 d0                	add    %edx,%eax
c0204527:	0f b6 00             	movzbl (%eax),%eax
c020452a:	88 45 fb             	mov    %al,-0x5(%ebp)
        if(byte_now != 0){
c020452d:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0204531:	74 7f                	je     c02045b2 <bitmap_alloc+0xc1>
            int pos;     //在本字节中目标bit所在位置（从左往右 从0开始）
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0204533:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020453a:	eb 21                	jmp    c020455d <bitmap_alloc+0x6c>
                byte temp_byte = byte_now<<1;
c020453c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0204540:	01 c0                	add    %eax,%eax
c0204542:	88 45 e3             	mov    %al,-0x1d(%ebp)
                if(byte_now>temp_byte){
c0204545:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0204549:	3a 45 e3             	cmp    -0x1d(%ebp),%al
c020454c:	76 08                	jbe    c0204556 <bitmap_alloc+0x65>
                    pos = j;
c020454e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204551:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    break;
c0204554:	eb 0d                	jmp    c0204563 <bitmap_alloc+0x72>
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c0204556:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020455a:	d0 65 fb             	shlb   -0x5(%ebp)
c020455d:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c0204561:	7e d9                	jle    c020453c <bitmap_alloc+0x4b>
                }
            }
            byte byte_sub = 1<<(7-pos);     //1=00000001b
c0204563:	b8 07 00 00 00       	mov    $0x7,%eax
c0204568:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020456b:	ba 01 00 00 00       	mov    $0x1,%edx
c0204570:	89 c1                	mov    %eax,%ecx
c0204572:	d3 e2                	shl    %cl,%edx
c0204574:	89 d0                	mov    %edx,%eax
c0204576:	88 45 e2             	mov    %al,-0x1e(%ebp)
            *((byte*)(vaddr_header+i)) = *((byte*)(vaddr_header+i))-byte_sub;
c0204579:	8b 55 e8             	mov    -0x18(%ebp),%edx
c020457c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020457f:	01 d0                	add    %edx,%eax
c0204581:	0f b6 00             	movzbl (%eax),%eax
c0204584:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0204587:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020458a:	01 ca                	add    %ecx,%edx
c020458c:	2a 45 e2             	sub    -0x1e(%ebp),%al
c020458f:	88 02                	mov    %al,(%edx)
            int page_no = i*8+pos;
c0204591:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204594:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c020459b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020459e:	01 d0                	add    %edx,%eax
c02045a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
            return page_no*PAGE_SIZE+target_addr_header;
c02045a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c02045a6:	c1 e0 0c             	shl    $0xc,%eax
c02045a9:	89 c2                	mov    %eax,%edx
c02045ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c02045ae:	01 d0                	add    %edx,%eax
c02045b0:	eb 15                	jmp    c02045c7 <bitmap_alloc+0xd6>
    for(uint32_t i =0;i<lenght;i++){
c02045b2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c02045b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02045b9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c02045bc:	0f 82 5d ff ff ff    	jb     c020451f <bitmap_alloc+0x2e>
        }
    }
    return BITMAP_RETURN_ERRO;
c02045c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c02045c7:	c9                   	leave  
c02045c8:	c3                   	ret    

c02045c9 <bitmap_test>:

//测试bitmap相关函数
void bitmap_test(){
c02045c9:	55                   	push   %ebp
c02045ca:	89 e5                	mov    %esp,%ebp
c02045cc:	53                   	push   %ebx
c02045cd:	83 ec 24             	sub    $0x24,%esp
c02045d0:	e8 2f 2a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02045d5:	81 c3 2b 3a 00 00    	add    $0x3a2b,%ebx
#include "printk.h"
extern uint32_t kern_bitmap;
    bitmap bm;
    bm.length =2 ;
c02045db:	c7 45 e8 02 00 00 00 	movl   $0x2,-0x18(%ebp)
    bm.vaddr_header = kern_bitmap;
c02045e2:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c02045e8:	8b 00                	mov    (%eax),%eax
c02045ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    bm.target_addr_header = 0x00000000;
c02045ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    bitmap_init_mem(bm);
c02045f4:	ff 75 ec             	pushl  -0x14(%ebp)
c02045f7:	ff 75 e8             	pushl  -0x18(%ebp)
c02045fa:	ff 75 e4             	pushl  -0x1c(%ebp)
c02045fd:	e8 28 fd ff ff       	call   c020432a <bitmap_init_mem>
c0204602:	83 c4 0c             	add    $0xc,%esp
    for(int i = 0;i<8;i++){
c0204605:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020460c:	eb 3b                	jmp    c0204649 <bitmap_test+0x80>
        printk("mem:0x%h\n",bitmap_alloc(bm));
c020460e:	ff 75 ec             	pushl  -0x14(%ebp)
c0204611:	ff 75 e8             	pushl  -0x18(%ebp)
c0204614:	ff 75 e4             	pushl  -0x1c(%ebp)
c0204617:	e8 d5 fe ff ff       	call   c02044f1 <bitmap_alloc>
c020461c:	83 c4 0c             	add    $0xc,%esp
c020461f:	83 ec 08             	sub    $0x8,%esp
c0204622:	50                   	push   %eax
c0204623:	8d 83 36 00 00 00    	lea    0x36(%ebx),%eax
c0204629:	50                   	push   %eax
c020462a:	e8 27 f2 ff ff       	call   c0203856 <printk>
c020462f:	83 c4 10             	add    $0x10,%esp
        bitmap_release_one_page(bm,0x0);
c0204632:	6a 00                	push   $0x0
c0204634:	ff 75 ec             	pushl  -0x14(%ebp)
c0204637:	ff 75 e8             	pushl  -0x18(%ebp)
c020463a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020463d:	e8 04 fe ff ff       	call   c0204446 <bitmap_release_one_page>
c0204642:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<8;i++){
c0204645:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0204649:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c020464d:	7e bf                	jle    c020460e <bitmap_test+0x45>
    }
    printk("alloc_page:0x%h\n",bitmap_alloc_one_page(bm,0xf010));
c020464f:	68 10 f0 00 00       	push   $0xf010
c0204654:	ff 75 ec             	pushl  -0x14(%ebp)
c0204657:	ff 75 e8             	pushl  -0x18(%ebp)
c020465a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020465d:	e8 07 fd ff ff       	call   c0204369 <bitmap_alloc_one_page>
c0204662:	83 c4 10             	add    $0x10,%esp
c0204665:	83 ec 08             	sub    $0x8,%esp
c0204668:	50                   	push   %eax
c0204669:	8d 83 40 00 00 00    	lea    0x40(%ebx),%eax
c020466f:	50                   	push   %eax
c0204670:	e8 e1 f1 ff ff       	call   c0203856 <printk>
c0204675:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<16;i++){
c0204678:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020467f:	eb 2b                	jmp    c02046ac <bitmap_test+0xe3>
        printk("mem:0x%h\n",bitmap_alloc(bm));
c0204681:	83 ec 04             	sub    $0x4,%esp
c0204684:	ff 75 ec             	pushl  -0x14(%ebp)
c0204687:	ff 75 e8             	pushl  -0x18(%ebp)
c020468a:	ff 75 e4             	pushl  -0x1c(%ebp)
c020468d:	e8 5f fe ff ff       	call   c02044f1 <bitmap_alloc>
c0204692:	83 c4 10             	add    $0x10,%esp
c0204695:	83 ec 08             	sub    $0x8,%esp
c0204698:	50                   	push   %eax
c0204699:	8d 83 36 00 00 00    	lea    0x36(%ebx),%eax
c020469f:	50                   	push   %eax
c02046a0:	e8 b1 f1 ff ff       	call   c0203856 <printk>
c02046a5:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<16;i++){
c02046a8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02046ac:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c02046b0:	7e cf                	jle    c0204681 <bitmap_test+0xb8>
    }
c02046b2:	90                   	nop
c02046b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02046b6:	c9                   	leave  
c02046b7:	c3                   	ret    

c02046b8 <pmm_page_no_to_addr>:
pm_page_t *page_array = (pm_page_t*)0xC0000100;       
pm_multi_link_t * MULTI_LINK;   //用大写来表示很重要 并且定义为结构体指针，用->更加美观了～
pm_multi_link_t multi_link_struct={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
pm_page_t * SINGLE_LINK = NULL ;
//获取page编号对应的addr
static uint32_t pmm_page_no_to_addr(uint32_t page_no){
c02046b8:	55                   	push   %ebp
c02046b9:	89 e5                	mov    %esp,%ebp
c02046bb:	e8 40 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046c0:	05 40 39 00 00       	add    $0x3940,%eax
	return (page_no<<12)+pmm_page_start;
c02046c5:	8b 55 08             	mov    0x8(%ebp),%edx
c02046c8:	c1 e2 0c             	shl    $0xc,%edx
c02046cb:	8b 80 d0 91 08 00    	mov    0x891d0(%eax),%eax
c02046d1:	01 d0                	add    %edx,%eax
}
c02046d3:	5d                   	pop    %ebp
c02046d4:	c3                   	ret    

c02046d5 <addr_to_pmm_page_no>:

//addr转为page_no
static uint32_t addr_to_pmm_page_no(uint32_t addr){
c02046d5:	55                   	push   %ebp
c02046d6:	89 e5                	mov    %esp,%ebp
c02046d8:	e8 23 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046dd:	05 23 39 00 00       	add    $0x3923,%eax
	return (addr-pmm_page_start)>>12;
c02046e2:	8b 80 d0 91 08 00    	mov    0x891d0(%eax),%eax
c02046e8:	8b 55 08             	mov    0x8(%ebp),%edx
c02046eb:	29 c2                	sub    %eax,%edx
c02046ed:	89 d0                	mov    %edx,%eax
c02046ef:	c1 e8 0c             	shr    $0xc,%eax
}
c02046f2:	5d                   	pop    %ebp
c02046f3:	c3                   	ret    

c02046f4 <c_to_uint32>:

//将 page_c_t枚举类型转化为对应的块大小 如 (page_c_t)_256——> (uint32_t)256
static uint32_t c_to_uint32(page_c_t ph){
c02046f4:	55                   	push   %ebp
c02046f5:	89 e5                	mov    %esp,%ebp
c02046f7:	83 ec 10             	sub    $0x10,%esp
c02046fa:	e8 01 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046ff:	05 01 39 00 00       	add    $0x3901,%eax
	uint32_t re = 1;
c0204704:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
	re = re<<ph;
c020470b:	8b 45 08             	mov    0x8(%ebp),%eax
c020470e:	89 c1                	mov    %eax,%ecx
c0204710:	d3 65 fc             	shll   %cl,-0x4(%ebp)
	return re;
c0204713:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0204716:	c9                   	leave  
c0204717:	c3                   	ret    

c0204718 <get_partner_page_no>:

static uint32_t get_partner_page_no(uint32_t page_no,page_c_t type){
c0204718:	55                   	push   %ebp
c0204719:	89 e5                	mov    %esp,%ebp
c020471b:	83 ec 10             	sub    $0x10,%esp
c020471e:	e8 dd 28 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204723:	05 dd 38 00 00       	add    $0x38dd,%eax
	//--|--|--|--|--|--| 如图 必须整数倍或者0
	uint32_t v1 = c_to_uint32(type);
c0204728:	ff 75 0c             	pushl  0xc(%ebp)
c020472b:	e8 c4 ff ff ff       	call   c02046f4 <c_to_uint32>
c0204730:	83 c4 04             	add    $0x4,%esp
c0204733:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t v2 = 2*v1;
c0204736:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204739:	01 c0                	add    %eax,%eax
c020473b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if((page_no - v1)%v2 == 0)
c020473e:	8b 45 08             	mov    0x8(%ebp),%eax
c0204741:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0204744:	ba 00 00 00 00       	mov    $0x0,%edx
c0204749:	f7 75 f8             	divl   -0x8(%ebp)
c020474c:	89 d0                	mov    %edx,%eax
c020474e:	85 c0                	test   %eax,%eax
c0204750:	75 08                	jne    c020475a <get_partner_page_no+0x42>
		return page_no-v1;
c0204752:	8b 45 08             	mov    0x8(%ebp),%eax
c0204755:	2b 45 fc             	sub    -0x4(%ebp),%eax
c0204758:	eb 08                	jmp    c0204762 <get_partner_page_no+0x4a>
	else
		return page_no+v1;
c020475a:	8b 55 08             	mov    0x8(%ebp),%edx
c020475d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204760:	01 d0                	add    %edx,%eax
}
c0204762:	c9                   	leave  
c0204763:	c3                   	ret    

c0204764 <append_block>:


//向链表添加块（用于初始化链表以及free后添加块）
//此处可以使用##连接宏（但是我偏不）
static void append_block(int page_no,page_c_t c){
c0204764:	55                   	push   %ebp
c0204765:	89 e5                	mov    %esp,%ebp
c0204767:	53                   	push   %ebx
c0204768:	83 ec 10             	sub    $0x10,%esp
c020476b:	e8 90 28 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204770:	05 90 38 00 00       	add    $0x3890,%eax
	page_array[page_no].next = NULL ;     //一定要设置 新加入块的下个指针为NULL
c0204775:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c020477b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020477e:	89 ca                	mov    %ecx,%edx
c0204780:	01 d2                	add    %edx,%edx
c0204782:	01 ca                	add    %ecx,%edx
c0204784:	c1 e2 02             	shl    $0x2,%edx
c0204787:	01 da                	add    %ebx,%edx
c0204789:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	pm_page_t * header;
	switch(c){
c0204790:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204794:	0f 87 cd 02 00 00    	ja     c0204a67 <.L39+0x22>
c020479a:	8b 55 0c             	mov    0xc(%ebp),%edx
c020479d:	c1 e2 02             	shl    $0x2,%edx
c02047a0:	8b 94 02 54 00 00 00 	mov    0x54(%edx,%eax,1),%edx
c02047a7:	01 c2                	add    %eax,%edx
c02047a9:	ff e2                	jmp    *%edx

c02047ab <.L12>:
		case _1:
			header = MULTI_LINK ->_1;
c02047ab:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047b1:	8b 12                	mov    (%edx),%edx
c02047b3:	8b 12                	mov    (%edx),%edx
c02047b5:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02047b8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02047bc:	0f 85 86 02 00 00    	jne    c0204a48 <.L39+0x3>
				MULTI_LINK ->_1 = &(page_array[page_no]);
c02047c2:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02047c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02047cb:	89 ca                	mov    %ecx,%edx
c02047cd:	01 d2                	add    %edx,%edx
c02047cf:	01 ca                	add    %ecx,%edx
c02047d1:	c1 e2 02             	shl    $0x2,%edx
c02047d4:	89 d1                	mov    %edx,%ecx
c02047d6:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047dc:	8b 12                	mov    (%edx),%edx
c02047de:	01 d9                	add    %ebx,%ecx
c02047e0:	89 0a                	mov    %ecx,(%edx)
			break;
c02047e2:	e9 61 02 00 00       	jmp    c0204a48 <.L39+0x3>

c02047e7 <.L14>:
		case _2:
			header = MULTI_LINK ->_2;
c02047e7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047ed:	8b 12                	mov    (%edx),%edx
c02047ef:	8b 52 04             	mov    0x4(%edx),%edx
c02047f2:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02047f5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02047f9:	0f 85 4c 02 00 00    	jne    c0204a4b <.L39+0x6>
				MULTI_LINK ->_2 = &(page_array[page_no]);
c02047ff:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204805:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204808:	89 ca                	mov    %ecx,%edx
c020480a:	01 d2                	add    %edx,%edx
c020480c:	01 ca                	add    %ecx,%edx
c020480e:	c1 e2 02             	shl    $0x2,%edx
c0204811:	89 d1                	mov    %edx,%ecx
c0204813:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204819:	8b 12                	mov    (%edx),%edx
c020481b:	01 d9                	add    %ebx,%ecx
c020481d:	89 4a 04             	mov    %ecx,0x4(%edx)
			break;
c0204820:	e9 26 02 00 00       	jmp    c0204a4b <.L39+0x6>

c0204825 <.L15>:
		case _4:
			header = MULTI_LINK ->_4;
c0204825:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020482b:	8b 12                	mov    (%edx),%edx
c020482d:	8b 52 08             	mov    0x8(%edx),%edx
c0204830:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204833:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204837:	0f 85 11 02 00 00    	jne    c0204a4e <.L39+0x9>
				MULTI_LINK ->_4 = &(page_array[page_no]);
c020483d:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204843:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204846:	89 ca                	mov    %ecx,%edx
c0204848:	01 d2                	add    %edx,%edx
c020484a:	01 ca                	add    %ecx,%edx
c020484c:	c1 e2 02             	shl    $0x2,%edx
c020484f:	89 d1                	mov    %edx,%ecx
c0204851:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204857:	8b 12                	mov    (%edx),%edx
c0204859:	01 d9                	add    %ebx,%ecx
c020485b:	89 4a 08             	mov    %ecx,0x8(%edx)
			break;
c020485e:	e9 eb 01 00 00       	jmp    c0204a4e <.L39+0x9>

c0204863 <.L16>:
		case _8:
			header = MULTI_LINK ->_8;
c0204863:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204869:	8b 12                	mov    (%edx),%edx
c020486b:	8b 52 0c             	mov    0xc(%edx),%edx
c020486e:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204871:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204875:	0f 85 d6 01 00 00    	jne    c0204a51 <.L39+0xc>
				MULTI_LINK ->_8 = &(page_array[page_no]);
c020487b:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204881:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204884:	89 ca                	mov    %ecx,%edx
c0204886:	01 d2                	add    %edx,%edx
c0204888:	01 ca                	add    %ecx,%edx
c020488a:	c1 e2 02             	shl    $0x2,%edx
c020488d:	89 d1                	mov    %edx,%ecx
c020488f:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204895:	8b 12                	mov    (%edx),%edx
c0204897:	01 d9                	add    %ebx,%ecx
c0204899:	89 4a 0c             	mov    %ecx,0xc(%edx)
			break;
c020489c:	e9 b0 01 00 00       	jmp    c0204a51 <.L39+0xc>

c02048a1 <.L17>:
		case _16:
			header = MULTI_LINK ->_16;
c02048a1:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048a7:	8b 12                	mov    (%edx),%edx
c02048a9:	8b 52 10             	mov    0x10(%edx),%edx
c02048ac:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02048af:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02048b3:	0f 85 9b 01 00 00    	jne    c0204a54 <.L39+0xf>
				MULTI_LINK ->_16 = &(page_array[page_no]);
c02048b9:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02048bf:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02048c2:	89 ca                	mov    %ecx,%edx
c02048c4:	01 d2                	add    %edx,%edx
c02048c6:	01 ca                	add    %ecx,%edx
c02048c8:	c1 e2 02             	shl    $0x2,%edx
c02048cb:	89 d1                	mov    %edx,%ecx
c02048cd:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048d3:	8b 12                	mov    (%edx),%edx
c02048d5:	01 d9                	add    %ebx,%ecx
c02048d7:	89 4a 10             	mov    %ecx,0x10(%edx)
			break;
c02048da:	e9 75 01 00 00       	jmp    c0204a54 <.L39+0xf>

c02048df <.L18>:
		case _32:
			header = MULTI_LINK ->_32;
c02048df:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048e5:	8b 12                	mov    (%edx),%edx
c02048e7:	8b 52 14             	mov    0x14(%edx),%edx
c02048ea:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02048ed:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02048f1:	0f 85 60 01 00 00    	jne    c0204a57 <.L39+0x12>
				MULTI_LINK ->_32 = &(page_array[page_no]);
c02048f7:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02048fd:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204900:	89 ca                	mov    %ecx,%edx
c0204902:	01 d2                	add    %edx,%edx
c0204904:	01 ca                	add    %ecx,%edx
c0204906:	c1 e2 02             	shl    $0x2,%edx
c0204909:	89 d1                	mov    %edx,%ecx
c020490b:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204911:	8b 12                	mov    (%edx),%edx
c0204913:	01 d9                	add    %ebx,%ecx
c0204915:	89 4a 14             	mov    %ecx,0x14(%edx)
			break;
c0204918:	e9 3a 01 00 00       	jmp    c0204a57 <.L39+0x12>

c020491d <.L19>:
		case _64:
			header = MULTI_LINK ->_64;
c020491d:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204923:	8b 12                	mov    (%edx),%edx
c0204925:	8b 52 18             	mov    0x18(%edx),%edx
c0204928:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020492b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020492f:	0f 85 25 01 00 00    	jne    c0204a5a <.L39+0x15>
				MULTI_LINK ->_64 = &(page_array[page_no]);
c0204935:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c020493b:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020493e:	89 ca                	mov    %ecx,%edx
c0204940:	01 d2                	add    %edx,%edx
c0204942:	01 ca                	add    %ecx,%edx
c0204944:	c1 e2 02             	shl    $0x2,%edx
c0204947:	89 d1                	mov    %edx,%ecx
c0204949:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020494f:	8b 12                	mov    (%edx),%edx
c0204951:	01 d9                	add    %ebx,%ecx
c0204953:	89 4a 18             	mov    %ecx,0x18(%edx)
			break;
c0204956:	e9 ff 00 00 00       	jmp    c0204a5a <.L39+0x15>

c020495b <.L20>:
		case _128:
			header = MULTI_LINK ->_128;
c020495b:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204961:	8b 12                	mov    (%edx),%edx
c0204963:	8b 52 1c             	mov    0x1c(%edx),%edx
c0204966:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204969:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020496d:	0f 85 ea 00 00 00    	jne    c0204a5d <.L39+0x18>
				MULTI_LINK ->_128 = &(page_array[page_no]);
c0204973:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204979:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020497c:	89 ca                	mov    %ecx,%edx
c020497e:	01 d2                	add    %edx,%edx
c0204980:	01 ca                	add    %ecx,%edx
c0204982:	c1 e2 02             	shl    $0x2,%edx
c0204985:	89 d1                	mov    %edx,%ecx
c0204987:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020498d:	8b 12                	mov    (%edx),%edx
c020498f:	01 d9                	add    %ebx,%ecx
c0204991:	89 4a 1c             	mov    %ecx,0x1c(%edx)
			break;
c0204994:	e9 c4 00 00 00       	jmp    c0204a5d <.L39+0x18>

c0204999 <.L21>:
		case _256:
			header = MULTI_LINK ->_256;
c0204999:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020499f:	8b 12                	mov    (%edx),%edx
c02049a1:	8b 52 20             	mov    0x20(%edx),%edx
c02049a4:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02049a7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02049ab:	0f 85 af 00 00 00    	jne    c0204a60 <.L39+0x1b>
				MULTI_LINK ->_256 = &(page_array[page_no]);
c02049b1:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02049b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02049ba:	89 ca                	mov    %ecx,%edx
c02049bc:	01 d2                	add    %edx,%edx
c02049be:	01 ca                	add    %ecx,%edx
c02049c0:	c1 e2 02             	shl    $0x2,%edx
c02049c3:	89 d1                	mov    %edx,%ecx
c02049c5:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049cb:	8b 12                	mov    (%edx),%edx
c02049cd:	01 d9                	add    %ebx,%ecx
c02049cf:	89 4a 20             	mov    %ecx,0x20(%edx)
			break;
c02049d2:	e9 89 00 00 00       	jmp    c0204a60 <.L39+0x1b>

c02049d7 <.L22>:
		case _512:
			header = MULTI_LINK ->_512;
c02049d7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049dd:	8b 12                	mov    (%edx),%edx
c02049df:	8b 52 24             	mov    0x24(%edx),%edx
c02049e2:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02049e5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02049e9:	75 78                	jne    c0204a63 <.L39+0x1e>
				MULTI_LINK ->_512 = &(page_array[page_no]);
c02049eb:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02049f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02049f4:	89 ca                	mov    %ecx,%edx
c02049f6:	01 d2                	add    %edx,%edx
c02049f8:	01 ca                	add    %ecx,%edx
c02049fa:	c1 e2 02             	shl    $0x2,%edx
c02049fd:	89 d1                	mov    %edx,%ecx
c02049ff:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204a05:	8b 12                	mov    (%edx),%edx
c0204a07:	01 d9                	add    %ebx,%ecx
c0204a09:	89 4a 24             	mov    %ecx,0x24(%edx)
			break;
c0204a0c:	eb 55                	jmp    c0204a63 <.L39+0x1e>

c0204a0e <.L23>:
		case _1024:
			header = MULTI_LINK ->_1024;
c0204a0e:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204a14:	8b 12                	mov    (%edx),%edx
c0204a16:	8b 52 28             	mov    0x28(%edx),%edx
c0204a19:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204a1c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204a20:	75 44                	jne    c0204a66 <.L39+0x21>
				MULTI_LINK ->_1024 = &(page_array[page_no]);
c0204a22:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204a28:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204a2b:	89 ca                	mov    %ecx,%edx
c0204a2d:	01 d2                	add    %edx,%edx
c0204a2f:	01 ca                	add    %ecx,%edx
c0204a31:	c1 e2 02             	shl    $0x2,%edx
c0204a34:	89 d1                	mov    %edx,%ecx
c0204a36:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204a3c:	8b 12                	mov    (%edx),%edx
c0204a3e:	01 d9                	add    %ebx,%ecx
c0204a40:	89 4a 28             	mov    %ecx,0x28(%edx)
			break;
c0204a43:	eb 21                	jmp    c0204a66 <.L39+0x21>

c0204a45 <.L39>:
		case _erro:
			break;
c0204a45:	90                   	nop
c0204a46:	eb 1f                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a48:	90                   	nop
c0204a49:	eb 1c                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a4b:	90                   	nop
c0204a4c:	eb 19                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a4e:	90                   	nop
c0204a4f:	eb 16                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a51:	90                   	nop
c0204a52:	eb 13                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a54:	90                   	nop
c0204a55:	eb 10                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a57:	90                   	nop
c0204a58:	eb 0d                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a5a:	90                   	nop
c0204a5b:	eb 0a                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a5d:	90                   	nop
c0204a5e:	eb 07                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a60:	90                   	nop
c0204a61:	eb 04                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a63:	90                   	nop
c0204a64:	eb 01                	jmp    c0204a67 <.L39+0x22>
			break;
c0204a66:	90                   	nop
	}
	if(header!=NULL){
c0204a67:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204a6b:	74 36                	je     c0204aa3 <.L39+0x5e>
		pm_page_t * probe = header;
c0204a6d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204a70:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;(probe->next)!=NULL;probe = probe->next)
c0204a73:	eb 09                	jmp    c0204a7e <.L39+0x39>
c0204a75:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204a78:	8b 52 04             	mov    0x4(%edx),%edx
c0204a7b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0204a7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204a81:	8b 52 04             	mov    0x4(%edx),%edx
c0204a84:	85 d2                	test   %edx,%edx
c0204a86:	75 ed                	jne    c0204a75 <.L39+0x30>
			;
		(probe -> next)=&(page_array[page_no]);
c0204a88:	8b 88 24 f0 ff ff    	mov    -0xfdc(%eax),%ecx
c0204a8e:	8b 55 08             	mov    0x8(%ebp),%edx
c0204a91:	89 d0                	mov    %edx,%eax
c0204a93:	01 c0                	add    %eax,%eax
c0204a95:	01 d0                	add    %edx,%eax
c0204a97:	c1 e0 02             	shl    $0x2,%eax
c0204a9a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204a9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204aa0:	89 50 04             	mov    %edx,0x4(%eax)
	}
}
c0204aa3:	90                   	nop
c0204aa4:	83 c4 10             	add    $0x10,%esp
c0204aa7:	5b                   	pop    %ebx
c0204aa8:	5d                   	pop    %ebp
c0204aa9:	c3                   	ret    

c0204aaa <pop_block>:

//从链表中取出一个块 链表为空返回ERRO_POP_BLOCK
static uint32_t pop_block(page_c_t c){
c0204aaa:	55                   	push   %ebp
c0204aab:	89 e5                	mov    %esp,%ebp
c0204aad:	83 ec 10             	sub    $0x10,%esp
c0204ab0:	e8 4b 25 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204ab5:	05 4b 35 00 00       	add    $0x354b,%eax
	pm_page_t * header;
	switch(c){
c0204aba:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0204abe:	0f 87 1e 03 00 00    	ja     c0204de2 <.L66+0x26>
c0204ac4:	8b 55 08             	mov    0x8(%ebp),%edx
c0204ac7:	c1 e2 02             	shl    $0x2,%edx
c0204aca:	8b 94 02 84 00 00 00 	mov    0x84(%edx,%eax,1),%edx
c0204ad1:	01 c2                	add    %eax,%edx
c0204ad3:	ff e2                	jmp    *%edx

c0204ad5 <.L54>:
		case _1:
			header = MULTI_LINK ->_1;
c0204ad5:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204adb:	8b 12                	mov    (%edx),%edx
c0204add:	8b 12                	mov    (%edx),%edx
c0204adf:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204ae2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ae6:	75 0a                	jne    c0204af2 <.L54+0x1d>
				return ERRO_POP_BLOCK;
c0204ae8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204aed:	e9 26 03 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204af2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204af5:	8b 52 04             	mov    0x4(%edx),%edx
c0204af8:	85 d2                	test   %edx,%edx
c0204afa:	0f 85 c3 02 00 00    	jne    c0204dc3 <.L66+0x7>
				MULTI_LINK ->_1 =NULL;
c0204b00:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b06:	8b 00                	mov    (%eax),%eax
c0204b08:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				return header->page_no;
c0204b0e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b11:	8b 00                	mov    (%eax),%eax
c0204b13:	e9 00 03 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204b18 <.L56>:
			}
			break;
		case _2:
			header = MULTI_LINK ->_2;
c0204b18:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204b1e:	8b 12                	mov    (%edx),%edx
c0204b20:	8b 52 04             	mov    0x4(%edx),%edx
c0204b23:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b26:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b2a:	75 0a                	jne    c0204b36 <.L56+0x1e>
				return ERRO_POP_BLOCK;
c0204b2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b31:	e9 e2 02 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204b36:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204b39:	8b 52 04             	mov    0x4(%edx),%edx
c0204b3c:	85 d2                	test   %edx,%edx
c0204b3e:	0f 85 82 02 00 00    	jne    c0204dc6 <.L66+0xa>
				MULTI_LINK ->_2 = NULL;
c0204b44:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b4a:	8b 00                	mov    (%eax),%eax
c0204b4c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
				return header->page_no;
c0204b53:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b56:	8b 00                	mov    (%eax),%eax
c0204b58:	e9 bb 02 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204b5d <.L57>:
			}
			break;
		case _4:
			header = MULTI_LINK ->_4;
c0204b5d:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204b63:	8b 12                	mov    (%edx),%edx
c0204b65:	8b 52 08             	mov    0x8(%edx),%edx
c0204b68:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b6b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b6f:	75 0a                	jne    c0204b7b <.L57+0x1e>
				return ERRO_POP_BLOCK;
c0204b71:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b76:	e9 9d 02 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204b7b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204b7e:	8b 52 04             	mov    0x4(%edx),%edx
c0204b81:	85 d2                	test   %edx,%edx
c0204b83:	0f 85 40 02 00 00    	jne    c0204dc9 <.L66+0xd>
				MULTI_LINK ->_4 = NULL;
c0204b89:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b8f:	8b 00                	mov    (%eax),%eax
c0204b91:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				return header->page_no;
c0204b98:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b9b:	8b 00                	mov    (%eax),%eax
c0204b9d:	e9 76 02 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204ba2 <.L58>:
			}
			break;
		case _8:
			header = MULTI_LINK ->_8;
c0204ba2:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204ba8:	8b 12                	mov    (%edx),%edx
c0204baa:	8b 52 0c             	mov    0xc(%edx),%edx
c0204bad:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204bb0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204bb4:	75 0a                	jne    c0204bc0 <.L58+0x1e>
				return ERRO_POP_BLOCK;
c0204bb6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204bbb:	e9 58 02 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204bc0:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204bc3:	8b 52 04             	mov    0x4(%edx),%edx
c0204bc6:	85 d2                	test   %edx,%edx
c0204bc8:	0f 85 fe 01 00 00    	jne    c0204dcc <.L66+0x10>
				MULTI_LINK ->_8 = NULL;
c0204bce:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204bd4:	8b 00                	mov    (%eax),%eax
c0204bd6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				return header->page_no;
c0204bdd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204be0:	8b 00                	mov    (%eax),%eax
c0204be2:	e9 31 02 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204be7 <.L59>:
			}
			break;
		case _16:
			header = MULTI_LINK ->_16;
c0204be7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204bed:	8b 12                	mov    (%edx),%edx
c0204bef:	8b 52 10             	mov    0x10(%edx),%edx
c0204bf2:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204bf5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204bf9:	75 0a                	jne    c0204c05 <.L59+0x1e>
				return ERRO_POP_BLOCK;
c0204bfb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c00:	e9 13 02 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204c05:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c08:	8b 52 04             	mov    0x4(%edx),%edx
c0204c0b:	85 d2                	test   %edx,%edx
c0204c0d:	0f 85 bc 01 00 00    	jne    c0204dcf <.L66+0x13>
				MULTI_LINK ->_16 = NULL;
c0204c13:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204c19:	8b 00                	mov    (%eax),%eax
c0204c1b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
				return header->page_no;
c0204c22:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c25:	8b 00                	mov    (%eax),%eax
c0204c27:	e9 ec 01 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204c2c <.L60>:
			}
			break;
		case _32:
			header = MULTI_LINK ->_32;
c0204c2c:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c32:	8b 12                	mov    (%edx),%edx
c0204c34:	8b 52 14             	mov    0x14(%edx),%edx
c0204c37:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204c3a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204c3e:	75 0a                	jne    c0204c4a <.L60+0x1e>
				return ERRO_POP_BLOCK;
c0204c40:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c45:	e9 ce 01 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204c4a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c4d:	8b 52 04             	mov    0x4(%edx),%edx
c0204c50:	85 d2                	test   %edx,%edx
c0204c52:	0f 85 7a 01 00 00    	jne    c0204dd2 <.L66+0x16>
				MULTI_LINK ->_32 = NULL;
c0204c58:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204c5e:	8b 00                	mov    (%eax),%eax
c0204c60:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
				return header->page_no;
c0204c67:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c6a:	8b 00                	mov    (%eax),%eax
c0204c6c:	e9 a7 01 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204c71 <.L61>:
			}
			break;
		case _64:
			header = MULTI_LINK ->_64;
c0204c71:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c77:	8b 12                	mov    (%edx),%edx
c0204c79:	8b 52 18             	mov    0x18(%edx),%edx
c0204c7c:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204c7f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204c83:	75 0a                	jne    c0204c8f <.L61+0x1e>
				return ERRO_POP_BLOCK;
c0204c85:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c8a:	e9 89 01 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204c8f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c92:	8b 52 04             	mov    0x4(%edx),%edx
c0204c95:	85 d2                	test   %edx,%edx
c0204c97:	0f 85 38 01 00 00    	jne    c0204dd5 <.L66+0x19>
				MULTI_LINK ->_64 = NULL;
c0204c9d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ca3:	8b 00                	mov    (%eax),%eax
c0204ca5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
				return header->page_no;
c0204cac:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204caf:	8b 00                	mov    (%eax),%eax
c0204cb1:	e9 62 01 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204cb6 <.L62>:
			}
			break;
		case _128:
			header = MULTI_LINK ->_128;
c0204cb6:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204cbc:	8b 12                	mov    (%edx),%edx
c0204cbe:	8b 52 1c             	mov    0x1c(%edx),%edx
c0204cc1:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204cc4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204cc8:	75 0a                	jne    c0204cd4 <.L62+0x1e>
				return ERRO_POP_BLOCK;
c0204cca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204ccf:	e9 44 01 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204cd4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204cd7:	8b 52 04             	mov    0x4(%edx),%edx
c0204cda:	85 d2                	test   %edx,%edx
c0204cdc:	0f 85 f6 00 00 00    	jne    c0204dd8 <.L66+0x1c>
				MULTI_LINK ->_128 = NULL;
c0204ce2:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ce8:	8b 00                	mov    (%eax),%eax
c0204cea:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
				return header->page_no;
c0204cf1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204cf4:	8b 00                	mov    (%eax),%eax
c0204cf6:	e9 1d 01 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204cfb <.L63>:
			}
			break;
		case _256:
			header = MULTI_LINK ->_256;
c0204cfb:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204d01:	8b 12                	mov    (%edx),%edx
c0204d03:	8b 52 20             	mov    0x20(%edx),%edx
c0204d06:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204d09:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204d0d:	75 0a                	jne    c0204d19 <.L63+0x1e>
				return ERRO_POP_BLOCK;
c0204d0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d14:	e9 ff 00 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204d19:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204d1c:	8b 52 04             	mov    0x4(%edx),%edx
c0204d1f:	85 d2                	test   %edx,%edx
c0204d21:	0f 85 b4 00 00 00    	jne    c0204ddb <.L66+0x1f>
				MULTI_LINK ->_256 = NULL;
c0204d27:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d2d:	8b 00                	mov    (%eax),%eax
c0204d2f:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				return header->page_no;
c0204d36:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d39:	8b 00                	mov    (%eax),%eax
c0204d3b:	e9 d8 00 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204d40 <.L64>:
			}
			break;
		case _512:
			header = MULTI_LINK ->_512;
c0204d40:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204d46:	8b 12                	mov    (%edx),%edx
c0204d48:	8b 52 24             	mov    0x24(%edx),%edx
c0204d4b:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204d4e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204d52:	75 0a                	jne    c0204d5e <.L64+0x1e>
				return ERRO_POP_BLOCK;
c0204d54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d59:	e9 ba 00 00 00       	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204d5e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204d61:	8b 52 04             	mov    0x4(%edx),%edx
c0204d64:	85 d2                	test   %edx,%edx
c0204d66:	75 76                	jne    c0204dde <.L66+0x22>
				MULTI_LINK ->_512 = NULL;
c0204d68:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d6e:	8b 00                	mov    (%eax),%eax
c0204d70:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
				return header->page_no;
c0204d77:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d7a:	8b 00                	mov    (%eax),%eax
c0204d7c:	e9 97 00 00 00       	jmp    c0204e18 <.L66+0x5c>

c0204d81 <.L65>:
			}
			break;
		case _1024:
			header = MULTI_LINK ->_1024;
c0204d81:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204d87:	8b 12                	mov    (%edx),%edx
c0204d89:	8b 52 28             	mov    0x28(%edx),%edx
c0204d8c:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204d8f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204d93:	75 07                	jne    c0204d9c <.L65+0x1b>
				return ERRO_POP_BLOCK;
c0204d95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d9a:	eb 7c                	jmp    c0204e18 <.L66+0x5c>
			if(header->next==NULL){
c0204d9c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204d9f:	8b 52 04             	mov    0x4(%edx),%edx
c0204da2:	85 d2                	test   %edx,%edx
c0204da4:	75 3b                	jne    c0204de1 <.L66+0x25>
				MULTI_LINK ->_1024 = NULL;
c0204da6:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204dac:	8b 00                	mov    (%eax),%eax
c0204dae:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
				return header->page_no;
c0204db5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204db8:	8b 00                	mov    (%eax),%eax
c0204dba:	eb 5c                	jmp    c0204e18 <.L66+0x5c>

c0204dbc <.L66>:
			}
			break;
		case _erro:
			return ERRO_POP_BLOCK; 
c0204dbc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204dc1:	eb 55                	jmp    c0204e18 <.L66+0x5c>
			break;
c0204dc3:	90                   	nop
c0204dc4:	eb 1c                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dc6:	90                   	nop
c0204dc7:	eb 19                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dc9:	90                   	nop
c0204dca:	eb 16                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dcc:	90                   	nop
c0204dcd:	eb 13                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dcf:	90                   	nop
c0204dd0:	eb 10                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dd2:	90                   	nop
c0204dd3:	eb 0d                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dd5:	90                   	nop
c0204dd6:	eb 0a                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dd8:	90                   	nop
c0204dd9:	eb 07                	jmp    c0204de2 <.L66+0x26>
			break;
c0204ddb:	90                   	nop
c0204ddc:	eb 04                	jmp    c0204de2 <.L66+0x26>
			break;
c0204dde:	90                   	nop
c0204ddf:	eb 01                	jmp    c0204de2 <.L66+0x26>
			break;
c0204de1:	90                   	nop
			break;
	}
	pm_page_t * probe = header;
c0204de2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204de5:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;probe->next->next!=NULL;probe = probe->next)
c0204de8:	eb 09                	jmp    c0204df3 <.L66+0x37>
c0204dea:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ded:	8b 40 04             	mov    0x4(%eax),%eax
c0204df0:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204df3:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204df6:	8b 40 04             	mov    0x4(%eax),%eax
c0204df9:	8b 40 04             	mov    0x4(%eax),%eax
c0204dfc:	85 c0                	test   %eax,%eax
c0204dfe:	75 ea                	jne    c0204dea <.L66+0x2e>
		;
	uint32_t return_page_no = probe->next->page_no;
c0204e00:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204e03:	8b 40 04             	mov    0x4(%eax),%eax
c0204e06:	8b 00                	mov    (%eax),%eax
c0204e08:	89 45 f4             	mov    %eax,-0xc(%ebp)
	probe->next=NULL;
c0204e0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204e0e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	return return_page_no;
c0204e15:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204e18:	c9                   	leave  
c0204e19:	c3                   	ret    

c0204e1a <find_and_pop_block>:
 
//free合并块使用函数
//如果链表中没有 返回ERRO_POP_BLOCK 否则返回对应page_no
static uint32_t find_and_pop_block(uint32_t target_page_no,page_c_t ph){
c0204e1a:	55                   	push   %ebp
c0204e1b:	89 e5                	mov    %esp,%ebp
c0204e1d:	83 ec 10             	sub    $0x10,%esp
c0204e20:	e8 db 21 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204e25:	05 db 31 00 00       	add    $0x31db,%eax
	pm_page_t * header;
	switch(ph){
c0204e2a:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204e2e:	0f 87 d3 00 00 00    	ja     c0204f07 <.L117+0xa>
c0204e34:	8b 55 0c             	mov    0xc(%ebp),%edx
c0204e37:	c1 e2 02             	shl    $0x2,%edx
c0204e3a:	8b 94 02 b4 00 00 00 	mov    0xb4(%edx,%eax,1),%edx
c0204e41:	01 c2                	add    %eax,%edx
c0204e43:	ff e2                	jmp    *%edx

c0204e45 <.L105>:
		case _1:
			header = MULTI_LINK -> _1;
c0204e45:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e4b:	8b 00                	mov    (%eax),%eax
c0204e4d:	8b 00                	mov    (%eax),%eax
c0204e4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e52:	e9 b0 00 00 00       	jmp    c0204f07 <.L117+0xa>

c0204e57 <.L107>:
		case _2:
			header = MULTI_LINK -> _2;
c0204e57:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e5d:	8b 00                	mov    (%eax),%eax
c0204e5f:	8b 40 04             	mov    0x4(%eax),%eax
c0204e62:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e65:	e9 9d 00 00 00       	jmp    c0204f07 <.L117+0xa>

c0204e6a <.L108>:
		case _4:
			header = MULTI_LINK -> _4;
c0204e6a:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e70:	8b 00                	mov    (%eax),%eax
c0204e72:	8b 40 08             	mov    0x8(%eax),%eax
c0204e75:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e78:	e9 8a 00 00 00       	jmp    c0204f07 <.L117+0xa>

c0204e7d <.L109>:
		case _8:
			header = MULTI_LINK -> _8;
c0204e7d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e83:	8b 00                	mov    (%eax),%eax
c0204e85:	8b 40 0c             	mov    0xc(%eax),%eax
c0204e88:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e8b:	eb 7a                	jmp    c0204f07 <.L117+0xa>

c0204e8d <.L110>:
		case _16:
			header = MULTI_LINK -> _16;
c0204e8d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e93:	8b 00                	mov    (%eax),%eax
c0204e95:	8b 40 10             	mov    0x10(%eax),%eax
c0204e98:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e9b:	eb 6a                	jmp    c0204f07 <.L117+0xa>

c0204e9d <.L111>:
		case _32:
			header = MULTI_LINK -> _32;
c0204e9d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ea3:	8b 00                	mov    (%eax),%eax
c0204ea5:	8b 40 14             	mov    0x14(%eax),%eax
c0204ea8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204eab:	eb 5a                	jmp    c0204f07 <.L117+0xa>

c0204ead <.L112>:
		case _64:
			header = MULTI_LINK -> _64;
c0204ead:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204eb3:	8b 00                	mov    (%eax),%eax
c0204eb5:	8b 40 18             	mov    0x18(%eax),%eax
c0204eb8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204ebb:	eb 4a                	jmp    c0204f07 <.L117+0xa>

c0204ebd <.L113>:
		case _128:
			header = MULTI_LINK -> _128;
c0204ebd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ec3:	8b 00                	mov    (%eax),%eax
c0204ec5:	8b 40 1c             	mov    0x1c(%eax),%eax
c0204ec8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204ecb:	eb 3a                	jmp    c0204f07 <.L117+0xa>

c0204ecd <.L114>:
		case _256:
			header = MULTI_LINK -> _256;
c0204ecd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ed3:	8b 00                	mov    (%eax),%eax
c0204ed5:	8b 40 20             	mov    0x20(%eax),%eax
c0204ed8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204edb:	eb 2a                	jmp    c0204f07 <.L117+0xa>

c0204edd <.L115>:
		case _512:
			header = MULTI_LINK -> _512;
c0204edd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ee3:	8b 00                	mov    (%eax),%eax
c0204ee5:	8b 40 24             	mov    0x24(%eax),%eax
c0204ee8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204eeb:	eb 1a                	jmp    c0204f07 <.L117+0xa>

c0204eed <.L116>:
		case _1024:
			header = MULTI_LINK -> _1024;
c0204eed:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ef3:	8b 00                	mov    (%eax),%eax
c0204ef5:	8b 40 28             	mov    0x28(%eax),%eax
c0204ef8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204efb:	eb 0a                	jmp    c0204f07 <.L117+0xa>

c0204efd <.L117>:
		case _erro:
			return ERRO_POP_BLOCK;
c0204efd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204f02:	e9 8c 00 00 00       	jmp    c0204f93 <.L117+0x96>
	}
	if(header == NULL)
c0204f07:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204f0b:	75 07                	jne    c0204f14 <.L117+0x17>
		return ERRO_POP_BLOCK;
c0204f0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204f12:	eb 7f                	jmp    c0204f93 <.L117+0x96>
	if(header->next==NULL){
c0204f14:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204f17:	8b 40 04             	mov    0x4(%eax),%eax
c0204f1a:	85 c0                	test   %eax,%eax
c0204f1c:	75 1a                	jne    c0204f38 <.L117+0x3b>
		if(header->page_no==target_page_no){
c0204f1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204f21:	8b 00                	mov    (%eax),%eax
c0204f23:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f26:	75 10                	jne    c0204f38 <.L117+0x3b>
			pop_block(ph);
c0204f28:	ff 75 0c             	pushl  0xc(%ebp)
c0204f2b:	e8 7a fb ff ff       	call   c0204aaa <pop_block>
c0204f30:	83 c4 04             	add    $0x4,%esp
			return target_page_no;
c0204f33:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f36:	eb 5b                	jmp    c0204f93 <.L117+0x96>
		}
	}
	pm_page_t * probe = header ;
c0204f38:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204f3b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(; probe->next!=NULL;probe=probe->next){
c0204f3e:	eb 2a                	jmp    c0204f6a <.L117+0x6d>
		if(probe->next->page_no == target_page_no){
c0204f40:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f43:	8b 40 04             	mov    0x4(%eax),%eax
c0204f46:	8b 00                	mov    (%eax),%eax
c0204f48:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f4b:	75 14                	jne    c0204f61 <.L117+0x64>
			probe->next = probe->next->next;
c0204f4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f50:	8b 40 04             	mov    0x4(%eax),%eax
c0204f53:	8b 50 04             	mov    0x4(%eax),%edx
c0204f56:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f59:	89 50 04             	mov    %edx,0x4(%eax)
			return target_page_no;
c0204f5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f5f:	eb 32                	jmp    c0204f93 <.L117+0x96>
	for(; probe->next!=NULL;probe=probe->next){
c0204f61:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f64:	8b 40 04             	mov    0x4(%eax),%eax
c0204f67:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204f6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f6d:	8b 40 04             	mov    0x4(%eax),%eax
c0204f70:	85 c0                	test   %eax,%eax
c0204f72:	75 cc                	jne    c0204f40 <.L117+0x43>
		}
	}
	if(probe->page_no == target_page_no){
c0204f74:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f77:	8b 00                	mov    (%eax),%eax
c0204f79:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f7c:	75 10                	jne    c0204f8e <.L117+0x91>
		pop_block(ph);
c0204f7e:	ff 75 0c             	pushl  0xc(%ebp)
c0204f81:	e8 24 fb ff ff       	call   c0204aaa <pop_block>
c0204f86:	83 c4 04             	add    $0x4,%esp
		return target_page_no;
c0204f89:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f8c:	eb 05                	jmp    c0204f93 <.L117+0x96>
	}

	return ERRO_POP_BLOCK;
c0204f8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0204f93:	c9                   	leave  
c0204f94:	c3                   	ret    

c0204f95 <get_max_pm_addr>:

//从multi_boot结构体中取出需要管理的地址空间大小 
static uint32_t get_max_pm_addr(){          //qemu默认为128M
c0204f95:	55                   	push   %ebp
c0204f96:	89 e5                	mov    %esp,%ebp
c0204f98:	56                   	push   %esi
c0204f99:	53                   	push   %ebx
c0204f9a:	83 ec 10             	sub    $0x10,%esp
c0204f9d:	e8 62 20 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0204fa2:	81 c3 5e 30 00 00    	add    $0x305e,%ebx
	uint32_t max_addr=0;
c0204fa8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204faf:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c0204fb5:	8b 00                	mov    (%eax),%eax
c0204fb7:	8b 40 30             	mov    0x30(%eax),%eax
c0204fba:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0204fbd:	eb 6a                	jmp    c0205029 <get_max_pm_addr+0x94>
		printk("0x%h-0x%h-0x%h-%d\n",pm_entry_cur->base_addr_low,pm_entry_cur->length_low,pm_entry_cur->base_addr_low+pm_entry_cur->length_low,pm_entry_cur->type);
c0204fbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fc2:	8b 48 14             	mov    0x14(%eax),%ecx
c0204fc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fc8:	8b 50 04             	mov    0x4(%eax),%edx
c0204fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fce:	8b 40 0c             	mov    0xc(%eax),%eax
c0204fd1:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0204fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fd7:	8b 50 0c             	mov    0xc(%eax),%edx
c0204fda:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fdd:	8b 40 04             	mov    0x4(%eax),%eax
c0204fe0:	83 ec 0c             	sub    $0xc,%esp
c0204fe3:	51                   	push   %ecx
c0204fe4:	56                   	push   %esi
c0204fe5:	52                   	push   %edx
c0204fe6:	50                   	push   %eax
c0204fe7:	8d 83 e4 00 00 00    	lea    0xe4(%ebx),%eax
c0204fed:	50                   	push   %eax
c0204fee:	e8 63 e8 ff ff       	call   c0203856 <printk>
c0204ff3:	83 c4 20             	add    $0x20,%esp
		if(pm_entry_cur->type==1&&max_addr<pm_entry_cur->base_addr_low+pm_entry_cur->length_low)
c0204ff6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204ff9:	8b 40 14             	mov    0x14(%eax),%eax
c0204ffc:	83 f8 01             	cmp    $0x1,%eax
c0204fff:	75 24                	jne    c0205025 <get_max_pm_addr+0x90>
c0205001:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0205004:	8b 50 04             	mov    0x4(%eax),%edx
c0205007:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020500a:	8b 40 0c             	mov    0xc(%eax),%eax
c020500d:	01 d0                	add    %edx,%eax
c020500f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0205012:	73 11                	jae    c0205025 <get_max_pm_addr+0x90>
			max_addr=pm_entry_cur->base_addr_low+pm_entry_cur->length_low;		
c0205014:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0205017:	8b 50 04             	mov    0x4(%eax),%edx
c020501a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020501d:	8b 40 0c             	mov    0xc(%eax),%eax
c0205020:	01 d0                	add    %edx,%eax
c0205022:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0205025:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
c0205029:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c020502f:	8b 00                	mov    (%eax),%eax
c0205031:	8b 50 30             	mov    0x30(%eax),%edx
c0205034:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c020503a:	8b 00                	mov    (%eax),%eax
c020503c:	8b 40 2c             	mov    0x2c(%eax),%eax
c020503f:	01 d0                	add    %edx,%eax
c0205041:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0205044:	0f 82 75 ff ff ff    	jb     c0204fbf <get_max_pm_addr+0x2a>
	}
	return max_addr;
c020504a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c020504d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0205050:	5b                   	pop    %ebx
c0205051:	5e                   	pop    %esi
c0205052:	5d                   	pop    %ebp
c0205053:	c3                   	ret    

c0205054 <pmm_page_init>:

//初始化页描述结构体以及装载链表
static void pmm_page_init(){  //初始化链表结构体并且填充链表
c0205054:	55                   	push   %ebp
c0205055:	89 e5                	mov    %esp,%ebp
c0205057:	53                   	push   %ebx
c0205058:	83 ec 14             	sub    $0x14,%esp
c020505b:	e8 a4 1f 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205060:	81 c3 a0 2f 00 00    	add    $0x2fa0,%ebx
	MULTI_LINK=&multi_link_struct;
c0205066:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020506c:	8d 93 a0 91 08 00    	lea    0x891a0(%ebx),%edx
c0205072:	89 10                	mov    %edx,(%eax)
	MULTI_LINK->_1=NULL;
c0205074:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020507a:	8b 00                	mov    (%eax),%eax
c020507c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	MULTI_LINK->_2=NULL;
c0205082:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205088:	8b 00                	mov    (%eax),%eax
c020508a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	MULTI_LINK->_4=NULL;
c0205091:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205097:	8b 00                	mov    (%eax),%eax
c0205099:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	MULTI_LINK->_8=NULL;
c02050a0:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050a6:	8b 00                	mov    (%eax),%eax
c02050a8:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	MULTI_LINK->_16=NULL;
c02050af:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050b5:	8b 00                	mov    (%eax),%eax
c02050b7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	MULTI_LINK->_32=NULL;
c02050be:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050c4:	8b 00                	mov    (%eax),%eax
c02050c6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	MULTI_LINK->_64=NULL;
c02050cd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050d3:	8b 00                	mov    (%eax),%eax
c02050d5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	MULTI_LINK->_128=NULL;
c02050dc:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050e2:	8b 00                	mov    (%eax),%eax
c02050e4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	MULTI_LINK->_256=NULL;
c02050eb:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050f1:	8b 00                	mov    (%eax),%eax
c02050f3:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	MULTI_LINK->_512=NULL;
c02050fa:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205100:	8b 00                	mov    (%eax),%eax
c0205102:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	MULTI_LINK->_1024=NULL;
c0205109:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020510f:	8b 00                	mov    (%eax),%eax
c0205111:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	//我们将要余出至多1023页来作为单页分配的一个缓冲区 这个缓冲区是与伙伴算法独立的 便于快速分配单页
	for(int i=0;i<pmm_max_page_no;i++){
c0205118:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c020511f:	eb 51                	jmp    c0205172 <pmm_page_init+0x11e>
		page_array[i].page_no = i;
c0205121:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c0205127:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020512a:	89 d0                	mov    %edx,%eax
c020512c:	01 c0                	add    %eax,%eax
c020512e:	01 d0                	add    %edx,%eax
c0205130:	c1 e0 02             	shl    $0x2,%eax
c0205133:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0205136:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205139:	89 02                	mov    %eax,(%edx)
		page_array[i].state = 1;
c020513b:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c0205141:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205144:	89 d0                	mov    %edx,%eax
c0205146:	01 c0                	add    %eax,%eax
c0205148:	01 d0                	add    %edx,%eax
c020514a:	c1 e0 02             	shl    $0x2,%eax
c020514d:	01 c8                	add    %ecx,%eax
c020514f:	c6 40 08 01          	movb   $0x1,0x8(%eax)
		page_array[i].next = NULL;
c0205153:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c0205159:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020515c:	89 d0                	mov    %edx,%eax
c020515e:	01 c0                	add    %eax,%eax
c0205160:	01 d0                	add    %edx,%eax
c0205162:	c1 e0 02             	shl    $0x2,%eax
c0205165:	01 c8                	add    %ecx,%eax
c0205167:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	for(int i=0;i<pmm_max_page_no;i++){
c020516e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0205172:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205175:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c020517b:	39 c2                	cmp    %eax,%edx
c020517d:	72 a2                	jb     c0205121 <pmm_page_init+0xcd>
	}
	//装载链表
	append_block(0,_1);    //1页链表
c020517f:	6a 00                	push   $0x0
c0205181:	6a 00                	push   $0x0
c0205183:	e8 dc f5 ff ff       	call   c0204764 <append_block>
c0205188:	83 c4 08             	add    $0x8,%esp
	append_block(1,_1);
c020518b:	6a 00                	push   $0x0
c020518d:	6a 01                	push   $0x1
c020518f:	e8 d0 f5 ff ff       	call   c0204764 <append_block>
c0205194:	83 c4 08             	add    $0x8,%esp

	append_block(2,_2);    //2页链表
c0205197:	6a 01                	push   $0x1
c0205199:	6a 02                	push   $0x2
c020519b:	e8 c4 f5 ff ff       	call   c0204764 <append_block>
c02051a0:	83 c4 08             	add    $0x8,%esp

	append_block(4,_4);
c02051a3:	6a 02                	push   $0x2
c02051a5:	6a 04                	push   $0x4
c02051a7:	e8 b8 f5 ff ff       	call   c0204764 <append_block>
c02051ac:	83 c4 08             	add    $0x8,%esp

	append_block(8,_8);
c02051af:	6a 03                	push   $0x3
c02051b1:	6a 08                	push   $0x8
c02051b3:	e8 ac f5 ff ff       	call   c0204764 <append_block>
c02051b8:	83 c4 08             	add    $0x8,%esp

	append_block(16,_16);
c02051bb:	6a 04                	push   $0x4
c02051bd:	6a 10                	push   $0x10
c02051bf:	e8 a0 f5 ff ff       	call   c0204764 <append_block>
c02051c4:	83 c4 08             	add    $0x8,%esp

	append_block(32,_32);
c02051c7:	6a 05                	push   $0x5
c02051c9:	6a 20                	push   $0x20
c02051cb:	e8 94 f5 ff ff       	call   c0204764 <append_block>
c02051d0:	83 c4 08             	add    $0x8,%esp

	append_block(64,_64);
c02051d3:	6a 06                	push   $0x6
c02051d5:	6a 40                	push   $0x40
c02051d7:	e8 88 f5 ff ff       	call   c0204764 <append_block>
c02051dc:	83 c4 08             	add    $0x8,%esp

	append_block(128,_128);
c02051df:	6a 07                	push   $0x7
c02051e1:	68 80 00 00 00       	push   $0x80
c02051e6:	e8 79 f5 ff ff       	call   c0204764 <append_block>
c02051eb:	83 c4 08             	add    $0x8,%esp

	append_block(256,_256);
c02051ee:	6a 08                	push   $0x8
c02051f0:	68 00 01 00 00       	push   $0x100
c02051f5:	e8 6a f5 ff ff       	call   c0204764 <append_block>
c02051fa:	83 c4 08             	add    $0x8,%esp

	append_block(512,_512);
c02051fd:	6a 09                	push   $0x9
c02051ff:	68 00 02 00 00       	push   $0x200
c0205204:	e8 5b f5 ff ff       	call   c0204764 <append_block>
c0205209:	83 c4 08             	add    $0x8,%esp

	append_block(1024,_1024);
c020520c:	6a 0a                	push   $0xa
c020520e:	68 00 04 00 00       	push   $0x400
c0205213:	e8 4c f5 ff ff       	call   c0204764 <append_block>
c0205218:	83 c4 08             	add    $0x8,%esp


	int temp_page_no=2048;
c020521b:	c7 45 f0 00 08 00 00 	movl   $0x800,-0x10(%ebp)
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0205222:	eb 14                	jmp    c0205238 <pmm_page_init+0x1e4>
		append_block(temp_page_no,_1024);
c0205224:	6a 0a                	push   $0xa
c0205226:	ff 75 f0             	pushl  -0x10(%ebp)
c0205229:	e8 36 f5 ff ff       	call   c0204764 <append_block>
c020522e:	83 c4 08             	add    $0x8,%esp
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c0205231:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c0205238:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c020523e:	8d 90 00 fc ff ff    	lea    -0x400(%eax),%edx
c0205244:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0205247:	39 c2                	cmp    %eax,%edx
c0205249:	77 d9                	ja     c0205224 <pmm_page_init+0x1d0>
	}
	singel_page_first_no = temp_page_no;   //将第一个单页缓冲区的编号存放好
c020524b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020524e:	89 83 dc 91 08 00    	mov    %eax,0x891dc(%ebx)

	printk("we have %d pages for singel page alloc!\n",pmm_max_page_no-temp_page_no);
c0205254:	8b 93 d8 91 08 00    	mov    0x891d8(%ebx),%edx
c020525a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020525d:	29 c2                	sub    %eax,%edx
c020525f:	89 d0                	mov    %edx,%eax
c0205261:	83 ec 08             	sub    $0x8,%esp
c0205264:	50                   	push   %eax
c0205265:	8d 83 f8 00 00 00    	lea    0xf8(%ebx),%eax
c020526b:	50                   	push   %eax
c020526c:	e8 e5 e5 ff ff       	call   c0203856 <printk>
c0205271:	83 c4 10             	add    $0x10,%esp
	pm_page_t * temp_single_probe = NULL;
c0205274:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c020527b:	eb 57                	jmp    c02052d4 <pmm_page_init+0x280>
		if(SINGLE_LINK == NULL){
c020527d:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205283:	85 c0                	test   %eax,%eax
c0205285:	75 25                	jne    c02052ac <pmm_page_init+0x258>
			SINGLE_LINK=&(page_array[temp_page_no]);
c0205287:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c020528d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205290:	89 d0                	mov    %edx,%eax
c0205292:	01 c0                	add    %eax,%eax
c0205294:	01 d0                	add    %edx,%eax
c0205296:	c1 e0 02             	shl    $0x2,%eax
c0205299:	01 c8                	add    %ecx,%eax
c020529b:	89 83 cc 91 08 00    	mov    %eax,0x891cc(%ebx)
			temp_single_probe = SINGLE_LINK ;
c02052a1:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c02052a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
c02052aa:	eb 24                	jmp    c02052d0 <pmm_page_init+0x27c>
		}
		else{
			temp_single_probe->next = &(page_array[temp_page_no]);
c02052ac:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c02052b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02052b5:	89 d0                	mov    %edx,%eax
c02052b7:	01 c0                	add    %eax,%eax
c02052b9:	01 d0                	add    %edx,%eax
c02052bb:	c1 e0 02             	shl    $0x2,%eax
c02052be:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c02052c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02052c4:	89 50 04             	mov    %edx,0x4(%eax)
			temp_single_probe = temp_single_probe -> next;
c02052c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02052ca:	8b 40 04             	mov    0x4(%eax),%eax
c02052cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c02052d0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02052d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02052d7:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c02052dd:	39 c2                	cmp    %eax,%edx
c02052df:	72 9c                	jb     c020527d <pmm_page_init+0x229>
		}
	}
}
c02052e1:	90                   	nop
c02052e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02052e5:	c9                   	leave  
c02052e6:	c3                   	ret    

c02052e7 <alloc_helper>:





static uint32_t alloc_helper(page_c_t target_ph,page_c_t pop_ph,uint32_t pop_page_no){
c02052e7:	55                   	push   %ebp
c02052e8:	89 e5                	mov    %esp,%ebp
c02052ea:	83 ec 10             	sub    $0x10,%esp
c02052ed:	e8 0e 1d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02052f2:	05 0e 2d 00 00       	add    $0x2d0e,%eax
	for(;pop_ph!=target_ph;pop_ph--){
c02052f7:	eb 2e                	jmp    c0205327 <alloc_helper+0x40>
		uint32_t append_page_no = pop_page_no+(c_to_uint32(pop_ph)/2);
c02052f9:	ff 75 0c             	pushl  0xc(%ebp)
c02052fc:	e8 f3 f3 ff ff       	call   c02046f4 <c_to_uint32>
c0205301:	83 c4 04             	add    $0x4,%esp
c0205304:	d1 e8                	shr    %eax
c0205306:	89 c2                	mov    %eax,%edx
c0205308:	8b 45 10             	mov    0x10(%ebp),%eax
c020530b:	01 d0                	add    %edx,%eax
c020530d:	89 45 fc             	mov    %eax,-0x4(%ebp)
		append_block(append_page_no,pop_page_no-1);
c0205310:	8b 45 10             	mov    0x10(%ebp),%eax
c0205313:	8d 50 ff             	lea    -0x1(%eax),%edx
c0205316:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205319:	52                   	push   %edx
c020531a:	50                   	push   %eax
c020531b:	e8 44 f4 ff ff       	call   c0204764 <append_block>
c0205320:	83 c4 08             	add    $0x8,%esp
	for(;pop_ph!=target_ph;pop_ph--){
c0205323:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0205327:	8b 45 0c             	mov    0xc(%ebp),%eax
c020532a:	3b 45 08             	cmp    0x8(%ebp),%eax
c020532d:	75 ca                	jne    c02052f9 <alloc_helper+0x12>
	}
	return pop_page_no;
c020532f:	8b 45 10             	mov    0x10(%ebp),%eax
}
c0205332:	c9                   	leave  
c0205333:	c3                   	ret    

c0205334 <pmm_alloc_pages>:



//伙伴算法多页分配
pm_alloc_t pmm_alloc_pages(uint32_t page_count){
c0205334:	55                   	push   %ebp
c0205335:	89 e5                	mov    %esp,%ebp
c0205337:	83 ec 30             	sub    $0x30,%esp
c020533a:	e8 c1 1c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020533f:	05 c1 2c 00 00       	add    $0x2cc1,%eax
	pm_alloc_t return_struct = {0,_erro,0}; 
c0205344:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c020534b:	c7 45 dc 0b 00 00 00 	movl   $0xb,-0x24(%ebp)
c0205352:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
	if (page_count>1024||page_count==0)
c0205356:	81 7d 0c 00 04 00 00 	cmpl   $0x400,0xc(%ebp)
c020535d:	77 06                	ja     c0205365 <pmm_alloc_pages+0x31>
c020535f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0205363:	75 19                	jne    c020537e <pmm_alloc_pages+0x4a>
		return return_struct;    //分配失败
c0205365:	8b 45 08             	mov    0x8(%ebp),%eax
c0205368:	8b 55 d8             	mov    -0x28(%ebp),%edx
c020536b:	89 10                	mov    %edx,(%eax)
c020536d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0205370:	89 50 04             	mov    %edx,0x4(%eax)
c0205373:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0205376:	89 50 08             	mov    %edx,0x8(%eax)
c0205379:	e9 ce 00 00 00       	jmp    c020544c <pmm_alloc_pages+0x118>
	//来点骚操作
	//获取需要分配的页数
	uint32_t page_count_probe=page_count;
c020537e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0205381:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter1 = 0;
c0205384:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;page_count_probe!=0 ;counter1++,page_count_probe=page_count_probe>>1)
c020538b:	eb 07                	jmp    c0205394 <pmm_alloc_pages+0x60>
c020538d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0205391:	d1 6d fc             	shrl   -0x4(%ebp)
c0205394:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0205398:	75 f3                	jne    c020538d <pmm_alloc_pages+0x59>
		;
	uint32_t counter2= counter1-1;
c020539a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020539d:	83 e8 01             	sub    $0x1,%eax
c02053a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(page_count==(1<<counter2))
c02053a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02053a6:	ba 01 00 00 00       	mov    $0x1,%edx
c02053ab:	89 c1                	mov    %eax,%ecx
c02053ad:	d3 e2                	shl    %cl,%edx
c02053af:	89 d0                	mov    %edx,%eax
c02053b1:	39 45 0c             	cmp    %eax,0xc(%ebp)
c02053b4:	75 04                	jne    c02053ba <pmm_alloc_pages+0x86>
		counter1--;
c02053b6:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	//此时的counter1即为pm_c_t枚举的对应值
	page_c_t ph = counter1;
c02053ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02053bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	page_c_t origin_ph = ph;    //存放原始ph
c02053c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02053c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pop_page_no = ERRO_POP_BLOCK;
c02053c6:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	for(;ph<_erro;ph++){
c02053cd:	eb 18                	jmp    c02053e7 <pmm_alloc_pages+0xb3>
		pop_page_no = pop_block(ph);
c02053cf:	ff 75 f4             	pushl  -0xc(%ebp)
c02053d2:	e8 d3 f6 ff ff       	call   c0204aaa <pop_block>
c02053d7:	83 c4 04             	add    $0x4,%esp
c02053da:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(pop_page_no!=ERRO_POP_BLOCK)
c02053dd:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c02053e1:	75 0c                	jne    c02053ef <pmm_alloc_pages+0xbb>
	for(;ph<_erro;ph++){
c02053e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02053e7:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
c02053eb:	76 e2                	jbe    c02053cf <pmm_alloc_pages+0x9b>
c02053ed:	eb 01                	jmp    c02053f0 <pmm_alloc_pages+0xbc>
			break;
c02053ef:	90                   	nop
	}
	if(pop_page_no==ERRO_POP_BLOCK){
c02053f0:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c02053f4:	75 16                	jne    c020540c <pmm_alloc_pages+0xd8>
		return return_struct;    //分配失败
c02053f6:	8b 45 08             	mov    0x8(%ebp),%eax
c02053f9:	8b 55 d8             	mov    -0x28(%ebp),%edx
c02053fc:	89 10                	mov    %edx,(%eax)
c02053fe:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0205401:	89 50 04             	mov    %edx,0x4(%eax)
c0205404:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0205407:	89 50 08             	mov    %edx,0x8(%eax)
c020540a:	eb 40                	jmp    c020544c <pmm_alloc_pages+0x118>
	}
	else{
		uint32_t target_page_no = alloc_helper(origin_ph,ph,pop_page_no);
c020540c:	ff 75 f0             	pushl  -0x10(%ebp)
c020540f:	ff 75 f4             	pushl  -0xc(%ebp)
c0205412:	ff 75 e8             	pushl  -0x18(%ebp)
c0205415:	e8 cd fe ff ff       	call   c02052e7 <alloc_helper>
c020541a:	83 c4 0c             	add    $0xc,%esp
c020541d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return_struct.addr = pmm_page_no_to_addr(target_page_no);
c0205420:	ff 75 e4             	pushl  -0x1c(%ebp)
c0205423:	e8 90 f2 ff ff       	call   c02046b8 <pmm_page_no_to_addr>
c0205428:	83 c4 04             	add    $0x4,%esp
c020542b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		return_struct.state = 1;
c020542e:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
		return_struct.size = origin_ph;
c0205432:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0205435:	89 45 dc             	mov    %eax,-0x24(%ebp)
		return return_struct;
c0205438:	8b 45 08             	mov    0x8(%ebp),%eax
c020543b:	8b 55 d8             	mov    -0x28(%ebp),%edx
c020543e:	89 10                	mov    %edx,(%eax)
c0205440:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0205443:	89 50 04             	mov    %edx,0x4(%eax)
c0205446:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0205449:	89 50 08             	mov    %edx,0x8(%eax)
	}
}
c020544c:	8b 45 08             	mov    0x8(%ebp),%eax
c020544f:	c9                   	leave  
c0205450:	c2 04 00             	ret    $0x4

c0205453 <pmm_alloc_one_page>:

//缓冲区及伙伴算法单页分配
//当缓冲区没有页的时候会调用伙伴算法分配一页
pm_alloc_t pmm_alloc_one_page(){
c0205453:	55                   	push   %ebp
c0205454:	89 e5                	mov    %esp,%ebp
c0205456:	83 ec 20             	sub    $0x20,%esp
c0205459:	e8 a2 1b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020545e:	05 a2 2b 00 00       	add    $0x2ba2,%eax
	pm_alloc_t return_struct = {0,_erro,0};
c0205463:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c020546a:	c7 45 f0 0b 00 00 00 	movl   $0xb,-0x10(%ebp)
c0205471:	c6 45 f4 00          	movb   $0x0,-0xc(%ebp)
	if(SINGLE_LINK!=NULL){
c0205475:	8b 90 cc 91 08 00    	mov    0x891cc(%eax),%edx
c020547b:	85 d2                	test   %edx,%edx
c020547d:	0f 84 ac 00 00 00    	je     c020552f <pmm_alloc_one_page+0xdc>
		pm_page_t * header = SINGLE_LINK;
c0205483:	8b 90 cc 91 08 00    	mov    0x891cc(%eax),%edx
c0205489:	89 55 f8             	mov    %edx,-0x8(%ebp)
		if(header->next==NULL){
c020548c:	8b 55 f8             	mov    -0x8(%ebp),%edx
c020548f:	8b 52 04             	mov    0x4(%edx),%edx
c0205492:	85 d2                	test   %edx,%edx
c0205494:	75 3c                	jne    c02054d2 <pmm_alloc_one_page+0x7f>
			SINGLE_LINK = NULL;
c0205496:	c7 80 cc 91 08 00 00 	movl   $0x0,0x891cc(%eax)
c020549d:	00 00 00 
			return_struct.state = 1;
c02054a0:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c02054a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(header->page_no);
c02054ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02054ae:	8b 00                	mov    (%eax),%eax
c02054b0:	50                   	push   %eax
c02054b1:	e8 02 f2 ff ff       	call   c02046b8 <pmm_page_no_to_addr>
c02054b6:	83 c4 04             	add    $0x4,%esp
c02054b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
			return return_struct;
c02054bc:	8b 45 08             	mov    0x8(%ebp),%eax
c02054bf:	8b 55 ec             	mov    -0x14(%ebp),%edx
c02054c2:	89 10                	mov    %edx,(%eax)
c02054c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02054c7:	89 50 04             	mov    %edx,0x4(%eax)
c02054ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02054cd:	89 50 08             	mov    %edx,0x8(%eax)
c02054d0:	eb 6b                	jmp    c020553d <pmm_alloc_one_page+0xea>
		}
		else{
			pm_page_t * probe = header;
c02054d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02054d5:	89 45 fc             	mov    %eax,-0x4(%ebp)
			for(;probe->next->next!=NULL;probe=probe->next){
c02054d8:	eb 09                	jmp    c02054e3 <pmm_alloc_one_page+0x90>
c02054da:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054dd:	8b 40 04             	mov    0x4(%eax),%eax
c02054e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c02054e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054e6:	8b 40 04             	mov    0x4(%eax),%eax
c02054e9:	8b 40 04             	mov    0x4(%eax),%eax
c02054ec:	85 c0                	test   %eax,%eax
c02054ee:	75 ea                	jne    c02054da <pmm_alloc_one_page+0x87>
				//printk("%d\n",probe->page_no);
				//if(probe->page_no==0){
				//	while(1);
				//}
			}
			return_struct.state = 1;
c02054f0:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c02054f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(probe->next->page_no);
c02054fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054fe:	8b 40 04             	mov    0x4(%eax),%eax
c0205501:	8b 00                	mov    (%eax),%eax
c0205503:	50                   	push   %eax
c0205504:	e8 af f1 ff ff       	call   c02046b8 <pmm_page_no_to_addr>
c0205509:	83 c4 04             	add    $0x4,%esp
c020550c:	89 45 ec             	mov    %eax,-0x14(%ebp)
			probe->next = NULL;
c020550f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205512:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		}
		return return_struct;
c0205519:	8b 45 08             	mov    0x8(%ebp),%eax
c020551c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c020551f:	89 10                	mov    %edx,(%eax)
c0205521:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205524:	89 50 04             	mov    %edx,0x4(%eax)
c0205527:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020552a:	89 50 08             	mov    %edx,0x8(%eax)
c020552d:	eb 0e                	jmp    c020553d <pmm_alloc_one_page+0xea>
	}
	else{
		return pmm_alloc_pages(1);
c020552f:	8b 45 08             	mov    0x8(%ebp),%eax
c0205532:	6a 01                	push   $0x1
c0205534:	50                   	push   %eax
c0205535:	e8 fa fd ff ff       	call   c0205334 <pmm_alloc_pages>
c020553a:	83 c4 04             	add    $0x4,%esp
	}
}
c020553d:	8b 45 08             	mov    0x8(%ebp),%eax
c0205540:	c9                   	leave  
c0205541:	c2 04 00             	ret    $0x4

c0205544 <free_helper>:

static void free_helper(uint32_t page_no,page_c_t size){
c0205544:	55                   	push   %ebp
c0205545:	89 e5                	mov    %esp,%ebp
c0205547:	53                   	push   %ebx
c0205548:	83 ec 14             	sub    $0x14,%esp
c020554b:	e8 b4 1a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205550:	81 c3 b0 2a 00 00    	add    $0x2ab0,%ebx
	printk("free size : %d\n",c_to_uint32(size));
c0205556:	ff 75 0c             	pushl  0xc(%ebp)
c0205559:	e8 96 f1 ff ff       	call   c02046f4 <c_to_uint32>
c020555e:	83 c4 04             	add    $0x4,%esp
c0205561:	83 ec 08             	sub    $0x8,%esp
c0205564:	50                   	push   %eax
c0205565:	8d 83 21 01 00 00    	lea    0x121(%ebx),%eax
c020556b:	50                   	push   %eax
c020556c:	e8 e5 e2 ff ff       	call   c0203856 <printk>
c0205571:	83 c4 10             	add    $0x10,%esp
	uint32_t partner_page_no = get_partner_page_no(page_no,size);
c0205574:	83 ec 08             	sub    $0x8,%esp
c0205577:	ff 75 0c             	pushl  0xc(%ebp)
c020557a:	ff 75 08             	pushl  0x8(%ebp)
c020557d:	e8 96 f1 ff ff       	call   c0204718 <get_partner_page_no>
c0205582:	83 c4 10             	add    $0x10,%esp
c0205585:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(find_and_pop_block(partner_page_no,size)!=ERRO_POP_BLOCK){
c0205588:	83 ec 08             	sub    $0x8,%esp
c020558b:	ff 75 0c             	pushl  0xc(%ebp)
c020558e:	ff 75 f4             	pushl  -0xc(%ebp)
c0205591:	e8 84 f8 ff ff       	call   c0204e1a <find_and_pop_block>
c0205596:	83 c4 10             	add    $0x10,%esp
c0205599:	83 f8 ff             	cmp    $0xffffffff,%eax
c020559c:	74 1f                	je     c02055bd <free_helper+0x79>
		//合并
		free_helper(partner_page_no<page_no?partner_page_no:page_no,size+1);
c020559e:	8b 45 0c             	mov    0xc(%ebp),%eax
c02055a1:	8d 50 01             	lea    0x1(%eax),%edx
c02055a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02055a7:	39 45 08             	cmp    %eax,0x8(%ebp)
c02055aa:	0f 46 45 08          	cmovbe 0x8(%ebp),%eax
c02055ae:	83 ec 08             	sub    $0x8,%esp
c02055b1:	52                   	push   %edx
c02055b2:	50                   	push   %eax
c02055b3:	e8 8c ff ff ff       	call   c0205544 <free_helper>
c02055b8:	83 c4 10             	add    $0x10,%esp
	}
	else{
		append_block(page_no,size);
	}
}
c02055bb:	eb 12                	jmp    c02055cf <free_helper+0x8b>
		append_block(page_no,size);
c02055bd:	8b 45 08             	mov    0x8(%ebp),%eax
c02055c0:	83 ec 08             	sub    $0x8,%esp
c02055c3:	ff 75 0c             	pushl  0xc(%ebp)
c02055c6:	50                   	push   %eax
c02055c7:	e8 98 f1 ff ff       	call   c0204764 <append_block>
c02055cc:	83 c4 10             	add    $0x10,%esp
}
c02055cf:	90                   	nop
c02055d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02055d3:	c9                   	leave  
c02055d4:	c3                   	ret    

c02055d5 <pmm_free_page>:

//free页 返回bool型（定义在typs.h中） True-成功free False-失败
bool pmm_free_page(pm_alloc_t block_disc){
c02055d5:	55                   	push   %ebp
c02055d6:	89 e5                	mov    %esp,%ebp
c02055d8:	53                   	push   %ebx
c02055d9:	83 ec 14             	sub    $0x14,%esp
c02055dc:	e8 23 1a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02055e1:	81 c3 1f 2a 00 00    	add    $0x2a1f,%ebx
	//检查页是否在页编号范围内
	uint32_t page_no = addr_to_pmm_page_no(block_disc.addr);
c02055e7:	8b 45 08             	mov    0x8(%ebp),%eax
c02055ea:	50                   	push   %eax
c02055eb:	e8 e5 f0 ff ff       	call   c02046d5 <addr_to_pmm_page_no>
c02055f0:	83 c4 04             	add    $0x4,%esp
c02055f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(page_no<pmm_max_page_no){
c02055f6:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c02055fc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c02055ff:	73 7f                	jae    c0205680 <pmm_free_page+0xab>
		if(page_no<singel_page_first_no)
c0205601:	8b 83 dc 91 08 00    	mov    0x891dc(%ebx),%eax
c0205607:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c020560a:	73 14                	jae    c0205620 <pmm_free_page+0x4b>
			free_helper(page_no,block_disc.size);
c020560c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020560f:	83 ec 08             	sub    $0x8,%esp
c0205612:	50                   	push   %eax
c0205613:	ff 75 f0             	pushl  -0x10(%ebp)
c0205616:	e8 29 ff ff ff       	call   c0205544 <free_helper>
c020561b:	83 c4 10             	add    $0x10,%esp
c020561e:	eb 59                	jmp    c0205679 <pmm_free_page+0xa4>
		else{
			pm_page_t *probe = SINGLE_LINK;
c0205620:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205626:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if(probe==NULL){
c0205629:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c020562d:	75 25                	jne    c0205654 <pmm_free_page+0x7f>
				SINGLE_LINK=&page_array[page_no];
c020562f:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c0205635:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205638:	89 d0                	mov    %edx,%eax
c020563a:	01 c0                	add    %eax,%eax
c020563c:	01 d0                	add    %edx,%eax
c020563e:	c1 e0 02             	shl    $0x2,%eax
c0205641:	01 c8                	add    %ecx,%eax
c0205643:	89 83 cc 91 08 00    	mov    %eax,0x891cc(%ebx)
c0205649:	eb 2e                	jmp    c0205679 <pmm_free_page+0xa4>
			}
			else{
				for(;probe->next!=NULL;probe=probe->next)
c020564b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020564e:	8b 40 04             	mov    0x4(%eax),%eax
c0205651:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0205654:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205657:	8b 40 04             	mov    0x4(%eax),%eax
c020565a:	85 c0                	test   %eax,%eax
c020565c:	75 ed                	jne    c020564b <pmm_free_page+0x76>
					;
				probe->next = &page_array[page_no];
c020565e:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c0205664:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205667:	89 d0                	mov    %edx,%eax
c0205669:	01 c0                	add    %eax,%eax
c020566b:	01 d0                	add    %edx,%eax
c020566d:	c1 e0 02             	shl    $0x2,%eax
c0205670:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0205673:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205676:	89 50 04             	mov    %edx,0x4(%eax)
			}
		}
		return True;
c0205679:	b8 01 00 00 00       	mov    $0x1,%eax
c020567e:	eb 05                	jmp    c0205685 <pmm_free_page+0xb0>
	}
	else
		return False;
c0205680:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0205685:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205688:	c9                   	leave  
c0205689:	c3                   	ret    

c020568a <counte_helper>:

static uint32_t counte_helper(pm_page_t * probe){
c020568a:	55                   	push   %ebp
c020568b:	89 e5                	mov    %esp,%ebp
c020568d:	83 ec 10             	sub    $0x10,%esp
c0205690:	e8 6b 19 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205695:	05 6b 29 00 00       	add    $0x296b,%eax
	uint32_t counter = 0;
c020569a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02056a1:	eb 0d                	jmp    c02056b0 <counte_helper+0x26>
		counter++;
c02056a3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02056a7:	8b 45 08             	mov    0x8(%ebp),%eax
c02056aa:	8b 40 04             	mov    0x4(%eax),%eax
c02056ad:	89 45 08             	mov    %eax,0x8(%ebp)
c02056b0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c02056b4:	75 ed                	jne    c02056a3 <counte_helper+0x19>
	return counter;
c02056b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c02056b9:	c9                   	leave  
c02056ba:	c3                   	ret    

c02056bb <get_block_count>:

uint32_t * get_block_count(){
c02056bb:	55                   	push   %ebp
c02056bc:	89 e5                	mov    %esp,%ebp
c02056be:	53                   	push   %ebx
c02056bf:	e8 40 19 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02056c4:	81 c3 3c 29 00 00    	add    $0x293c,%ebx
	block_count_array[_1]=counte_helper(MULTI_LINK->_1);
c02056ca:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056d0:	8b 00                	mov    (%eax),%eax
c02056d2:	8b 00                	mov    (%eax),%eax
c02056d4:	50                   	push   %eax
c02056d5:	e8 b0 ff ff ff       	call   c020568a <counte_helper>
c02056da:	83 c4 04             	add    $0x4,%esp
c02056dd:	89 83 60 91 08 00    	mov    %eax,0x89160(%ebx)
	block_count_array[_2]=counte_helper(MULTI_LINK->_2);
c02056e3:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056e9:	8b 00                	mov    (%eax),%eax
c02056eb:	8b 40 04             	mov    0x4(%eax),%eax
c02056ee:	50                   	push   %eax
c02056ef:	e8 96 ff ff ff       	call   c020568a <counte_helper>
c02056f4:	83 c4 04             	add    $0x4,%esp
c02056f7:	89 83 64 91 08 00    	mov    %eax,0x89164(%ebx)
	block_count_array[_4]=counte_helper(MULTI_LINK->_4);
c02056fd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205703:	8b 00                	mov    (%eax),%eax
c0205705:	8b 40 08             	mov    0x8(%eax),%eax
c0205708:	50                   	push   %eax
c0205709:	e8 7c ff ff ff       	call   c020568a <counte_helper>
c020570e:	83 c4 04             	add    $0x4,%esp
c0205711:	89 83 68 91 08 00    	mov    %eax,0x89168(%ebx)
	block_count_array[_8]=counte_helper(MULTI_LINK->_8);
c0205717:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020571d:	8b 00                	mov    (%eax),%eax
c020571f:	8b 40 0c             	mov    0xc(%eax),%eax
c0205722:	50                   	push   %eax
c0205723:	e8 62 ff ff ff       	call   c020568a <counte_helper>
c0205728:	83 c4 04             	add    $0x4,%esp
c020572b:	89 83 6c 91 08 00    	mov    %eax,0x8916c(%ebx)
	block_count_array[_16]=counte_helper(MULTI_LINK->_16);
c0205731:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205737:	8b 00                	mov    (%eax),%eax
c0205739:	8b 40 10             	mov    0x10(%eax),%eax
c020573c:	50                   	push   %eax
c020573d:	e8 48 ff ff ff       	call   c020568a <counte_helper>
c0205742:	83 c4 04             	add    $0x4,%esp
c0205745:	89 83 70 91 08 00    	mov    %eax,0x89170(%ebx)
	block_count_array[_32]=counte_helper(MULTI_LINK->_32);
c020574b:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205751:	8b 00                	mov    (%eax),%eax
c0205753:	8b 40 14             	mov    0x14(%eax),%eax
c0205756:	50                   	push   %eax
c0205757:	e8 2e ff ff ff       	call   c020568a <counte_helper>
c020575c:	83 c4 04             	add    $0x4,%esp
c020575f:	89 83 74 91 08 00    	mov    %eax,0x89174(%ebx)
	block_count_array[_64]=counte_helper(MULTI_LINK->_64);
c0205765:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020576b:	8b 00                	mov    (%eax),%eax
c020576d:	8b 40 18             	mov    0x18(%eax),%eax
c0205770:	50                   	push   %eax
c0205771:	e8 14 ff ff ff       	call   c020568a <counte_helper>
c0205776:	83 c4 04             	add    $0x4,%esp
c0205779:	89 83 78 91 08 00    	mov    %eax,0x89178(%ebx)
	block_count_array[_128]=counte_helper(MULTI_LINK->_128);
c020577f:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205785:	8b 00                	mov    (%eax),%eax
c0205787:	8b 40 1c             	mov    0x1c(%eax),%eax
c020578a:	50                   	push   %eax
c020578b:	e8 fa fe ff ff       	call   c020568a <counte_helper>
c0205790:	83 c4 04             	add    $0x4,%esp
c0205793:	89 83 7c 91 08 00    	mov    %eax,0x8917c(%ebx)
	block_count_array[_256]=counte_helper(MULTI_LINK->_256);
c0205799:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020579f:	8b 00                	mov    (%eax),%eax
c02057a1:	8b 40 20             	mov    0x20(%eax),%eax
c02057a4:	50                   	push   %eax
c02057a5:	e8 e0 fe ff ff       	call   c020568a <counte_helper>
c02057aa:	83 c4 04             	add    $0x4,%esp
c02057ad:	89 83 80 91 08 00    	mov    %eax,0x89180(%ebx)
	block_count_array[_512]=counte_helper(MULTI_LINK->_512);
c02057b3:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02057b9:	8b 00                	mov    (%eax),%eax
c02057bb:	8b 40 24             	mov    0x24(%eax),%eax
c02057be:	50                   	push   %eax
c02057bf:	e8 c6 fe ff ff       	call   c020568a <counte_helper>
c02057c4:	83 c4 04             	add    $0x4,%esp
c02057c7:	89 83 84 91 08 00    	mov    %eax,0x89184(%ebx)
	block_count_array[_1024]=counte_helper(MULTI_LINK->_1024);
c02057cd:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02057d3:	8b 00                	mov    (%eax),%eax
c02057d5:	8b 40 28             	mov    0x28(%eax),%eax
c02057d8:	50                   	push   %eax
c02057d9:	e8 ac fe ff ff       	call   c020568a <counte_helper>
c02057de:	83 c4 04             	add    $0x4,%esp
c02057e1:	89 83 88 91 08 00    	mov    %eax,0x89188(%ebx)
	block_count_array[_erro]=0;
c02057e7:	c7 83 8c 91 08 00 00 	movl   $0x0,0x8918c(%ebx)
c02057ee:	00 00 00 
	return block_count_array;
c02057f1:	8d 83 60 91 08 00    	lea    0x89160(%ebx),%eax
}
c02057f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02057fa:	c9                   	leave  
c02057fb:	c3                   	ret    

c02057fc <get_single_count>:

uint32_t get_single_count(){
c02057fc:	55                   	push   %ebp
c02057fd:	89 e5                	mov    %esp,%ebp
c02057ff:	83 ec 10             	sub    $0x10,%esp
c0205802:	e8 f9 17 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205807:	05 f9 27 00 00       	add    $0x27f9,%eax
	pm_page_t * probe =SINGLE_LINK;
c020580c:	8b 80 cc 91 08 00    	mov    0x891cc(%eax),%eax
c0205812:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter = 0;
c0205815:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c020581c:	eb 0d                	jmp    c020582b <get_single_count+0x2f>
		counter++;
c020581e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205822:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205825:	8b 40 04             	mov    0x4(%eax),%eax
c0205828:	89 45 fc             	mov    %eax,-0x4(%ebp)
c020582b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c020582f:	75 ed                	jne    c020581e <get_single_count+0x22>
	return counter;	
c0205831:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c0205834:	c9                   	leave  
c0205835:	c3                   	ret    

c0205836 <pmm_show_page_count>:

//打印块使用情况的函数 
//懒得挨个写 用宏来解决
// #表示字符串化 ##表示连接生成符号操作
#define MACRO_PMM_1(number) printk("_"#number":%d blocks\n",block_count_array[_##number])
void pmm_show_page_count(){
c0205836:	55                   	push   %ebp
c0205837:	89 e5                	mov    %esp,%ebp
c0205839:	53                   	push   %ebx
c020583a:	83 ec 04             	sub    $0x4,%esp
c020583d:	e8 c2 17 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205842:	81 c3 be 27 00 00    	add    $0x27be,%ebx
	get_block_count();
c0205848:	e8 6e fe ff ff       	call   c02056bb <get_block_count>
	printk("Partner:\n");
c020584d:	83 ec 0c             	sub    $0xc,%esp
c0205850:	8d 83 31 01 00 00    	lea    0x131(%ebx),%eax
c0205856:	50                   	push   %eax
c0205857:	e8 fa df ff ff       	call   c0203856 <printk>
c020585c:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1);
c020585f:	8b 83 60 91 08 00    	mov    0x89160(%ebx),%eax
c0205865:	83 ec 08             	sub    $0x8,%esp
c0205868:	50                   	push   %eax
c0205869:	8d 83 3b 01 00 00    	lea    0x13b(%ebx),%eax
c020586f:	50                   	push   %eax
c0205870:	e8 e1 df ff ff       	call   c0203856 <printk>
c0205875:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(2);
c0205878:	8b 83 64 91 08 00    	mov    0x89164(%ebx),%eax
c020587e:	83 ec 08             	sub    $0x8,%esp
c0205881:	50                   	push   %eax
c0205882:	8d 83 49 01 00 00    	lea    0x149(%ebx),%eax
c0205888:	50                   	push   %eax
c0205889:	e8 c8 df ff ff       	call   c0203856 <printk>
c020588e:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(4);
c0205891:	8b 83 68 91 08 00    	mov    0x89168(%ebx),%eax
c0205897:	83 ec 08             	sub    $0x8,%esp
c020589a:	50                   	push   %eax
c020589b:	8d 83 57 01 00 00    	lea    0x157(%ebx),%eax
c02058a1:	50                   	push   %eax
c02058a2:	e8 af df ff ff       	call   c0203856 <printk>
c02058a7:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(8);
c02058aa:	8b 83 6c 91 08 00    	mov    0x8916c(%ebx),%eax
c02058b0:	83 ec 08             	sub    $0x8,%esp
c02058b3:	50                   	push   %eax
c02058b4:	8d 83 65 01 00 00    	lea    0x165(%ebx),%eax
c02058ba:	50                   	push   %eax
c02058bb:	e8 96 df ff ff       	call   c0203856 <printk>
c02058c0:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(16);
c02058c3:	8b 83 70 91 08 00    	mov    0x89170(%ebx),%eax
c02058c9:	83 ec 08             	sub    $0x8,%esp
c02058cc:	50                   	push   %eax
c02058cd:	8d 83 73 01 00 00    	lea    0x173(%ebx),%eax
c02058d3:	50                   	push   %eax
c02058d4:	e8 7d df ff ff       	call   c0203856 <printk>
c02058d9:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(32);
c02058dc:	8b 83 74 91 08 00    	mov    0x89174(%ebx),%eax
c02058e2:	83 ec 08             	sub    $0x8,%esp
c02058e5:	50                   	push   %eax
c02058e6:	8d 83 82 01 00 00    	lea    0x182(%ebx),%eax
c02058ec:	50                   	push   %eax
c02058ed:	e8 64 df ff ff       	call   c0203856 <printk>
c02058f2:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(64);
c02058f5:	8b 83 78 91 08 00    	mov    0x89178(%ebx),%eax
c02058fb:	83 ec 08             	sub    $0x8,%esp
c02058fe:	50                   	push   %eax
c02058ff:	8d 83 91 01 00 00    	lea    0x191(%ebx),%eax
c0205905:	50                   	push   %eax
c0205906:	e8 4b df ff ff       	call   c0203856 <printk>
c020590b:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(128);
c020590e:	8b 83 7c 91 08 00    	mov    0x8917c(%ebx),%eax
c0205914:	83 ec 08             	sub    $0x8,%esp
c0205917:	50                   	push   %eax
c0205918:	8d 83 a0 01 00 00    	lea    0x1a0(%ebx),%eax
c020591e:	50                   	push   %eax
c020591f:	e8 32 df ff ff       	call   c0203856 <printk>
c0205924:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(256);
c0205927:	8b 83 80 91 08 00    	mov    0x89180(%ebx),%eax
c020592d:	83 ec 08             	sub    $0x8,%esp
c0205930:	50                   	push   %eax
c0205931:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0205937:	50                   	push   %eax
c0205938:	e8 19 df ff ff       	call   c0203856 <printk>
c020593d:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(512);
c0205940:	8b 83 84 91 08 00    	mov    0x89184(%ebx),%eax
c0205946:	83 ec 08             	sub    $0x8,%esp
c0205949:	50                   	push   %eax
c020594a:	8d 83 c0 01 00 00    	lea    0x1c0(%ebx),%eax
c0205950:	50                   	push   %eax
c0205951:	e8 00 df ff ff       	call   c0203856 <printk>
c0205956:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1024);
c0205959:	8b 83 88 91 08 00    	mov    0x89188(%ebx),%eax
c020595f:	83 ec 08             	sub    $0x8,%esp
c0205962:	50                   	push   %eax
c0205963:	8d 83 d0 01 00 00    	lea    0x1d0(%ebx),%eax
c0205969:	50                   	push   %eax
c020596a:	e8 e7 de ff ff       	call   c0203856 <printk>
c020596f:	83 c4 10             	add    $0x10,%esp
	printk("singel buffer have:%d pages!\n",get_single_count());
c0205972:	e8 85 fe ff ff       	call   c02057fc <get_single_count>
c0205977:	83 ec 08             	sub    $0x8,%esp
c020597a:	50                   	push   %eax
c020597b:	8d 83 e1 01 00 00    	lea    0x1e1(%ebx),%eax
c0205981:	50                   	push   %eax
c0205982:	e8 cf de ff ff       	call   c0203856 <printk>
c0205987:	83 c4 10             	add    $0x10,%esp
}
c020598a:	90                   	nop
c020598b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020598e:	c9                   	leave  
c020598f:	c3                   	ret    

c0205990 <pmm_init>:
//取消此宏定义 将宏定义范围限制在此函数中
#undef MACRO_PMM_1(number)

//为内核entry使用的pmm管理模块初始化函数
void pmm_init(){
c0205990:	55                   	push   %ebp
c0205991:	89 e5                	mov    %esp,%ebp
c0205993:	53                   	push   %ebx
c0205994:	83 ec 04             	sub    $0x4,%esp
c0205997:	e8 68 16 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020599c:	81 c3 64 26 00 00    	add    $0x2664,%ebx
	printk("kern_start:0x%h\n",kern_start);
c02059a2:	83 ec 08             	sub    $0x8,%esp
c02059a5:	c7 c0 00 00 10 00    	mov    $0x100000,%eax
c02059ab:	50                   	push   %eax
c02059ac:	8d 83 ff 01 00 00    	lea    0x1ff(%ebx),%eax
c02059b2:	50                   	push   %eax
c02059b3:	e8 9e de ff ff       	call   c0203856 <printk>
c02059b8:	83 c4 10             	add    $0x10,%esp
	printk("kern_end:0x%h\n",kern_end);
c02059bb:	83 ec 08             	sub    $0x8,%esp
c02059be:	c7 c0 00 d0 29 00    	mov    $0x29d000,%eax
c02059c4:	50                   	push   %eax
c02059c5:	8d 83 10 02 00 00    	lea    0x210(%ebx),%eax
c02059cb:	50                   	push   %eax
c02059cc:	e8 85 de ff ff       	call   c0203856 <printk>
c02059d1:	83 c4 10             	add    $0x10,%esp

	//一定要注意 由于分页必须4k对齐 所以此处的物理页管理必须与虚拟页相同 都要4K对齐
	pmm_page_start = ((((uint32_t)kern_end >> 12))+1)<<12;
c02059d4:	c7 c0 00 d0 29 00    	mov    $0x29d000,%eax
c02059da:	c1 e8 0c             	shr    $0xc,%eax
c02059dd:	83 c0 01             	add    $0x1,%eax
c02059e0:	c1 e0 0c             	shl    $0xc,%eax
c02059e3:	89 83 d0 91 08 00    	mov    %eax,0x891d0(%ebx)
	pmm_page_end = (((get_max_pm_addr() >> 12)))<<12;
c02059e9:	e8 a7 f5 ff ff       	call   c0204f95 <get_max_pm_addr>
c02059ee:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02059f3:	89 83 d4 91 08 00    	mov    %eax,0x891d4(%ebx)
	pmm_max_page_no = ((pmm_page_end - pmm_page_start)>>12);
c02059f9:	8b 93 d4 91 08 00    	mov    0x891d4(%ebx),%edx
c02059ff:	8b 83 d0 91 08 00    	mov    0x891d0(%ebx),%eax
c0205a05:	29 c2                	sub    %eax,%edx
c0205a07:	89 d0                	mov    %edx,%eax
c0205a09:	c1 e8 0c             	shr    $0xc,%eax
c0205a0c:	89 83 d8 91 08 00    	mov    %eax,0x891d8(%ebx)
	printk("0x%h\n",pmm_page_start);
c0205a12:	8b 83 d0 91 08 00    	mov    0x891d0(%ebx),%eax
c0205a18:	83 ec 08             	sub    $0x8,%esp
c0205a1b:	50                   	push   %eax
c0205a1c:	8d 83 1f 02 00 00    	lea    0x21f(%ebx),%eax
c0205a22:	50                   	push   %eax
c0205a23:	e8 2e de ff ff       	call   c0203856 <printk>
c0205a28:	83 c4 10             	add    $0x10,%esp
	printk("0x%h\n",pmm_page_end);
c0205a2b:	8b 83 d4 91 08 00    	mov    0x891d4(%ebx),%eax
c0205a31:	83 ec 08             	sub    $0x8,%esp
c0205a34:	50                   	push   %eax
c0205a35:	8d 83 1f 02 00 00    	lea    0x21f(%ebx),%eax
c0205a3b:	50                   	push   %eax
c0205a3c:	e8 15 de ff ff       	call   c0203856 <printk>
c0205a41:	83 c4 10             	add    $0x10,%esp
	printk("%d\n",pmm_max_page_no);
c0205a44:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c0205a4a:	83 ec 08             	sub    $0x8,%esp
c0205a4d:	50                   	push   %eax
c0205a4e:	8d 83 25 02 00 00    	lea    0x225(%ebx),%eax
c0205a54:	50                   	push   %eax
c0205a55:	e8 fc dd ff ff       	call   c0203856 <printk>
c0205a5a:	83 c4 10             	add    $0x10,%esp
	printk("page0:0x%h\n",pmm_page_no_to_addr(32000));
c0205a5d:	83 ec 0c             	sub    $0xc,%esp
c0205a60:	68 00 7d 00 00       	push   $0x7d00
c0205a65:	e8 4e ec ff ff       	call   c02046b8 <pmm_page_no_to_addr>
c0205a6a:	83 c4 10             	add    $0x10,%esp
c0205a6d:	83 ec 08             	sub    $0x8,%esp
c0205a70:	50                   	push   %eax
c0205a71:	8d 83 29 02 00 00    	lea    0x229(%ebx),%eax
c0205a77:	50                   	push   %eax
c0205a78:	e8 d9 dd ff ff       	call   c0203856 <printk>
c0205a7d:	83 c4 10             	add    $0x10,%esp
	pmm_page_init();
c0205a80:	e8 cf f5 ff ff       	call   c0205054 <pmm_page_init>
	printk("page_no:%d\n",SINGLE_LINK->next->page_no);
c0205a85:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205a8b:	8b 40 04             	mov    0x4(%eax),%eax
c0205a8e:	8b 00                	mov    (%eax),%eax
c0205a90:	83 ec 08             	sub    $0x8,%esp
c0205a93:	50                   	push   %eax
c0205a94:	8d 83 35 02 00 00    	lea    0x235(%ebx),%eax
c0205a9a:	50                   	push   %eax
c0205a9b:	e8 b6 dd ff ff       	call   c0203856 <printk>
c0205aa0:	83 c4 10             	add    $0x10,%esp
	printk("***%d***",get_partner_page_no(4,_2));
c0205aa3:	83 ec 08             	sub    $0x8,%esp
c0205aa6:	6a 01                	push   $0x1
c0205aa8:	6a 04                	push   $0x4
c0205aaa:	e8 69 ec ff ff       	call   c0204718 <get_partner_page_no>
c0205aaf:	83 c4 10             	add    $0x10,%esp
c0205ab2:	83 ec 08             	sub    $0x8,%esp
c0205ab5:	50                   	push   %eax
c0205ab6:	8d 83 41 02 00 00    	lea    0x241(%ebx),%eax
c0205abc:	50                   	push   %eax
c0205abd:	e8 94 dd ff ff       	call   c0203856 <printk>
c0205ac2:	83 c4 10             	add    $0x10,%esp
c0205ac5:	90                   	nop
c0205ac6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205ac9:	c9                   	leave  
c0205aca:	c3                   	ret    

c0205acb <set_int_disc>:
int_server_func_t int_server_func_list[256];
interrupt_discripter_t idt_entries[256];    //中断描述符表 idt_entries为表首指针
lidt_target_t lidt_target;
static uint8_t default_inf=0x8E;
static uint16_t kern_cs=0x08; 
static void set_int_disc(int int_no, uint32_t offset, uint16_t selector, uint8_t inf){
c0205acb:	55                   	push   %ebp
c0205acc:	89 e5                	mov    %esp,%ebp
c0205ace:	53                   	push   %ebx
c0205acf:	83 ec 08             	sub    $0x8,%esp
c0205ad2:	e8 29 15 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205ad7:	05 29 25 00 00       	add    $0x2529,%eax
c0205adc:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0205adf:	8b 55 14             	mov    0x14(%ebp),%edx
c0205ae2:	66 89 4d f8          	mov    %cx,-0x8(%ebp)
c0205ae6:	88 55 f4             	mov    %dl,-0xc(%ebp)
	idt_entries[int_no].offset_low=(uint16_t)offset;
c0205ae9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0205aec:	89 d3                	mov    %edx,%ebx
c0205aee:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205af4:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205af7:	66 89 1c ca          	mov    %bx,(%edx,%ecx,8)
	idt_entries[int_no].offset_high=(uint16_t)(offset>>16);
c0205afb:	8b 55 0c             	mov    0xc(%ebp),%edx
c0205afe:	c1 ea 10             	shr    $0x10,%edx
c0205b01:	89 d3                	mov    %edx,%ebx
c0205b03:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205b09:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205b0c:	66 89 5c ca 06       	mov    %bx,0x6(%edx,%ecx,8)
	idt_entries[int_no].selector=selector;
c0205b11:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205b17:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205b1a:	0f b7 5d f8          	movzwl -0x8(%ebp),%ebx
c0205b1e:	66 89 5c ca 02       	mov    %bx,0x2(%edx,%ecx,8)
	idt_entries[int_no].inf=inf;
c0205b23:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205b29:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205b2c:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0205b30:	88 5c ca 05          	mov    %bl,0x5(%edx,%ecx,8)
	idt_entries[int_no].default_bit8=0;
c0205b34:	c7 c0 40 24 29 c0    	mov    $0xc0292440,%eax
c0205b3a:	8b 55 08             	mov    0x8(%ebp),%edx
c0205b3d:	c6 44 d0 04 00       	movb   $0x0,0x4(%eax,%edx,8)
}
c0205b42:	90                   	nop
c0205b43:	83 c4 08             	add    $0x8,%esp
c0205b46:	5b                   	pop    %ebx
c0205b47:	5d                   	pop    %ebp
c0205b48:	c3                   	ret    

c0205b49 <timer_init>:
static void timer_init(uint32_t frequency){
c0205b49:	55                   	push   %ebp
c0205b4a:	89 e5                	mov    %esp,%ebp
c0205b4c:	53                   	push   %ebx
c0205b4d:	83 ec 14             	sub    $0x14,%esp
c0205b50:	e8 af 14 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205b55:	81 c3 ab 24 00 00    	add    $0x24ab,%ebx
	// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h
    // 输入频率为 1193180，frequency 即每秒中断次数
    uint32_t divisor = 1193180 / frequency;
c0205b5b:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0205b60:	ba 00 00 00 00       	mov    $0x0,%edx
c0205b65:	f7 75 08             	divl   0x8(%ebp)
c0205b68:	89 45 f4             	mov    %eax,-0xc(%ebp)
    // D7 D6 D5 D4 D3 D2 D1 D0
    // 0  0  1  1  0  1  1  0
    // 即就是 36 H
    // 设置 8253/8254 芯片工作在模式 3 下
    outb(0x43, 0x36);
c0205b6b:	83 ec 08             	sub    $0x8,%esp
c0205b6e:	6a 36                	push   $0x36
c0205b70:	6a 43                	push   $0x43
c0205b72:	e8 c4 db ff ff       	call   c020373b <outb>
c0205b77:	83 c4 10             	add    $0x10,%esp

    // 拆分低字节和高字节
    uint8_t low = (uint8_t)(divisor & 0xFF);
c0205b7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205b7d:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t hign = (uint8_t)((divisor >> 8) & 0xFF);
c0205b80:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205b83:	c1 e8 08             	shr    $0x8,%eax
c0205b86:	88 45 f2             	mov    %al,-0xe(%ebp)
    
    // 分别写入低字节和高字节
    outb(0x40, low);
c0205b89:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0205b8d:	83 ec 08             	sub    $0x8,%esp
c0205b90:	50                   	push   %eax
c0205b91:	6a 40                	push   $0x40
c0205b93:	e8 a3 db ff ff       	call   c020373b <outb>
c0205b98:	83 c4 10             	add    $0x10,%esp
    outb(0x40, hign);
c0205b9b:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
c0205b9f:	83 ec 08             	sub    $0x8,%esp
c0205ba2:	50                   	push   %eax
c0205ba3:	6a 40                	push   $0x40
c0205ba5:	e8 91 db ff ff       	call   c020373b <outb>
c0205baa:	83 c4 10             	add    $0x10,%esp
}
c0205bad:	90                   	nop
c0205bae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205bb1:	c9                   	leave  
c0205bb2:	c3                   	ret    

c0205bb3 <registe_interrupt>:

static void registe_interrupt(int int_no,int_server_func_t target_func){
c0205bb3:	55                   	push   %ebp
c0205bb4:	89 e5                	mov    %esp,%ebp
c0205bb6:	e8 45 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205bbb:	05 45 24 00 00       	add    $0x2445,%eax
	int_server_func_list[int_no] = target_func;
c0205bc0:	c7 c0 20 20 29 c0    	mov    $0xc0292020,%eax
c0205bc6:	8b 55 08             	mov    0x8(%ebp),%edx
c0205bc9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0205bcc:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
}
c0205bcf:	90                   	nop
c0205bd0:	5d                   	pop    %ebp
c0205bd1:	c3                   	ret    

c0205bd2 <default_server_func>:

void default_server_func(void *args){
c0205bd2:	55                   	push   %ebp
c0205bd3:	89 e5                	mov    %esp,%ebp
c0205bd5:	53                   	push   %ebx
c0205bd6:	83 ec 04             	sub    $0x4,%esp
c0205bd9:	e8 22 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205bde:	05 22 24 00 00       	add    $0x2422,%eax
	printk("Default Int server function!\n");
c0205be3:	83 ec 0c             	sub    $0xc,%esp
c0205be6:	8d 90 4a 02 00 00    	lea    0x24a(%eax),%edx
c0205bec:	52                   	push   %edx
c0205bed:	89 c3                	mov    %eax,%ebx
c0205bef:	e8 62 dc ff ff       	call   c0203856 <printk>
c0205bf4:	83 c4 10             	add    $0x10,%esp
}
c0205bf7:	90                   	nop
c0205bf8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205bfb:	c9                   	leave  
c0205bfc:	c3                   	ret    

c0205bfd <timer_server_func>:


extern TCB_t * cur_tcb; 

//时钟中断函数 主要用于线程调度
void timer_server_func(void *args){
c0205bfd:	55                   	push   %ebp
c0205bfe:	89 e5                	mov    %esp,%ebp
c0205c00:	53                   	push   %ebx
c0205c01:	83 ec 04             	sub    $0x4,%esp
c0205c04:	e8 f7 13 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205c09:	05 f7 23 00 00       	add    $0x23f7,%eax
	if(cur_tcb->time_left!=0){
c0205c0e:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0205c14:	8b 12                	mov    (%edx),%edx
c0205c16:	8b 52 0c             	mov    0xc(%edx),%edx
c0205c19:	85 d2                	test   %edx,%edx
c0205c1b:	74 24                	je     c0205c41 <timer_server_func+0x44>
		(cur_tcb->time_left)--;
c0205c1d:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0205c23:	8b 12                	mov    (%edx),%edx
c0205c25:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0205c28:	83 e9 01             	sub    $0x1,%ecx
c0205c2b:	89 4a 0c             	mov    %ecx,0xc(%edx)
		(cur_tcb->time_counter)++;
c0205c2e:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0205c34:	8b 00                	mov    (%eax),%eax
c0205c36:	8b 50 08             	mov    0x8(%eax),%edx
c0205c39:	83 c2 01             	add    $0x1,%edx
c0205c3c:	89 50 08             	mov    %edx,0x8(%eax)
	}
	else{
		schedule();
	}
}
c0205c3f:	eb 07                	jmp    c0205c48 <timer_server_func+0x4b>
		schedule();
c0205c41:	89 c3                	mov    %eax,%ebx
c0205c43:	e8 6e 07 00 00       	call   c02063b6 <schedule>
}
c0205c48:	90                   	nop
c0205c49:	83 c4 04             	add    $0x4,%esp
c0205c4c:	5b                   	pop    %ebx
c0205c4d:	5d                   	pop    %ebp
c0205c4e:	c3                   	ret    

c0205c4f <lost_page_func>:

//cr2 保存引起缺页的线性地址
void get_cr2();
extern uint32_t _CR2;
void lost_page_func(){
c0205c4f:	55                   	push   %ebp
c0205c50:	89 e5                	mov    %esp,%ebp
c0205c52:	53                   	push   %ebx
c0205c53:	83 ec 04             	sub    $0x4,%esp
c0205c56:	e8 a9 13 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205c5b:	81 c3 a5 23 00 00    	add    $0x23a5,%ebx
	get_cr2();
c0205c61:	e8 e3 d5 ff ff       	call   c0203249 <get_cr2>
	printk("INT 14:lost page--0x%h\n",_CR2);
c0205c66:	c7 c0 52 32 20 c0    	mov    $0xc0203252,%eax
c0205c6c:	8b 00                	mov    (%eax),%eax
c0205c6e:	83 ec 08             	sub    $0x8,%esp
c0205c71:	50                   	push   %eax
c0205c72:	8d 83 68 02 00 00    	lea    0x268(%ebx),%eax
c0205c78:	50                   	push   %eax
c0205c79:	e8 d8 db ff ff       	call   c0203856 <printk>
c0205c7e:	83 c4 10             	add    $0x10,%esp
}
c0205c81:	90                   	nop
c0205c82:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205c85:	c9                   	leave  
c0205c86:	c3                   	ret    

c0205c87 <idt_init>:
void isr30();
void isr31();

void isr32();

void idt_init(){
c0205c87:	55                   	push   %ebp
c0205c88:	89 e5                	mov    %esp,%ebp
c0205c8a:	53                   	push   %ebx
c0205c8b:	83 ec 04             	sub    $0x4,%esp
c0205c8e:	e8 71 13 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205c93:	81 c3 6d 23 00 00    	add    $0x236d,%ebx
	_8259A_init();   //初始化中断控制器
c0205c99:	e8 29 e5 ff ff       	call   c02041c7 <_8259A_init>
	set_int_disc(0,(uint32_t)isr0,kern_cs,default_inf);
c0205c9e:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205ca5:	0f b6 d0             	movzbl %al,%edx
c0205ca8:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205caf:	0f b7 c0             	movzwl %ax,%eax
c0205cb2:	c7 c1 ef 30 20 c0    	mov    $0xc02030ef,%ecx
c0205cb8:	52                   	push   %edx
c0205cb9:	50                   	push   %eax
c0205cba:	51                   	push   %ecx
c0205cbb:	6a 00                	push   $0x0
c0205cbd:	e8 09 fe ff ff       	call   c0205acb <set_int_disc>
c0205cc2:	83 c4 10             	add    $0x10,%esp
	set_int_disc(1,(uint32_t)isr1,kern_cs,default_inf);
c0205cc5:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205ccc:	0f b6 d0             	movzbl %al,%edx
c0205ccf:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205cd6:	0f b7 c0             	movzwl %ax,%eax
c0205cd9:	c7 c1 f7 30 20 c0    	mov    $0xc02030f7,%ecx
c0205cdf:	52                   	push   %edx
c0205ce0:	50                   	push   %eax
c0205ce1:	51                   	push   %ecx
c0205ce2:	6a 01                	push   $0x1
c0205ce4:	e8 e2 fd ff ff       	call   c0205acb <set_int_disc>
c0205ce9:	83 c4 10             	add    $0x10,%esp
	set_int_disc(2,(uint32_t)isr2,kern_cs,default_inf);
c0205cec:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205cf3:	0f b6 d0             	movzbl %al,%edx
c0205cf6:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205cfd:	0f b7 c0             	movzwl %ax,%eax
c0205d00:	c7 c1 ff 30 20 c0    	mov    $0xc02030ff,%ecx
c0205d06:	52                   	push   %edx
c0205d07:	50                   	push   %eax
c0205d08:	51                   	push   %ecx
c0205d09:	6a 02                	push   $0x2
c0205d0b:	e8 bb fd ff ff       	call   c0205acb <set_int_disc>
c0205d10:	83 c4 10             	add    $0x10,%esp
	set_int_disc(3,(uint32_t)isr3,kern_cs,default_inf);
c0205d13:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d1a:	0f b6 d0             	movzbl %al,%edx
c0205d1d:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d24:	0f b7 c0             	movzwl %ax,%eax
c0205d27:	c7 c1 07 31 20 c0    	mov    $0xc0203107,%ecx
c0205d2d:	52                   	push   %edx
c0205d2e:	50                   	push   %eax
c0205d2f:	51                   	push   %ecx
c0205d30:	6a 03                	push   $0x3
c0205d32:	e8 94 fd ff ff       	call   c0205acb <set_int_disc>
c0205d37:	83 c4 10             	add    $0x10,%esp
	set_int_disc(4,(uint32_t)isr4,kern_cs,default_inf);
c0205d3a:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d41:	0f b6 d0             	movzbl %al,%edx
c0205d44:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d4b:	0f b7 c0             	movzwl %ax,%eax
c0205d4e:	c7 c1 0f 31 20 c0    	mov    $0xc020310f,%ecx
c0205d54:	52                   	push   %edx
c0205d55:	50                   	push   %eax
c0205d56:	51                   	push   %ecx
c0205d57:	6a 04                	push   $0x4
c0205d59:	e8 6d fd ff ff       	call   c0205acb <set_int_disc>
c0205d5e:	83 c4 10             	add    $0x10,%esp
	set_int_disc(5,(uint32_t)isr5,kern_cs,default_inf);
c0205d61:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d68:	0f b6 d0             	movzbl %al,%edx
c0205d6b:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d72:	0f b7 c0             	movzwl %ax,%eax
c0205d75:	c7 c1 17 31 20 c0    	mov    $0xc0203117,%ecx
c0205d7b:	52                   	push   %edx
c0205d7c:	50                   	push   %eax
c0205d7d:	51                   	push   %ecx
c0205d7e:	6a 05                	push   $0x5
c0205d80:	e8 46 fd ff ff       	call   c0205acb <set_int_disc>
c0205d85:	83 c4 10             	add    $0x10,%esp
	set_int_disc(6,(uint32_t)isr6,kern_cs,default_inf);
c0205d88:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d8f:	0f b6 d0             	movzbl %al,%edx
c0205d92:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d99:	0f b7 c0             	movzwl %ax,%eax
c0205d9c:	c7 c1 1f 31 20 c0    	mov    $0xc020311f,%ecx
c0205da2:	52                   	push   %edx
c0205da3:	50                   	push   %eax
c0205da4:	51                   	push   %ecx
c0205da5:	6a 06                	push   $0x6
c0205da7:	e8 1f fd ff ff       	call   c0205acb <set_int_disc>
c0205dac:	83 c4 10             	add    $0x10,%esp
	set_int_disc(7,(uint32_t)isr7,kern_cs,default_inf);
c0205daf:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205db6:	0f b6 d0             	movzbl %al,%edx
c0205db9:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205dc0:	0f b7 c0             	movzwl %ax,%eax
c0205dc3:	c7 c1 2a 31 20 c0    	mov    $0xc020312a,%ecx
c0205dc9:	52                   	push   %edx
c0205dca:	50                   	push   %eax
c0205dcb:	51                   	push   %ecx
c0205dcc:	6a 07                	push   $0x7
c0205dce:	e8 f8 fc ff ff       	call   c0205acb <set_int_disc>
c0205dd3:	83 c4 10             	add    $0x10,%esp
	set_int_disc(8,(uint32_t)isr8,kern_cs,default_inf);
c0205dd6:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205ddd:	0f b6 d0             	movzbl %al,%edx
c0205de0:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205de7:	0f b7 c0             	movzwl %ax,%eax
c0205dea:	c7 c1 35 31 20 c0    	mov    $0xc0203135,%ecx
c0205df0:	52                   	push   %edx
c0205df1:	50                   	push   %eax
c0205df2:	51                   	push   %ecx
c0205df3:	6a 08                	push   $0x8
c0205df5:	e8 d1 fc ff ff       	call   c0205acb <set_int_disc>
c0205dfa:	83 c4 10             	add    $0x10,%esp
	set_int_disc(9,(uint32_t)isr9,kern_cs,default_inf);
c0205dfd:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e04:	0f b6 d0             	movzbl %al,%edx
c0205e07:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e0e:	0f b7 c0             	movzwl %ax,%eax
c0205e11:	c7 c1 3f 31 20 c0    	mov    $0xc020313f,%ecx
c0205e17:	52                   	push   %edx
c0205e18:	50                   	push   %eax
c0205e19:	51                   	push   %ecx
c0205e1a:	6a 09                	push   $0x9
c0205e1c:	e8 aa fc ff ff       	call   c0205acb <set_int_disc>
c0205e21:	83 c4 10             	add    $0x10,%esp
	set_int_disc(10,(uint32_t)isr10,kern_cs,default_inf);
c0205e24:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e2b:	0f b6 d0             	movzbl %al,%edx
c0205e2e:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e35:	0f b7 c0             	movzwl %ax,%eax
c0205e38:	c7 c1 4a 31 20 c0    	mov    $0xc020314a,%ecx
c0205e3e:	52                   	push   %edx
c0205e3f:	50                   	push   %eax
c0205e40:	51                   	push   %ecx
c0205e41:	6a 0a                	push   $0xa
c0205e43:	e8 83 fc ff ff       	call   c0205acb <set_int_disc>
c0205e48:	83 c4 10             	add    $0x10,%esp
	set_int_disc(11,(uint32_t)isr11,kern_cs,default_inf);
c0205e4b:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e52:	0f b6 d0             	movzbl %al,%edx
c0205e55:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e5c:	0f b7 c0             	movzwl %ax,%eax
c0205e5f:	c7 c1 54 31 20 c0    	mov    $0xc0203154,%ecx
c0205e65:	52                   	push   %edx
c0205e66:	50                   	push   %eax
c0205e67:	51                   	push   %ecx
c0205e68:	6a 0b                	push   $0xb
c0205e6a:	e8 5c fc ff ff       	call   c0205acb <set_int_disc>
c0205e6f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(12,(uint32_t)isr12,kern_cs,default_inf);
c0205e72:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e79:	0f b6 d0             	movzbl %al,%edx
c0205e7c:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e83:	0f b7 c0             	movzwl %ax,%eax
c0205e86:	c7 c1 5e 31 20 c0    	mov    $0xc020315e,%ecx
c0205e8c:	52                   	push   %edx
c0205e8d:	50                   	push   %eax
c0205e8e:	51                   	push   %ecx
c0205e8f:	6a 0c                	push   $0xc
c0205e91:	e8 35 fc ff ff       	call   c0205acb <set_int_disc>
c0205e96:	83 c4 10             	add    $0x10,%esp
	set_int_disc(13,(uint32_t)isr13,kern_cs,default_inf);
c0205e99:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205ea0:	0f b6 d0             	movzbl %al,%edx
c0205ea3:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205eaa:	0f b7 c0             	movzwl %ax,%eax
c0205ead:	c7 c1 68 31 20 c0    	mov    $0xc0203168,%ecx
c0205eb3:	52                   	push   %edx
c0205eb4:	50                   	push   %eax
c0205eb5:	51                   	push   %ecx
c0205eb6:	6a 0d                	push   $0xd
c0205eb8:	e8 0e fc ff ff       	call   c0205acb <set_int_disc>
c0205ebd:	83 c4 10             	add    $0x10,%esp
	set_int_disc(14,(uint32_t)isr14,kern_cs,default_inf);
c0205ec0:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205ec7:	0f b6 d0             	movzbl %al,%edx
c0205eca:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205ed1:	0f b7 c0             	movzwl %ax,%eax
c0205ed4:	c7 c1 72 31 20 c0    	mov    $0xc0203172,%ecx
c0205eda:	52                   	push   %edx
c0205edb:	50                   	push   %eax
c0205edc:	51                   	push   %ecx
c0205edd:	6a 0e                	push   $0xe
c0205edf:	e8 e7 fb ff ff       	call   c0205acb <set_int_disc>
c0205ee4:	83 c4 10             	add    $0x10,%esp
	set_int_disc(15,(uint32_t)isr15,kern_cs,default_inf);
c0205ee7:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205eee:	0f b6 d0             	movzbl %al,%edx
c0205ef1:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205ef8:	0f b7 c0             	movzwl %ax,%eax
c0205efb:	c7 c1 7c 31 20 c0    	mov    $0xc020317c,%ecx
c0205f01:	52                   	push   %edx
c0205f02:	50                   	push   %eax
c0205f03:	51                   	push   %ecx
c0205f04:	6a 0f                	push   $0xf
c0205f06:	e8 c0 fb ff ff       	call   c0205acb <set_int_disc>
c0205f0b:	83 c4 10             	add    $0x10,%esp
	set_int_disc(16,(uint32_t)isr16,kern_cs,default_inf);
c0205f0e:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f15:	0f b6 d0             	movzbl %al,%edx
c0205f18:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f1f:	0f b7 c0             	movzwl %ax,%eax
c0205f22:	c7 c1 87 31 20 c0    	mov    $0xc0203187,%ecx
c0205f28:	52                   	push   %edx
c0205f29:	50                   	push   %eax
c0205f2a:	51                   	push   %ecx
c0205f2b:	6a 10                	push   $0x10
c0205f2d:	e8 99 fb ff ff       	call   c0205acb <set_int_disc>
c0205f32:	83 c4 10             	add    $0x10,%esp
	set_int_disc(17,(uint32_t)isr17,kern_cs,default_inf);
c0205f35:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f3c:	0f b6 d0             	movzbl %al,%edx
c0205f3f:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f46:	0f b7 c0             	movzwl %ax,%eax
c0205f49:	c7 c1 92 31 20 c0    	mov    $0xc0203192,%ecx
c0205f4f:	52                   	push   %edx
c0205f50:	50                   	push   %eax
c0205f51:	51                   	push   %ecx
c0205f52:	6a 11                	push   $0x11
c0205f54:	e8 72 fb ff ff       	call   c0205acb <set_int_disc>
c0205f59:	83 c4 10             	add    $0x10,%esp
	set_int_disc(18,(uint32_t)isr18,kern_cs,default_inf);
c0205f5c:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f63:	0f b6 d0             	movzbl %al,%edx
c0205f66:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f6d:	0f b7 c0             	movzwl %ax,%eax
c0205f70:	c7 c1 9c 31 20 c0    	mov    $0xc020319c,%ecx
c0205f76:	52                   	push   %edx
c0205f77:	50                   	push   %eax
c0205f78:	51                   	push   %ecx
c0205f79:	6a 12                	push   $0x12
c0205f7b:	e8 4b fb ff ff       	call   c0205acb <set_int_disc>
c0205f80:	83 c4 10             	add    $0x10,%esp
	set_int_disc(19,(uint32_t)isr19,kern_cs,default_inf);
c0205f83:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f8a:	0f b6 d0             	movzbl %al,%edx
c0205f8d:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f94:	0f b7 c0             	movzwl %ax,%eax
c0205f97:	c7 c1 a7 31 20 c0    	mov    $0xc02031a7,%ecx
c0205f9d:	52                   	push   %edx
c0205f9e:	50                   	push   %eax
c0205f9f:	51                   	push   %ecx
c0205fa0:	6a 13                	push   $0x13
c0205fa2:	e8 24 fb ff ff       	call   c0205acb <set_int_disc>
c0205fa7:	83 c4 10             	add    $0x10,%esp
	set_int_disc(20,(uint32_t)isr20,kern_cs,default_inf);
c0205faa:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205fb1:	0f b6 d0             	movzbl %al,%edx
c0205fb4:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205fbb:	0f b7 c0             	movzwl %ax,%eax
c0205fbe:	c7 c1 b2 31 20 c0    	mov    $0xc02031b2,%ecx
c0205fc4:	52                   	push   %edx
c0205fc5:	50                   	push   %eax
c0205fc6:	51                   	push   %ecx
c0205fc7:	6a 14                	push   $0x14
c0205fc9:	e8 fd fa ff ff       	call   c0205acb <set_int_disc>
c0205fce:	83 c4 10             	add    $0x10,%esp
	set_int_disc(21,(uint32_t)isr21,kern_cs,default_inf);
c0205fd1:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205fd8:	0f b6 d0             	movzbl %al,%edx
c0205fdb:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205fe2:	0f b7 c0             	movzwl %ax,%eax
c0205fe5:	c7 c1 bd 31 20 c0    	mov    $0xc02031bd,%ecx
c0205feb:	52                   	push   %edx
c0205fec:	50                   	push   %eax
c0205fed:	51                   	push   %ecx
c0205fee:	6a 15                	push   $0x15
c0205ff0:	e8 d6 fa ff ff       	call   c0205acb <set_int_disc>
c0205ff5:	83 c4 10             	add    $0x10,%esp
	set_int_disc(22,(uint32_t)isr22,kern_cs,default_inf);
c0205ff8:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205fff:	0f b6 d0             	movzbl %al,%edx
c0206002:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206009:	0f b7 c0             	movzwl %ax,%eax
c020600c:	c7 c1 c8 31 20 c0    	mov    $0xc02031c8,%ecx
c0206012:	52                   	push   %edx
c0206013:	50                   	push   %eax
c0206014:	51                   	push   %ecx
c0206015:	6a 16                	push   $0x16
c0206017:	e8 af fa ff ff       	call   c0205acb <set_int_disc>
c020601c:	83 c4 10             	add    $0x10,%esp
	set_int_disc(23,(uint32_t)isr23,kern_cs,default_inf);
c020601f:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206026:	0f b6 d0             	movzbl %al,%edx
c0206029:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206030:	0f b7 c0             	movzwl %ax,%eax
c0206033:	c7 c1 d3 31 20 c0    	mov    $0xc02031d3,%ecx
c0206039:	52                   	push   %edx
c020603a:	50                   	push   %eax
c020603b:	51                   	push   %ecx
c020603c:	6a 17                	push   $0x17
c020603e:	e8 88 fa ff ff       	call   c0205acb <set_int_disc>
c0206043:	83 c4 10             	add    $0x10,%esp
	set_int_disc(24,(uint32_t)isr24,kern_cs,default_inf);
c0206046:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c020604d:	0f b6 d0             	movzbl %al,%edx
c0206050:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206057:	0f b7 c0             	movzwl %ax,%eax
c020605a:	c7 c1 de 31 20 c0    	mov    $0xc02031de,%ecx
c0206060:	52                   	push   %edx
c0206061:	50                   	push   %eax
c0206062:	51                   	push   %ecx
c0206063:	6a 18                	push   $0x18
c0206065:	e8 61 fa ff ff       	call   c0205acb <set_int_disc>
c020606a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(25,(uint32_t)isr25,kern_cs,default_inf);
c020606d:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206074:	0f b6 d0             	movzbl %al,%edx
c0206077:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c020607e:	0f b7 c0             	movzwl %ax,%eax
c0206081:	c7 c1 e9 31 20 c0    	mov    $0xc02031e9,%ecx
c0206087:	52                   	push   %edx
c0206088:	50                   	push   %eax
c0206089:	51                   	push   %ecx
c020608a:	6a 19                	push   $0x19
c020608c:	e8 3a fa ff ff       	call   c0205acb <set_int_disc>
c0206091:	83 c4 10             	add    $0x10,%esp
	set_int_disc(26,(uint32_t)isr26,kern_cs,default_inf);
c0206094:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c020609b:	0f b6 d0             	movzbl %al,%edx
c020609e:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c02060a5:	0f b7 c0             	movzwl %ax,%eax
c02060a8:	c7 c1 f4 31 20 c0    	mov    $0xc02031f4,%ecx
c02060ae:	52                   	push   %edx
c02060af:	50                   	push   %eax
c02060b0:	51                   	push   %ecx
c02060b1:	6a 1a                	push   $0x1a
c02060b3:	e8 13 fa ff ff       	call   c0205acb <set_int_disc>
c02060b8:	83 c4 10             	add    $0x10,%esp
	set_int_disc(27,(uint32_t)isr27,kern_cs,default_inf);
c02060bb:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c02060c2:	0f b6 d0             	movzbl %al,%edx
c02060c5:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c02060cc:	0f b7 c0             	movzwl %ax,%eax
c02060cf:	c7 c1 ff 31 20 c0    	mov    $0xc02031ff,%ecx
c02060d5:	52                   	push   %edx
c02060d6:	50                   	push   %eax
c02060d7:	51                   	push   %ecx
c02060d8:	6a 1b                	push   $0x1b
c02060da:	e8 ec f9 ff ff       	call   c0205acb <set_int_disc>
c02060df:	83 c4 10             	add    $0x10,%esp
	set_int_disc(28,(uint32_t)isr28,kern_cs,default_inf);
c02060e2:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c02060e9:	0f b6 d0             	movzbl %al,%edx
c02060ec:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c02060f3:	0f b7 c0             	movzwl %ax,%eax
c02060f6:	c7 c1 0a 32 20 c0    	mov    $0xc020320a,%ecx
c02060fc:	52                   	push   %edx
c02060fd:	50                   	push   %eax
c02060fe:	51                   	push   %ecx
c02060ff:	6a 1c                	push   $0x1c
c0206101:	e8 c5 f9 ff ff       	call   c0205acb <set_int_disc>
c0206106:	83 c4 10             	add    $0x10,%esp
	set_int_disc(29,(uint32_t)isr29,kern_cs,default_inf);
c0206109:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206110:	0f b6 d0             	movzbl %al,%edx
c0206113:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c020611a:	0f b7 c0             	movzwl %ax,%eax
c020611d:	c7 c1 15 32 20 c0    	mov    $0xc0203215,%ecx
c0206123:	52                   	push   %edx
c0206124:	50                   	push   %eax
c0206125:	51                   	push   %ecx
c0206126:	6a 1d                	push   $0x1d
c0206128:	e8 9e f9 ff ff       	call   c0205acb <set_int_disc>
c020612d:	83 c4 10             	add    $0x10,%esp
	set_int_disc(30,(uint32_t)isr30,kern_cs,default_inf);
c0206130:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206137:	0f b6 d0             	movzbl %al,%edx
c020613a:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206141:	0f b7 c0             	movzwl %ax,%eax
c0206144:	c7 c1 20 32 20 c0    	mov    $0xc0203220,%ecx
c020614a:	52                   	push   %edx
c020614b:	50                   	push   %eax
c020614c:	51                   	push   %ecx
c020614d:	6a 1e                	push   $0x1e
c020614f:	e8 77 f9 ff ff       	call   c0205acb <set_int_disc>
c0206154:	83 c4 10             	add    $0x10,%esp
	set_int_disc(31,(uint32_t)isr31,kern_cs,default_inf);
c0206157:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c020615e:	0f b6 d0             	movzbl %al,%edx
c0206161:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206168:	0f b7 c0             	movzwl %ax,%eax
c020616b:	c7 c1 2b 32 20 c0    	mov    $0xc020322b,%ecx
c0206171:	52                   	push   %edx
c0206172:	50                   	push   %eax
c0206173:	51                   	push   %ecx
c0206174:	6a 1f                	push   $0x1f
c0206176:	e8 50 f9 ff ff       	call   c0205acb <set_int_disc>
c020617b:	83 c4 10             	add    $0x10,%esp
	set_int_disc(32,(uint32_t)isr32,kern_cs,default_inf);
c020617e:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206185:	0f b6 d0             	movzbl %al,%edx
c0206188:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c020618f:	0f b7 c0             	movzwl %ax,%eax
c0206192:	c7 c1 36 32 20 c0    	mov    $0xc0203236,%ecx
c0206198:	52                   	push   %edx
c0206199:	50                   	push   %eax
c020619a:	51                   	push   %ecx
c020619b:	6a 20                	push   $0x20
c020619d:	e8 29 f9 ff ff       	call   c0205acb <set_int_disc>
c02061a2:	83 c4 10             	add    $0x10,%esp
	//registe_interrupt(32,timer_server_func);
	registe_interrupt(14,lost_page_func);
c02061a5:	83 ec 08             	sub    $0x8,%esp
c02061a8:	8d 83 4f dc ff ff    	lea    -0x23b1(%ebx),%eax
c02061ae:	50                   	push   %eax
c02061af:	6a 0e                	push   $0xe
c02061b1:	e8 fd f9 ff ff       	call   c0205bb3 <registe_interrupt>
c02061b6:	83 c4 10             	add    $0x10,%esp
	lidt_target.limit = sizeof(interrupt_discripter_t)*256;
c02061b9:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c02061bf:	66 c7 00 00 08       	movw   $0x800,(%eax)
	lidt_target.base = (uint32_t)&idt_entries;
c02061c4:	c7 c0 40 24 29 c0    	mov    $0xc0292440,%eax
c02061ca:	89 c2                	mov    %eax,%edx
c02061cc:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c02061d2:	89 50 02             	mov    %edx,0x2(%eax)
	timer_init(1000);        
c02061d5:	83 ec 0c             	sub    $0xc,%esp
c02061d8:	68 e8 03 00 00       	push   $0x3e8
c02061dd:	e8 67 f9 ff ff       	call   c0205b49 <timer_init>
c02061e2:	83 c4 10             	add    $0x10,%esp
	load_idt((uint32_t)&lidt_target);
c02061e5:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c02061eb:	83 ec 0c             	sub    $0xc,%esp
c02061ee:	50                   	push   %eax
c02061ef:	e8 4d d0 ff ff       	call   c0203241 <load_idt>
c02061f4:	83 c4 10             	add    $0x10,%esp
}
c02061f7:	90                   	nop
c02061f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02061fb:	c9                   	leave  
c02061fc:	c3                   	ret    

c02061fd <int_func_route>:
void int_func_route(int int_no,void * args){
c02061fd:	55                   	push   %ebp
c02061fe:	89 e5                	mov    %esp,%ebp
c0206200:	83 ec 08             	sub    $0x8,%esp
c0206203:	e8 f8 0d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206208:	05 f8 1d 00 00       	add    $0x1df8,%eax
	int_server_func_list[int_no](args);
c020620d:	c7 c0 20 20 29 c0    	mov    $0xc0292020,%eax
c0206213:	8b 55 08             	mov    0x8(%ebp),%edx
c0206216:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0206219:	83 ec 0c             	sub    $0xc,%esp
c020621c:	ff 75 0c             	pushl  0xc(%ebp)
c020621f:	ff d0                	call   *%eax
c0206221:	83 c4 10             	add    $0x10,%esp
}
c0206224:	90                   	nop
c0206225:	c9                   	leave  
c0206226:	c3                   	ret    

c0206227 <threads_init>:
#include "printk.h"
#define TIME_CONT  2 //默认时间片计数
TCB_t main_TCB;    //主线程TCB
TCB_t* cur_tcb;

void threads_init(){
c0206227:	55                   	push   %ebp
c0206228:	89 e5                	mov    %esp,%ebp
c020622a:	83 ec 10             	sub    $0x10,%esp
c020622d:	e8 ce 0d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206232:	05 ce 1d 00 00       	add    $0x1dce,%eax
	TCB_t *tcb_buffer_addr = &main_TCB;
c0206237:	c7 c2 60 2c 29 c0    	mov    $0xc0292c60,%edx
c020623d:	89 55 fc             	mov    %edx,-0x4(%ebp)
	tcb_buffer_addr->tid = 0;        //主线程的编号为0  
c0206240:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206243:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
	tcb_buffer_addr->time_counter=0;
c020624a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020624d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	tcb_buffer_addr->time_left=TIME_CONT;
c0206254:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206257:	c7 42 0c 02 00 00 00 	movl   $0x2,0xc(%edx)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c020625e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206261:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	tcb_buffer_addr->page_counte=0;   //主线程不会被回收内存 所以可以任意赋值
c0206268:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020626b:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	tcb_buffer_addr->page_addr=0;
c0206272:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206275:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	tcb_buffer_addr->next = tcb_buffer_addr;
c020627c:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020627f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0206282:	89 4a 10             	mov    %ecx,0x10(%edx)
	tcb_buffer_addr->kern_stack_top=0;
c0206285:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206288:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	cur_tcb = tcb_buffer_addr;
c020628e:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206294:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206297:	89 10                	mov    %edx,(%eax)
}
c0206299:	90                   	nop
c020629a:	c9                   	leave  
c020629b:	c3                   	ret    

c020629c <create_TCB>:

uint32_t create_TCB(uint32_t tid,uint32_t page_addr,uint32_t page_counte){
c020629c:	55                   	push   %ebp
c020629d:	89 e5                	mov    %esp,%ebp
c020629f:	83 ec 10             	sub    $0x10,%esp
c02062a2:	e8 59 0d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02062a7:	05 59 1d 00 00       	add    $0x1d59,%eax
	TCB_t * tcb_buffer_addr = (TCB_t*)page_addr;
c02062ac:	8b 45 0c             	mov    0xc(%ebp),%eax
c02062af:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = tid;         
c02062b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062b5:	8b 55 08             	mov    0x8(%ebp),%edx
c02062b8:	89 50 14             	mov    %edx,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c02062bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062be:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c02062c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062c8:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c02062cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062d2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=page_counte; 
c02062d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062dc:	8b 55 10             	mov    0x10(%ebp),%edx
c02062df:	89 50 18             	mov    %edx,0x18(%eax)
	tcb_buffer_addr->page_addr=page_addr;
c02062e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062e5:	8b 55 0c             	mov    0xc(%ebp),%edx
c02062e8:	89 50 1c             	mov    %edx,0x1c(%eax)
	tcb_buffer_addr->kern_stack_top=page_addr+page_counte*4096;
c02062eb:	8b 45 10             	mov    0x10(%ebp),%eax
c02062ee:	c1 e0 0c             	shl    $0xc,%eax
c02062f1:	89 c2                	mov    %eax,%edx
c02062f3:	8b 45 0c             	mov    0xc(%ebp),%eax
c02062f6:	01 d0                	add    %edx,%eax
c02062f8:	89 c2                	mov    %eax,%edx
c02062fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02062fd:	89 10                	mov    %edx,(%eax)
	return page_addr;
c02062ff:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c0206302:	c9                   	leave  
c0206303:	c3                   	ret    

c0206304 <create_thread>:

void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte){	
c0206304:	55                   	push   %ebp
c0206305:	89 e5                	mov    %esp,%ebp
c0206307:	53                   	push   %ebx
c0206308:	83 ec 10             	sub    $0x10,%esp
c020630b:	e8 f4 0c 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206310:	81 c3 f0 1c 00 00    	add    $0x1cf0,%ebx
	asm volatile("cli");  //由于创建过程会使用到共享的数据 不使用锁的话会造成临界区错误 所以我们在此处关闭中断
c0206316:	fa                   	cli    
	TCB_t * new_tcb = create_TCB(tid,addr,page_counte);
c0206317:	ff 75 18             	pushl  0x18(%ebp)
c020631a:	ff 75 14             	pushl  0x14(%ebp)
c020631d:	ff 75 08             	pushl  0x8(%ebp)
c0206320:	e8 77 ff ff ff       	call   c020629c <create_TCB>
c0206325:	83 c4 0c             	add    $0xc,%esp
c0206328:	89 45 f8             	mov    %eax,-0x8(%ebp)
	TCB_t * temp_next = cur_tcb->next;
c020632b:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206331:	8b 00                	mov    (%eax),%eax
c0206333:	8b 40 10             	mov    0x10(%eax),%eax
c0206336:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cur_tcb->next = new_tcb;
c0206339:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020633f:	8b 00                	mov    (%eax),%eax
c0206341:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0206344:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->next = temp_next;
c0206347:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020634a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020634d:	89 50 10             	mov    %edx,0x10(%eax)
	*(--new_tcb->kern_stack_top)=args;     //压入初始化的参数与线程执行函数
c0206350:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206353:	8b 00                	mov    (%eax),%eax
c0206355:	8d 50 fc             	lea    -0x4(%eax),%edx
c0206358:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020635b:	89 10                	mov    %edx,(%eax)
c020635d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206360:	8b 00                	mov    (%eax),%eax
c0206362:	8b 55 10             	mov    0x10(%ebp),%edx
c0206365:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=exit;
c0206367:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020636a:	8b 00                	mov    (%eax),%eax
c020636c:	8d 50 fc             	lea    -0x4(%eax),%edx
c020636f:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206372:	89 10                	mov    %edx,(%eax)
c0206374:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206377:	8b 00                	mov    (%eax),%eax
c0206379:	8d 93 b7 e4 ff ff    	lea    -0x1b49(%ebx),%edx
c020637f:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=func;
c0206381:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206384:	8b 00                	mov    (%eax),%eax
c0206386:	8d 50 fc             	lea    -0x4(%eax),%edx
c0206389:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020638c:	89 10                	mov    %edx,(%eax)
c020638e:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206391:	8b 00                	mov    (%eax),%eax
c0206393:	8b 55 0c             	mov    0xc(%ebp),%edx
c0206396:	89 10                	mov    %edx,(%eax)
	new_tcb->context.eflags = 0x200;
c0206398:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020639b:	c7 40 38 00 02 00 00 	movl   $0x200,0x38(%eax)
	new_tcb->context.esp =new_tcb->kern_stack_top;
c02063a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02063a5:	8b 00                	mov    (%eax),%eax
c02063a7:	89 c2                	mov    %eax,%edx
c02063a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02063ac:	89 50 3c             	mov    %edx,0x3c(%eax)
	asm volatile("sti");	
c02063af:	fb                   	sti    
}
c02063b0:	90                   	nop
c02063b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02063b4:	c9                   	leave  
c02063b5:	c3                   	ret    

c02063b6 <schedule>:

void schedule(){      //调度函数  检测时间片为0时调用此函数
c02063b6:	55                   	push   %ebp
c02063b7:	89 e5                	mov    %esp,%ebp
c02063b9:	53                   	push   %ebx
c02063ba:	83 ec 14             	sub    $0x14,%esp
c02063bd:	e8 42 0c 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02063c2:	81 c3 3e 1c 00 00    	add    $0x1c3e,%ebx
	if(cur_tcb->next==cur_tcb){
c02063c8:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02063ce:	8b 00                	mov    (%eax),%eax
c02063d0:	8b 50 10             	mov    0x10(%eax),%edx
c02063d3:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02063d9:	8b 00                	mov    (%eax),%eax
c02063db:	39 c2                	cmp    %eax,%edx
c02063dd:	75 11                	jne    c02063f0 <schedule+0x3a>
		cur_tcb->time_left = TIME_CONT;    //如果只有一个线程 就再次给此线程添加时间片
c02063df:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02063e5:	8b 00                	mov    (%eax),%eax
c02063e7:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
		return ;
c02063ee:	eb 4c                	jmp    c020643c <schedule+0x86>
	}
	TCB_t *now = cur_tcb;
c02063f0:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02063f6:	8b 00                	mov    (%eax),%eax
c02063f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c02063fb:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206401:	8b 00                	mov    (%eax),%eax
c0206403:	8b 40 10             	mov    0x10(%eax),%eax
c0206406:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0206409:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020640c:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	cur_tcb = next_tcb;
c0206413:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206419:	8b 55 f0             	mov    -0x10(%ebp),%edx
c020641c:	89 10                	mov    %edx,(%eax)
	get_esp();      //有一个隐藏bug 需要call刷新寄存器
c020641e:	e8 3d ce ff ff       	call   c0203260 <get_esp>
	switch_to(&(now->context),&(next_tcb->context));      
c0206423:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206426:	8d 50 20             	lea    0x20(%eax),%edx
c0206429:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020642c:	83 c0 20             	add    $0x20,%eax
c020642f:	83 ec 08             	sub    $0x8,%esp
c0206432:	52                   	push   %edx
c0206433:	50                   	push   %eax
c0206434:	e8 2d ce ff ff       	call   c0203266 <switch_to>
c0206439:	83 c4 10             	add    $0x10,%esp
}
c020643c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020643f:	c9                   	leave  
c0206440:	c3                   	ret    

c0206441 <remove_thread>:

void remove_thread(){
c0206441:	55                   	push   %ebp
c0206442:	89 e5                	mov    %esp,%ebp
c0206444:	53                   	push   %ebx
c0206445:	83 ec 14             	sub    $0x14,%esp
c0206448:	e8 b3 0b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020644d:	05 b3 1b 00 00       	add    $0x1bb3,%eax
	asm volatile("cli");
c0206452:	fa                   	cli    
	if(cur_tcb->tid==0)
c0206453:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0206459:	8b 12                	mov    (%edx),%edx
c020645b:	8b 52 14             	mov    0x14(%edx),%edx
c020645e:	85 d2                	test   %edx,%edx
c0206460:	75 16                	jne    c0206478 <remove_thread+0x37>
		printk("ERRO:main thread can`t use function exit\n");
c0206462:	83 ec 0c             	sub    $0xc,%esp
c0206465:	8d 90 80 02 00 00    	lea    0x280(%eax),%edx
c020646b:	52                   	push   %edx
c020646c:	89 c3                	mov    %eax,%ebx
c020646e:	e8 e3 d3 ff ff       	call   c0203856 <printk>
c0206473:	83 c4 10             	add    $0x10,%esp
		TCB_t *temp = cur_tcb;
		for(;temp->next!=cur_tcb;temp=temp->next)
			;
		temp->next = cur_tcb->next;
	}
}
c0206476:	eb 39                	jmp    c02064b1 <remove_thread+0x70>
		TCB_t *temp = cur_tcb;
c0206478:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c020647e:	8b 12                	mov    (%edx),%edx
c0206480:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;temp->next!=cur_tcb;temp=temp->next)
c0206483:	eb 09                	jmp    c020648e <remove_thread+0x4d>
c0206485:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206488:	8b 52 10             	mov    0x10(%edx),%edx
c020648b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c020648e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206491:	8b 4a 10             	mov    0x10(%edx),%ecx
c0206494:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c020649a:	8b 12                	mov    (%edx),%edx
c020649c:	39 d1                	cmp    %edx,%ecx
c020649e:	75 e5                	jne    c0206485 <remove_thread+0x44>
		temp->next = cur_tcb->next;
c02064a0:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02064a6:	8b 00                	mov    (%eax),%eax
c02064a8:	8b 50 10             	mov    0x10(%eax),%edx
c02064ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02064ae:	89 50 10             	mov    %edx,0x10(%eax)
}
c02064b1:	90                   	nop
c02064b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02064b5:	c9                   	leave  
c02064b6:	c3                   	ret    

c02064b7 <exit>:

void exit(){
c02064b7:	55                   	push   %ebp
c02064b8:	89 e5                	mov    %esp,%ebp
c02064ba:	53                   	push   %ebx
c02064bb:	83 ec 14             	sub    $0x14,%esp
c02064be:	e8 41 0b 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02064c3:	81 c3 3d 1b 00 00    	add    $0x1b3d,%ebx
	remove_thread();
c02064c9:	e8 73 ff ff ff       	call   c0206441 <remove_thread>
	TCB_t *now = cur_tcb;
c02064ce:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02064d4:	8b 00                	mov    (%eax),%eax
c02064d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c02064d9:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02064df:	8b 00                	mov    (%eax),%eax
c02064e1:	8b 40 10             	mov    0x10(%eax),%eax
c02064e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c02064e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02064ea:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	cur_tcb = cur_tcb->next;
c02064f1:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02064f7:	8b 00                	mov    (%eax),%eax
c02064f9:	8b 50 10             	mov    0x10(%eax),%edx
c02064fc:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206502:	89 10                	mov    %edx,(%eax)
	switch_to(&(now->context),&(next_tcb->context));
c0206504:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206507:	8d 50 20             	lea    0x20(%eax),%edx
c020650a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020650d:	83 c0 20             	add    $0x20,%eax
c0206510:	83 ec 08             	sub    $0x8,%esp
c0206513:	52                   	push   %edx
c0206514:	50                   	push   %eax
c0206515:	e8 4c cd ff ff       	call   c0203266 <switch_to>
c020651a:	83 c4 10             	add    $0x10,%esp
	//注意 暂时没有回收此线程页
}
c020651d:	90                   	nop
c020651e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206521:	c9                   	leave  
c0206522:	c3                   	ret    

c0206523 <get_kern_used_page_count>:
//内核已使用的页数量(1MB以下也是已使用的部分)

bitmap kern_vmm_pool;


static int get_kern_used_page_count(){
c0206523:	55                   	push   %ebp
c0206524:	89 e5                	mov    %esp,%ebp
c0206526:	83 ec 10             	sub    $0x10,%esp
c0206529:	e8 d2 0a 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020652e:	05 d2 1a 00 00       	add    $0x1ad2,%eax
    uint32_t size_bytes = kern_end-0;
c0206533:	c7 c0 00 d0 29 00    	mov    $0x29d000,%eax
c0206539:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (size_bytes+PAGE_SIZE-1)/PAGE_SIZE;     //向上取整
c020653c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020653f:	05 ff 0f 00 00       	add    $0xfff,%eax
c0206544:	c1 e8 0c             	shr    $0xc,%eax
}
c0206547:	c9                   	leave  
c0206548:	c3                   	ret    

c0206549 <kern_vmm_init>:

//初始化内核虚拟空间
//预分配已使用内核空间
static void kern_vmm_init(){    
c0206549:	55                   	push   %ebp
c020654a:	89 e5                	mov    %esp,%ebp
c020654c:	53                   	push   %ebx
c020654d:	83 ec 24             	sub    $0x24,%esp
c0206550:	e8 af 0a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206555:	81 c3 ab 1a 00 00    	add    $0x1aab,%ebx
    kern_vmm_pool.target_addr_header = 0xC0000000;   //内核空间起始地址
c020655b:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c0206561:	c7 40 08 00 00 00 c0 	movl   $0xc0000000,0x8(%eax)
    kern_vmm_pool.length = 0x8000;     //总共1GB空间
c0206568:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020656e:	c7 40 04 00 80 00 00 	movl   $0x8000,0x4(%eax)
    kern_vmm_pool.vaddr_header = kern_bitmap;
c0206575:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c020657b:	8b 10                	mov    (%eax),%edx
c020657d:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c0206583:	89 10                	mov    %edx,(%eax)

    bitmap_init_mem(kern_vmm_pool);
c0206585:	83 ec 04             	sub    $0x4,%esp
c0206588:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020658e:	ff 70 08             	pushl  0x8(%eax)
c0206591:	ff 70 04             	pushl  0x4(%eax)
c0206594:	ff 30                	pushl  (%eax)
c0206596:	e8 8f dd ff ff       	call   c020432a <bitmap_init_mem>
c020659b:	83 c4 10             	add    $0x10,%esp
    int page_used = get_kern_used_page_count();
c020659e:	e8 80 ff ff ff       	call   c0206523 <get_kern_used_page_count>
c02065a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(page_used>1024){
c02065a6:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
c02065ad:	7e 14                	jle    c02065c3 <kern_vmm_init+0x7a>
        printk("\nERRO!don`t have enough vm page for kernel when init!\n");
c02065af:	83 ec 0c             	sub    $0xc,%esp
c02065b2:	8d 83 ac 02 00 00    	lea    0x2ac(%ebx),%eax
c02065b8:	50                   	push   %eax
c02065b9:	e8 98 d2 ff ff       	call   c0203856 <printk>
c02065be:	83 c4 10             	add    $0x10,%esp
        while (True){
c02065c1:	eb fe                	jmp    c02065c1 <kern_vmm_init+0x78>
            //内核暂停
        }
    }
    for(int i = 0; i<page_used ;i++){
c02065c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02065ca:	eb 20                	jmp    c02065ec <kern_vmm_init+0xa3>
        uint32_t rem = bitmap_alloc(kern_vmm_pool); //将内核空间在内存池中置为繁忙   此处可做性能优化
c02065cc:	83 ec 04             	sub    $0x4,%esp
c02065cf:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02065d5:	ff 70 08             	pushl  0x8(%eax)
c02065d8:	ff 70 04             	pushl  0x4(%eax)
c02065db:	ff 30                	pushl  (%eax)
c02065dd:	e8 0f df ff ff       	call   c02044f1 <bitmap_alloc>
c02065e2:	83 c4 10             	add    $0x10,%esp
c02065e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(int i = 0; i<page_used ;i++){
c02065e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02065ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02065ef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c02065f2:	7c d8                	jl     c02065cc <kern_vmm_init+0x83>
    }    
    //将内核虚拟内存管理页（最后1024页）在内存池中置为繁忙
    //1024页占用128字节 所以要将bitmap最后128字节清零
    int temp_cnt =0;
c02065f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c02065fb:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c0206601:	8b 00                	mov    (%eax),%eax
c0206603:	05 ff 7f 00 00       	add    $0x7fff,%eax
c0206608:	89 45 ec             	mov    %eax,-0x14(%ebp)
c020660b:	eb 0e                	jmp    c020661b <kern_vmm_init+0xd2>
        *((byte*)probe) = 0;
c020660d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206610:	c6 00 00             	movb   $0x0,(%eax)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c0206613:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0206617:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c020661b:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
c020661f:	7e ec                	jle    c020660d <kern_vmm_init+0xc4>
    }
}
c0206621:	90                   	nop
c0206622:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206625:	c9                   	leave  
c0206626:	c3                   	ret    

c0206627 <vmm_init>:

void vmm_init(){
c0206627:	55                   	push   %ebp
c0206628:	89 e5                	mov    %esp,%ebp
c020662a:	83 ec 08             	sub    $0x8,%esp
c020662d:	e8 ce 09 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206632:	05 ce 19 00 00       	add    $0x19ce,%eax
       kern_vmm_init(); 
c0206637:	e8 0d ff ff ff       	call   c0206549 <kern_vmm_init>
}
c020663c:	90                   	nop
c020663d:	c9                   	leave  
c020663e:	c3                   	ret    

c020663f <vmm_get_page_vaddr_by_target>:

static uint32_t vmm_get_page_vaddr_by_target(uint32_t target){
c020663f:	55                   	push   %ebp
c0206640:	89 e5                	mov    %esp,%ebp
c0206642:	83 ec 10             	sub    $0x10,%esp
c0206645:	e8 b6 09 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020664a:	05 b6 19 00 00       	add    $0x19b6,%eax
    target = target&0xFFFFF000;
c020664f:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = 0x3FF<<22;     //高10位
c0206656:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = (target>>10) & 0x003FF000;//中间10位为target高10位
c020665d:	8b 45 08             	mov    0x8(%ebp),%eax
c0206660:	c1 e8 0a             	shr    $0xa,%eax
c0206663:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0206668:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t addr_low12 = ((target>>12)&0x3FF)*4;//低12位为target中间10位×4
c020666b:	8b 45 08             	mov    0x8(%ebp),%eax
c020666e:	c1 e8 0c             	shr    $0xc,%eax
c0206671:	25 ff 03 00 00       	and    $0x3ff,%eax
c0206676:	c1 e0 02             	shl    $0x2,%eax
c0206679:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c020667c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020667f:	0b 45 f8             	or     -0x8(%ebp),%eax
c0206682:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c0206685:	c9                   	leave  
c0206686:	c3                   	ret    

c0206687 <vmm_kern_alloc_one_page>:
//修改页表时的地址结构：
//      1111111111_xxxxxxxxxx_xxxxxxxxxx
//前十位为1表示页目录表最后一项 指向页目录表起始地址
// 中间十位表示在1024项页目录表中的索引
//最后12位表示在页表中的索引（每张页表1024项 共4096B 也就是12位可表达的最大范围）
uint32_t vmm_kern_alloc_one_page(uint32_t target){
c0206687:	55                   	push   %ebp
c0206688:	89 e5                	mov    %esp,%ebp
c020668a:	53                   	push   %ebx
c020668b:	83 ec 24             	sub    $0x24,%esp
c020668e:	e8 71 09 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0206693:	81 c3 6d 19 00 00    	add    $0x196d,%ebx
    uint32_t vaddr_get=bitmap_alloc_one_page(kern_vmm_pool,target);
c0206699:	ff 75 08             	pushl  0x8(%ebp)
c020669c:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02066a2:	ff 70 08             	pushl  0x8(%eax)
c02066a5:	ff 70 04             	pushl  0x4(%eax)
c02066a8:	ff 30                	pushl  (%eax)
c02066aa:	e8 ba dc ff ff       	call   c0204369 <bitmap_alloc_one_page>
c02066af:	83 c4 10             	add    $0x10,%esp
c02066b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c02066b5:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c02066b9:	75 19                	jne    c02066d4 <vmm_kern_alloc_one_page+0x4d>
        printk("1\n");
c02066bb:	83 ec 0c             	sub    $0xc,%esp
c02066be:	8d 83 e3 02 00 00    	lea    0x2e3(%ebx),%eax
c02066c4:	50                   	push   %eax
c02066c5:	e8 8c d1 ff ff       	call   c0203856 <printk>
c02066ca:	83 c4 10             	add    $0x10,%esp
        return VMM_ALLOC_ERRO;
c02066cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02066d2:	eb 59                	jmp    c020672d <vmm_kern_alloc_one_page+0xa6>
    }            
    else{
        uint32_t page_desc_vaddr = vmm_get_page_vaddr_by_target(target);
c02066d4:	83 ec 0c             	sub    $0xc,%esp
c02066d7:	ff 75 08             	pushl  0x8(%ebp)
c02066da:	e8 60 ff ff ff       	call   c020663f <vmm_get_page_vaddr_by_target>
c02066df:	83 c4 10             	add    $0x10,%esp
c02066e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        pm_alloc_t phy_page = pmm_alloc_one_page();
c02066e5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c02066e8:	83 ec 0c             	sub    $0xc,%esp
c02066eb:	50                   	push   %eax
c02066ec:	e8 62 ed ff ff       	call   c0205453 <pmm_alloc_one_page>
c02066f1:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c02066f4:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c02066f8:	84 c0                	test   %al,%al
c02066fa:	75 19                	jne    c0206715 <vmm_kern_alloc_one_page+0x8e>
            //没有可用的物理页
        printk("2\n"); 
c02066fc:	83 ec 0c             	sub    $0xc,%esp
c02066ff:	8d 83 e6 02 00 00    	lea    0x2e6(%ebx),%eax
c0206705:	50                   	push   %eax
c0206706:	e8 4b d1 ff ff       	call   c0203856 <printk>
c020670b:	83 c4 10             	add    $0x10,%esp
            return VMM_ALLOC_ERRO;
c020670e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0206713:	eb 18                	jmp    c020672d <vmm_kern_alloc_one_page+0xa6>
        }
        //修改页表
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c0206715:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0206718:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020671d:	89 c2                	mov    %eax,%edx
c020671f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206722:	81 c2 03 01 00 00    	add    $0x103,%edx
c0206728:	89 10                	mov    %edx,(%eax)
        return target;
c020672a:	8b 45 08             	mov    0x8(%ebp),%eax
    }
    
}
c020672d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206730:	c9                   	leave  
c0206731:	c3                   	ret    

c0206732 <vmm_kern_alloc>:

uint32_t vmm_kern_alloc(){
c0206732:	55                   	push   %ebp
c0206733:	89 e5                	mov    %esp,%ebp
c0206735:	53                   	push   %ebx
c0206736:	83 ec 24             	sub    $0x24,%esp
c0206739:	e8 c6 08 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020673e:	81 c3 c2 18 00 00    	add    $0x18c2,%ebx
    uint32_t target = bitmap_alloc(kern_vmm_pool);
c0206744:	83 ec 04             	sub    $0x4,%esp
c0206747:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020674d:	ff 70 08             	pushl  0x8(%eax)
c0206750:	ff 70 04             	pushl  0x4(%eax)
c0206753:	ff 30                	pushl  (%eax)
c0206755:	e8 97 dd ff ff       	call   c02044f1 <bitmap_alloc>
c020675a:	83 c4 10             	add    $0x10,%esp
c020675d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (target == BITMAP_RETURN_ERRO){
c0206760:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0206764:	75 07                	jne    c020676d <vmm_kern_alloc+0x3b>
        return VMM_ALLOC_ERRO;
c0206766:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020676b:	eb 7e                	jmp    c02067eb <vmm_kern_alloc+0xb9>
    }
    uint32_t vaddr_get = target;
c020676d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206770:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c0206773:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0206777:	75 19                	jne    c0206792 <vmm_kern_alloc+0x60>
        printk("1\n");
c0206779:	83 ec 0c             	sub    $0xc,%esp
c020677c:	8d 83 e3 02 00 00    	lea    0x2e3(%ebx),%eax
c0206782:	50                   	push   %eax
c0206783:	e8 ce d0 ff ff       	call   c0203856 <printk>
c0206788:	83 c4 10             	add    $0x10,%esp
        return VMM_ALLOC_ERRO;
c020678b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0206790:	eb 59                	jmp    c02067eb <vmm_kern_alloc+0xb9>
    }            
    else{
        uint32_t page_desc_vaddr = vmm_get_page_vaddr_by_target(target);
c0206792:	83 ec 0c             	sub    $0xc,%esp
c0206795:	ff 75 f4             	pushl  -0xc(%ebp)
c0206798:	e8 a2 fe ff ff       	call   c020663f <vmm_get_page_vaddr_by_target>
c020679d:	83 c4 10             	add    $0x10,%esp
c02067a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        pm_alloc_t phy_page = pmm_alloc_one_page();
c02067a3:	8d 45 e0             	lea    -0x20(%ebp),%eax
c02067a6:	83 ec 0c             	sub    $0xc,%esp
c02067a9:	50                   	push   %eax
c02067aa:	e8 a4 ec ff ff       	call   c0205453 <pmm_alloc_one_page>
c02067af:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c02067b2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c02067b6:	84 c0                	test   %al,%al
c02067b8:	75 19                	jne    c02067d3 <vmm_kern_alloc+0xa1>
            //没有可用的物理页
        printk("2\n"); 
c02067ba:	83 ec 0c             	sub    $0xc,%esp
c02067bd:	8d 83 e6 02 00 00    	lea    0x2e6(%ebx),%eax
c02067c3:	50                   	push   %eax
c02067c4:	e8 8d d0 ff ff       	call   c0203856 <printk>
c02067c9:	83 c4 10             	add    $0x10,%esp
            return VMM_ALLOC_ERRO;
c02067cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02067d1:	eb 18                	jmp    c02067eb <vmm_kern_alloc+0xb9>
        }
        //修改页表
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c02067d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c02067d6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02067db:	89 c2                	mov    %eax,%edx
c02067dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02067e0:	81 c2 03 01 00 00    	add    $0x103,%edx
c02067e6:	89 10                	mov    %edx,(%eax)
        return target;
c02067e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c02067eb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02067ee:	c9                   	leave  
c02067ef:	c3                   	ret    

c02067f0 <vmm_kern_release_one_page>:

void vmm_kern_release_one_page(uint32_t target){
c02067f0:	55                   	push   %ebp
c02067f1:	89 e5                	mov    %esp,%ebp
c02067f3:	e8 08 08 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02067f8:	05 08 18 00 00       	add    $0x1808,%eax

}
c02067fd:	90                   	nop
c02067fe:	5d                   	pop    %ebp
c02067ff:	c3                   	ret    

c0206800 <user_vmm_init>:

static void user_vmm_init(){
c0206800:	55                   	push   %ebp
c0206801:	89 e5                	mov    %esp,%ebp
c0206803:	e8 f8 07 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206808:	05 f8 17 00 00       	add    $0x17f8,%eax

}
c020680d:	90                   	nop
c020680e:	5d                   	pop    %ebp
c020680f:	c3                   	ret    

c0206810 <vmm_test>:

void vmm_test(){
c0206810:	55                   	push   %ebp
c0206811:	89 e5                	mov    %esp,%ebp
c0206813:	53                   	push   %ebx
c0206814:	83 ec 14             	sub    $0x14,%esp
c0206817:	e8 e8 07 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020681c:	81 c3 e4 17 00 00    	add    $0x17e4,%ebx
    vmm_init();
c0206822:	e8 00 fe ff ff       	call   c0206627 <vmm_init>
    uint32_t re = vmm_kern_alloc();
c0206827:	e8 06 ff ff ff       	call   c0206732 <vmm_kern_alloc>
c020682c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    printk("get:0x%h\n",re);
c020682f:	83 ec 08             	sub    $0x8,%esp
c0206832:	ff 75 f4             	pushl  -0xc(%ebp)
c0206835:	8d 83 e9 02 00 00    	lea    0x2e9(%ebx),%eax
c020683b:	50                   	push   %eax
c020683c:	e8 15 d0 ff ff       	call   c0203856 <printk>
c0206841:	83 c4 10             	add    $0x10,%esp
c0206844:	90                   	nop
c0206845:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206848:	c9                   	leave  
c0206849:	c3                   	ret    
c020684a:	66 90                	xchg   %ax,%ax
c020684c:	66 90                	xchg   %ax,%ax
c020684e:	66 90                	xchg   %ax,%ax
c0206850:	66 90                	xchg   %ax,%ax
c0206852:	66 90                	xchg   %ax,%ax
c0206854:	66 90                	xchg   %ax,%ax
c0206856:	66 90                	xchg   %ax,%ax
c0206858:	66 90                	xchg   %ax,%ax
c020685a:	66 90                	xchg   %ax,%ax
c020685c:	66 90                	xchg   %ax,%ax
c020685e:	66 90                	xchg   %ax,%ax
c0206860:	66 90                	xchg   %ax,%ax
c0206862:	66 90                	xchg   %ax,%ax
c0206864:	66 90                	xchg   %ax,%ax
c0206866:	66 90                	xchg   %ax,%ax
c0206868:	66 90                	xchg   %ax,%ax
c020686a:	66 90                	xchg   %ax,%ax
c020686c:	66 90                	xchg   %ax,%ax
c020686e:	66 90                	xchg   %ax,%ax
c0206870:	66 90                	xchg   %ax,%ax
c0206872:	66 90                	xchg   %ax,%ax
c0206874:	66 90                	xchg   %ax,%ax
c0206876:	66 90                	xchg   %ax,%ax
c0206878:	66 90                	xchg   %ax,%ax
c020687a:	66 90                	xchg   %ax,%ax
c020687c:	66 90                	xchg   %ax,%ax
c020687e:	66 90                	xchg   %ax,%ax
c0206880:	66 90                	xchg   %ax,%ax
c0206882:	66 90                	xchg   %ax,%ax
c0206884:	66 90                	xchg   %ax,%ax
c0206886:	66 90                	xchg   %ax,%ax
c0206888:	66 90                	xchg   %ax,%ax
c020688a:	66 90                	xchg   %ax,%ax
c020688c:	66 90                	xchg   %ax,%ax
c020688e:	66 90                	xchg   %ax,%ax
c0206890:	66 90                	xchg   %ax,%ax
c0206892:	66 90                	xchg   %ax,%ax
c0206894:	66 90                	xchg   %ax,%ax
c0206896:	66 90                	xchg   %ax,%ax
c0206898:	66 90                	xchg   %ax,%ax
c020689a:	66 90                	xchg   %ax,%ax
c020689c:	66 90                	xchg   %ax,%ax
c020689e:	66 90                	xchg   %ax,%ax
c02068a0:	66 90                	xchg   %ax,%ax
c02068a2:	66 90                	xchg   %ax,%ax
c02068a4:	66 90                	xchg   %ax,%ax
c02068a6:	66 90                	xchg   %ax,%ax
c02068a8:	66 90                	xchg   %ax,%ax
c02068aa:	66 90                	xchg   %ax,%ax
c02068ac:	66 90                	xchg   %ax,%ax
c02068ae:	66 90                	xchg   %ax,%ax
c02068b0:	66 90                	xchg   %ax,%ax
c02068b2:	66 90                	xchg   %ax,%ax
c02068b4:	66 90                	xchg   %ax,%ax
c02068b6:	66 90                	xchg   %ax,%ax
c02068b8:	66 90                	xchg   %ax,%ax
c02068ba:	66 90                	xchg   %ax,%ax
c02068bc:	66 90                	xchg   %ax,%ax
c02068be:	66 90                	xchg   %ax,%ax
c02068c0:	66 90                	xchg   %ax,%ax
c02068c2:	66 90                	xchg   %ax,%ax
c02068c4:	66 90                	xchg   %ax,%ax
c02068c6:	66 90                	xchg   %ax,%ax
c02068c8:	66 90                	xchg   %ax,%ax
c02068ca:	66 90                	xchg   %ax,%ax
c02068cc:	66 90                	xchg   %ax,%ax
c02068ce:	66 90                	xchg   %ax,%ax
c02068d0:	66 90                	xchg   %ax,%ax
c02068d2:	66 90                	xchg   %ax,%ax
c02068d4:	66 90                	xchg   %ax,%ax
c02068d6:	66 90                	xchg   %ax,%ax
c02068d8:	66 90                	xchg   %ax,%ax
c02068da:	66 90                	xchg   %ax,%ax
c02068dc:	66 90                	xchg   %ax,%ax
c02068de:	66 90                	xchg   %ax,%ax
c02068e0:	66 90                	xchg   %ax,%ax
c02068e2:	66 90                	xchg   %ax,%ax
c02068e4:	66 90                	xchg   %ax,%ax
c02068e6:	66 90                	xchg   %ax,%ax
c02068e8:	66 90                	xchg   %ax,%ax
c02068ea:	66 90                	xchg   %ax,%ax
c02068ec:	66 90                	xchg   %ax,%ax
c02068ee:	66 90                	xchg   %ax,%ax
c02068f0:	66 90                	xchg   %ax,%ax
c02068f2:	66 90                	xchg   %ax,%ax
c02068f4:	66 90                	xchg   %ax,%ax
c02068f6:	66 90                	xchg   %ax,%ax
c02068f8:	66 90                	xchg   %ax,%ax
c02068fa:	66 90                	xchg   %ax,%ax
c02068fc:	66 90                	xchg   %ax,%ax
c02068fe:	66 90                	xchg   %ax,%ax
c0206900:	66 90                	xchg   %ax,%ax
c0206902:	66 90                	xchg   %ax,%ax
c0206904:	66 90                	xchg   %ax,%ax
c0206906:	66 90                	xchg   %ax,%ax
c0206908:	66 90                	xchg   %ax,%ax
c020690a:	66 90                	xchg   %ax,%ax
c020690c:	66 90                	xchg   %ax,%ax
c020690e:	66 90                	xchg   %ax,%ax
c0206910:	66 90                	xchg   %ax,%ax
c0206912:	66 90                	xchg   %ax,%ax
c0206914:	66 90                	xchg   %ax,%ax
c0206916:	66 90                	xchg   %ax,%ax
c0206918:	66 90                	xchg   %ax,%ax
c020691a:	66 90                	xchg   %ax,%ax
c020691c:	66 90                	xchg   %ax,%ax
c020691e:	66 90                	xchg   %ax,%ax
c0206920:	66 90                	xchg   %ax,%ax
c0206922:	66 90                	xchg   %ax,%ax
c0206924:	66 90                	xchg   %ax,%ax
c0206926:	66 90                	xchg   %ax,%ax
c0206928:	66 90                	xchg   %ax,%ax
c020692a:	66 90                	xchg   %ax,%ax
c020692c:	66 90                	xchg   %ax,%ax
c020692e:	66 90                	xchg   %ax,%ax
c0206930:	66 90                	xchg   %ax,%ax
c0206932:	66 90                	xchg   %ax,%ax
c0206934:	66 90                	xchg   %ax,%ax
c0206936:	66 90                	xchg   %ax,%ax
c0206938:	66 90                	xchg   %ax,%ax
c020693a:	66 90                	xchg   %ax,%ax
c020693c:	66 90                	xchg   %ax,%ax
c020693e:	66 90                	xchg   %ax,%ax
c0206940:	66 90                	xchg   %ax,%ax
c0206942:	66 90                	xchg   %ax,%ax
c0206944:	66 90                	xchg   %ax,%ax
c0206946:	66 90                	xchg   %ax,%ax
c0206948:	66 90                	xchg   %ax,%ax
c020694a:	66 90                	xchg   %ax,%ax
c020694c:	66 90                	xchg   %ax,%ax
c020694e:	66 90                	xchg   %ax,%ax
c0206950:	66 90                	xchg   %ax,%ax
c0206952:	66 90                	xchg   %ax,%ax
c0206954:	66 90                	xchg   %ax,%ax
c0206956:	66 90                	xchg   %ax,%ax
c0206958:	66 90                	xchg   %ax,%ax
c020695a:	66 90                	xchg   %ax,%ax
c020695c:	66 90                	xchg   %ax,%ax
c020695e:	66 90                	xchg   %ax,%ax
c0206960:	66 90                	xchg   %ax,%ax
c0206962:	66 90                	xchg   %ax,%ax
c0206964:	66 90                	xchg   %ax,%ax
c0206966:	66 90                	xchg   %ax,%ax
c0206968:	66 90                	xchg   %ax,%ax
c020696a:	66 90                	xchg   %ax,%ax
c020696c:	66 90                	xchg   %ax,%ax
c020696e:	66 90                	xchg   %ax,%ax
c0206970:	66 90                	xchg   %ax,%ax
c0206972:	66 90                	xchg   %ax,%ax
c0206974:	66 90                	xchg   %ax,%ax
c0206976:	66 90                	xchg   %ax,%ax
c0206978:	66 90                	xchg   %ax,%ax
c020697a:	66 90                	xchg   %ax,%ax
c020697c:	66 90                	xchg   %ax,%ax
c020697e:	66 90                	xchg   %ax,%ax
c0206980:	66 90                	xchg   %ax,%ax
c0206982:	66 90                	xchg   %ax,%ax
c0206984:	66 90                	xchg   %ax,%ax
c0206986:	66 90                	xchg   %ax,%ax
c0206988:	66 90                	xchg   %ax,%ax
c020698a:	66 90                	xchg   %ax,%ax
c020698c:	66 90                	xchg   %ax,%ax
c020698e:	66 90                	xchg   %ax,%ax
c0206990:	66 90                	xchg   %ax,%ax
c0206992:	66 90                	xchg   %ax,%ax
c0206994:	66 90                	xchg   %ax,%ax
c0206996:	66 90                	xchg   %ax,%ax
c0206998:	66 90                	xchg   %ax,%ax
c020699a:	66 90                	xchg   %ax,%ax
c020699c:	66 90                	xchg   %ax,%ax
c020699e:	66 90                	xchg   %ax,%ax
c02069a0:	66 90                	xchg   %ax,%ax
c02069a2:	66 90                	xchg   %ax,%ax
c02069a4:	66 90                	xchg   %ax,%ax
c02069a6:	66 90                	xchg   %ax,%ax
c02069a8:	66 90                	xchg   %ax,%ax
c02069aa:	66 90                	xchg   %ax,%ax
c02069ac:	66 90                	xchg   %ax,%ax
c02069ae:	66 90                	xchg   %ax,%ax
c02069b0:	66 90                	xchg   %ax,%ax
c02069b2:	66 90                	xchg   %ax,%ax
c02069b4:	66 90                	xchg   %ax,%ax
c02069b6:	66 90                	xchg   %ax,%ax
c02069b8:	66 90                	xchg   %ax,%ax
c02069ba:	66 90                	xchg   %ax,%ax
c02069bc:	66 90                	xchg   %ax,%ax
c02069be:	66 90                	xchg   %ax,%ax
c02069c0:	66 90                	xchg   %ax,%ax
c02069c2:	66 90                	xchg   %ax,%ax
c02069c4:	66 90                	xchg   %ax,%ax
c02069c6:	66 90                	xchg   %ax,%ax
c02069c8:	66 90                	xchg   %ax,%ax
c02069ca:	66 90                	xchg   %ax,%ax
c02069cc:	66 90                	xchg   %ax,%ax
c02069ce:	66 90                	xchg   %ax,%ax
c02069d0:	66 90                	xchg   %ax,%ax
c02069d2:	66 90                	xchg   %ax,%ax
c02069d4:	66 90                	xchg   %ax,%ax
c02069d6:	66 90                	xchg   %ax,%ax
c02069d8:	66 90                	xchg   %ax,%ax
c02069da:	66 90                	xchg   %ax,%ax
c02069dc:	66 90                	xchg   %ax,%ax
c02069de:	66 90                	xchg   %ax,%ax
c02069e0:	66 90                	xchg   %ax,%ax
c02069e2:	66 90                	xchg   %ax,%ax
c02069e4:	66 90                	xchg   %ax,%ax
c02069e6:	66 90                	xchg   %ax,%ax
c02069e8:	66 90                	xchg   %ax,%ax
c02069ea:	66 90                	xchg   %ax,%ax
c02069ec:	66 90                	xchg   %ax,%ax
c02069ee:	66 90                	xchg   %ax,%ax
c02069f0:	66 90                	xchg   %ax,%ax
c02069f2:	66 90                	xchg   %ax,%ax
c02069f4:	66 90                	xchg   %ax,%ax
c02069f6:	66 90                	xchg   %ax,%ax
c02069f8:	66 90                	xchg   %ax,%ax
c02069fa:	66 90                	xchg   %ax,%ax
c02069fc:	66 90                	xchg   %ax,%ax
c02069fe:	66 90                	xchg   %ax,%ax
c0206a00:	66 90                	xchg   %ax,%ax
c0206a02:	66 90                	xchg   %ax,%ax
c0206a04:	66 90                	xchg   %ax,%ax
c0206a06:	66 90                	xchg   %ax,%ax
c0206a08:	66 90                	xchg   %ax,%ax
c0206a0a:	66 90                	xchg   %ax,%ax
c0206a0c:	66 90                	xchg   %ax,%ax
c0206a0e:	66 90                	xchg   %ax,%ax
c0206a10:	66 90                	xchg   %ax,%ax
c0206a12:	66 90                	xchg   %ax,%ax
c0206a14:	66 90                	xchg   %ax,%ax
c0206a16:	66 90                	xchg   %ax,%ax
c0206a18:	66 90                	xchg   %ax,%ax
c0206a1a:	66 90                	xchg   %ax,%ax
c0206a1c:	66 90                	xchg   %ax,%ax
c0206a1e:	66 90                	xchg   %ax,%ax
c0206a20:	66 90                	xchg   %ax,%ax
c0206a22:	66 90                	xchg   %ax,%ax
c0206a24:	66 90                	xchg   %ax,%ax
c0206a26:	66 90                	xchg   %ax,%ax
c0206a28:	66 90                	xchg   %ax,%ax
c0206a2a:	66 90                	xchg   %ax,%ax
c0206a2c:	66 90                	xchg   %ax,%ax
c0206a2e:	66 90                	xchg   %ax,%ax
c0206a30:	66 90                	xchg   %ax,%ax
c0206a32:	66 90                	xchg   %ax,%ax
c0206a34:	66 90                	xchg   %ax,%ax
c0206a36:	66 90                	xchg   %ax,%ax
c0206a38:	66 90                	xchg   %ax,%ax
c0206a3a:	66 90                	xchg   %ax,%ax
c0206a3c:	66 90                	xchg   %ax,%ax
c0206a3e:	66 90                	xchg   %ax,%ax
c0206a40:	66 90                	xchg   %ax,%ax
c0206a42:	66 90                	xchg   %ax,%ax
c0206a44:	66 90                	xchg   %ax,%ax
c0206a46:	66 90                	xchg   %ax,%ax
c0206a48:	66 90                	xchg   %ax,%ax
c0206a4a:	66 90                	xchg   %ax,%ax
c0206a4c:	66 90                	xchg   %ax,%ax
c0206a4e:	66 90                	xchg   %ax,%ax
c0206a50:	66 90                	xchg   %ax,%ax
c0206a52:	66 90                	xchg   %ax,%ax
c0206a54:	66 90                	xchg   %ax,%ax
c0206a56:	66 90                	xchg   %ax,%ax
c0206a58:	66 90                	xchg   %ax,%ax
c0206a5a:	66 90                	xchg   %ax,%ax
c0206a5c:	66 90                	xchg   %ax,%ax
c0206a5e:	66 90                	xchg   %ax,%ax
c0206a60:	66 90                	xchg   %ax,%ax
c0206a62:	66 90                	xchg   %ax,%ax
c0206a64:	66 90                	xchg   %ax,%ax
c0206a66:	66 90                	xchg   %ax,%ax
c0206a68:	66 90                	xchg   %ax,%ax
c0206a6a:	66 90                	xchg   %ax,%ax
c0206a6c:	66 90                	xchg   %ax,%ax
c0206a6e:	66 90                	xchg   %ax,%ax
c0206a70:	66 90                	xchg   %ax,%ax
c0206a72:	66 90                	xchg   %ax,%ax
c0206a74:	66 90                	xchg   %ax,%ax
c0206a76:	66 90                	xchg   %ax,%ax
c0206a78:	66 90                	xchg   %ax,%ax
c0206a7a:	66 90                	xchg   %ax,%ax
c0206a7c:	66 90                	xchg   %ax,%ax
c0206a7e:	66 90                	xchg   %ax,%ax
c0206a80:	66 90                	xchg   %ax,%ax
c0206a82:	66 90                	xchg   %ax,%ax
c0206a84:	66 90                	xchg   %ax,%ax
c0206a86:	66 90                	xchg   %ax,%ax
c0206a88:	66 90                	xchg   %ax,%ax
c0206a8a:	66 90                	xchg   %ax,%ax
c0206a8c:	66 90                	xchg   %ax,%ax
c0206a8e:	66 90                	xchg   %ax,%ax
c0206a90:	66 90                	xchg   %ax,%ax
c0206a92:	66 90                	xchg   %ax,%ax
c0206a94:	66 90                	xchg   %ax,%ax
c0206a96:	66 90                	xchg   %ax,%ax
c0206a98:	66 90                	xchg   %ax,%ax
c0206a9a:	66 90                	xchg   %ax,%ax
c0206a9c:	66 90                	xchg   %ax,%ax
c0206a9e:	66 90                	xchg   %ax,%ax
c0206aa0:	66 90                	xchg   %ax,%ax
c0206aa2:	66 90                	xchg   %ax,%ax
c0206aa4:	66 90                	xchg   %ax,%ax
c0206aa6:	66 90                	xchg   %ax,%ax
c0206aa8:	66 90                	xchg   %ax,%ax
c0206aaa:	66 90                	xchg   %ax,%ax
c0206aac:	66 90                	xchg   %ax,%ax
c0206aae:	66 90                	xchg   %ax,%ax
c0206ab0:	66 90                	xchg   %ax,%ax
c0206ab2:	66 90                	xchg   %ax,%ax
c0206ab4:	66 90                	xchg   %ax,%ax
c0206ab6:	66 90                	xchg   %ax,%ax
c0206ab8:	66 90                	xchg   %ax,%ax
c0206aba:	66 90                	xchg   %ax,%ax
c0206abc:	66 90                	xchg   %ax,%ax
c0206abe:	66 90                	xchg   %ax,%ax
c0206ac0:	66 90                	xchg   %ax,%ax
c0206ac2:	66 90                	xchg   %ax,%ax
c0206ac4:	66 90                	xchg   %ax,%ax
c0206ac6:	66 90                	xchg   %ax,%ax
c0206ac8:	66 90                	xchg   %ax,%ax
c0206aca:	66 90                	xchg   %ax,%ax
c0206acc:	66 90                	xchg   %ax,%ax
c0206ace:	66 90                	xchg   %ax,%ax
c0206ad0:	66 90                	xchg   %ax,%ax
c0206ad2:	66 90                	xchg   %ax,%ax
c0206ad4:	66 90                	xchg   %ax,%ax
c0206ad6:	66 90                	xchg   %ax,%ax
c0206ad8:	66 90                	xchg   %ax,%ax
c0206ada:	66 90                	xchg   %ax,%ax
c0206adc:	66 90                	xchg   %ax,%ax
c0206ade:	66 90                	xchg   %ax,%ax
c0206ae0:	66 90                	xchg   %ax,%ax
c0206ae2:	66 90                	xchg   %ax,%ax
c0206ae4:	66 90                	xchg   %ax,%ax
c0206ae6:	66 90                	xchg   %ax,%ax
c0206ae8:	66 90                	xchg   %ax,%ax
c0206aea:	66 90                	xchg   %ax,%ax
c0206aec:	66 90                	xchg   %ax,%ax
c0206aee:	66 90                	xchg   %ax,%ax
c0206af0:	66 90                	xchg   %ax,%ax
c0206af2:	66 90                	xchg   %ax,%ax
c0206af4:	66 90                	xchg   %ax,%ax
c0206af6:	66 90                	xchg   %ax,%ax
c0206af8:	66 90                	xchg   %ax,%ax
c0206afa:	66 90                	xchg   %ax,%ax
c0206afc:	66 90                	xchg   %ax,%ax
c0206afe:	66 90                	xchg   %ax,%ax
c0206b00:	66 90                	xchg   %ax,%ax
c0206b02:	66 90                	xchg   %ax,%ax
c0206b04:	66 90                	xchg   %ax,%ax
c0206b06:	66 90                	xchg   %ax,%ax
c0206b08:	66 90                	xchg   %ax,%ax
c0206b0a:	66 90                	xchg   %ax,%ax
c0206b0c:	66 90                	xchg   %ax,%ax
c0206b0e:	66 90                	xchg   %ax,%ax
c0206b10:	66 90                	xchg   %ax,%ax
c0206b12:	66 90                	xchg   %ax,%ax
c0206b14:	66 90                	xchg   %ax,%ax
c0206b16:	66 90                	xchg   %ax,%ax
c0206b18:	66 90                	xchg   %ax,%ax
c0206b1a:	66 90                	xchg   %ax,%ax
c0206b1c:	66 90                	xchg   %ax,%ax
c0206b1e:	66 90                	xchg   %ax,%ax
c0206b20:	66 90                	xchg   %ax,%ax
c0206b22:	66 90                	xchg   %ax,%ax
c0206b24:	66 90                	xchg   %ax,%ax
c0206b26:	66 90                	xchg   %ax,%ax
c0206b28:	66 90                	xchg   %ax,%ax
c0206b2a:	66 90                	xchg   %ax,%ax
c0206b2c:	66 90                	xchg   %ax,%ax
c0206b2e:	66 90                	xchg   %ax,%ax
c0206b30:	66 90                	xchg   %ax,%ax
c0206b32:	66 90                	xchg   %ax,%ax
c0206b34:	66 90                	xchg   %ax,%ax
c0206b36:	66 90                	xchg   %ax,%ax
c0206b38:	66 90                	xchg   %ax,%ax
c0206b3a:	66 90                	xchg   %ax,%ax
c0206b3c:	66 90                	xchg   %ax,%ax
c0206b3e:	66 90                	xchg   %ax,%ax
c0206b40:	66 90                	xchg   %ax,%ax
c0206b42:	66 90                	xchg   %ax,%ax
c0206b44:	66 90                	xchg   %ax,%ax
c0206b46:	66 90                	xchg   %ax,%ax
c0206b48:	66 90                	xchg   %ax,%ax
c0206b4a:	66 90                	xchg   %ax,%ax
c0206b4c:	66 90                	xchg   %ax,%ax
c0206b4e:	66 90                	xchg   %ax,%ax
c0206b50:	66 90                	xchg   %ax,%ax
c0206b52:	66 90                	xchg   %ax,%ax
c0206b54:	66 90                	xchg   %ax,%ax
c0206b56:	66 90                	xchg   %ax,%ax
c0206b58:	66 90                	xchg   %ax,%ax
c0206b5a:	66 90                	xchg   %ax,%ax
c0206b5c:	66 90                	xchg   %ax,%ax
c0206b5e:	66 90                	xchg   %ax,%ax
c0206b60:	66 90                	xchg   %ax,%ax
c0206b62:	66 90                	xchg   %ax,%ax
c0206b64:	66 90                	xchg   %ax,%ax
c0206b66:	66 90                	xchg   %ax,%ax
c0206b68:	66 90                	xchg   %ax,%ax
c0206b6a:	66 90                	xchg   %ax,%ax
c0206b6c:	66 90                	xchg   %ax,%ax
c0206b6e:	66 90                	xchg   %ax,%ax
c0206b70:	66 90                	xchg   %ax,%ax
c0206b72:	66 90                	xchg   %ax,%ax
c0206b74:	66 90                	xchg   %ax,%ax
c0206b76:	66 90                	xchg   %ax,%ax
c0206b78:	66 90                	xchg   %ax,%ax
c0206b7a:	66 90                	xchg   %ax,%ax
c0206b7c:	66 90                	xchg   %ax,%ax
c0206b7e:	66 90                	xchg   %ax,%ax
c0206b80:	66 90                	xchg   %ax,%ax
c0206b82:	66 90                	xchg   %ax,%ax
c0206b84:	66 90                	xchg   %ax,%ax
c0206b86:	66 90                	xchg   %ax,%ax
c0206b88:	66 90                	xchg   %ax,%ax
c0206b8a:	66 90                	xchg   %ax,%ax
c0206b8c:	66 90                	xchg   %ax,%ax
c0206b8e:	66 90                	xchg   %ax,%ax
c0206b90:	66 90                	xchg   %ax,%ax
c0206b92:	66 90                	xchg   %ax,%ax
c0206b94:	66 90                	xchg   %ax,%ax
c0206b96:	66 90                	xchg   %ax,%ax
c0206b98:	66 90                	xchg   %ax,%ax
c0206b9a:	66 90                	xchg   %ax,%ax
c0206b9c:	66 90                	xchg   %ax,%ax
c0206b9e:	66 90                	xchg   %ax,%ax
c0206ba0:	66 90                	xchg   %ax,%ax
c0206ba2:	66 90                	xchg   %ax,%ax
c0206ba4:	66 90                	xchg   %ax,%ax
c0206ba6:	66 90                	xchg   %ax,%ax
c0206ba8:	66 90                	xchg   %ax,%ax
c0206baa:	66 90                	xchg   %ax,%ax
c0206bac:	66 90                	xchg   %ax,%ax
c0206bae:	66 90                	xchg   %ax,%ax
c0206bb0:	66 90                	xchg   %ax,%ax
c0206bb2:	66 90                	xchg   %ax,%ax
c0206bb4:	66 90                	xchg   %ax,%ax
c0206bb6:	66 90                	xchg   %ax,%ax
c0206bb8:	66 90                	xchg   %ax,%ax
c0206bba:	66 90                	xchg   %ax,%ax
c0206bbc:	66 90                	xchg   %ax,%ax
c0206bbe:	66 90                	xchg   %ax,%ax
c0206bc0:	66 90                	xchg   %ax,%ax
c0206bc2:	66 90                	xchg   %ax,%ax
c0206bc4:	66 90                	xchg   %ax,%ax
c0206bc6:	66 90                	xchg   %ax,%ax
c0206bc8:	66 90                	xchg   %ax,%ax
c0206bca:	66 90                	xchg   %ax,%ax
c0206bcc:	66 90                	xchg   %ax,%ax
c0206bce:	66 90                	xchg   %ax,%ax
c0206bd0:	66 90                	xchg   %ax,%ax
c0206bd2:	66 90                	xchg   %ax,%ax
c0206bd4:	66 90                	xchg   %ax,%ax
c0206bd6:	66 90                	xchg   %ax,%ax
c0206bd8:	66 90                	xchg   %ax,%ax
c0206bda:	66 90                	xchg   %ax,%ax
c0206bdc:	66 90                	xchg   %ax,%ax
c0206bde:	66 90                	xchg   %ax,%ax
c0206be0:	66 90                	xchg   %ax,%ax
c0206be2:	66 90                	xchg   %ax,%ax
c0206be4:	66 90                	xchg   %ax,%ax
c0206be6:	66 90                	xchg   %ax,%ax
c0206be8:	66 90                	xchg   %ax,%ax
c0206bea:	66 90                	xchg   %ax,%ax
c0206bec:	66 90                	xchg   %ax,%ax
c0206bee:	66 90                	xchg   %ax,%ax
c0206bf0:	66 90                	xchg   %ax,%ax
c0206bf2:	66 90                	xchg   %ax,%ax
c0206bf4:	66 90                	xchg   %ax,%ax
c0206bf6:	66 90                	xchg   %ax,%ax
c0206bf8:	66 90                	xchg   %ax,%ax
c0206bfa:	66 90                	xchg   %ax,%ax
c0206bfc:	66 90                	xchg   %ax,%ax
c0206bfe:	66 90                	xchg   %ax,%ax
c0206c00:	66 90                	xchg   %ax,%ax
c0206c02:	66 90                	xchg   %ax,%ax
c0206c04:	66 90                	xchg   %ax,%ax
c0206c06:	66 90                	xchg   %ax,%ax
c0206c08:	66 90                	xchg   %ax,%ax
c0206c0a:	66 90                	xchg   %ax,%ax
c0206c0c:	66 90                	xchg   %ax,%ax
c0206c0e:	66 90                	xchg   %ax,%ax
c0206c10:	66 90                	xchg   %ax,%ax
c0206c12:	66 90                	xchg   %ax,%ax
c0206c14:	66 90                	xchg   %ax,%ax
c0206c16:	66 90                	xchg   %ax,%ax
c0206c18:	66 90                	xchg   %ax,%ax
c0206c1a:	66 90                	xchg   %ax,%ax
c0206c1c:	66 90                	xchg   %ax,%ax
c0206c1e:	66 90                	xchg   %ax,%ax
c0206c20:	66 90                	xchg   %ax,%ax
c0206c22:	66 90                	xchg   %ax,%ax
c0206c24:	66 90                	xchg   %ax,%ax
c0206c26:	66 90                	xchg   %ax,%ax
c0206c28:	66 90                	xchg   %ax,%ax
c0206c2a:	66 90                	xchg   %ax,%ax
c0206c2c:	66 90                	xchg   %ax,%ax
c0206c2e:	66 90                	xchg   %ax,%ax
c0206c30:	66 90                	xchg   %ax,%ax
c0206c32:	66 90                	xchg   %ax,%ax
c0206c34:	66 90                	xchg   %ax,%ax
c0206c36:	66 90                	xchg   %ax,%ax
c0206c38:	66 90                	xchg   %ax,%ax
c0206c3a:	66 90                	xchg   %ax,%ax
c0206c3c:	66 90                	xchg   %ax,%ax
c0206c3e:	66 90                	xchg   %ax,%ax
c0206c40:	66 90                	xchg   %ax,%ax
c0206c42:	66 90                	xchg   %ax,%ax
c0206c44:	66 90                	xchg   %ax,%ax
c0206c46:	66 90                	xchg   %ax,%ax
c0206c48:	66 90                	xchg   %ax,%ax
c0206c4a:	66 90                	xchg   %ax,%ax
c0206c4c:	66 90                	xchg   %ax,%ax
c0206c4e:	66 90                	xchg   %ax,%ax
c0206c50:	66 90                	xchg   %ax,%ax
c0206c52:	66 90                	xchg   %ax,%ax
c0206c54:	66 90                	xchg   %ax,%ax
c0206c56:	66 90                	xchg   %ax,%ax
c0206c58:	66 90                	xchg   %ax,%ax
c0206c5a:	66 90                	xchg   %ax,%ax
c0206c5c:	66 90                	xchg   %ax,%ax
c0206c5e:	66 90                	xchg   %ax,%ax
c0206c60:	66 90                	xchg   %ax,%ax
c0206c62:	66 90                	xchg   %ax,%ax
c0206c64:	66 90                	xchg   %ax,%ax
c0206c66:	66 90                	xchg   %ax,%ax
c0206c68:	66 90                	xchg   %ax,%ax
c0206c6a:	66 90                	xchg   %ax,%ax
c0206c6c:	66 90                	xchg   %ax,%ax
c0206c6e:	66 90                	xchg   %ax,%ax
c0206c70:	66 90                	xchg   %ax,%ax
c0206c72:	66 90                	xchg   %ax,%ax
c0206c74:	66 90                	xchg   %ax,%ax
c0206c76:	66 90                	xchg   %ax,%ax
c0206c78:	66 90                	xchg   %ax,%ax
c0206c7a:	66 90                	xchg   %ax,%ax
c0206c7c:	66 90                	xchg   %ax,%ax
c0206c7e:	66 90                	xchg   %ax,%ax
c0206c80:	66 90                	xchg   %ax,%ax
c0206c82:	66 90                	xchg   %ax,%ax
c0206c84:	66 90                	xchg   %ax,%ax
c0206c86:	66 90                	xchg   %ax,%ax
c0206c88:	66 90                	xchg   %ax,%ax
c0206c8a:	66 90                	xchg   %ax,%ax
c0206c8c:	66 90                	xchg   %ax,%ax
c0206c8e:	66 90                	xchg   %ax,%ax
c0206c90:	66 90                	xchg   %ax,%ax
c0206c92:	66 90                	xchg   %ax,%ax
c0206c94:	66 90                	xchg   %ax,%ax
c0206c96:	66 90                	xchg   %ax,%ax
c0206c98:	66 90                	xchg   %ax,%ax
c0206c9a:	66 90                	xchg   %ax,%ax
c0206c9c:	66 90                	xchg   %ax,%ax
c0206c9e:	66 90                	xchg   %ax,%ax
c0206ca0:	66 90                	xchg   %ax,%ax
c0206ca2:	66 90                	xchg   %ax,%ax
c0206ca4:	66 90                	xchg   %ax,%ax
c0206ca6:	66 90                	xchg   %ax,%ax
c0206ca8:	66 90                	xchg   %ax,%ax
c0206caa:	66 90                	xchg   %ax,%ax
c0206cac:	66 90                	xchg   %ax,%ax
c0206cae:	66 90                	xchg   %ax,%ax
c0206cb0:	66 90                	xchg   %ax,%ax
c0206cb2:	66 90                	xchg   %ax,%ax
c0206cb4:	66 90                	xchg   %ax,%ax
c0206cb6:	66 90                	xchg   %ax,%ax
c0206cb8:	66 90                	xchg   %ax,%ax
c0206cba:	66 90                	xchg   %ax,%ax
c0206cbc:	66 90                	xchg   %ax,%ax
c0206cbe:	66 90                	xchg   %ax,%ax
c0206cc0:	66 90                	xchg   %ax,%ax
c0206cc2:	66 90                	xchg   %ax,%ax
c0206cc4:	66 90                	xchg   %ax,%ax
c0206cc6:	66 90                	xchg   %ax,%ax
c0206cc8:	66 90                	xchg   %ax,%ax
c0206cca:	66 90                	xchg   %ax,%ax
c0206ccc:	66 90                	xchg   %ax,%ax
c0206cce:	66 90                	xchg   %ax,%ax
c0206cd0:	66 90                	xchg   %ax,%ax
c0206cd2:	66 90                	xchg   %ax,%ax
c0206cd4:	66 90                	xchg   %ax,%ax
c0206cd6:	66 90                	xchg   %ax,%ax
c0206cd8:	66 90                	xchg   %ax,%ax
c0206cda:	66 90                	xchg   %ax,%ax
c0206cdc:	66 90                	xchg   %ax,%ax
c0206cde:	66 90                	xchg   %ax,%ax
c0206ce0:	66 90                	xchg   %ax,%ax
c0206ce2:	66 90                	xchg   %ax,%ax
c0206ce4:	66 90                	xchg   %ax,%ax
c0206ce6:	66 90                	xchg   %ax,%ax
c0206ce8:	66 90                	xchg   %ax,%ax
c0206cea:	66 90                	xchg   %ax,%ax
c0206cec:	66 90                	xchg   %ax,%ax
c0206cee:	66 90                	xchg   %ax,%ax
c0206cf0:	66 90                	xchg   %ax,%ax
c0206cf2:	66 90                	xchg   %ax,%ax
c0206cf4:	66 90                	xchg   %ax,%ax
c0206cf6:	66 90                	xchg   %ax,%ax
c0206cf8:	66 90                	xchg   %ax,%ax
c0206cfa:	66 90                	xchg   %ax,%ax
c0206cfc:	66 90                	xchg   %ax,%ax
c0206cfe:	66 90                	xchg   %ax,%ax
c0206d00:	66 90                	xchg   %ax,%ax
c0206d02:	66 90                	xchg   %ax,%ax
c0206d04:	66 90                	xchg   %ax,%ax
c0206d06:	66 90                	xchg   %ax,%ax
c0206d08:	66 90                	xchg   %ax,%ax
c0206d0a:	66 90                	xchg   %ax,%ax
c0206d0c:	66 90                	xchg   %ax,%ax
c0206d0e:	66 90                	xchg   %ax,%ax
c0206d10:	66 90                	xchg   %ax,%ax
c0206d12:	66 90                	xchg   %ax,%ax
c0206d14:	66 90                	xchg   %ax,%ax
c0206d16:	66 90                	xchg   %ax,%ax
c0206d18:	66 90                	xchg   %ax,%ax
c0206d1a:	66 90                	xchg   %ax,%ax
c0206d1c:	66 90                	xchg   %ax,%ax
c0206d1e:	66 90                	xchg   %ax,%ax
c0206d20:	66 90                	xchg   %ax,%ax
c0206d22:	66 90                	xchg   %ax,%ax
c0206d24:	66 90                	xchg   %ax,%ax
c0206d26:	66 90                	xchg   %ax,%ax
c0206d28:	66 90                	xchg   %ax,%ax
c0206d2a:	66 90                	xchg   %ax,%ax
c0206d2c:	66 90                	xchg   %ax,%ax
c0206d2e:	66 90                	xchg   %ax,%ax
c0206d30:	66 90                	xchg   %ax,%ax
c0206d32:	66 90                	xchg   %ax,%ax
c0206d34:	66 90                	xchg   %ax,%ax
c0206d36:	66 90                	xchg   %ax,%ax
c0206d38:	66 90                	xchg   %ax,%ax
c0206d3a:	66 90                	xchg   %ax,%ax
c0206d3c:	66 90                	xchg   %ax,%ax
c0206d3e:	66 90                	xchg   %ax,%ax
c0206d40:	66 90                	xchg   %ax,%ax
c0206d42:	66 90                	xchg   %ax,%ax
c0206d44:	66 90                	xchg   %ax,%ax
c0206d46:	66 90                	xchg   %ax,%ax
c0206d48:	66 90                	xchg   %ax,%ax
c0206d4a:	66 90                	xchg   %ax,%ax
c0206d4c:	66 90                	xchg   %ax,%ax
c0206d4e:	66 90                	xchg   %ax,%ax
c0206d50:	66 90                	xchg   %ax,%ax
c0206d52:	66 90                	xchg   %ax,%ax
c0206d54:	66 90                	xchg   %ax,%ax
c0206d56:	66 90                	xchg   %ax,%ax
c0206d58:	66 90                	xchg   %ax,%ax
c0206d5a:	66 90                	xchg   %ax,%ax
c0206d5c:	66 90                	xchg   %ax,%ax
c0206d5e:	66 90                	xchg   %ax,%ax
c0206d60:	66 90                	xchg   %ax,%ax
c0206d62:	66 90                	xchg   %ax,%ax
c0206d64:	66 90                	xchg   %ax,%ax
c0206d66:	66 90                	xchg   %ax,%ax
c0206d68:	66 90                	xchg   %ax,%ax
c0206d6a:	66 90                	xchg   %ax,%ax
c0206d6c:	66 90                	xchg   %ax,%ax
c0206d6e:	66 90                	xchg   %ax,%ax
c0206d70:	66 90                	xchg   %ax,%ax
c0206d72:	66 90                	xchg   %ax,%ax
c0206d74:	66 90                	xchg   %ax,%ax
c0206d76:	66 90                	xchg   %ax,%ax
c0206d78:	66 90                	xchg   %ax,%ax
c0206d7a:	66 90                	xchg   %ax,%ax
c0206d7c:	66 90                	xchg   %ax,%ax
c0206d7e:	66 90                	xchg   %ax,%ax
c0206d80:	66 90                	xchg   %ax,%ax
c0206d82:	66 90                	xchg   %ax,%ax
c0206d84:	66 90                	xchg   %ax,%ax
c0206d86:	66 90                	xchg   %ax,%ax
c0206d88:	66 90                	xchg   %ax,%ax
c0206d8a:	66 90                	xchg   %ax,%ax
c0206d8c:	66 90                	xchg   %ax,%ax
c0206d8e:	66 90                	xchg   %ax,%ax
c0206d90:	66 90                	xchg   %ax,%ax
c0206d92:	66 90                	xchg   %ax,%ax
c0206d94:	66 90                	xchg   %ax,%ax
c0206d96:	66 90                	xchg   %ax,%ax
c0206d98:	66 90                	xchg   %ax,%ax
c0206d9a:	66 90                	xchg   %ax,%ax
c0206d9c:	66 90                	xchg   %ax,%ax
c0206d9e:	66 90                	xchg   %ax,%ax
c0206da0:	66 90                	xchg   %ax,%ax
c0206da2:	66 90                	xchg   %ax,%ax
c0206da4:	66 90                	xchg   %ax,%ax
c0206da6:	66 90                	xchg   %ax,%ax
c0206da8:	66 90                	xchg   %ax,%ax
c0206daa:	66 90                	xchg   %ax,%ax
c0206dac:	66 90                	xchg   %ax,%ax
c0206dae:	66 90                	xchg   %ax,%ax
c0206db0:	66 90                	xchg   %ax,%ax
c0206db2:	66 90                	xchg   %ax,%ax
c0206db4:	66 90                	xchg   %ax,%ax
c0206db6:	66 90                	xchg   %ax,%ax
c0206db8:	66 90                	xchg   %ax,%ax
c0206dba:	66 90                	xchg   %ax,%ax
c0206dbc:	66 90                	xchg   %ax,%ax
c0206dbe:	66 90                	xchg   %ax,%ax
c0206dc0:	66 90                	xchg   %ax,%ax
c0206dc2:	66 90                	xchg   %ax,%ax
c0206dc4:	66 90                	xchg   %ax,%ax
c0206dc6:	66 90                	xchg   %ax,%ax
c0206dc8:	66 90                	xchg   %ax,%ax
c0206dca:	66 90                	xchg   %ax,%ax
c0206dcc:	66 90                	xchg   %ax,%ax
c0206dce:	66 90                	xchg   %ax,%ax
c0206dd0:	66 90                	xchg   %ax,%ax
c0206dd2:	66 90                	xchg   %ax,%ax
c0206dd4:	66 90                	xchg   %ax,%ax
c0206dd6:	66 90                	xchg   %ax,%ax
c0206dd8:	66 90                	xchg   %ax,%ax
c0206dda:	66 90                	xchg   %ax,%ax
c0206ddc:	66 90                	xchg   %ax,%ax
c0206dde:	66 90                	xchg   %ax,%ax
c0206de0:	66 90                	xchg   %ax,%ax
c0206de2:	66 90                	xchg   %ax,%ax
c0206de4:	66 90                	xchg   %ax,%ax
c0206de6:	66 90                	xchg   %ax,%ax
c0206de8:	66 90                	xchg   %ax,%ax
c0206dea:	66 90                	xchg   %ax,%ax
c0206dec:	66 90                	xchg   %ax,%ax
c0206dee:	66 90                	xchg   %ax,%ax
c0206df0:	66 90                	xchg   %ax,%ax
c0206df2:	66 90                	xchg   %ax,%ax
c0206df4:	66 90                	xchg   %ax,%ax
c0206df6:	66 90                	xchg   %ax,%ax
c0206df8:	66 90                	xchg   %ax,%ax
c0206dfa:	66 90                	xchg   %ax,%ax
c0206dfc:	66 90                	xchg   %ax,%ax
c0206dfe:	66 90                	xchg   %ax,%ax
c0206e00:	66 90                	xchg   %ax,%ax
c0206e02:	66 90                	xchg   %ax,%ax
c0206e04:	66 90                	xchg   %ax,%ax
c0206e06:	66 90                	xchg   %ax,%ax
c0206e08:	66 90                	xchg   %ax,%ax
c0206e0a:	66 90                	xchg   %ax,%ax
c0206e0c:	66 90                	xchg   %ax,%ax
c0206e0e:	66 90                	xchg   %ax,%ax
c0206e10:	66 90                	xchg   %ax,%ax
c0206e12:	66 90                	xchg   %ax,%ax
c0206e14:	66 90                	xchg   %ax,%ax
c0206e16:	66 90                	xchg   %ax,%ax
c0206e18:	66 90                	xchg   %ax,%ax
c0206e1a:	66 90                	xchg   %ax,%ax
c0206e1c:	66 90                	xchg   %ax,%ax
c0206e1e:	66 90                	xchg   %ax,%ax
c0206e20:	66 90                	xchg   %ax,%ax
c0206e22:	66 90                	xchg   %ax,%ax
c0206e24:	66 90                	xchg   %ax,%ax
c0206e26:	66 90                	xchg   %ax,%ax
c0206e28:	66 90                	xchg   %ax,%ax
c0206e2a:	66 90                	xchg   %ax,%ax
c0206e2c:	66 90                	xchg   %ax,%ax
c0206e2e:	66 90                	xchg   %ax,%ax
c0206e30:	66 90                	xchg   %ax,%ax
c0206e32:	66 90                	xchg   %ax,%ax
c0206e34:	66 90                	xchg   %ax,%ax
c0206e36:	66 90                	xchg   %ax,%ax
c0206e38:	66 90                	xchg   %ax,%ax
c0206e3a:	66 90                	xchg   %ax,%ax
c0206e3c:	66 90                	xchg   %ax,%ax
c0206e3e:	66 90                	xchg   %ax,%ax
c0206e40:	66 90                	xchg   %ax,%ax
c0206e42:	66 90                	xchg   %ax,%ax
c0206e44:	66 90                	xchg   %ax,%ax
c0206e46:	66 90                	xchg   %ax,%ax
c0206e48:	66 90                	xchg   %ax,%ax
c0206e4a:	66 90                	xchg   %ax,%ax
c0206e4c:	66 90                	xchg   %ax,%ax
c0206e4e:	66 90                	xchg   %ax,%ax
c0206e50:	66 90                	xchg   %ax,%ax
c0206e52:	66 90                	xchg   %ax,%ax
c0206e54:	66 90                	xchg   %ax,%ax
c0206e56:	66 90                	xchg   %ax,%ax
c0206e58:	66 90                	xchg   %ax,%ax
c0206e5a:	66 90                	xchg   %ax,%ax
c0206e5c:	66 90                	xchg   %ax,%ax
c0206e5e:	66 90                	xchg   %ax,%ax
c0206e60:	66 90                	xchg   %ax,%ax
c0206e62:	66 90                	xchg   %ax,%ax
c0206e64:	66 90                	xchg   %ax,%ax
c0206e66:	66 90                	xchg   %ax,%ax
c0206e68:	66 90                	xchg   %ax,%ax
c0206e6a:	66 90                	xchg   %ax,%ax
c0206e6c:	66 90                	xchg   %ax,%ax
c0206e6e:	66 90                	xchg   %ax,%ax
c0206e70:	66 90                	xchg   %ax,%ax
c0206e72:	66 90                	xchg   %ax,%ax
c0206e74:	66 90                	xchg   %ax,%ax
c0206e76:	66 90                	xchg   %ax,%ax
c0206e78:	66 90                	xchg   %ax,%ax
c0206e7a:	66 90                	xchg   %ax,%ax
c0206e7c:	66 90                	xchg   %ax,%ax
c0206e7e:	66 90                	xchg   %ax,%ax
c0206e80:	66 90                	xchg   %ax,%ax
c0206e82:	66 90                	xchg   %ax,%ax
c0206e84:	66 90                	xchg   %ax,%ax
c0206e86:	66 90                	xchg   %ax,%ax
c0206e88:	66 90                	xchg   %ax,%ax
c0206e8a:	66 90                	xchg   %ax,%ax
c0206e8c:	66 90                	xchg   %ax,%ax
c0206e8e:	66 90                	xchg   %ax,%ax
c0206e90:	66 90                	xchg   %ax,%ax
c0206e92:	66 90                	xchg   %ax,%ax
c0206e94:	66 90                	xchg   %ax,%ax
c0206e96:	66 90                	xchg   %ax,%ax
c0206e98:	66 90                	xchg   %ax,%ax
c0206e9a:	66 90                	xchg   %ax,%ax
c0206e9c:	66 90                	xchg   %ax,%ax
c0206e9e:	66 90                	xchg   %ax,%ax
c0206ea0:	66 90                	xchg   %ax,%ax
c0206ea2:	66 90                	xchg   %ax,%ax
c0206ea4:	66 90                	xchg   %ax,%ax
c0206ea6:	66 90                	xchg   %ax,%ax
c0206ea8:	66 90                	xchg   %ax,%ax
c0206eaa:	66 90                	xchg   %ax,%ax
c0206eac:	66 90                	xchg   %ax,%ax
c0206eae:	66 90                	xchg   %ax,%ax
c0206eb0:	66 90                	xchg   %ax,%ax
c0206eb2:	66 90                	xchg   %ax,%ax
c0206eb4:	66 90                	xchg   %ax,%ax
c0206eb6:	66 90                	xchg   %ax,%ax
c0206eb8:	66 90                	xchg   %ax,%ax
c0206eba:	66 90                	xchg   %ax,%ax
c0206ebc:	66 90                	xchg   %ax,%ax
c0206ebe:	66 90                	xchg   %ax,%ax
c0206ec0:	66 90                	xchg   %ax,%ax
c0206ec2:	66 90                	xchg   %ax,%ax
c0206ec4:	66 90                	xchg   %ax,%ax
c0206ec6:	66 90                	xchg   %ax,%ax
c0206ec8:	66 90                	xchg   %ax,%ax
c0206eca:	66 90                	xchg   %ax,%ax
c0206ecc:	66 90                	xchg   %ax,%ax
c0206ece:	66 90                	xchg   %ax,%ax
c0206ed0:	66 90                	xchg   %ax,%ax
c0206ed2:	66 90                	xchg   %ax,%ax
c0206ed4:	66 90                	xchg   %ax,%ax
c0206ed6:	66 90                	xchg   %ax,%ax
c0206ed8:	66 90                	xchg   %ax,%ax
c0206eda:	66 90                	xchg   %ax,%ax
c0206edc:	66 90                	xchg   %ax,%ax
c0206ede:	66 90                	xchg   %ax,%ax
c0206ee0:	66 90                	xchg   %ax,%ax
c0206ee2:	66 90                	xchg   %ax,%ax
c0206ee4:	66 90                	xchg   %ax,%ax
c0206ee6:	66 90                	xchg   %ax,%ax
c0206ee8:	66 90                	xchg   %ax,%ax
c0206eea:	66 90                	xchg   %ax,%ax
c0206eec:	66 90                	xchg   %ax,%ax
c0206eee:	66 90                	xchg   %ax,%ax
c0206ef0:	66 90                	xchg   %ax,%ax
c0206ef2:	66 90                	xchg   %ax,%ax
c0206ef4:	66 90                	xchg   %ax,%ax
c0206ef6:	66 90                	xchg   %ax,%ax
c0206ef8:	66 90                	xchg   %ax,%ax
c0206efa:	66 90                	xchg   %ax,%ax
c0206efc:	66 90                	xchg   %ax,%ax
c0206efe:	66 90                	xchg   %ax,%ax
c0206f00:	66 90                	xchg   %ax,%ax
c0206f02:	66 90                	xchg   %ax,%ax
c0206f04:	66 90                	xchg   %ax,%ax
c0206f06:	66 90                	xchg   %ax,%ax
c0206f08:	66 90                	xchg   %ax,%ax
c0206f0a:	66 90                	xchg   %ax,%ax
c0206f0c:	66 90                	xchg   %ax,%ax
c0206f0e:	66 90                	xchg   %ax,%ax
c0206f10:	66 90                	xchg   %ax,%ax
c0206f12:	66 90                	xchg   %ax,%ax
c0206f14:	66 90                	xchg   %ax,%ax
c0206f16:	66 90                	xchg   %ax,%ax
c0206f18:	66 90                	xchg   %ax,%ax
c0206f1a:	66 90                	xchg   %ax,%ax
c0206f1c:	66 90                	xchg   %ax,%ax
c0206f1e:	66 90                	xchg   %ax,%ax
c0206f20:	66 90                	xchg   %ax,%ax
c0206f22:	66 90                	xchg   %ax,%ax
c0206f24:	66 90                	xchg   %ax,%ax
c0206f26:	66 90                	xchg   %ax,%ax
c0206f28:	66 90                	xchg   %ax,%ax
c0206f2a:	66 90                	xchg   %ax,%ax
c0206f2c:	66 90                	xchg   %ax,%ax
c0206f2e:	66 90                	xchg   %ax,%ax
c0206f30:	66 90                	xchg   %ax,%ax
c0206f32:	66 90                	xchg   %ax,%ax
c0206f34:	66 90                	xchg   %ax,%ax
c0206f36:	66 90                	xchg   %ax,%ax
c0206f38:	66 90                	xchg   %ax,%ax
c0206f3a:	66 90                	xchg   %ax,%ax
c0206f3c:	66 90                	xchg   %ax,%ax
c0206f3e:	66 90                	xchg   %ax,%ax
c0206f40:	66 90                	xchg   %ax,%ax
c0206f42:	66 90                	xchg   %ax,%ax
c0206f44:	66 90                	xchg   %ax,%ax
c0206f46:	66 90                	xchg   %ax,%ax
c0206f48:	66 90                	xchg   %ax,%ax
c0206f4a:	66 90                	xchg   %ax,%ax
c0206f4c:	66 90                	xchg   %ax,%ax
c0206f4e:	66 90                	xchg   %ax,%ax
c0206f50:	66 90                	xchg   %ax,%ax
c0206f52:	66 90                	xchg   %ax,%ax
c0206f54:	66 90                	xchg   %ax,%ax
c0206f56:	66 90                	xchg   %ax,%ax
c0206f58:	66 90                	xchg   %ax,%ax
c0206f5a:	66 90                	xchg   %ax,%ax
c0206f5c:	66 90                	xchg   %ax,%ax
c0206f5e:	66 90                	xchg   %ax,%ax
c0206f60:	66 90                	xchg   %ax,%ax
c0206f62:	66 90                	xchg   %ax,%ax
c0206f64:	66 90                	xchg   %ax,%ax
c0206f66:	66 90                	xchg   %ax,%ax
c0206f68:	66 90                	xchg   %ax,%ax
c0206f6a:	66 90                	xchg   %ax,%ax
c0206f6c:	66 90                	xchg   %ax,%ax
c0206f6e:	66 90                	xchg   %ax,%ax
c0206f70:	66 90                	xchg   %ax,%ax
c0206f72:	66 90                	xchg   %ax,%ax
c0206f74:	66 90                	xchg   %ax,%ax
c0206f76:	66 90                	xchg   %ax,%ax
c0206f78:	66 90                	xchg   %ax,%ax
c0206f7a:	66 90                	xchg   %ax,%ax
c0206f7c:	66 90                	xchg   %ax,%ax
c0206f7e:	66 90                	xchg   %ax,%ax
c0206f80:	66 90                	xchg   %ax,%ax
c0206f82:	66 90                	xchg   %ax,%ax
c0206f84:	66 90                	xchg   %ax,%ax
c0206f86:	66 90                	xchg   %ax,%ax
c0206f88:	66 90                	xchg   %ax,%ax
c0206f8a:	66 90                	xchg   %ax,%ax
c0206f8c:	66 90                	xchg   %ax,%ax
c0206f8e:	66 90                	xchg   %ax,%ax
c0206f90:	66 90                	xchg   %ax,%ax
c0206f92:	66 90                	xchg   %ax,%ax
c0206f94:	66 90                	xchg   %ax,%ax
c0206f96:	66 90                	xchg   %ax,%ax
c0206f98:	66 90                	xchg   %ax,%ax
c0206f9a:	66 90                	xchg   %ax,%ax
c0206f9c:	66 90                	xchg   %ax,%ax
c0206f9e:	66 90                	xchg   %ax,%ax
c0206fa0:	66 90                	xchg   %ax,%ax
c0206fa2:	66 90                	xchg   %ax,%ax
c0206fa4:	66 90                	xchg   %ax,%ax
c0206fa6:	66 90                	xchg   %ax,%ax
c0206fa8:	66 90                	xchg   %ax,%ax
c0206faa:	66 90                	xchg   %ax,%ax
c0206fac:	66 90                	xchg   %ax,%ax
c0206fae:	66 90                	xchg   %ax,%ax
c0206fb0:	66 90                	xchg   %ax,%ax
c0206fb2:	66 90                	xchg   %ax,%ax
c0206fb4:	66 90                	xchg   %ax,%ax
c0206fb6:	66 90                	xchg   %ax,%ax
c0206fb8:	66 90                	xchg   %ax,%ax
c0206fba:	66 90                	xchg   %ax,%ax
c0206fbc:	66 90                	xchg   %ax,%ax
c0206fbe:	66 90                	xchg   %ax,%ax
c0206fc0:	66 90                	xchg   %ax,%ax
c0206fc2:	66 90                	xchg   %ax,%ax
c0206fc4:	66 90                	xchg   %ax,%ax
c0206fc6:	66 90                	xchg   %ax,%ax
c0206fc8:	66 90                	xchg   %ax,%ax
c0206fca:	66 90                	xchg   %ax,%ax
c0206fcc:	66 90                	xchg   %ax,%ax
c0206fce:	66 90                	xchg   %ax,%ax
c0206fd0:	66 90                	xchg   %ax,%ax
c0206fd2:	66 90                	xchg   %ax,%ax
c0206fd4:	66 90                	xchg   %ax,%ax
c0206fd6:	66 90                	xchg   %ax,%ax
c0206fd8:	66 90                	xchg   %ax,%ax
c0206fda:	66 90                	xchg   %ax,%ax
c0206fdc:	66 90                	xchg   %ax,%ax
c0206fde:	66 90                	xchg   %ax,%ax
c0206fe0:	66 90                	xchg   %ax,%ax
c0206fe2:	66 90                	xchg   %ax,%ax
c0206fe4:	66 90                	xchg   %ax,%ax
c0206fe6:	66 90                	xchg   %ax,%ax
c0206fe8:	66 90                	xchg   %ax,%ax
c0206fea:	66 90                	xchg   %ax,%ax
c0206fec:	66 90                	xchg   %ax,%ax
c0206fee:	66 90                	xchg   %ax,%ax
c0206ff0:	66 90                	xchg   %ax,%ax
c0206ff2:	66 90                	xchg   %ax,%ax
c0206ff4:	66 90                	xchg   %ax,%ax
c0206ff6:	66 90                	xchg   %ax,%ax
c0206ff8:	66 90                	xchg   %ax,%ax
c0206ffa:	66 90                	xchg   %ax,%ax
c0206ffc:	66 90                	xchg   %ax,%ax
c0206ffe:	66 90                	xchg   %ax,%ax

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0207000 <__x86.get_pc_thunk.ax>:
c0207000:	8b 04 24             	mov    (%esp),%eax
c0207003:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c0207004 <__x86.get_pc_thunk.bx>:
c0207004:	8b 1c 24             	mov    (%esp),%ebx
c0207007:	c3                   	ret    
