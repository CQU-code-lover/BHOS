
kernel.elf：     文件格式 elf32-i386


Disassembly of section .text:

c0203000 <GDT_BASE>:
	...

c0203008 <CODE_DESC>:
section .text    
[EXTERN kern_entry]
   GDT_BASE:   dd    0x00000000 
           	   dd    0x00000000

   CODE_DESC:  dd    0x0000FFFF 
c0203008:	ff ff 00 00 00 98 cf 00                             ........

c0203010 <DATA_STACK_DESC>:
               dd    DESC_CODE_HIGH4

   DATA_STACK_DESC:  dd    0x0000FFFF
c0203010:	ff ff 00 00 00 92 cf 00                             ........

c0203018 <VIDEO_DESC>:
                     dd    DESC_DATA_HIGH4

   VIDEO_DESC: dd    0x80000007        ; limit=(0xbffff-0xb8000)/4k=0x7
c0203018:	07 00 00 80 0b 92 c0 00                             ........

c0203020 <USER_CODE_DESC>:
               dd    DESC_VIDEO_HIGH4  ; 此时dpl为0

    ;---------新增段描述符-----------
    ;用户代码段与数据段
    USER_CODE_DESC: dd 0x0000FFFF
c0203020:	ff ff 00 00 00 f8 cf 00                             ........

c0203028 <USER_DATA_DESC>:
                dd   DESC_USER_CODE_HIGH4

    USER_DATA_DESC: dd 0x0000FFFF
c0203028:	ff ff 00 00 00 f2 cf 00                             ........

c0203030 <total_mem_bytes>:
   SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0     ; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0
   SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0     ; 同上
   SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0    ; 同上 
   ;SELECTOR_USER_CODE equ (0x004<<3) + TI_GDT + RPL3
   ;SELECTOR_USER_DATA equ (0x005<<3) + TI_GDT + RPL3
   total_mem_bytes dd 0                  
c0203030:	00 00 00 00                                         ....

c0203034 <gdt_ptr>:
   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址
   gdt_ptr  dw  GDT_LIMIT 
c0203034:	2f 00 00 30 20 c0                                   /..0 .

c020303a <boot_start_after_set_paging>:
        	dd  GDT_BASE
;boot开始！
boot_start_after_set_paging:        ;此处修改了函数名     在设置好页表后调用此函数
    mov ebx,[temp_mboot_ptr]     ;此处将暂存的mboot信息取出    但是一定要注意：必须要前4MB的物理-虚拟内存映射才能够使用
c020303a:	8b 1d 0c 00 10 00    	mov    0x10000c,%ebx
    mov [mboot_ptr], ebx ; GRUB加载内核后会将mutiboot信息地址存放在ebx中
c0203040:	89 1d 0c 70 20 c0    	mov    %ebx,0xc020700c
    ;-----------------   准备进入保护模式   -------------------
;1 打开A20
;2 加载gdt
;3 将cr0的pe位置1
   ;-----------------  打开A20  ----------------
    in al,0x92
c0203046:	e4 92                	in     $0x92,%al
    or al,0000_0010B
c0203048:	0c 02                	or     $0x2,%al
    out 0x92,al
c020304a:	e6 92                	out    %al,$0x92
   ;-----------------  加载GDT  ----------------
    lgdt [gdt_ptr]
c020304c:	0f 01 15 34 30 20 c0 	lgdtl  0xc0203034
   ;-----------------  cr0第0位置1  ----------------
    mov eax, cr0
c0203053:	0f 20 c0             	mov    %cr0,%eax
    or eax, 0x00000001
c0203056:	83 c8 01             	or     $0x1,%eax
    mov cr0, eax
c0203059:	0f 22 c0             	mov    %eax,%cr0
    jmp dword SELECTOR_CODE:far_jmp_target      ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，
c020305c:	ea 63 30 20 c0 08 00 	ljmp   $0x8,$0xc0203063

c0203063 <far_jmp_target>:

;初始化段寄存器以及栈结构
    far_jmp_target:
    mov ax,SELECTOR_DATA
c0203063:	66 b8 10 00          	mov    $0x10,%ax
    mov ss,ax
c0203067:	8e d0                	mov    %eax,%ss
    mov ds,ax
c0203069:	8e d8                	mov    %eax,%ds
  	mov ax,SELECTOR_VIDEO
c020306b:	66 b8 18 00          	mov    $0x18,%ax
  	mov gs,ax
c020306f:	8e e8                	mov    %eax,%gs
    mov esp, STACK_TOP      
c0203071:	bc 03 10 29 c0       	mov    $0xc0291003,%esp
    and esp, 0xFFFFFFF0  ;16字节对齐
c0203076:	83 e4 f0             	and    $0xfffffff0,%esp
    mov ebp, 0         
c0203079:	bd 00 00 00 00       	mov    $0x0,%ebp
    mov eax,kern_bitmap_block
c020307e:	b8 00 90 20 c0       	mov    $0xc0209000,%eax
    mov [kern_bitmap],eax
c0203083:	a3 08 70 20 c0       	mov    %eax,0xc0207008
;进入内核主函数    
    call kern_entry                    
c0203088:	e8 12 12 00 00       	call   c020429f <kern_entry>
    jmp dword $          ;防止意外退出内核
c020308d:	e9 fb ff ff ff       	jmp    c020308d <far_jmp_target+0x2a>
c0203092:	66 90                	xchg   %ax,%ax
c0203094:	66 90                	xchg   %ax,%ax
c0203096:	66 90                	xchg   %ax,%ax
c0203098:	66 90                	xchg   %ax,%ax
c020309a:	66 90                	xchg   %ax,%ax
c020309c:	66 90                	xchg   %ax,%ax
c020309e:	66 90                	xchg   %ax,%ax

c02030a0 <pre_handle>:
%endmacro


[EXTERN int_func_route]
pre_handle:
	pushad               ;压入八个32位
c02030a0:	60                   	pusha  
	mov ecx,[ss:esp+32]
c02030a1:	36 8b 4c 24 20       	mov    %ss:0x20(%esp),%ecx
	mov ebx,eax
c02030a6:	89 c3                	mov    %eax,%ebx
	mov ax,es          ;进入时ss已经被切换了
c02030a8:	66 8c c0             	mov    %es,%ax
	and eax,0x0000FFFF
c02030ab:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030b0:	50                   	push   %eax
	mov ax,fs          
c02030b1:	66 8c e0             	mov    %fs,%ax
	and eax,0x0000FFFF
c02030b4:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030b9:	50                   	push   %eax
	mov ax,gs
c02030ba:	66 8c e8             	mov    %gs,%ax
	and eax,0x0000FFFF
c02030bd:	25 ff ff 00 00       	and    $0xffff,%eax
	push eax
c02030c2:	50                   	push   %eax
	mov ax,KERN_DATA_SELECTOR    ;不包含ss
c02030c3:	66 b8 10 00          	mov    $0x10,%ax
	mov es,ax
c02030c7:	8e c0                	mov    %eax,%es
	mov fs,ax
c02030c9:	8e e0                	mov    %eax,%fs
	mov ax,KERN_VGA_SELECTOR
c02030cb:	66 b8 18 00          	mov    $0x18,%ax
	mov gs,ax
c02030cf:	8e e8                	mov    %eax,%gs
	push ebx     ;传入void *
c02030d1:	53                   	push   %ebx
	push ecx     ;传入int类型中断号
c02030d2:	51                   	push   %ecx
	call int_func_route
c02030d3:	e8 be 30 00 00       	call   c0206196 <int_func_route>
	add esp,8
c02030d8:	83 c4 08             	add    $0x8,%esp
	pop eax
c02030db:	58                   	pop    %eax
	mov gs,ax
c02030dc:	8e e8                	mov    %eax,%gs
	pop eax
c02030de:	58                   	pop    %eax
	mov fs,ax
c02030df:	8e e0                	mov    %eax,%fs
	pop eax
c02030e1:	58                   	pop    %eax
	mov es,ax
c02030e2:	8e c0                	mov    %eax,%es
	popad
c02030e4:	61                   	popa   
	add esp,8
c02030e5:	83 c4 08             	add    $0x8,%esp
	mov al,0x20
c02030e8:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02030ea:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02030ec:	e6 20                	out    %al,$0x20
	iret
c02030ee:	cf                   	iret   

c02030ef <isr0>:


NO_ERROCODE 0
c02030ef:	89 e0                	mov    %esp,%eax
c02030f1:	6a 00                	push   $0x0
c02030f3:	6a 00                	push   $0x0
c02030f5:	eb a9                	jmp    c02030a0 <pre_handle>

c02030f7 <isr1>:
NO_ERROCODE 1
c02030f7:	89 e0                	mov    %esp,%eax
c02030f9:	6a 00                	push   $0x0
c02030fb:	6a 01                	push   $0x1
c02030fd:	eb a1                	jmp    c02030a0 <pre_handle>

c02030ff <isr2>:
NO_ERROCODE 2
c02030ff:	89 e0                	mov    %esp,%eax
c0203101:	6a 00                	push   $0x0
c0203103:	6a 02                	push   $0x2
c0203105:	eb 99                	jmp    c02030a0 <pre_handle>

c0203107 <isr3>:
NO_ERROCODE 3
c0203107:	89 e0                	mov    %esp,%eax
c0203109:	6a 00                	push   $0x0
c020310b:	6a 03                	push   $0x3
c020310d:	eb 91                	jmp    c02030a0 <pre_handle>

c020310f <isr4>:
NO_ERROCODE 4
c020310f:	89 e0                	mov    %esp,%eax
c0203111:	6a 00                	push   $0x0
c0203113:	6a 04                	push   $0x4
c0203115:	eb 89                	jmp    c02030a0 <pre_handle>

c0203117 <isr5>:
NO_ERROCODE 5
c0203117:	89 e0                	mov    %esp,%eax
c0203119:	6a 00                	push   $0x0
c020311b:	6a 05                	push   $0x5
c020311d:	eb 81                	jmp    c02030a0 <pre_handle>

c020311f <isr6>:
NO_ERROCODE 6
c020311f:	89 e0                	mov    %esp,%eax
c0203121:	6a 00                	push   $0x0
c0203123:	6a 06                	push   $0x6
c0203125:	e9 76 ff ff ff       	jmp    c02030a0 <pre_handle>

c020312a <isr7>:
NO_ERROCODE 7
c020312a:	89 e0                	mov    %esp,%eax
c020312c:	6a 00                	push   $0x0
c020312e:	6a 07                	push   $0x7
c0203130:	e9 6b ff ff ff       	jmp    c02030a0 <pre_handle>

c0203135 <isr8>:
HAVE_ERROCODE 8
c0203135:	89 e0                	mov    %esp,%eax
c0203137:	90                   	nop
c0203138:	6a 08                	push   $0x8
c020313a:	e9 61 ff ff ff       	jmp    c02030a0 <pre_handle>

c020313f <isr9>:
NO_ERROCODE 9
c020313f:	89 e0                	mov    %esp,%eax
c0203141:	6a 00                	push   $0x0
c0203143:	6a 09                	push   $0x9
c0203145:	e9 56 ff ff ff       	jmp    c02030a0 <pre_handle>

c020314a <isr10>:
HAVE_ERROCODE 10
c020314a:	89 e0                	mov    %esp,%eax
c020314c:	90                   	nop
c020314d:	6a 0a                	push   $0xa
c020314f:	e9 4c ff ff ff       	jmp    c02030a0 <pre_handle>

c0203154 <isr11>:
HAVE_ERROCODE 11
c0203154:	89 e0                	mov    %esp,%eax
c0203156:	90                   	nop
c0203157:	6a 0b                	push   $0xb
c0203159:	e9 42 ff ff ff       	jmp    c02030a0 <pre_handle>

c020315e <isr12>:
HAVE_ERROCODE 12 
c020315e:	89 e0                	mov    %esp,%eax
c0203160:	90                   	nop
c0203161:	6a 0c                	push   $0xc
c0203163:	e9 38 ff ff ff       	jmp    c02030a0 <pre_handle>

c0203168 <isr13>:
HAVE_ERROCODE 13 
c0203168:	89 e0                	mov    %esp,%eax
c020316a:	90                   	nop
c020316b:	6a 0d                	push   $0xd
c020316d:	e9 2e ff ff ff       	jmp    c02030a0 <pre_handle>

c0203172 <isr14>:
HAVE_ERROCODE 14
c0203172:	89 e0                	mov    %esp,%eax
c0203174:	90                   	nop
c0203175:	6a 0e                	push   $0xe
c0203177:	e9 24 ff ff ff       	jmp    c02030a0 <pre_handle>

c020317c <isr15>:
NO_ERROCODE 15
c020317c:	89 e0                	mov    %esp,%eax
c020317e:	6a 00                	push   $0x0
c0203180:	6a 0f                	push   $0xf
c0203182:	e9 19 ff ff ff       	jmp    c02030a0 <pre_handle>

c0203187 <isr16>:
NO_ERROCODE 16
c0203187:	89 e0                	mov    %esp,%eax
c0203189:	6a 00                	push   $0x0
c020318b:	6a 10                	push   $0x10
c020318d:	e9 0e ff ff ff       	jmp    c02030a0 <pre_handle>

c0203192 <isr17>:
HAVE_ERROCODE 17
c0203192:	89 e0                	mov    %esp,%eax
c0203194:	90                   	nop
c0203195:	6a 11                	push   $0x11
c0203197:	e9 04 ff ff ff       	jmp    c02030a0 <pre_handle>

c020319c <isr18>:
NO_ERROCODE 18
c020319c:	89 e0                	mov    %esp,%eax
c020319e:	6a 00                	push   $0x0
c02031a0:	6a 12                	push   $0x12
c02031a2:	e9 f9 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031a7 <isr19>:
NO_ERROCODE 19
c02031a7:	89 e0                	mov    %esp,%eax
c02031a9:	6a 00                	push   $0x0
c02031ab:	6a 13                	push   $0x13
c02031ad:	e9 ee fe ff ff       	jmp    c02030a0 <pre_handle>

c02031b2 <isr20>:

NO_ERROCODE 20
c02031b2:	89 e0                	mov    %esp,%eax
c02031b4:	6a 00                	push   $0x0
c02031b6:	6a 14                	push   $0x14
c02031b8:	e9 e3 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031bd <isr21>:
NO_ERROCODE 21
c02031bd:	89 e0                	mov    %esp,%eax
c02031bf:	6a 00                	push   $0x0
c02031c1:	6a 15                	push   $0x15
c02031c3:	e9 d8 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031c8 <isr22>:
NO_ERROCODE 22
c02031c8:	89 e0                	mov    %esp,%eax
c02031ca:	6a 00                	push   $0x0
c02031cc:	6a 16                	push   $0x16
c02031ce:	e9 cd fe ff ff       	jmp    c02030a0 <pre_handle>

c02031d3 <isr23>:
NO_ERROCODE 23
c02031d3:	89 e0                	mov    %esp,%eax
c02031d5:	6a 00                	push   $0x0
c02031d7:	6a 17                	push   $0x17
c02031d9:	e9 c2 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031de <isr24>:
NO_ERROCODE 24
c02031de:	89 e0                	mov    %esp,%eax
c02031e0:	6a 00                	push   $0x0
c02031e2:	6a 18                	push   $0x18
c02031e4:	e9 b7 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031e9 <isr25>:
NO_ERROCODE 25
c02031e9:	89 e0                	mov    %esp,%eax
c02031eb:	6a 00                	push   $0x0
c02031ed:	6a 19                	push   $0x19
c02031ef:	e9 ac fe ff ff       	jmp    c02030a0 <pre_handle>

c02031f4 <isr26>:
NO_ERROCODE 26
c02031f4:	89 e0                	mov    %esp,%eax
c02031f6:	6a 00                	push   $0x0
c02031f8:	6a 1a                	push   $0x1a
c02031fa:	e9 a1 fe ff ff       	jmp    c02030a0 <pre_handle>

c02031ff <isr27>:
NO_ERROCODE 27
c02031ff:	89 e0                	mov    %esp,%eax
c0203201:	6a 00                	push   $0x0
c0203203:	6a 1b                	push   $0x1b
c0203205:	e9 96 fe ff ff       	jmp    c02030a0 <pre_handle>

c020320a <isr28>:
NO_ERROCODE 28
c020320a:	89 e0                	mov    %esp,%eax
c020320c:	6a 00                	push   $0x0
c020320e:	6a 1c                	push   $0x1c
c0203210:	e9 8b fe ff ff       	jmp    c02030a0 <pre_handle>

c0203215 <isr29>:
NO_ERROCODE 29
c0203215:	89 e0                	mov    %esp,%eax
c0203217:	6a 00                	push   $0x0
c0203219:	6a 1d                	push   $0x1d
c020321b:	e9 80 fe ff ff       	jmp    c02030a0 <pre_handle>

c0203220 <isr30>:
NO_ERROCODE 30
c0203220:	89 e0                	mov    %esp,%eax
c0203222:	6a 00                	push   $0x0
c0203224:	6a 1e                	push   $0x1e
c0203226:	e9 75 fe ff ff       	jmp    c02030a0 <pre_handle>

c020322b <isr31>:
NO_ERROCODE 31
c020322b:	89 e0                	mov    %esp,%eax
c020322d:	6a 00                	push   $0x0
c020322f:	6a 1f                	push   $0x1f
c0203231:	e9 6a fe ff ff       	jmp    c02030a0 <pre_handle>

c0203236 <isr32>:
NO_ERROCODE 32
c0203236:	89 e0                	mov    %esp,%eax
c0203238:	6a 00                	push   $0x0
c020323a:	6a 20                	push   $0x20
c020323c:	e9 5f fe ff ff       	jmp    c02030a0 <pre_handle>

c0203241 <load_idt>:


[GLOBAL load_idt]
load_idt:
	mov eax, [esp+4]  ; 参数存入 eax 寄存器
c0203241:	8b 44 24 04          	mov    0x4(%esp),%eax
    lidt [eax]        ; 加载到 IDTR
c0203245:	0f 01 18             	lidtl  (%eax)
    ret
c0203248:	c3                   	ret    

c0203249 <get_cr2>:

[GLOBAL get_cr2]
[GLOBAL _CR2]
get_cr2:
	mov eax,cr2
c0203249:	0f 20 d0             	mov    %cr2,%eax
	mov [_CR2],eax
c020324c:	a3 52 32 20 c0       	mov    %eax,0xc0203252
	ret
c0203251:	c3                   	ret    

c0203252 <_CR2>:
_CR2:
c0203252:	00 00                	add    %al,(%eax)
c0203254:	00 00                	add    %al,(%eax)
c0203256:	66 90                	xchg   %ax,%ax
c0203258:	66 90                	xchg   %ax,%ax
c020325a:	66 90                	xchg   %ax,%ax
c020325c:	66 90                	xchg   %ax,%ax
c020325e:	66 90                	xchg   %ax,%ax

c0203260 <get_esp>:
;内核线程模块的汇编函数文件
[bits 32]
[GLOBAL get_esp]
get_esp:
	mov eax,esp
c0203260:	89 e0                	mov    %esp,%eax
	ret
c0203262:	c3                   	ret    

c0203263 <get_eflags>:
[GLOBAL get_eflags]
get_eflags:
	pushf
c0203263:	9c                   	pushf  
	pop eax
c0203264:	58                   	pop    %eax
	ret
c0203265:	c3                   	ret    

c0203266 <switch_to>:
[GLOBAL switch_to]
switch_to:
	;保存上下文
	mov [eax+28],esp
c0203266:	89 60 1c             	mov    %esp,0x1c(%eax)
	mov eax,[esp+4]     ;第一个参数 
c0203269:	8b 44 24 04          	mov    0x4(%esp),%eax
	mov [eax],ebp
c020326d:	89 28                	mov    %ebp,(%eax)
	mov [eax+4],ebx
c020326f:	89 58 04             	mov    %ebx,0x4(%eax)
	mov [eax+8],ecx
c0203272:	89 48 08             	mov    %ecx,0x8(%eax)
	mov [eax+12],edx
c0203275:	89 50 0c             	mov    %edx,0xc(%eax)
	mov [eax+16],esi
c0203278:	89 70 10             	mov    %esi,0x10(%eax)
	mov [eax+20],edi
c020327b:	89 78 14             	mov    %edi,0x14(%eax)
	push ebx
c020327e:	53                   	push   %ebx
	mov ebx,eax
c020327f:	89 c3                	mov    %eax,%ebx
	pushf
c0203281:	9c                   	pushf  
	pop eax
c0203282:	58                   	pop    %eax
	mov [ebx+24],eax
c0203283:	89 43 18             	mov    %eax,0x18(%ebx)
	mov eax,ebx
c0203286:	89 d8                	mov    %ebx,%eax
	pop ebx
c0203288:	5b                   	pop    %ebx

	;加载上下文
	mov eax,[esp+8]      ;第二个参数
c0203289:	8b 44 24 08          	mov    0x8(%esp),%eax
	mov esp,[eax+28]
c020328d:	8b 60 1c             	mov    0x1c(%eax),%esp
	mov ebp,[eax]
c0203290:	8b 28                	mov    (%eax),%ebp
	mov ebx,[eax+4]
c0203292:	8b 58 04             	mov    0x4(%eax),%ebx
	mov ecx,[eax+8]
c0203295:	8b 48 08             	mov    0x8(%eax),%ecx
	mov edx,[eax+12]
c0203298:	8b 50 0c             	mov    0xc(%eax),%edx
	mov esi,[eax+16]
c020329b:	8b 70 10             	mov    0x10(%eax),%esi
	mov edi,[eax+20]
c020329e:	8b 78 14             	mov    0x14(%eax),%edi
	add eax,24
c02032a1:	83 c0 18             	add    $0x18,%eax
	push dword [eax] ;eflags
c02032a4:	ff 30                	pushl  (%eax)
	popf	
c02032a6:	9d                   	popf   

	;由于8259a设置的手动模式 所以必须给主片与从片发送信号 否则8259a会暂停
	;这个bug找了一下午才找到 顺便吐槽下 内核级的代码debug太难了(GDB在多线程与汇编级会失效 只有print调试法) 
	mov al,0x20         
c02032a7:	b0 20                	mov    $0x20,%al
	out 0xA0,al
c02032a9:	e6 a0                	out    %al,$0xa0
	out 0x20,al
c02032ab:	e6 20                	out    %al,$0x20
	
	ret                  ;执行下一个函数
c02032ad:	c3                   	ret    

c02032ae <move_cursor>:
static uint8_t *video_memory = (uint8_t *)0xC00B8000;
//光标位置
static uint8_t cursor_x = 0;
static uint8_t cursor_y = 0;
static void move_cursor()
{
c02032ae:	55                   	push   %ebp
c02032af:	89 e5                	mov    %esp,%ebp
c02032b1:	53                   	push   %ebx
c02032b2:	83 ec 14             	sub    $0x14,%esp
c02032b5:	e8 4a 3d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02032ba:	81 c3 46 4d 00 00    	add    $0x4d46,%ebx
// 屏幕是 80 字节宽
    uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c02032c0:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c02032c7:	0f b6 d0             	movzbl %al,%edx
c02032ca:	89 d0                	mov    %edx,%eax
c02032cc:	c1 e0 02             	shl    $0x2,%eax
c02032cf:	01 d0                	add    %edx,%eax
c02032d1:	c1 e0 04             	shl    $0x4,%eax
c02032d4:	89 c2                	mov    %eax,%edx
c02032d6:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c02032dd:	0f b6 c0             	movzbl %al,%eax
c02032e0:	01 d0                	add    %edx,%eax
c02032e2:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    // 在这里用到的两个内部寄存器的编号为14与15，分别表示光标位置
    // 的高8位与低8位。
    outb(0x3D4, 14);                    // 告诉 VGA 我们要设置光标的高字节
c02032e6:	83 ec 08             	sub    $0x8,%esp
c02032e9:	6a 0e                	push   $0xe
c02032eb:	68 d4 03 00 00       	push   $0x3d4
c02032f0:	e8 46 04 00 00       	call   c020373b <outb>
c02032f5:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation >> 8);   // 发送高 8 位
c02032f8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c02032fc:	66 c1 e8 08          	shr    $0x8,%ax
c0203300:	0f b6 c0             	movzbl %al,%eax
c0203303:	83 ec 08             	sub    $0x8,%esp
c0203306:	50                   	push   %eax
c0203307:	68 d5 03 00 00       	push   $0x3d5
c020330c:	e8 2a 04 00 00       	call   c020373b <outb>
c0203311:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4, 15);                    // 告诉 VGA 我们要设置光标的低字节
c0203314:	83 ec 08             	sub    $0x8,%esp
c0203317:	6a 0f                	push   $0xf
c0203319:	68 d4 03 00 00       	push   $0x3d4
c020331e:	e8 18 04 00 00       	call   c020373b <outb>
c0203323:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5, cursorLocation);        // 发送低 8 位
c0203326:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c020332a:	0f b6 c0             	movzbl %al,%eax
c020332d:	83 ec 08             	sub    $0x8,%esp
c0203330:	50                   	push   %eax
c0203331:	68 d5 03 00 00       	push   $0x3d5
c0203336:	e8 00 04 00 00       	call   c020373b <outb>
c020333b:	83 c4 10             	add    $0x10,%esp
}
c020333e:	90                   	nop
c020333f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203342:	c9                   	leave  
c0203343:	c3                   	ret    

c0203344 <move_cursor_by_XY>:

void move_cursor_by_XY(uint8_t x,uint8_t y){
c0203344:	55                   	push   %ebp
c0203345:	89 e5                	mov    %esp,%ebp
c0203347:	83 ec 18             	sub    $0x18,%esp
c020334a:	e8 b1 3c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020334f:	05 b1 4c 00 00       	add    $0x4cb1,%eax
c0203354:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0203357:	8b 55 0c             	mov    0xc(%ebp),%edx
c020335a:	88 4d f4             	mov    %cl,-0xc(%ebp)
c020335d:	88 55 f0             	mov    %dl,-0x10(%ebp)
	if(x>79||y>24)
c0203360:	80 7d f4 4f          	cmpb   $0x4f,-0xc(%ebp)
c0203364:	77 21                	ja     c0203387 <move_cursor_by_XY+0x43>
c0203366:	80 7d f0 18          	cmpb   $0x18,-0x10(%ebp)
c020336a:	77 1b                	ja     c0203387 <move_cursor_by_XY+0x43>
		return ;
	cursor_x=x;
c020336c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0203370:	88 90 04 90 08 00    	mov    %dl,0x89004(%eax)
	cursor_y=y;
c0203376:	0f b6 55 f0          	movzbl -0x10(%ebp),%edx
c020337a:	88 90 05 90 08 00    	mov    %dl,0x89005(%eax)
	move_cursor();
c0203380:	e8 29 ff ff ff       	call   c02032ae <move_cursor>
c0203385:	eb 01                	jmp    c0203388 <move_cursor_by_XY+0x44>
		return ;
c0203387:	90                   	nop
}
c0203388:	c9                   	leave  
c0203389:	c3                   	ret    

c020338a <clear_screen>:

void clear_screen(){
c020338a:	55                   	push   %ebp
c020338b:	89 e5                	mov    %esp,%ebp
c020338d:	53                   	push   %ebx
c020338e:	83 ec 14             	sub    $0x14,%esp
c0203391:	e8 6e 3c 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203396:	81 c3 6a 4c 00 00    	add    $0x4c6a,%ebx
	cursor_x=0;
c020339c:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
	cursor_y=0;
c02033a3:	c6 83 05 90 08 00 00 	movb   $0x0,0x89005(%ebx)
	for(int j=0;j<25;j++){
c02033aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02033b1:	eb 28                	jmp    c02033db <clear_screen+0x51>
		for(int i=0;i<80;i++)
c02033b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c02033ba:	eb 15                	jmp    c02033d1 <clear_screen+0x47>
			vga_putc('\0',black,white);
c02033bc:	83 ec 04             	sub    $0x4,%esp
c02033bf:	6a 0f                	push   $0xf
c02033c1:	6a 00                	push   $0x0
c02033c3:	6a 00                	push   $0x0
c02033c5:	e8 2b 01 00 00       	call   c02034f5 <vga_putc>
c02033ca:	83 c4 10             	add    $0x10,%esp
		for(int i=0;i<80;i++)
c02033cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02033d1:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c02033d5:	7e e5                	jle    c02033bc <clear_screen+0x32>
	for(int j=0;j<25;j++){
c02033d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02033db:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c02033df:	7e d2                	jle    c02033b3 <clear_screen+0x29>
	}
	cursor_x=0;
c02033e1:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
	cursor_y=0;
c02033e8:	c6 83 05 90 08 00 00 	movb   $0x0,0x89005(%ebx)
	move_cursor();
c02033ef:	e8 ba fe ff ff       	call   c02032ae <move_cursor>
}
c02033f4:	90                   	nop
c02033f5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02033f8:	c9                   	leave  
c02033f9:	c3                   	ret    

c02033fa <screen_uproll_once>:

void screen_uproll_once(){     //光标是会变化的
c02033fa:	55                   	push   %ebp
c02033fb:	89 e5                	mov    %esp,%ebp
c02033fd:	53                   	push   %ebx
c02033fe:	83 ec 24             	sub    $0x24,%esp
c0203401:	e8 fa 3b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203406:	05 fa 4b 00 00       	add    $0x4bfa,%eax
	for(int j=1;j<25;j++){
c020340b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0203412:	eb 70                	jmp    c0203484 <screen_uproll_once+0x8a>
		for(int i=0;i<80;i++){
c0203414:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c020341b:	eb 5d                	jmp    c020347a <screen_uproll_once+0x80>
			uint16_t cursorLocation = j * 80 + i;
c020341d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203420:	89 d1                	mov    %edx,%ecx
c0203422:	89 ca                	mov    %ecx,%edx
c0203424:	c1 e2 02             	shl    $0x2,%edx
c0203427:	01 ca                	add    %ecx,%edx
c0203429:	c1 e2 04             	shl    $0x4,%edx
c020342c:	89 d1                	mov    %edx,%ecx
c020342e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0203431:	01 ca                	add    %ecx,%edx
c0203433:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
			uint16_t targetCursorLocation = (j-1) * 80 + i;
c0203437:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020343a:	83 ea 01             	sub    $0x1,%edx
c020343d:	89 d1                	mov    %edx,%ecx
c020343f:	89 ca                	mov    %ecx,%edx
c0203441:	c1 e2 02             	shl    $0x2,%edx
c0203444:	01 ca                	add    %ecx,%edx
c0203446:	c1 e2 04             	shl    $0x4,%edx
c0203449:	89 d1                	mov    %edx,%ecx
c020344b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c020344e:	01 ca                	add    %ecx,%edx
c0203450:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
			*((uint16_t *)video_memory+targetCursorLocation)=*((uint16_t *)video_memory+cursorLocation);										
c0203454:	8b 90 18 f0 ff ff    	mov    -0xfe8(%eax),%edx
c020345a:	0f b7 4d e8          	movzwl -0x18(%ebp),%ecx
c020345e:	01 c9                	add    %ecx,%ecx
c0203460:	01 ca                	add    %ecx,%edx
c0203462:	8b 88 18 f0 ff ff    	mov    -0xfe8(%eax),%ecx
c0203468:	0f b7 5d e6          	movzwl -0x1a(%ebp),%ebx
c020346c:	01 db                	add    %ebx,%ebx
c020346e:	01 d9                	add    %ebx,%ecx
c0203470:	0f b7 12             	movzwl (%edx),%edx
c0203473:	66 89 11             	mov    %dx,(%ecx)
		for(int i=0;i<80;i++){
c0203476:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020347a:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
c020347e:	7e 9d                	jle    c020341d <screen_uproll_once+0x23>
	for(int j=1;j<25;j++){
c0203480:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203484:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0203488:	7e 8a                	jle    c0203414 <screen_uproll_once+0x1a>
		}
	}
	for(int i=0;i<80;i++){
c020348a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0203491:	eb 35                	jmp    c02034c8 <screen_uproll_once+0xce>
		uint16_t lastRowCur=24*80+i;
c0203493:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0203496:	66 81 c2 80 07       	add    $0x780,%dx
c020349b:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
		*((char *)video_memory+2*lastRowCur)='\0';
c020349f:	8b 90 18 f0 ff ff    	mov    -0xfe8(%eax),%edx
c02034a5:	0f b7 4d ea          	movzwl -0x16(%ebp),%ecx
c02034a9:	01 c9                	add    %ecx,%ecx
c02034ab:	01 ca                	add    %ecx,%edx
c02034ad:	c6 02 00             	movb   $0x0,(%edx)
		*((char *)video_memory+2*lastRowCur+1)=0x0F;									
c02034b0:	8b 90 18 f0 ff ff    	mov    -0xfe8(%eax),%edx
c02034b6:	0f b7 4d ea          	movzwl -0x16(%ebp),%ecx
c02034ba:	01 c9                	add    %ecx,%ecx
c02034bc:	83 c1 01             	add    $0x1,%ecx
c02034bf:	01 ca                	add    %ecx,%edx
c02034c1:	c6 02 0f             	movb   $0xf,(%edx)
	for(int i=0;i<80;i++){
c02034c4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c02034c8:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
c02034cc:	7e c5                	jle    c0203493 <screen_uproll_once+0x99>

	}
	if(cursor_y!=0){
c02034ce:	0f b6 90 05 90 08 00 	movzbl 0x89005(%eax),%edx
c02034d5:	84 d2                	test   %dl,%dl
c02034d7:	74 15                	je     c02034ee <screen_uproll_once+0xf4>
		cursor_y--;
c02034d9:	0f b6 90 05 90 08 00 	movzbl 0x89005(%eax),%edx
c02034e0:	83 ea 01             	sub    $0x1,%edx
c02034e3:	88 90 05 90 08 00    	mov    %dl,0x89005(%eax)
		move_cursor();
c02034e9:	e8 c0 fd ff ff       	call   c02032ae <move_cursor>
	}
}
c02034ee:	90                   	nop
c02034ef:	83 c4 24             	add    $0x24,%esp
c02034f2:	5b                   	pop    %ebx
c02034f3:	5d                   	pop    %ebp
c02034f4:	c3                   	ret    

c02034f5 <vga_putc>:
void vga_putc(char input,vga_color_t back,vga_color_t fore){
c02034f5:	55                   	push   %ebp
c02034f6:	89 e5                	mov    %esp,%ebp
c02034f8:	53                   	push   %ebx
c02034f9:	83 ec 24             	sub    $0x24,%esp
c02034fc:	e8 03 3b 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203501:	81 c3 ff 4a 00 00    	add    $0x4aff,%ebx
c0203507:	8b 45 08             	mov    0x8(%ebp),%eax
c020350a:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint16_t cursorLocation = cursor_y * 80 + cursor_x;
c020350d:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c0203514:	0f b6 d0             	movzbl %al,%edx
c0203517:	89 d0                	mov    %edx,%eax
c0203519:	c1 e0 02             	shl    $0x2,%eax
c020351c:	01 d0                	add    %edx,%eax
c020351e:	c1 e0 04             	shl    $0x4,%eax
c0203521:	89 c2                	mov    %eax,%edx
c0203523:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c020352a:	0f b6 c0             	movzbl %al,%eax
c020352d:	01 d0                	add    %edx,%eax
c020352f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	*((char *)video_memory+2*cursorLocation)=input;
c0203533:	8b 83 18 f0 ff ff    	mov    -0xfe8(%ebx),%eax
c0203539:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c020353d:	01 d2                	add    %edx,%edx
c020353f:	01 c2                	add    %eax,%edx
c0203541:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0203545:	88 02                	mov    %al,(%edx)
	*((char *)video_memory+2*cursorLocation+1)=(back<<4)|(fore&0x0F);
c0203547:	8b 45 0c             	mov    0xc(%ebp),%eax
c020354a:	c1 e0 04             	shl    $0x4,%eax
c020354d:	89 c2                	mov    %eax,%edx
c020354f:	8b 45 10             	mov    0x10(%ebp),%eax
c0203552:	83 e0 0f             	and    $0xf,%eax
c0203555:	89 d1                	mov    %edx,%ecx
c0203557:	09 c1                	or     %eax,%ecx
c0203559:	8b 83 18 f0 ff ff    	mov    -0xfe8(%ebx),%eax
c020355f:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0203563:	01 d2                	add    %edx,%edx
c0203565:	83 c2 01             	add    $0x1,%edx
c0203568:	01 d0                	add    %edx,%eax
c020356a:	89 ca                	mov    %ecx,%edx
c020356c:	88 10                	mov    %dl,(%eax)
	if(cursor_x==79){
c020356e:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c0203575:	3c 4f                	cmp    $0x4f,%al
c0203577:	75 39                	jne    c02035b2 <vga_putc+0xbd>
		if(cursor_y==24){
c0203579:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c0203580:	3c 18                	cmp    $0x18,%al
c0203582:	75 15                	jne    c0203599 <vga_putc+0xa4>
			screen_uproll_once();
c0203584:	e8 71 fe ff ff       	call   c02033fa <screen_uproll_once>
			cursor_x=0;
c0203589:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
			cursor_y=24;
c0203590:	c6 83 05 90 08 00 18 	movb   $0x18,0x89005(%ebx)
c0203597:	eb 29                	jmp    c02035c2 <vga_putc+0xcd>
		}
		else{
			cursor_x=0;
c0203599:	c6 83 04 90 08 00 00 	movb   $0x0,0x89004(%ebx)
			cursor_y++;
c02035a0:	0f b6 83 05 90 08 00 	movzbl 0x89005(%ebx),%eax
c02035a7:	83 c0 01             	add    $0x1,%eax
c02035aa:	88 83 05 90 08 00    	mov    %al,0x89005(%ebx)
c02035b0:	eb 10                	jmp    c02035c2 <vga_putc+0xcd>
		}
	}
	else{
		cursor_x++;
c02035b2:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c02035b9:	83 c0 01             	add    $0x1,%eax
c02035bc:	88 83 04 90 08 00    	mov    %al,0x89004(%ebx)
	}
	move_cursor();
c02035c2:	e8 e7 fc ff ff       	call   c02032ae <move_cursor>
}
c02035c7:	90                   	nop
c02035c8:	83 c4 24             	add    $0x24,%esp
c02035cb:	5b                   	pop    %ebx
c02035cc:	5d                   	pop    %ebp
c02035cd:	c3                   	ret    

c02035ce <kputc_color>:
void kputc_color(char input,vga_color_t back,vga_color_t fore){
c02035ce:	55                   	push   %ebp
c02035cf:	89 e5                	mov    %esp,%ebp
c02035d1:	53                   	push   %ebx
c02035d2:	83 ec 24             	sub    $0x24,%esp
c02035d5:	e8 2a 3a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02035da:	81 c3 26 4a 00 00    	add    $0x4a26,%ebx
c02035e0:	8b 45 08             	mov    0x8(%ebp),%eax
c02035e3:	88 45 e4             	mov    %al,-0x1c(%ebp)
	switch (input)
c02035e6:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c02035ea:	83 f8 09             	cmp    $0x9,%eax
c02035ed:	74 07                	je     c02035f6 <kputc_color+0x28>
c02035ef:	83 f8 0a             	cmp    $0xa,%eax
c02035f2:	74 33                	je     c0203627 <kputc_color+0x59>
c02035f4:	eb 79                	jmp    c020366f <kputc_color+0xa1>
	{
		case '\t':{
			for(int i=0;i<tab_length;i++)
c02035f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02035fd:	eb 17                	jmp    c0203616 <kputc_color+0x48>
				vga_putc('\0',back,fore);
c02035ff:	83 ec 04             	sub    $0x4,%esp
c0203602:	ff 75 10             	pushl  0x10(%ebp)
c0203605:	ff 75 0c             	pushl  0xc(%ebp)
c0203608:	6a 00                	push   $0x0
c020360a:	e8 e6 fe ff ff       	call   c02034f5 <vga_putc>
c020360f:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<tab_length;i++)
c0203612:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203616:	0f b6 83 14 f0 ff ff 	movzbl -0xfec(%ebx),%eax
c020361d:	0f b6 c0             	movzbl %al,%eax
c0203620:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0203623:	7c da                	jl     c02035ff <kputc_color+0x31>
			break;
c0203625:	eb 5e                	jmp    c0203685 <kputc_color+0xb7>
		}
		case '\n':{
			uint8_t temp_num = 80-cursor_x;
c0203627:	0f b6 83 04 90 08 00 	movzbl 0x89004(%ebx),%eax
c020362e:	ba 50 00 00 00       	mov    $0x50,%edx
c0203633:	29 c2                	sub    %eax,%edx
c0203635:	89 d0                	mov    %edx,%eax
c0203637:	88 45 f3             	mov    %al,-0xd(%ebp)
			if(temp_num==0)
c020363a:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c020363e:	75 04                	jne    c0203644 <kputc_color+0x76>
				temp_num=80;
c0203640:	c6 45 f3 50          	movb   $0x50,-0xd(%ebp)
			for(int i=0;i<temp_num;i++)
c0203644:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c020364b:	eb 17                	jmp    c0203664 <kputc_color+0x96>
			vga_putc('\0',back,fore);
c020364d:	83 ec 04             	sub    $0x4,%esp
c0203650:	ff 75 10             	pushl  0x10(%ebp)
c0203653:	ff 75 0c             	pushl  0xc(%ebp)
c0203656:	6a 00                	push   $0x0
c0203658:	e8 98 fe ff ff       	call   c02034f5 <vga_putc>
c020365d:	83 c4 10             	add    $0x10,%esp
			for(int i=0;i<temp_num;i++)
c0203660:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0203664:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0203668:	39 45 ec             	cmp    %eax,-0x14(%ebp)
c020366b:	7c e0                	jl     c020364d <kputc_color+0x7f>
			break;
c020366d:	eb 16                	jmp    c0203685 <kputc_color+0xb7>
		}
		default:
			vga_putc(input,back,fore);	
c020366f:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c0203673:	83 ec 04             	sub    $0x4,%esp
c0203676:	ff 75 10             	pushl  0x10(%ebp)
c0203679:	ff 75 0c             	pushl  0xc(%ebp)
c020367c:	50                   	push   %eax
c020367d:	e8 73 fe ff ff       	call   c02034f5 <vga_putc>
c0203682:	83 c4 10             	add    $0x10,%esp
	}
}
c0203685:	90                   	nop
c0203686:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203689:	c9                   	leave  
c020368a:	c3                   	ret    

c020368b <kputc>:

void kputc(char input){
c020368b:	55                   	push   %ebp
c020368c:	89 e5                	mov    %esp,%ebp
c020368e:	83 ec 18             	sub    $0x18,%esp
c0203691:	e8 6a 39 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203696:	05 6a 49 00 00       	add    $0x496a,%eax
c020369b:	8b 45 08             	mov    0x8(%ebp),%eax
c020369e:	88 45 f4             	mov    %al,-0xc(%ebp)
	kputc_color(input,black,white);
c02036a1:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c02036a5:	83 ec 04             	sub    $0x4,%esp
c02036a8:	6a 0f                	push   $0xf
c02036aa:	6a 00                	push   $0x0
c02036ac:	50                   	push   %eax
c02036ad:	e8 1c ff ff ff       	call   c02035ce <kputc_color>
c02036b2:	83 c4 10             	add    $0x10,%esp
}
c02036b5:	90                   	nop
c02036b6:	c9                   	leave  
c02036b7:	c3                   	ret    

c02036b8 <kputs_color>:

void kputs_color(char * input_str,vga_color_t back,vga_color_t fore){
c02036b8:	55                   	push   %ebp
c02036b9:	89 e5                	mov    %esp,%ebp
c02036bb:	83 ec 18             	sub    $0x18,%esp
c02036be:	e8 3d 39 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02036c3:	05 3d 49 00 00       	add    $0x493d,%eax
	char * probe=input_str;
c02036c8:	8b 45 08             	mov    0x8(%ebp),%eax
c02036cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(*probe!='\0')
c02036ce:	eb 21                	jmp    c02036f1 <kputs_color+0x39>
		kputc_color(*probe++,back,fore);
c02036d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02036d3:	8d 50 01             	lea    0x1(%eax),%edx
c02036d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c02036d9:	0f b6 00             	movzbl (%eax),%eax
c02036dc:	0f be c0             	movsbl %al,%eax
c02036df:	83 ec 04             	sub    $0x4,%esp
c02036e2:	ff 75 10             	pushl  0x10(%ebp)
c02036e5:	ff 75 0c             	pushl  0xc(%ebp)
c02036e8:	50                   	push   %eax
c02036e9:	e8 e0 fe ff ff       	call   c02035ce <kputc_color>
c02036ee:	83 c4 10             	add    $0x10,%esp
	while(*probe!='\0')
c02036f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02036f4:	0f b6 00             	movzbl (%eax),%eax
c02036f7:	84 c0                	test   %al,%al
c02036f9:	75 d5                	jne    c02036d0 <kputs_color+0x18>
}
c02036fb:	90                   	nop
c02036fc:	c9                   	leave  
c02036fd:	c3                   	ret    

c02036fe <kputs>:

void kputs(char *input_str){
c02036fe:	55                   	push   %ebp
c02036ff:	89 e5                	mov    %esp,%ebp
c0203701:	83 ec 08             	sub    $0x8,%esp
c0203704:	e8 f7 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203709:	05 f7 48 00 00       	add    $0x48f7,%eax
	kputs_color(input_str,black,white);
c020370e:	83 ec 04             	sub    $0x4,%esp
c0203711:	6a 0f                	push   $0xf
c0203713:	6a 00                	push   $0x0
c0203715:	ff 75 08             	pushl  0x8(%ebp)
c0203718:	e8 9b ff ff ff       	call   c02036b8 <kputs_color>
c020371d:	83 c4 10             	add    $0x10,%esp
}
c0203720:	90                   	nop
c0203721:	c9                   	leave  
c0203722:	c3                   	ret    

c0203723 <vga_init>:

void vga_init(){
c0203723:	55                   	push   %ebp
c0203724:	89 e5                	mov    %esp,%ebp
c0203726:	83 ec 08             	sub    $0x8,%esp
c0203729:	e8 d2 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020372e:	05 d2 48 00 00       	add    $0x48d2,%eax
	clear_screen();
c0203733:	e8 52 fc ff ff       	call   c020338a <clear_screen>
c0203738:	90                   	nop
c0203739:	c9                   	leave  
c020373a:	c3                   	ret    

c020373b <outb>:
#include "port.h"
// 端口写一个字节
inline void outb(uint16_t port, uint8_t value)
{
c020373b:	55                   	push   %ebp
c020373c:	89 e5                	mov    %esp,%ebp
c020373e:	83 ec 08             	sub    $0x8,%esp
c0203741:	e8 ba 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203746:	05 ba 48 00 00       	add    $0x48ba,%eax
c020374b:	8b 55 08             	mov    0x8(%ebp),%edx
c020374e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203751:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0203755:	88 45 f8             	mov    %al,-0x8(%ebp)
    asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
c0203758:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c020375c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0203760:	ee                   	out    %al,(%dx)
}
c0203761:	90                   	nop
c0203762:	c9                   	leave  
c0203763:	c3                   	ret    

c0203764 <inb>:

// 端口读一个字节
inline uint8_t inb(uint16_t port)
{
c0203764:	55                   	push   %ebp
c0203765:	89 e5                	mov    %esp,%ebp
c0203767:	83 ec 14             	sub    $0x14,%esp
c020376a:	e8 91 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020376f:	05 91 48 00 00       	add    $0x4891,%eax
c0203774:	8b 45 08             	mov    0x8(%ebp),%eax
c0203777:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint8_t ret;

    asm volatile("inb %1, %0" : "=a" (ret) : "dN" (port));
c020377b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c020377f:	89 c2                	mov    %eax,%edx
c0203781:	ec                   	in     (%dx),%al
c0203782:	88 45 ff             	mov    %al,-0x1(%ebp)

    return ret;
c0203785:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0203789:	c9                   	leave  
c020378a:	c3                   	ret    

c020378b <inw>:

// 端口读一个字
inline uint16_t inw(uint16_t port)
{
c020378b:	55                   	push   %ebp
c020378c:	89 e5                	mov    %esp,%ebp
c020378e:	83 ec 14             	sub    $0x14,%esp
c0203791:	e8 6a 38 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203796:	05 6a 48 00 00       	add    $0x486a,%eax
c020379b:	8b 45 08             	mov    0x8(%ebp),%eax
c020379e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    uint16_t ret;

    asm volatile ("inw %1, %0" : "=a" (ret) : "dN" (port));
c02037a2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c02037a6:	89 c2                	mov    %eax,%edx
c02037a8:	66 ed                	in     (%dx),%ax
c02037aa:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

    return ret;
c02037ae:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c02037b2:	c9                   	leave  
c02037b3:	c3                   	ret    

c02037b4 <insert_str>:
#include "vga_basic.h"
#include "vargs.h"


void insert_str(char *inserted_str,char *inserting_str,uint32_t offset)  //插入辅助函数
{
c02037b4:	55                   	push   %ebp
c02037b5:	89 e5                	mov    %esp,%ebp
c02037b7:	57                   	push   %edi
c02037b8:	53                   	push   %ebx
c02037b9:	83 ec 70             	sub    $0x70,%esp
c02037bc:	e8 43 38 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02037c1:	81 c3 3f 48 00 00    	add    $0x483f,%ebx
	char m[100]={0};
c02037c7:	8d 55 90             	lea    -0x70(%ebp),%edx
c02037ca:	b8 00 00 00 00       	mov    $0x0,%eax
c02037cf:	b9 19 00 00 00       	mov    $0x19,%ecx
c02037d4:	89 d7                	mov    %edx,%edi
c02037d6:	f3 ab                	rep stos %eax,%es:(%edi)
	char *afterInsetedPositionStr=m;
c02037d8:	8d 45 90             	lea    -0x70(%ebp),%eax
c02037db:	89 45 f4             	mov    %eax,-0xc(%ebp)
	strcpy(afterInsetedPositionStr,inserted_str+offset+2);
c02037de:	8b 45 10             	mov    0x10(%ebp),%eax
c02037e1:	8d 50 02             	lea    0x2(%eax),%edx
c02037e4:	8b 45 08             	mov    0x8(%ebp),%eax
c02037e7:	01 d0                	add    %edx,%eax
c02037e9:	83 ec 08             	sub    $0x8,%esp
c02037ec:	50                   	push   %eax
c02037ed:	ff 75 f4             	pushl  -0xc(%ebp)
c02037f0:	e8 11 08 00 00       	call   c0204006 <strcpy>
c02037f5:	83 c4 10             	add    $0x10,%esp
	memcpy(inserted_str+offset,inserting_str,strlen(inserting_str));
c02037f8:	83 ec 0c             	sub    $0xc,%esp
c02037fb:	ff 75 0c             	pushl  0xc(%ebp)
c02037fe:	e8 d2 07 00 00       	call   c0203fd5 <strlen>
c0203803:	83 c4 10             	add    $0x10,%esp
c0203806:	89 c1                	mov    %eax,%ecx
c0203808:	8b 55 08             	mov    0x8(%ebp),%edx
c020380b:	8b 45 10             	mov    0x10(%ebp),%eax
c020380e:	01 d0                	add    %edx,%eax
c0203810:	83 ec 04             	sub    $0x4,%esp
c0203813:	51                   	push   %ecx
c0203814:	ff 75 0c             	pushl  0xc(%ebp)
c0203817:	50                   	push   %eax
c0203818:	e8 cd 06 00 00       	call   c0203eea <memcpy>
c020381d:	83 c4 10             	add    $0x10,%esp
	*(inserted_str+offset+strlen(inserting_str))='\0';
c0203820:	83 ec 0c             	sub    $0xc,%esp
c0203823:	ff 75 0c             	pushl  0xc(%ebp)
c0203826:	e8 aa 07 00 00       	call   c0203fd5 <strlen>
c020382b:	83 c4 10             	add    $0x10,%esp
c020382e:	89 c2                	mov    %eax,%edx
c0203830:	8b 45 10             	mov    0x10(%ebp),%eax
c0203833:	01 c2                	add    %eax,%edx
c0203835:	8b 45 08             	mov    0x8(%ebp),%eax
c0203838:	01 d0                	add    %edx,%eax
c020383a:	c6 00 00             	movb   $0x0,(%eax)
	strcat(inserted_str,afterInsetedPositionStr);
c020383d:	83 ec 08             	sub    $0x8,%esp
c0203840:	ff 75 f4             	pushl  -0xc(%ebp)
c0203843:	ff 75 08             	pushl  0x8(%ebp)
c0203846:	e8 01 08 00 00       	call   c020404c <strcat>
c020384b:	83 c4 10             	add    $0x10,%esp
	//memcpy(*(inserted_str+offset+1+strlen(inserting_str)),afterInsetedPositionStr,strlen(afterInsetedPositionStr));
	return inserted_str;
c020384e:	90                   	nop
}
c020384f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0203852:	5b                   	pop    %ebx
c0203853:	5f                   	pop    %edi
c0203854:	5d                   	pop    %ebp
c0203855:	c3                   	ret    

c0203856 <printk>:

void printk(char *input_str,...)
{	
c0203856:	55                   	push   %ebp
c0203857:	89 e5                	mov    %esp,%ebp
c0203859:	53                   	push   %ebx
c020385a:	83 ec 34             	sub    $0x34,%esp
c020385d:	e8 a2 37 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203862:	81 c3 9e 47 00 00    	add    $0x479e,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0203868:	8d 83 20 90 08 00    	lea    0x89020(%ebx),%eax
c020386e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0203871:	83 ec 08             	sub    $0x8,%esp
c0203874:	ff 75 08             	pushl  0x8(%ebp)
c0203877:	ff 75 f0             	pushl  -0x10(%ebp)
c020387a:	e8 87 07 00 00       	call   c0204006 <strcpy>
c020387f:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0203882:	8d 45 0c             	lea    0xc(%ebp),%eax
c0203885:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0203888:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c020388f:	e9 9e 01 00 00       	jmp    c0203a32 <printk+0x1dc>
	{
		char *charptr=output_str+offset;
c0203894:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203897:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020389a:	01 d0                	add    %edx,%eax
c020389c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c020389f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02038a2:	0f b6 00             	movzbl (%eax),%eax
c02038a5:	3c 25                	cmp    $0x25,%al
c02038a7:	0f 85 81 01 00 00    	jne    c0203a2e <printk+0x1d8>
		{
			if (*(charptr+1)=='s')
c02038ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02038b0:	83 c0 01             	add    $0x1,%eax
c02038b3:	0f b6 00             	movzbl (%eax),%eax
c02038b6:	3c 73                	cmp    $0x73,%al
c02038b8:	75 43                	jne    c02038fd <printk+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c02038ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02038bd:	8d 50 04             	lea    0x4(%eax),%edx
c02038c0:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02038c3:	8b 00                	mov    (%eax),%eax
c02038c5:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c02038c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02038cb:	83 ec 04             	sub    $0x4,%esp
c02038ce:	50                   	push   %eax
c02038cf:	ff 75 d0             	pushl  -0x30(%ebp)
c02038d2:	ff 75 f0             	pushl  -0x10(%ebp)
c02038d5:	e8 da fe ff ff       	call   c02037b4 <insert_str>
c02038da:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c02038dd:	83 ec 0c             	sub    $0xc,%esp
c02038e0:	ff 75 d0             	pushl  -0x30(%ebp)
c02038e3:	e8 ed 06 00 00       	call   c0203fd5 <strlen>
c02038e8:	83 c4 10             	add    $0x10,%esp
c02038eb:	89 c2                	mov    %eax,%edx
c02038ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02038f0:	01 d0                	add    %edx,%eax
c02038f2:	83 e8 01             	sub    $0x1,%eax
c02038f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02038f8:	e9 31 01 00 00       	jmp    c0203a2e <printk+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c02038fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203900:	83 c0 01             	add    $0x1,%eax
c0203903:	0f b6 00             	movzbl (%eax),%eax
c0203906:	3c 64                	cmp    $0x64,%al
c0203908:	75 55                	jne    c020395f <printk+0x109>
			{
				int arg_int=va_arg(ptr,int);
c020390a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c020390d:	8d 50 04             	lea    0x4(%eax),%edx
c0203910:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203913:	8b 00                	mov    (%eax),%eax
c0203915:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0203918:	8b 45 d8             	mov    -0x28(%ebp),%eax
c020391b:	83 ec 0c             	sub    $0xc,%esp
c020391e:	50                   	push   %eax
c020391f:	e8 61 07 00 00       	call   c0204085 <uintTostring>
c0203924:	83 c4 10             	add    $0x10,%esp
c0203927:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c020392a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020392d:	83 ec 04             	sub    $0x4,%esp
c0203930:	50                   	push   %eax
c0203931:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203934:	ff 75 f0             	pushl  -0x10(%ebp)
c0203937:	e8 78 fe ff ff       	call   c02037b4 <insert_str>
c020393c:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c020393f:	83 ec 0c             	sub    $0xc,%esp
c0203942:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203945:	e8 8b 06 00 00       	call   c0203fd5 <strlen>
c020394a:	83 c4 10             	add    $0x10,%esp
c020394d:	89 c2                	mov    %eax,%edx
c020394f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203952:	01 d0                	add    %edx,%eax
c0203954:	83 e8 01             	sub    $0x1,%eax
c0203957:	89 45 f4             	mov    %eax,-0xc(%ebp)
c020395a:	e9 cf 00 00 00       	jmp    c0203a2e <printk+0x1d8>
			}
			else if(*(charptr+1)=='c')
c020395f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203962:	83 c0 01             	add    $0x1,%eax
c0203965:	0f b6 00             	movzbl (%eax),%eax
c0203968:	3c 63                	cmp    $0x63,%al
c020396a:	0f 84 be 00 00 00    	je     c0203a2e <printk+0x1d8>
			{
				;
			}
			else if(*(charptr+1)=='H')
c0203970:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203973:	83 c0 01             	add    $0x1,%eax
c0203976:	0f b6 00             	movzbl (%eax),%eax
c0203979:	3c 48                	cmp    $0x48,%al
c020397b:	75 53                	jne    c02039d0 <printk+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c020397d:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203980:	8d 50 04             	lea    0x4(%eax),%edx
c0203983:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203986:	8b 00                	mov    (%eax),%eax
c0203988:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c020398b:	83 ec 08             	sub    $0x8,%esp
c020398e:	6a 01                	push   $0x1
c0203990:	ff 75 e0             	pushl  -0x20(%ebp)
c0203993:	e8 2c 04 00 00       	call   c0203dc4 <num2hexstr>
c0203998:	83 c4 10             	add    $0x10,%esp
c020399b:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c020399e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02039a1:	83 ec 04             	sub    $0x4,%esp
c02039a4:	50                   	push   %eax
c02039a5:	ff 75 dc             	pushl  -0x24(%ebp)
c02039a8:	ff 75 f0             	pushl  -0x10(%ebp)
c02039ab:	e8 04 fe ff ff       	call   c02037b4 <insert_str>
c02039b0:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c02039b3:	83 ec 0c             	sub    $0xc,%esp
c02039b6:	ff 75 dc             	pushl  -0x24(%ebp)
c02039b9:	e8 17 06 00 00       	call   c0203fd5 <strlen>
c02039be:	83 c4 10             	add    $0x10,%esp
c02039c1:	89 c2                	mov    %eax,%edx
c02039c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02039c6:	01 d0                	add    %edx,%eax
c02039c8:	83 e8 01             	sub    $0x1,%eax
c02039cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02039ce:	eb 5e                	jmp    c0203a2e <printk+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c02039d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02039d3:	83 c0 01             	add    $0x1,%eax
c02039d6:	0f b6 00             	movzbl (%eax),%eax
c02039d9:	3c 68                	cmp    $0x68,%al
c02039db:	75 51                	jne    c0203a2e <printk+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c02039dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
c02039e0:	8d 50 04             	lea    0x4(%eax),%edx
c02039e3:	89 55 cc             	mov    %edx,-0x34(%ebp)
c02039e6:	8b 00                	mov    (%eax),%eax
c02039e8:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c02039eb:	83 ec 08             	sub    $0x8,%esp
c02039ee:	6a 00                	push   $0x0
c02039f0:	ff 75 e8             	pushl  -0x18(%ebp)
c02039f3:	e8 cc 03 00 00       	call   c0203dc4 <num2hexstr>
c02039f8:	83 c4 10             	add    $0x10,%esp
c02039fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c02039fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a01:	83 ec 04             	sub    $0x4,%esp
c0203a04:	50                   	push   %eax
c0203a05:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a08:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a0b:	e8 a4 fd ff ff       	call   c02037b4 <insert_str>
c0203a10:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203a13:	83 ec 0c             	sub    $0xc,%esp
c0203a16:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203a19:	e8 b7 05 00 00       	call   c0203fd5 <strlen>
c0203a1e:	83 c4 10             	add    $0x10,%esp
c0203a21:	89 c2                	mov    %eax,%edx
c0203a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a26:	01 d0                	add    %edx,%eax
c0203a28:	83 e8 01             	sub    $0x1,%eax
c0203a2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203a2e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203a32:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203a35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203a38:	01 d0                	add    %edx,%eax
c0203a3a:	0f b6 00             	movzbl (%eax),%eax
c0203a3d:	84 c0                	test   %al,%al
c0203a3f:	0f 85 4f fe ff ff    	jne    c0203894 <printk+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs(output_str);
c0203a45:	83 ec 0c             	sub    $0xc,%esp
c0203a48:	ff 75 f0             	pushl  -0x10(%ebp)
c0203a4b:	e8 ae fc ff ff       	call   c02036fe <kputs>
c0203a50:	83 c4 10             	add    $0x10,%esp
}
c0203a53:	90                   	nop
c0203a54:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203a57:	c9                   	leave  
c0203a58:	c3                   	ret    

c0203a59 <printbasic>:


//输入uint32_t或者char*  使用%d或者%s
//wdnmd 这个可变参有问题！！
void printbasic(char *format_str,char *m)
{
c0203a59:	55                   	push   %ebp
c0203a5a:	89 e5                	mov    %esp,%ebp
c0203a5c:	83 ec 18             	sub    $0x18,%esp
c0203a5f:	e8 9c 35 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203a64:	05 9c 45 00 00       	add    $0x459c,%eax
	//va_list ptr_start=NULL;
	char *formatStr=format_str;
c0203a69:	8b 45 08             	mov    0x8(%ebp),%eax
c0203a6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//va_start(ptr_start,format_str);
	//kputs_color(va_arg(ptr_start,char *), rc_black, rc_green);	
	int i=0;
c0203a6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0203a76:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203a79:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0203a7c:	eb 3a                	jmp    c0203ab8 <printbasic+0x5f>
	{
		if (*(head+i)=='%'){
c0203a7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203a81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203a84:	01 d0                	add    %edx,%eax
c0203a86:	0f b6 00             	movzbl (%eax),%eax
c0203a89:	3c 25                	cmp    $0x25,%al
c0203a8b:	75 27                	jne    c0203ab4 <printbasic+0x5b>
			if(*(head+i+1)=='s')
c0203a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203a90:	8d 50 01             	lea    0x1(%eax),%edx
c0203a93:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203a96:	01 d0                	add    %edx,%eax
c0203a98:	0f b6 00             	movzbl (%eax),%eax
c0203a9b:	3c 73                	cmp    $0x73,%al
c0203a9d:	75 15                	jne    c0203ab4 <printbasic+0x5b>
			{
				//char *str_head=va_arg(&ptr_start,char*);
				insert_str(format_str,m,i);
c0203a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203aa2:	83 ec 04             	sub    $0x4,%esp
c0203aa5:	50                   	push   %eax
c0203aa6:	ff 75 0c             	pushl  0xc(%ebp)
c0203aa9:	ff 75 08             	pushl  0x8(%ebp)
c0203aac:	e8 03 fd ff ff       	call   c02037b4 <insert_str>
c0203ab1:	83 c4 10             	add    $0x10,%esp
	for(char *head=formatStr;*(head+i)!='\0';i++)
c0203ab4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203ab8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203abb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203abe:	01 d0                	add    %edx,%eax
c0203ac0:	0f b6 00             	movzbl (%eax),%eax
c0203ac3:	84 c0                	test   %al,%al
c0203ac5:	75 b7                	jne    c0203a7e <printbasic+0x25>
			else;
		}
	}
	//kputs_color(formatStr, black, white);
	
}
c0203ac7:	90                   	nop
c0203ac8:	c9                   	leave  
c0203ac9:	c3                   	ret    

c0203aca <printk_color>:



void printk_color(char *input_str,vga_color_t back,vga_color_t fore,...)
{
c0203aca:	55                   	push   %ebp
c0203acb:	89 e5                	mov    %esp,%ebp
c0203acd:	53                   	push   %ebx
c0203ace:	83 ec 34             	sub    $0x34,%esp
c0203ad1:	e8 2e 35 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203ad6:	81 c3 2a 45 00 00    	add    $0x452a,%ebx
	static char staticArry[100]={0};
	char *output_str=staticArry;
c0203adc:	8d 83 a0 90 08 00    	lea    0x890a0(%ebx),%eax
c0203ae2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	strcpy(output_str,input_str);
c0203ae5:	83 ec 08             	sub    $0x8,%esp
c0203ae8:	ff 75 08             	pushl  0x8(%ebp)
c0203aeb:	ff 75 f0             	pushl  -0x10(%ebp)
c0203aee:	e8 13 05 00 00       	call   c0204006 <strcpy>
c0203af3:	83 c4 10             	add    $0x10,%esp
	va_list ptr;
	va_start(ptr,output_str);
c0203af6:	8d 45 14             	lea    0x14(%ebp),%eax
c0203af9:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int offset=0;
c0203afc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203b03:	e9 9e 01 00 00       	jmp    c0203ca6 <printk_color+0x1dc>
	{
		char *charptr=output_str+offset;
c0203b08:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203b0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203b0e:	01 d0                	add    %edx,%eax
c0203b10:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (*charptr=='%')
c0203b13:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b16:	0f b6 00             	movzbl (%eax),%eax
c0203b19:	3c 25                	cmp    $0x25,%al
c0203b1b:	0f 85 81 01 00 00    	jne    c0203ca2 <printk_color+0x1d8>
		{
			if (*(charptr+1)=='s')
c0203b21:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b24:	83 c0 01             	add    $0x1,%eax
c0203b27:	0f b6 00             	movzbl (%eax),%eax
c0203b2a:	3c 73                	cmp    $0x73,%al
c0203b2c:	75 43                	jne    c0203b71 <printk_color+0xa7>
			{
				char *arg_str_ptr=va_arg(ptr,char*);//此处是否需要复制static数组？
c0203b2e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203b31:	8d 50 04             	lea    0x4(%eax),%edx
c0203b34:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203b37:	8b 00                	mov    (%eax),%eax
c0203b39:	89 45 d0             	mov    %eax,-0x30(%ebp)

				insert_str(output_str,arg_str_ptr,offset);
c0203b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b3f:	83 ec 04             	sub    $0x4,%esp
c0203b42:	50                   	push   %eax
c0203b43:	ff 75 d0             	pushl  -0x30(%ebp)
c0203b46:	ff 75 f0             	pushl  -0x10(%ebp)
c0203b49:	e8 66 fc ff ff       	call   c02037b4 <insert_str>
c0203b4e:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(arg_str_ptr)-1;
c0203b51:	83 ec 0c             	sub    $0xc,%esp
c0203b54:	ff 75 d0             	pushl  -0x30(%ebp)
c0203b57:	e8 79 04 00 00       	call   c0203fd5 <strlen>
c0203b5c:	83 c4 10             	add    $0x10,%esp
c0203b5f:	89 c2                	mov    %eax,%edx
c0203b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203b64:	01 d0                	add    %edx,%eax
c0203b66:	83 e8 01             	sub    $0x1,%eax
c0203b69:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203b6c:	e9 31 01 00 00       	jmp    c0203ca2 <printk_color+0x1d8>
				
			}
			else if(*(charptr+1)=='d')
c0203b71:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203b74:	83 c0 01             	add    $0x1,%eax
c0203b77:	0f b6 00             	movzbl (%eax),%eax
c0203b7a:	3c 64                	cmp    $0x64,%al
c0203b7c:	75 55                	jne    c0203bd3 <printk_color+0x109>
			{
				int arg_int=va_arg(ptr,int);
c0203b7e:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203b81:	8d 50 04             	lea    0x4(%eax),%edx
c0203b84:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203b87:	8b 00                	mov    (%eax),%eax
c0203b89:	89 45 d8             	mov    %eax,-0x28(%ebp)

				char *temp_ptr=uintTostring(arg_int);
c0203b8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0203b8f:	83 ec 0c             	sub    $0xc,%esp
c0203b92:	50                   	push   %eax
c0203b93:	e8 ed 04 00 00       	call   c0204085 <uintTostring>
c0203b98:	83 c4 10             	add    $0x10,%esp
c0203b9b:	89 45 d4             	mov    %eax,-0x2c(%ebp)

				insert_str(output_str,temp_ptr,offset);
c0203b9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203ba1:	83 ec 04             	sub    $0x4,%esp
c0203ba4:	50                   	push   %eax
c0203ba5:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203ba8:	ff 75 f0             	pushl  -0x10(%ebp)
c0203bab:	e8 04 fc ff ff       	call   c02037b4 <insert_str>
c0203bb0:	83 c4 10             	add    $0x10,%esp
				
				offset=offset+strlen(temp_ptr)-1;
c0203bb3:	83 ec 0c             	sub    $0xc,%esp
c0203bb6:	ff 75 d4             	pushl  -0x2c(%ebp)
c0203bb9:	e8 17 04 00 00       	call   c0203fd5 <strlen>
c0203bbe:	83 c4 10             	add    $0x10,%esp
c0203bc1:	89 c2                	mov    %eax,%edx
c0203bc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203bc6:	01 d0                	add    %edx,%eax
c0203bc8:	83 e8 01             	sub    $0x1,%eax
c0203bcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203bce:	e9 cf 00 00 00       	jmp    c0203ca2 <printk_color+0x1d8>
			}
			else if(*(charptr+1)=='c')
c0203bd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203bd6:	83 c0 01             	add    $0x1,%eax
c0203bd9:	0f b6 00             	movzbl (%eax),%eax
c0203bdc:	3c 63                	cmp    $0x63,%al
c0203bde:	0f 84 be 00 00 00    	je     c0203ca2 <printk_color+0x1d8>
			{
			
			}
			else if(*(charptr+1)=='H')
c0203be4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203be7:	83 c0 01             	add    $0x1,%eax
c0203bea:	0f b6 00             	movzbl (%eax),%eax
c0203bed:	3c 48                	cmp    $0x48,%al
c0203bef:	75 53                	jne    c0203c44 <printk_color+0x17a>
			{
				int arg_int=va_arg(ptr,int);
c0203bf1:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203bf4:	8d 50 04             	lea    0x4(%eax),%edx
c0203bf7:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203bfa:	8b 00                	mov    (%eax),%eax
c0203bfc:	89 45 e0             	mov    %eax,-0x20(%ebp)

				char*hexstrptr=num2hexstr(arg_int,1);
c0203bff:	83 ec 08             	sub    $0x8,%esp
c0203c02:	6a 01                	push   $0x1
c0203c04:	ff 75 e0             	pushl  -0x20(%ebp)
c0203c07:	e8 b8 01 00 00       	call   c0203dc4 <num2hexstr>
c0203c0c:	83 c4 10             	add    $0x10,%esp
c0203c0f:	89 45 dc             	mov    %eax,-0x24(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c15:	83 ec 04             	sub    $0x4,%esp
c0203c18:	50                   	push   %eax
c0203c19:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c1c:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c1f:	e8 90 fb ff ff       	call   c02037b4 <insert_str>
c0203c24:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203c27:	83 ec 0c             	sub    $0xc,%esp
c0203c2a:	ff 75 dc             	pushl  -0x24(%ebp)
c0203c2d:	e8 a3 03 00 00       	call   c0203fd5 <strlen>
c0203c32:	83 c4 10             	add    $0x10,%esp
c0203c35:	89 c2                	mov    %eax,%edx
c0203c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c3a:	01 d0                	add    %edx,%eax
c0203c3c:	83 e8 01             	sub    $0x1,%eax
c0203c3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0203c42:	eb 5e                	jmp    c0203ca2 <printk_color+0x1d8>
			} 
			else if(*(charptr+1)=='h')
c0203c44:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0203c47:	83 c0 01             	add    $0x1,%eax
c0203c4a:	0f b6 00             	movzbl (%eax),%eax
c0203c4d:	3c 68                	cmp    $0x68,%al
c0203c4f:	75 51                	jne    c0203ca2 <printk_color+0x1d8>
			{
				int arg_int=va_arg(ptr,int);
c0203c51:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0203c54:	8d 50 04             	lea    0x4(%eax),%edx
c0203c57:	89 55 cc             	mov    %edx,-0x34(%ebp)
c0203c5a:	8b 00                	mov    (%eax),%eax
c0203c5c:	89 45 e8             	mov    %eax,-0x18(%ebp)

				char*hexstrptr=num2hexstr(arg_int,0);
c0203c5f:	83 ec 08             	sub    $0x8,%esp
c0203c62:	6a 00                	push   $0x0
c0203c64:	ff 75 e8             	pushl  -0x18(%ebp)
c0203c67:	e8 58 01 00 00       	call   c0203dc4 <num2hexstr>
c0203c6c:	83 c4 10             	add    $0x10,%esp
c0203c6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				
				insert_str(output_str,hexstrptr,offset);
c0203c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c75:	83 ec 04             	sub    $0x4,%esp
c0203c78:	50                   	push   %eax
c0203c79:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203c7c:	ff 75 f0             	pushl  -0x10(%ebp)
c0203c7f:	e8 30 fb ff ff       	call   c02037b4 <insert_str>
c0203c84:	83 c4 10             	add    $0x10,%esp

				offset=offset+strlen(hexstrptr)-1;
c0203c87:	83 ec 0c             	sub    $0xc,%esp
c0203c8a:	ff 75 e4             	pushl  -0x1c(%ebp)
c0203c8d:	e8 43 03 00 00       	call   c0203fd5 <strlen>
c0203c92:	83 c4 10             	add    $0x10,%esp
c0203c95:	89 c2                	mov    %eax,%edx
c0203c97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203c9a:	01 d0                	add    %edx,%eax
c0203c9c:	83 e8 01             	sub    $0x1,%eax
c0203c9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(;*(output_str+offset)!='\0';offset++)
c0203ca2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203ca6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203ca9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0203cac:	01 d0                	add    %edx,%eax
c0203cae:	0f b6 00             	movzbl (%eax),%eax
c0203cb1:	84 c0                	test   %al,%al
c0203cb3:	0f 85 4f fe ff ff    	jne    c0203b08 <printk_color+0x3e>
			}
		}
	}
	va_end(ptr);
	kputs_color(output_str,back,fore);
c0203cb9:	83 ec 04             	sub    $0x4,%esp
c0203cbc:	ff 75 10             	pushl  0x10(%ebp)
c0203cbf:	ff 75 0c             	pushl  0xc(%ebp)
c0203cc2:	ff 75 f0             	pushl  -0x10(%ebp)
c0203cc5:	e8 ee f9 ff ff       	call   c02036b8 <kputs_color>
c0203cca:	83 c4 10             	add    $0x10,%esp
}
c0203ccd:	90                   	nop
c0203cce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203cd1:	c9                   	leave  
c0203cd2:	c3                   	ret    

c0203cd3 <printkDebug>:

void printkDebug(){
c0203cd3:	55                   	push   %ebp
c0203cd4:	89 e5                	mov    %esp,%ebp
c0203cd6:	53                   	push   %ebx
c0203cd7:	83 ec 04             	sub    $0x4,%esp
c0203cda:	e8 25 33 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203cdf:	81 c3 21 43 00 00    	add    $0x4321,%ebx
	printk("wkawda----");
c0203ce5:	83 ec 0c             	sub    $0xc,%esp
c0203ce8:	8d 83 0c 00 00 00    	lea    0xc(%ebx),%eax
c0203cee:	50                   	push   %eax
c0203cef:	e8 62 fb ff ff       	call   c0203856 <printk>
c0203cf4:	83 c4 10             	add    $0x10,%esp
	printk_color("wkdaowd",black,white);
c0203cf7:	83 ec 04             	sub    $0x4,%esp
c0203cfa:	6a 0f                	push   $0xf
c0203cfc:	6a 00                	push   $0x0
c0203cfe:	8d 83 17 00 00 00    	lea    0x17(%ebx),%eax
c0203d04:	50                   	push   %eax
c0203d05:	e8 c0 fd ff ff       	call   c0203aca <printk_color>
c0203d0a:	83 c4 10             	add    $0x10,%esp
c0203d0d:	90                   	nop
c0203d0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203d11:	c9                   	leave  
c0203d12:	c3                   	ret    

c0203d13 <func>:
#include "string.h"

//进制转换的辅助函数
static int func(char *s,int n,uint32_t i)          //n表示输入的数 i表示转化的进制
{
c0203d13:	55                   	push   %ebp
c0203d14:	89 e5                	mov    %esp,%ebp
c0203d16:	83 ec 28             	sub    $0x28,%esp
c0203d19:	e8 e2 32 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203d1e:	05 e2 42 00 00       	add    $0x42e2,%eax
    char bit[]={"0123456789ABCDEF"};
c0203d23:	c7 45 e3 30 31 32 33 	movl   $0x33323130,-0x1d(%ebp)
c0203d2a:	c7 45 e7 34 35 36 37 	movl   $0x37363534,-0x19(%ebp)
c0203d31:	c7 45 eb 38 39 41 42 	movl   $0x42413938,-0x15(%ebp)
c0203d38:	c7 45 ef 43 44 45 46 	movl   $0x46454443,-0x11(%ebp)
c0203d3f:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    int len;
    if(n==0)
c0203d43:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203d47:	75 1c                	jne    c0203d65 <func+0x52>
    {
        strcpy(s,"");
c0203d49:	83 ec 08             	sub    $0x8,%esp
c0203d4c:	8d 80 1f 00 00 00    	lea    0x1f(%eax),%eax
c0203d52:	50                   	push   %eax
c0203d53:	ff 75 08             	pushl  0x8(%ebp)
c0203d56:	e8 ab 02 00 00       	call   c0204006 <strcpy>
c0203d5b:	83 c4 10             	add    $0x10,%esp
        return 0;
c0203d5e:	b8 00 00 00 00       	mov    $0x0,%eax
c0203d63:	eb 5d                	jmp    c0203dc2 <func+0xaf>
    }
    func(s,n/i,i);
c0203d65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203d68:	ba 00 00 00 00       	mov    $0x0,%edx
c0203d6d:	f7 75 10             	divl   0x10(%ebp)
c0203d70:	83 ec 04             	sub    $0x4,%esp
c0203d73:	ff 75 10             	pushl  0x10(%ebp)
c0203d76:	50                   	push   %eax
c0203d77:	ff 75 08             	pushl  0x8(%ebp)
c0203d7a:	e8 94 ff ff ff       	call   c0203d13 <func>
c0203d7f:	83 c4 10             	add    $0x10,%esp
    len=strlen(s);
c0203d82:	83 ec 0c             	sub    $0xc,%esp
c0203d85:	ff 75 08             	pushl  0x8(%ebp)
c0203d88:	e8 48 02 00 00       	call   c0203fd5 <strlen>
c0203d8d:	83 c4 10             	add    $0x10,%esp
c0203d90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    s[len]=bit[n%i];
c0203d93:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203d96:	ba 00 00 00 00       	mov    $0x0,%edx
c0203d9b:	f7 75 10             	divl   0x10(%ebp)
c0203d9e:	89 d1                	mov    %edx,%ecx
c0203da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0203da3:	8b 45 08             	mov    0x8(%ebp),%eax
c0203da6:	01 c2                	add    %eax,%edx
c0203da8:	0f b6 44 0d e3       	movzbl -0x1d(%ebp,%ecx,1),%eax
c0203dad:	88 02                	mov    %al,(%edx)
    s[len+1]='\0';
c0203daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203db2:	8d 50 01             	lea    0x1(%eax),%edx
c0203db5:	8b 45 08             	mov    0x8(%ebp),%eax
c0203db8:	01 d0                	add    %edx,%eax
c0203dba:	c6 00 00             	movb   $0x0,(%eax)
    return 1;
c0203dbd:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0203dc2:	c9                   	leave  
c0203dc3:	c3                   	ret    

c0203dc4 <num2hexstr>:

//32位的16进制数 使用0x+8位字符表示+\0   共11位字符
inline char *num2hexstr(int number,int need0x)
{	if (number!=0)
c0203dc4:	55                   	push   %ebp
c0203dc5:	89 e5                	mov    %esp,%ebp
c0203dc7:	53                   	push   %ebx
c0203dc8:	83 ec 34             	sub    $0x34,%esp
c0203dcb:	e8 34 32 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0203dd0:	81 c3 30 42 00 00    	add    $0x4230,%ebx
c0203dd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0203dda:	0f 84 f1 00 00 00    	je     c0203ed1 <num2hexstr+0x10d>
	{
	static char static_hexstr[11]={0};
	static_hexstr[0]='0';
c0203de0:	c6 83 20 91 08 00 30 	movb   $0x30,0x89120(%ebx)
	static_hexstr[1]='x';
c0203de7:	c6 83 21 91 08 00 78 	movb   $0x78,0x89121(%ebx)
	char temp_arry[9]={0};
c0203dee:	c7 45 df 00 00 00 00 	movl   $0x0,-0x21(%ebp)
c0203df5:	c7 45 e3 00 00 00 00 	movl   $0x0,-0x1d(%ebp)
c0203dfc:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	char *temp_arry_ptr=temp_arry;
c0203e00:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203e03:	89 45 f0             	mov    %eax,-0x10(%ebp)
	func(temp_arry_ptr,number,16);
c0203e06:	83 ec 04             	sub    $0x4,%esp
c0203e09:	6a 10                	push   $0x10
c0203e0b:	ff 75 08             	pushl  0x8(%ebp)
c0203e0e:	ff 75 f0             	pushl  -0x10(%ebp)
c0203e11:	e8 fd fe ff ff       	call   c0203d13 <func>
c0203e16:	83 c4 10             	add    $0x10,%esp
	char temp_arry2[9]={0};
c0203e19:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
c0203e20:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
c0203e27:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	char *temp_arry2_ptr=temp_arry2;
c0203e2b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0203e2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	strcpy(temp_arry2_ptr,temp_arry_ptr);
c0203e31:	83 ec 08             	sub    $0x8,%esp
c0203e34:	ff 75 f0             	pushl  -0x10(%ebp)
c0203e37:	ff 75 ec             	pushl  -0x14(%ebp)
c0203e3a:	e8 c7 01 00 00       	call   c0204006 <strcpy>
c0203e3f:	83 c4 10             	add    $0x10,%esp
	int offset=8-strlen(temp_arry);
c0203e42:	83 ec 0c             	sub    $0xc,%esp
c0203e45:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203e48:	50                   	push   %eax
c0203e49:	e8 87 01 00 00       	call   c0203fd5 <strlen>
c0203e4e:	83 c4 10             	add    $0x10,%esp
c0203e51:	ba 08 00 00 00       	mov    $0x8,%edx
c0203e56:	29 c2                	sub    %eax,%edx
c0203e58:	89 d0                	mov    %edx,%eax
c0203e5a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	strcpy(temp_arry+offset,temp_arry2);
c0203e5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0203e60:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203e63:	01 c2                	add    %eax,%edx
c0203e65:	83 ec 08             	sub    $0x8,%esp
c0203e68:	8d 45 d6             	lea    -0x2a(%ebp),%eax
c0203e6b:	50                   	push   %eax
c0203e6c:	52                   	push   %edx
c0203e6d:	e8 94 01 00 00       	call   c0204006 <strcpy>
c0203e72:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<offset;i++)
c0203e75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0203e7c:	eb 0f                	jmp    c0203e8d <num2hexstr+0xc9>
		*(temp_arry+i)='0';
c0203e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203e81:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203e84:	01 d0                	add    %edx,%eax
c0203e86:	c6 00 30             	movb   $0x30,(%eax)
	for(int i=0;i<offset;i++)
c0203e89:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0203e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0203e90:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0203e93:	7c e9                	jl     c0203e7e <num2hexstr+0xba>
	if(need0x)
c0203e95:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203e99:	74 18                	je     c0203eb3 <num2hexstr+0xef>
		strcpy(static_hexstr+2,temp_arry);
c0203e9b:	8d 83 22 91 08 00    	lea    0x89122(%ebx),%eax
c0203ea1:	83 ec 08             	sub    $0x8,%esp
c0203ea4:	8d 55 df             	lea    -0x21(%ebp),%edx
c0203ea7:	52                   	push   %edx
c0203ea8:	50                   	push   %eax
c0203ea9:	e8 58 01 00 00       	call   c0204006 <strcpy>
c0203eae:	83 c4 10             	add    $0x10,%esp
c0203eb1:	eb 16                	jmp    c0203ec9 <num2hexstr+0x105>
	else
		strcpy(static_hexstr,temp_arry);
c0203eb3:	83 ec 08             	sub    $0x8,%esp
c0203eb6:	8d 45 df             	lea    -0x21(%ebp),%eax
c0203eb9:	50                   	push   %eax
c0203eba:	8d 83 20 91 08 00    	lea    0x89120(%ebx),%eax
c0203ec0:	50                   	push   %eax
c0203ec1:	e8 40 01 00 00       	call   c0204006 <strcpy>
c0203ec6:	83 c4 10             	add    $0x10,%esp
	return static_hexstr;
c0203ec9:	8d 83 20 91 08 00    	lea    0x89120(%ebx),%eax
c0203ecf:	eb 14                	jmp    c0203ee5 <num2hexstr+0x121>
	}
	else 
	{
		if(need0x)
c0203ed1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0203ed5:	74 08                	je     c0203edf <num2hexstr+0x11b>
			return "0x00000000";
c0203ed7:	8d 83 20 00 00 00    	lea    0x20(%ebx),%eax
c0203edd:	eb 06                	jmp    c0203ee5 <num2hexstr+0x121>
		else
			return "00000000";
c0203edf:	8d 83 2b 00 00 00    	lea    0x2b(%ebx),%eax
	}
}
c0203ee5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0203ee8:	c9                   	leave  
c0203ee9:	c3                   	ret    

c0203eea <memcpy>:


inline void memcpy(uint8_t *dest ,const uint8_t *src,uint32_t len)
{
c0203eea:	55                   	push   %ebp
c0203eeb:	89 e5                	mov    %esp,%ebp
c0203eed:	e8 0e 31 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203ef2:	05 0e 41 00 00       	add    $0x410e,%eax
	for(;len!=0;len--)
c0203ef7:	eb 17                	jmp    c0203f10 <memcpy+0x26>
	{
		*dest=*src;
c0203ef9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203efc:	0f b6 10             	movzbl (%eax),%edx
c0203eff:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f02:	88 10                	mov    %dl,(%eax)
		dest++;
c0203f04:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c0203f08:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	for(;len!=0;len--)
c0203f0c:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0203f10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0203f14:	75 e3                	jne    c0203ef9 <memcpy+0xf>
	}
}
c0203f16:	90                   	nop
c0203f17:	5d                   	pop    %ebp
c0203f18:	c3                   	ret    

c0203f19 <memset>:

inline void memset(void *dest,uint8_t val ,uint32_t len)
{
c0203f19:	55                   	push   %ebp
c0203f1a:	89 e5                	mov    %esp,%ebp
c0203f1c:	83 ec 14             	sub    $0x14,%esp
c0203f1f:	e8 dc 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f24:	05 dc 40 00 00       	add    $0x40dc,%eax
c0203f29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f2c:	88 45 ec             	mov    %al,-0x14(%ebp)
	uint8_t *dst = (uint8_t *)dest;
c0203f2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f32:	89 45 fc             	mov    %eax,-0x4(%ebp)

    for ( ; len != 0; len--) {
c0203f35:	eb 13                	jmp    c0203f4a <memset+0x31>
        *dst++ = val;
c0203f37:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0203f3a:	8d 50 01             	lea    0x1(%eax),%edx
c0203f3d:	89 55 fc             	mov    %edx,-0x4(%ebp)
c0203f40:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c0203f44:	88 10                	mov    %dl,(%eax)
    for ( ; len != 0; len--) {
c0203f46:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
c0203f4a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0203f4e:	75 e7                	jne    c0203f37 <memset+0x1e>
    }
}
c0203f50:	90                   	nop
c0203f51:	c9                   	leave  
c0203f52:	c3                   	ret    

c0203f53 <bzero>:

inline void bzero(void *dest, uint32_t len)
{
c0203f53:	55                   	push   %ebp
c0203f54:	89 e5                	mov    %esp,%ebp
c0203f56:	e8 a5 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f5b:	05 a5 40 00 00       	add    $0x40a5,%eax
    memset(dest, 0, len);
c0203f60:	ff 75 0c             	pushl  0xc(%ebp)
c0203f63:	6a 00                	push   $0x0
c0203f65:	ff 75 08             	pushl  0x8(%ebp)
c0203f68:	e8 ac ff ff ff       	call   c0203f19 <memset>
c0203f6d:	83 c4 0c             	add    $0xc,%esp
}
c0203f70:	90                   	nop
c0203f71:	c9                   	leave  
c0203f72:	c3                   	ret    

c0203f73 <strcmp>:

inline int strcmp(const char *str1,const char *str2)
{
c0203f73:	55                   	push   %ebp
c0203f74:	89 e5                	mov    %esp,%ebp
c0203f76:	e8 85 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203f7b:	05 85 40 00 00       	add    $0x4085,%eax
	while(1){
		if (*str1=='\0'&&*str2=='\0')
c0203f80:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f83:	0f b6 00             	movzbl (%eax),%eax
c0203f86:	84 c0                	test   %al,%al
c0203f88:	75 11                	jne    c0203f9b <strcmp+0x28>
c0203f8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203f8d:	0f b6 00             	movzbl (%eax),%eax
c0203f90:	84 c0                	test   %al,%al
c0203f92:	75 07                	jne    c0203f9b <strcmp+0x28>
			return 0;
c0203f94:	b8 00 00 00 00       	mov    $0x0,%eax
c0203f99:	eb 38                	jmp    c0203fd3 <strcmp+0x60>
		else if ((int)*str1>(int)*str2){
c0203f9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0203f9e:	0f b6 10             	movzbl (%eax),%edx
c0203fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203fa4:	0f b6 00             	movzbl (%eax),%eax
c0203fa7:	38 c2                	cmp    %al,%dl
c0203fa9:	7e 07                	jle    c0203fb2 <strcmp+0x3f>
			return 1;
c0203fab:	b8 01 00 00 00       	mov    $0x1,%eax
c0203fb0:	eb 21                	jmp    c0203fd3 <strcmp+0x60>
		}
		else if((int)*str1>(int)*str2){
c0203fb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0203fb5:	0f b6 10             	movzbl (%eax),%edx
c0203fb8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0203fbb:	0f b6 00             	movzbl (%eax),%eax
c0203fbe:	38 c2                	cmp    %al,%dl
c0203fc0:	7e 07                	jle    c0203fc9 <strcmp+0x56>
			return -1;
c0203fc2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0203fc7:	eb 0a                	jmp    c0203fd3 <strcmp+0x60>
		}
		else{
			str1++;
c0203fc9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
			str2++;
c0203fcd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
		if (*str1=='\0'&&*str2=='\0')
c0203fd1:	eb ad                	jmp    c0203f80 <strcmp+0xd>
		}
	}
}
c0203fd3:	5d                   	pop    %ebp
c0203fd4:	c3                   	ret    

c0203fd5 <strlen>:

inline int strlen(const char *src)
{
c0203fd5:	55                   	push   %ebp
c0203fd6:	89 e5                	mov    %esp,%ebp
c0203fd8:	83 ec 10             	sub    $0x10,%esp
c0203fdb:	e8 20 30 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0203fe0:	05 20 40 00 00       	add    $0x4020,%eax
	int i=0;
c0203fe5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while(*(src+i)!='\0')
c0203fec:	eb 04                	jmp    c0203ff2 <strlen+0x1d>
		i++;
c0203fee:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	while(*(src+i)!='\0')
c0203ff2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0203ff5:	8b 45 08             	mov    0x8(%ebp),%eax
c0203ff8:	01 d0                	add    %edx,%eax
c0203ffa:	0f b6 00             	movzbl (%eax),%eax
c0203ffd:	84 c0                	test   %al,%al
c0203fff:	75 ed                	jne    c0203fee <strlen+0x19>
	return i;
c0204001:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0204004:	c9                   	leave  
c0204005:	c3                   	ret    

c0204006 <strcpy>:

inline char *strcpy(char *dest, const char *src)
{
c0204006:	55                   	push   %ebp
c0204007:	89 e5                	mov    %esp,%ebp
c0204009:	83 ec 10             	sub    $0x10,%esp
c020400c:	e8 ef 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204011:	05 ef 3f 00 00       	add    $0x3fef,%eax
	char *dest_head=dest;
c0204016:	8b 45 08             	mov    0x8(%ebp),%eax
c0204019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(*(src)!='\0')
c020401c:	eb 13                	jmp    c0204031 <strcpy+0x2b>
	{
		*dest=*src;
c020401e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204021:	0f b6 10             	movzbl (%eax),%edx
c0204024:	8b 45 08             	mov    0x8(%ebp),%eax
c0204027:	88 10                	mov    %dl,(%eax)
		dest++;
c0204029:	83 45 08 01          	addl   $0x1,0x8(%ebp)
		src++;
c020402d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
	while(*(src)!='\0')
c0204031:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204034:	0f b6 00             	movzbl (%eax),%eax
c0204037:	84 c0                	test   %al,%al
c0204039:	75 e3                	jne    c020401e <strcpy+0x18>
	}
	*dest='\0';
c020403b:	8b 45 08             	mov    0x8(%ebp),%eax
c020403e:	c6 00 00             	movb   $0x0,(%eax)
	dest=dest_head;
c0204041:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204044:	89 45 08             	mov    %eax,0x8(%ebp)
	return dest;
c0204047:	8b 45 08             	mov    0x8(%ebp),%eax
}
c020404a:	c9                   	leave  
c020404b:	c3                   	ret    

c020404c <strcat>:

inline char *strcat(char *dest, const char *src)
{
c020404c:	55                   	push   %ebp
c020404d:	89 e5                	mov    %esp,%ebp
c020404f:	83 ec 10             	sub    $0x10,%esp
c0204052:	e8 a9 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204057:	05 a9 3f 00 00       	add    $0x3fa9,%eax
	char *pointer=dest;
c020405c:	8b 45 08             	mov    0x8(%ebp),%eax
c020405f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for(;*pointer!='\0';pointer++);
c0204062:	eb 04                	jmp    c0204068 <strcat+0x1c>
c0204064:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0204068:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020406b:	0f b6 00             	movzbl (%eax),%eax
c020406e:	84 c0                	test   %al,%al
c0204070:	75 f2                	jne    c0204064 <strcat+0x18>
	strcpy(pointer,src);
c0204072:	ff 75 0c             	pushl  0xc(%ebp)
c0204075:	ff 75 fc             	pushl  -0x4(%ebp)
c0204078:	e8 89 ff ff ff       	call   c0204006 <strcpy>
c020407d:	83 c4 08             	add    $0x8,%esp
	return dest;		
c0204080:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0204083:	c9                   	leave  
c0204084:	c3                   	ret    

c0204085 <uintTostring>:

inline char *uintTostring(uint32_t num)
{
c0204085:	55                   	push   %ebp
c0204086:	89 e5                	mov    %esp,%ebp
c0204088:	83 ec 28             	sub    $0x28,%esp
c020408b:	e8 70 2f 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204090:	05 70 3f 00 00       	add    $0x3f70,%eax
	char i2stable[10]={'0','1','2','3','4','5','6','7','8','9'};
c0204095:	c6 45 da 30          	movb   $0x30,-0x26(%ebp)
c0204099:	c6 45 db 31          	movb   $0x31,-0x25(%ebp)
c020409d:	c6 45 dc 32          	movb   $0x32,-0x24(%ebp)
c02040a1:	c6 45 dd 33          	movb   $0x33,-0x23(%ebp)
c02040a5:	c6 45 de 34          	movb   $0x34,-0x22(%ebp)
c02040a9:	c6 45 df 35          	movb   $0x35,-0x21(%ebp)
c02040ad:	c6 45 e0 36          	movb   $0x36,-0x20(%ebp)
c02040b1:	c6 45 e1 37          	movb   $0x37,-0x1f(%ebp)
c02040b5:	c6 45 e2 38          	movb   $0x38,-0x1e(%ebp)
c02040b9:	c6 45 e3 39          	movb   $0x39,-0x1d(%ebp)
	static char m[32]={0};
	char *str_ptr=m;
c02040bd:	8d 80 40 91 08 00    	lea    0x89140(%eax),%eax
c02040c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	char *head=str_ptr;
c02040c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02040c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int i=0;
c02040cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	for(;num>=10;i++)
c02040d3:	eb 46                	jmp    c020411b <uintTostring+0x96>
	{
		uint32_t num_=num/10;
c02040d5:	8b 45 08             	mov    0x8(%ebp),%eax
c02040d8:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c02040dd:	f7 e2                	mul    %edx
c02040df:	89 d0                	mov    %edx,%eax
c02040e1:	c1 e8 03             	shr    $0x3,%eax
c02040e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32_t index=num-(num_*10);
c02040e7:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02040ea:	89 d0                	mov    %edx,%eax
c02040ec:	c1 e0 02             	shl    $0x2,%eax
c02040ef:	01 d0                	add    %edx,%eax
c02040f1:	01 c0                	add    %eax,%eax
c02040f3:	89 c2                	mov    %eax,%edx
c02040f5:	8b 45 08             	mov    0x8(%ebp),%eax
c02040f8:	29 d0                	sub    %edx,%eax
c02040fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		num=num_;
c02040fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0204100:	89 45 08             	mov    %eax,0x8(%ebp)
		*str_ptr=i2stable[index];
c0204103:	8d 55 da             	lea    -0x26(%ebp),%edx
c0204106:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0204109:	01 d0                	add    %edx,%eax
c020410b:	0f b6 10             	movzbl (%eax),%edx
c020410e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204111:	88 10                	mov    %dl,(%eax)
		str_ptr++;
c0204113:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
	for(;num>=10;i++)
c0204117:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020411b:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c020411f:	77 b4                	ja     c02040d5 <uintTostring+0x50>
	}
	*str_ptr=i2stable[num];
c0204121:	8d 55 da             	lea    -0x26(%ebp),%edx
c0204124:	8b 45 08             	mov    0x8(%ebp),%eax
c0204127:	01 d0                	add    %edx,%eax
c0204129:	0f b6 10             	movzbl (%eax),%edx
c020412c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020412f:	88 10                	mov    %dl,(%eax)
	*(str_ptr+1)='\0';
c0204131:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204134:	83 c0 01             	add    $0x1,%eax
c0204137:	c6 00 00             	movb   $0x0,(%eax)
	return strrevers(head);
c020413a:	83 ec 0c             	sub    $0xc,%esp
c020413d:	ff 75 ec             	pushl  -0x14(%ebp)
c0204140:	e8 05 00 00 00       	call   c020414a <strrevers>
c0204145:	83 c4 10             	add    $0x10,%esp
}
c0204148:	c9                   	leave  
c0204149:	c3                   	ret    

c020414a <strrevers>:

inline  char *strrevers(char *str)
{
c020414a:	55                   	push   %ebp
c020414b:	89 e5                	mov    %esp,%ebp
c020414d:	83 ec 20             	sub    $0x20,%esp
c0204150:	e8 ab 2e 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204155:	05 ab 3e 00 00       	add    $0x3eab,%eax
	char *str_head=str;
c020415a:	8b 45 08             	mov    0x8(%ebp),%eax
c020415d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int lenth=strlen(str);
c0204160:	ff 75 08             	pushl  0x8(%ebp)
c0204163:	e8 6d fe ff ff       	call   c0203fd5 <strlen>
c0204168:	83 c4 04             	add    $0x4,%esp
c020416b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ptr_h=0;
c020416e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int ptr_t=--lenth;
c0204175:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0204179:	8b 45 f0             	mov    -0x10(%ebp),%eax
c020417c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c020417f:	eb 39                	jmp    c02041ba <strrevers+0x70>
	{
		char temp=*(str_head+ptr_t);
c0204181:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204184:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204187:	01 d0                	add    %edx,%eax
c0204189:	0f b6 00             	movzbl (%eax),%eax
c020418c:	88 45 ef             	mov    %al,-0x11(%ebp)
		*(str_head+ptr_t)=*(str_head+ptr_h);
c020418f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204192:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204195:	01 d0                	add    %edx,%eax
c0204197:	8b 4d f8             	mov    -0x8(%ebp),%ecx
c020419a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020419d:	01 ca                	add    %ecx,%edx
c020419f:	0f b6 00             	movzbl (%eax),%eax
c02041a2:	88 02                	mov    %al,(%edx)
		*(str_head+ptr_h)=temp;
c02041a4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02041a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02041aa:	01 c2                	add    %eax,%edx
c02041ac:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c02041b0:	88 02                	mov    %al,(%edx)
		ptr_h++;
c02041b2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		ptr_t--;
c02041b6:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	for(;ptr_h<ptr_t;)
c02041ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02041bd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c02041c0:	7c bf                	jl     c0204181 <strrevers+0x37>
	}
	return str_head;
c02041c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c02041c5:	c9                   	leave  
c02041c6:	c3                   	ret    

c02041c7 <_8259A_init>:
static uint16_t m_control_port = 0x20;     //主片控制端口号  main
static uint16_t m_data_port = 0x21;	       //从片数据端口号
static uint16_t o_control_port = 0xA0;     //从片控制端口号  other
static uint16_t o_data_port = 0xA1;        //从片数据端口号

void _8259A_init(){
c02041c7:	55                   	push   %ebp
c02041c8:	89 e5                	mov    %esp,%ebp
c02041ca:	53                   	push   %ebx
c02041cb:	83 ec 04             	sub    $0x4,%esp
c02041ce:	e8 31 2e 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02041d3:	81 c3 2d 3e 00 00    	add    $0x3e2d,%ebx
	//主片初始化
	outb(m_control_port,0x11);
c02041d9:	0f b7 83 1c f0 ff ff 	movzwl -0xfe4(%ebx),%eax
c02041e0:	0f b7 c0             	movzwl %ax,%eax
c02041e3:	83 ec 08             	sub    $0x8,%esp
c02041e6:	6a 11                	push   $0x11
c02041e8:	50                   	push   %eax
c02041e9:	e8 4d f5 ff ff       	call   c020373b <outb>
c02041ee:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x20);
c02041f1:	0f b7 83 1e f0 ff ff 	movzwl -0xfe2(%ebx),%eax
c02041f8:	0f b7 c0             	movzwl %ax,%eax
c02041fb:	83 ec 08             	sub    $0x8,%esp
c02041fe:	6a 20                	push   $0x20
c0204200:	50                   	push   %eax
c0204201:	e8 35 f5 ff ff       	call   c020373b <outb>
c0204206:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x04);
c0204209:	0f b7 83 1e f0 ff ff 	movzwl -0xfe2(%ebx),%eax
c0204210:	0f b7 c0             	movzwl %ax,%eax
c0204213:	83 ec 08             	sub    $0x8,%esp
c0204216:	6a 04                	push   $0x4
c0204218:	50                   	push   %eax
c0204219:	e8 1d f5 ff ff       	call   c020373b <outb>
c020421e:	83 c4 10             	add    $0x10,%esp
	outb(m_data_port,0x01);
c0204221:	0f b7 83 1e f0 ff ff 	movzwl -0xfe2(%ebx),%eax
c0204228:	0f b7 c0             	movzwl %ax,%eax
c020422b:	83 ec 08             	sub    $0x8,%esp
c020422e:	6a 01                	push   $0x1
c0204230:	50                   	push   %eax
c0204231:	e8 05 f5 ff ff       	call   c020373b <outb>
c0204236:	83 c4 10             	add    $0x10,%esp
	//从片初始化
	outb(o_control_port,0x11);
c0204239:	0f b7 83 20 f0 ff ff 	movzwl -0xfe0(%ebx),%eax
c0204240:	0f b7 c0             	movzwl %ax,%eax
c0204243:	83 ec 08             	sub    $0x8,%esp
c0204246:	6a 11                	push   $0x11
c0204248:	50                   	push   %eax
c0204249:	e8 ed f4 ff ff       	call   c020373b <outb>
c020424e:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x28);
c0204251:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204258:	0f b7 c0             	movzwl %ax,%eax
c020425b:	83 ec 08             	sub    $0x8,%esp
c020425e:	6a 28                	push   $0x28
c0204260:	50                   	push   %eax
c0204261:	e8 d5 f4 ff ff       	call   c020373b <outb>
c0204266:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x02);
c0204269:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204270:	0f b7 c0             	movzwl %ax,%eax
c0204273:	83 ec 08             	sub    $0x8,%esp
c0204276:	6a 02                	push   $0x2
c0204278:	50                   	push   %eax
c0204279:	e8 bd f4 ff ff       	call   c020373b <outb>
c020427e:	83 c4 10             	add    $0x10,%esp
	outb(o_data_port,0x01);
c0204281:	0f b7 83 22 f0 ff ff 	movzwl -0xfde(%ebx),%eax
c0204288:	0f b7 c0             	movzwl %ax,%eax
c020428b:	83 ec 08             	sub    $0x8,%esp
c020428e:	6a 01                	push   $0x1
c0204290:	50                   	push   %eax
c0204291:	e8 a5 f4 ff ff       	call   c020373b <outb>
c0204296:	83 c4 10             	add    $0x10,%esp
c0204299:	90                   	nop
c020429a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020429d:	c9                   	leave  
c020429e:	c3                   	ret    

c020429f <kern_entry>:
void kputc(char);
void screen_uproll_once();
uint32_t get_eflags();
extern TCB_t * cur_tcb;
extern TCB_t main_TCB;
void kern_entry(){
c020429f:	55                   	push   %ebp
c02042a0:	89 e5                	mov    %esp,%ebp
c02042a2:	53                   	push   %ebx
c02042a3:	83 ec 04             	sub    $0x4,%esp
c02042a6:	e8 59 2d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02042ab:	81 c3 55 3d 00 00    	add    $0x3d55,%ebx
	void func(void* args);
	vga_init();
c02042b1:	e8 6d f4 ff ff       	call   c0203723 <vga_init>
	pmm_init();
c02042b6:	e8 6e 16 00 00       	call   c0205929 <pmm_init>
	idt_init();
c02042bb:	e8 60 19 00 00       	call   c0205c20 <idt_init>
		asm volatile("sti");
c02042c0:	fb                   	sti    
	while (1)
c02042c1:	eb fe                	jmp    c02042c1 <kern_entry+0x22>

c02042c3 <bitmap_init_mem>:
#include "bitmap.h"
#include "types.h"
//4KB为一个页来管理

//初始化目标bitmap的内存区域
void bitmap_init_mem(bitmap bm){
c02042c3:	55                   	push   %ebp
c02042c4:	89 e5                	mov    %esp,%ebp
c02042c6:	83 ec 10             	sub    $0x10,%esp
c02042c9:	e8 32 2d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02042ce:	05 32 3d 00 00       	add    $0x3d32,%eax
    uint32_t lenght = bm.length;
c02042d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c02042d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02042d9:	8b 45 08             	mov    0x8(%ebp),%eax
c02042dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(uint32_t i = 0;i<lenght;i++){
c02042df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c02042e6:	eb 0f                	jmp    c02042f7 <bitmap_init_mem+0x34>
        *((byte*)(vaddr_header+i)) = 255;   //11111111b
c02042e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02042eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02042ee:	01 d0                	add    %edx,%eax
c02042f0:	c6 00 ff             	movb   $0xff,(%eax)
    for(uint32_t i = 0;i<lenght;i++){
c02042f3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c02042f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02042fa:	3b 45 f8             	cmp    -0x8(%ebp),%eax
c02042fd:	72 e9                	jb     c02042e8 <bitmap_init_mem+0x25>
    }
}
c02042ff:	90                   	nop
c0204300:	c9                   	leave  
c0204301:	c3                   	ret    

c0204302 <bitmap_alloc_one_page>:


//指定分配目标页
//分配成功：返回目标页起始地址
//分配失败：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc_one_page(bitmap bm,uint32_t target){
c0204302:	55                   	push   %ebp
c0204303:	89 e5                	mov    %esp,%ebp
c0204305:	83 ec 20             	sub    $0x20,%esp
c0204308:	e8 f3 2c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020430d:	05 f3 3c 00 00       	add    $0x3cf3,%eax
    uint32_t lenght = bm.length;
c0204312:	8b 45 0c             	mov    0xc(%ebp),%eax
c0204315:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c0204318:	8b 45 08             	mov    0x8(%ebp),%eax
c020431b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c020431e:	8b 45 10             	mov    0x10(%ebp),%eax
c0204321:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0204324:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;   //必须要-1 否则可能造成max_addr溢出为0
c020432b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020432e:	c1 e0 0f             	shl    $0xf,%eax
c0204331:	89 c2                	mov    %eax,%edx
c0204333:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204336:	01 d0                	add    %edx,%eax
c0204338:	83 e8 01             	sub    $0x1,%eax
c020433b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c020433e:	8b 45 14             	mov    0x14(%ebp),%eax
c0204341:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0204344:	0f 82 8e 00 00 00    	jb     c02043d8 <bitmap_alloc_one_page+0xd6>
c020434a:	8b 45 14             	mov    0x14(%ebp),%eax
c020434d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0204350:	0f 83 82 00 00 00    	jae    c02043d8 <bitmap_alloc_one_page+0xd6>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c0204356:	8b 45 14             	mov    0x14(%ebp),%eax
c0204359:	2b 45 f4             	sub    -0xc(%ebp),%eax
c020435c:	c1 e8 0c             	shr    $0xc,%eax
c020435f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c0204362:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204365:	8d 50 07             	lea    0x7(%eax),%edx
c0204368:	85 c0                	test   %eax,%eax
c020436a:	0f 48 c2             	cmovs  %edx,%eax
c020436d:	c1 f8 03             	sar    $0x3,%eax
c0204370:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c0204373:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0204376:	99                   	cltd   
c0204377:	c1 ea 1d             	shr    $0x1d,%edx
c020437a:	01 d0                	add    %edx,%eax
c020437c:	83 e0 07             	and    $0x7,%eax
c020437f:	29 d0                	sub    %edx,%eax
c0204381:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c0204384:	b8 07 00 00 00       	mov    $0x7,%eax
c0204389:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c020438c:	ba 01 00 00 00       	mov    $0x1,%edx
c0204391:	89 c1                	mov    %eax,%ecx
c0204393:	d3 e2                	shl    %cl,%edx
c0204395:	89 d0                	mov    %edx,%eax
c0204397:	88 45 e3             	mov    %al,-0x1d(%ebp)
        byte target_byte = *((byte*)(vaddr_header+i));
c020439a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c020439d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02043a0:	01 d0                	add    %edx,%eax
c02043a2:	0f b6 00             	movzbl (%eax),%eax
c02043a5:	88 45 e2             	mov    %al,-0x1e(%ebp)
        if(target_byte== (target_byte| byte_mask)){
c02043a8:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
c02043ac:	0a 45 e3             	or     -0x1d(%ebp),%al
c02043af:	38 45 e2             	cmp    %al,-0x1e(%ebp)
c02043b2:	75 1d                	jne    c02043d1 <bitmap_alloc_one_page+0xcf>
            //此时目标bit为1 空闲状态
            *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) - byte_mask;
c02043b4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02043b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02043ba:	01 d0                	add    %edx,%eax
c02043bc:	0f b6 00             	movzbl (%eax),%eax
c02043bf:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c02043c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02043c5:	01 ca                	add    %ecx,%edx
c02043c7:	2a 45 e3             	sub    -0x1d(%ebp),%al
c02043ca:	88 02                	mov    %al,(%edx)
            return target;    
c02043cc:	8b 45 14             	mov    0x14(%ebp),%eax
c02043cf:	eb 0c                	jmp    c02043dd <bitmap_alloc_one_page+0xdb>
        }
        else{
            //此时目标bit为0     忙碌状态
            return BITMAP_RETURN_ERRO;
c02043d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02043d6:	eb 05                	jmp    c02043dd <bitmap_alloc_one_page+0xdb>
        }   
    }
    else{
        return BITMAP_RETURN_ERRO;
c02043d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
c02043dd:	c9                   	leave  
c02043de:	c3                   	ret    

c02043df <bitmap_release_one_page>:

//释放指定的目标页
//释放成功或者失败都不会返回信息
void bitmap_release_one_page(bitmap bm,uint32_t target){
c02043df:	55                   	push   %ebp
c02043e0:	89 e5                	mov    %esp,%ebp
c02043e2:	83 ec 20             	sub    $0x20,%esp
c02043e5:	e8 16 2c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02043ea:	05 16 3c 00 00       	add    $0x3c16,%eax
    uint32_t lenght = bm.length;
c02043ef:	8b 45 0c             	mov    0xc(%ebp),%eax
c02043f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02043f5:	8b 45 08             	mov    0x8(%ebp),%eax
c02043f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c02043fb:	8b 45 10             	mov    0x10(%ebp),%eax
c02043fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    target = target&0xFFFFF000;
c0204401:	81 65 14 00 f0 ff ff 	andl   $0xfffff000,0x14(%ebp)
    uint32_t max_addr = target_addr_header-1+lenght*8*PAGE_SIZE;
c0204408:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020440b:	c1 e0 0f             	shl    $0xf,%eax
c020440e:	89 c2                	mov    %eax,%edx
c0204410:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204413:	01 d0                	add    %edx,%eax
c0204415:	83 e8 01             	sub    $0x1,%eax
c0204418:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(target>=target_addr_header&&target<max_addr){
c020441b:	8b 45 14             	mov    0x14(%ebp),%eax
c020441e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0204421:	72 64                	jb     c0204487 <bitmap_release_one_page+0xa8>
c0204423:	8b 45 14             	mov    0x14(%ebp),%eax
c0204426:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0204429:	73 5c                	jae    c0204487 <bitmap_release_one_page+0xa8>
        int page_num = (target-target_addr_header)/PAGE_SIZE;
c020442b:	8b 45 14             	mov    0x14(%ebp),%eax
c020442e:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0204431:	c1 e8 0c             	shr    $0xc,%eax
c0204434:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int i = page_num/8;
c0204437:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020443a:	8d 50 07             	lea    0x7(%eax),%edx
c020443d:	85 c0                	test   %eax,%eax
c020443f:	0f 48 c2             	cmovs  %edx,%eax
c0204442:	c1 f8 03             	sar    $0x3,%eax
c0204445:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int j =page_num%8;
c0204448:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020444b:	99                   	cltd   
c020444c:	c1 ea 1d             	shr    $0x1d,%edx
c020444f:	01 d0                	add    %edx,%eax
c0204451:	83 e0 07             	and    $0x7,%eax
c0204454:	29 d0                	sub    %edx,%eax
c0204456:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        byte byte_mask = 1<<(7-j);
c0204459:	b8 07 00 00 00       	mov    $0x7,%eax
c020445e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0204461:	ba 01 00 00 00       	mov    $0x1,%edx
c0204466:	89 c1                	mov    %eax,%ecx
c0204468:	d3 e2                	shl    %cl,%edx
c020446a:	89 d0                	mov    %edx,%eax
c020446c:	88 45 e3             	mov    %al,-0x1d(%ebp)
        *((byte*)(vaddr_header+i))=*((byte*)(vaddr_header+i)) | byte_mask;
c020446f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0204472:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204475:	01 d0                	add    %edx,%eax
c0204477:	0f b6 00             	movzbl (%eax),%eax
c020447a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c020447d:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204480:	01 ca                	add    %ecx,%edx
c0204482:	0a 45 e3             	or     -0x1d(%ebp),%al
c0204485:	88 02                	mov    %al,(%edx)
    }
}
c0204487:	90                   	nop
c0204488:	c9                   	leave  
c0204489:	c3                   	ret    

c020448a <bitmap_alloc>:

//任意分配 未指定分配的目标
//分配成功：返回目标页起始地址
//没有可用页：返回BITMAP_RETURN_ERRO
uint32_t bitmap_alloc(bitmap bm){      
c020448a:	55                   	push   %ebp
c020448b:	89 e5                	mov    %esp,%ebp
c020448d:	83 ec 30             	sub    $0x30,%esp
c0204490:	e8 6b 2b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204495:	05 6b 3b 00 00       	add    $0x3b6b,%eax
    uint32_t lenght = bm.length;
c020449a:	8b 45 0c             	mov    0xc(%ebp),%eax
c020449d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uint32_t vaddr_header = bm.vaddr_header;
c02044a0:	8b 45 08             	mov    0x8(%ebp),%eax
c02044a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint32_t target_addr_header=bm.target_addr_header;
c02044a6:	8b 45 10             	mov    0x10(%ebp),%eax
c02044a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(uint32_t i =0;i<lenght;i++){
c02044ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c02044b3:	e9 97 00 00 00       	jmp    c020454f <bitmap_alloc+0xc5>
        byte byte_now = *((byte*)(vaddr_header+i)) ;
c02044b8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c02044bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02044be:	01 d0                	add    %edx,%eax
c02044c0:	0f b6 00             	movzbl (%eax),%eax
c02044c3:	88 45 fb             	mov    %al,-0x5(%ebp)
        if(byte_now != 0){
c02044c6:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c02044ca:	74 7f                	je     c020454b <bitmap_alloc+0xc1>
            int pos;     //在本字节中目标bit所在位置（从左往右 从0开始）
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c02044cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c02044d3:	eb 21                	jmp    c02044f6 <bitmap_alloc+0x6c>
                byte temp_byte = byte_now<<1;
c02044d5:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c02044d9:	01 c0                	add    %eax,%eax
c02044db:	88 45 e3             	mov    %al,-0x1d(%ebp)
                if(byte_now>temp_byte){
c02044de:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c02044e2:	3a 45 e3             	cmp    -0x1d(%ebp),%al
c02044e5:	76 08                	jbe    c02044ef <bitmap_alloc+0x65>
                    pos = j;
c02044e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02044ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    break;
c02044ed:	eb 0d                	jmp    c02044fc <bitmap_alloc+0x72>
            for(int j=0;j<8;j++,byte_now=byte_now<<1){
c02044ef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02044f3:	d0 65 fb             	shlb   -0x5(%ebp)
c02044f6:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c02044fa:	7e d9                	jle    c02044d5 <bitmap_alloc+0x4b>
                }
            }
            byte byte_sub = 1<<(7-pos);     //1=00000001b
c02044fc:	b8 07 00 00 00       	mov    $0x7,%eax
c0204501:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0204504:	ba 01 00 00 00       	mov    $0x1,%edx
c0204509:	89 c1                	mov    %eax,%ecx
c020450b:	d3 e2                	shl    %cl,%edx
c020450d:	89 d0                	mov    %edx,%eax
c020450f:	88 45 e2             	mov    %al,-0x1e(%ebp)
            *((byte*)(vaddr_header+i)) = *((byte*)(vaddr_header+i))-byte_sub;
c0204512:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0204515:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204518:	01 d0                	add    %edx,%eax
c020451a:	0f b6 00             	movzbl (%eax),%eax
c020451d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0204520:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204523:	01 ca                	add    %ecx,%edx
c0204525:	2a 45 e2             	sub    -0x1e(%ebp),%al
c0204528:	88 02                	mov    %al,(%edx)
            int page_no = i*8+pos;
c020452a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020452d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0204534:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204537:	01 d0                	add    %edx,%eax
c0204539:	89 45 dc             	mov    %eax,-0x24(%ebp)
            return page_no*PAGE_SIZE+target_addr_header;
c020453c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c020453f:	c1 e0 0c             	shl    $0xc,%eax
c0204542:	89 c2                	mov    %eax,%edx
c0204544:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0204547:	01 d0                	add    %edx,%eax
c0204549:	eb 15                	jmp    c0204560 <bitmap_alloc+0xd6>
    for(uint32_t i =0;i<lenght;i++){
c020454b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c020454f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204552:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0204555:	0f 82 5d ff ff ff    	jb     c02044b8 <bitmap_alloc+0x2e>
        }
    }
    return BITMAP_RETURN_ERRO;
c020455b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0204560:	c9                   	leave  
c0204561:	c3                   	ret    

c0204562 <bitmap_test>:

//测试bitmap相关函数
void bitmap_test(){
c0204562:	55                   	push   %ebp
c0204563:	89 e5                	mov    %esp,%ebp
c0204565:	53                   	push   %ebx
c0204566:	83 ec 24             	sub    $0x24,%esp
c0204569:	e8 96 2a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020456e:	81 c3 92 3a 00 00    	add    $0x3a92,%ebx
#include "printk.h"
extern uint32_t kern_bitmap;
    bitmap bm;
    bm.length =2 ;
c0204574:	c7 45 e8 02 00 00 00 	movl   $0x2,-0x18(%ebp)
    bm.vaddr_header = kern_bitmap;
c020457b:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c0204581:	8b 00                	mov    (%eax),%eax
c0204583:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    bm.target_addr_header = 0x00000000;
c0204586:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    bitmap_init_mem(bm);
c020458d:	ff 75 ec             	pushl  -0x14(%ebp)
c0204590:	ff 75 e8             	pushl  -0x18(%ebp)
c0204593:	ff 75 e4             	pushl  -0x1c(%ebp)
c0204596:	e8 28 fd ff ff       	call   c02042c3 <bitmap_init_mem>
c020459b:	83 c4 0c             	add    $0xc,%esp
    for(int i = 0;i<8;i++){
c020459e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02045a5:	eb 3b                	jmp    c02045e2 <bitmap_test+0x80>
        printk("mem:0x%h\n",bitmap_alloc(bm));
c02045a7:	ff 75 ec             	pushl  -0x14(%ebp)
c02045aa:	ff 75 e8             	pushl  -0x18(%ebp)
c02045ad:	ff 75 e4             	pushl  -0x1c(%ebp)
c02045b0:	e8 d5 fe ff ff       	call   c020448a <bitmap_alloc>
c02045b5:	83 c4 0c             	add    $0xc,%esp
c02045b8:	83 ec 08             	sub    $0x8,%esp
c02045bb:	50                   	push   %eax
c02045bc:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c02045c2:	50                   	push   %eax
c02045c3:	e8 8e f2 ff ff       	call   c0203856 <printk>
c02045c8:	83 c4 10             	add    $0x10,%esp
        bitmap_release_one_page(bm,0x0);
c02045cb:	6a 00                	push   $0x0
c02045cd:	ff 75 ec             	pushl  -0x14(%ebp)
c02045d0:	ff 75 e8             	pushl  -0x18(%ebp)
c02045d3:	ff 75 e4             	pushl  -0x1c(%ebp)
c02045d6:	e8 04 fe ff ff       	call   c02043df <bitmap_release_one_page>
c02045db:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<8;i++){
c02045de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c02045e2:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c02045e6:	7e bf                	jle    c02045a7 <bitmap_test+0x45>
    }
    printk("alloc_page:0x%h\n",bitmap_alloc_one_page(bm,0xf010));
c02045e8:	68 10 f0 00 00       	push   $0xf010
c02045ed:	ff 75 ec             	pushl  -0x14(%ebp)
c02045f0:	ff 75 e8             	pushl  -0x18(%ebp)
c02045f3:	ff 75 e4             	pushl  -0x1c(%ebp)
c02045f6:	e8 07 fd ff ff       	call   c0204302 <bitmap_alloc_one_page>
c02045fb:	83 c4 10             	add    $0x10,%esp
c02045fe:	83 ec 08             	sub    $0x8,%esp
c0204601:	50                   	push   %eax
c0204602:	8d 83 3e 00 00 00    	lea    0x3e(%ebx),%eax
c0204608:	50                   	push   %eax
c0204609:	e8 48 f2 ff ff       	call   c0203856 <printk>
c020460e:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<16;i++){
c0204611:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0204618:	eb 2b                	jmp    c0204645 <bitmap_test+0xe3>
        printk("mem:0x%h\n",bitmap_alloc(bm));
c020461a:	83 ec 04             	sub    $0x4,%esp
c020461d:	ff 75 ec             	pushl  -0x14(%ebp)
c0204620:	ff 75 e8             	pushl  -0x18(%ebp)
c0204623:	ff 75 e4             	pushl  -0x1c(%ebp)
c0204626:	e8 5f fe ff ff       	call   c020448a <bitmap_alloc>
c020462b:	83 c4 10             	add    $0x10,%esp
c020462e:	83 ec 08             	sub    $0x8,%esp
c0204631:	50                   	push   %eax
c0204632:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
c0204638:	50                   	push   %eax
c0204639:	e8 18 f2 ff ff       	call   c0203856 <printk>
c020463e:	83 c4 10             	add    $0x10,%esp
    for(int i = 0;i<16;i++){
c0204641:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0204645:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c0204649:	7e cf                	jle    c020461a <bitmap_test+0xb8>
    }
c020464b:	90                   	nop
c020464c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020464f:	c9                   	leave  
c0204650:	c3                   	ret    

c0204651 <pmm_page_no_to_addr>:
pm_page_t *page_array = (pm_page_t*)0xC0000100;       
pm_multi_link_t * MULTI_LINK;   //用大写来表示很重要 并且定义为结构体指针，用->更加美观了～
pm_multi_link_t multi_link_struct={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
pm_page_t * SINGLE_LINK = NULL ;
//获取page编号对应的addr
static uint32_t pmm_page_no_to_addr(uint32_t page_no){
c0204651:	55                   	push   %ebp
c0204652:	89 e5                	mov    %esp,%ebp
c0204654:	e8 a7 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204659:	05 a7 39 00 00       	add    $0x39a7,%eax
	return (page_no<<12)+pmm_page_start;
c020465e:	8b 55 08             	mov    0x8(%ebp),%edx
c0204661:	c1 e2 0c             	shl    $0xc,%edx
c0204664:	8b 80 d0 91 08 00    	mov    0x891d0(%eax),%eax
c020466a:	01 d0                	add    %edx,%eax
}
c020466c:	5d                   	pop    %ebp
c020466d:	c3                   	ret    

c020466e <addr_to_pmm_page_no>:

//addr转为page_no
static uint32_t addr_to_pmm_page_no(uint32_t addr){
c020466e:	55                   	push   %ebp
c020466f:	89 e5                	mov    %esp,%ebp
c0204671:	e8 8a 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204676:	05 8a 39 00 00       	add    $0x398a,%eax
	return (addr-pmm_page_start)>>12;
c020467b:	8b 80 d0 91 08 00    	mov    0x891d0(%eax),%eax
c0204681:	8b 55 08             	mov    0x8(%ebp),%edx
c0204684:	29 c2                	sub    %eax,%edx
c0204686:	89 d0                	mov    %edx,%eax
c0204688:	c1 e8 0c             	shr    $0xc,%eax
}
c020468b:	5d                   	pop    %ebp
c020468c:	c3                   	ret    

c020468d <c_to_uint32>:

//将 page_c_t枚举类型转化为对应的块大小 如 (page_c_t)_256——> (uint32_t)256
static uint32_t c_to_uint32(page_c_t ph){
c020468d:	55                   	push   %ebp
c020468e:	89 e5                	mov    %esp,%ebp
c0204690:	83 ec 10             	sub    $0x10,%esp
c0204693:	e8 68 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204698:	05 68 39 00 00       	add    $0x3968,%eax
	uint32_t re = 1;
c020469d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
	re = re<<ph;
c02046a4:	8b 45 08             	mov    0x8(%ebp),%eax
c02046a7:	89 c1                	mov    %eax,%ecx
c02046a9:	d3 65 fc             	shll   %cl,-0x4(%ebp)
	return re;
c02046ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c02046af:	c9                   	leave  
c02046b0:	c3                   	ret    

c02046b1 <get_partner_page_no>:

static uint32_t get_partner_page_no(uint32_t page_no,page_c_t type){
c02046b1:	55                   	push   %ebp
c02046b2:	89 e5                	mov    %esp,%ebp
c02046b4:	83 ec 10             	sub    $0x10,%esp
c02046b7:	e8 44 29 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02046bc:	05 44 39 00 00       	add    $0x3944,%eax
	//--|--|--|--|--|--| 如图 必须整数倍或者0
	uint32_t v1 = c_to_uint32(type);
c02046c1:	ff 75 0c             	pushl  0xc(%ebp)
c02046c4:	e8 c4 ff ff ff       	call   c020468d <c_to_uint32>
c02046c9:	83 c4 04             	add    $0x4,%esp
c02046cc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t v2 = 2*v1;
c02046cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02046d2:	01 c0                	add    %eax,%eax
c02046d4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if((page_no - v1)%v2 == 0)
c02046d7:	8b 45 08             	mov    0x8(%ebp),%eax
c02046da:	2b 45 fc             	sub    -0x4(%ebp),%eax
c02046dd:	ba 00 00 00 00       	mov    $0x0,%edx
c02046e2:	f7 75 f8             	divl   -0x8(%ebp)
c02046e5:	89 d0                	mov    %edx,%eax
c02046e7:	85 c0                	test   %eax,%eax
c02046e9:	75 08                	jne    c02046f3 <get_partner_page_no+0x42>
		return page_no-v1;
c02046eb:	8b 45 08             	mov    0x8(%ebp),%eax
c02046ee:	2b 45 fc             	sub    -0x4(%ebp),%eax
c02046f1:	eb 08                	jmp    c02046fb <get_partner_page_no+0x4a>
	else
		return page_no+v1;
c02046f3:	8b 55 08             	mov    0x8(%ebp),%edx
c02046f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02046f9:	01 d0                	add    %edx,%eax
}
c02046fb:	c9                   	leave  
c02046fc:	c3                   	ret    

c02046fd <append_block>:


//向链表添加块（用于初始化链表以及free后添加块）
//此处可以使用##连接宏（但是我偏不）
static void append_block(int page_no,page_c_t c){
c02046fd:	55                   	push   %ebp
c02046fe:	89 e5                	mov    %esp,%ebp
c0204700:	53                   	push   %ebx
c0204701:	83 ec 10             	sub    $0x10,%esp
c0204704:	e8 f7 28 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204709:	05 f7 38 00 00       	add    $0x38f7,%eax
	page_array[page_no].next = NULL ;     //一定要设置 新加入块的下个指针为NULL
c020470e:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204714:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204717:	89 ca                	mov    %ecx,%edx
c0204719:	01 d2                	add    %edx,%edx
c020471b:	01 ca                	add    %ecx,%edx
c020471d:	c1 e2 02             	shl    $0x2,%edx
c0204720:	01 da                	add    %ebx,%edx
c0204722:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	pm_page_t * header;
	switch(c){
c0204729:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c020472d:	0f 87 cd 02 00 00    	ja     c0204a00 <.L39+0x22>
c0204733:	8b 55 0c             	mov    0xc(%ebp),%edx
c0204736:	c1 e2 02             	shl    $0x2,%edx
c0204739:	8b 94 02 50 00 00 00 	mov    0x50(%edx,%eax,1),%edx
c0204740:	01 c2                	add    %eax,%edx
c0204742:	ff e2                	jmp    *%edx

c0204744 <.L12>:
		case _1:
			header = MULTI_LINK ->_1;
c0204744:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020474a:	8b 12                	mov    (%edx),%edx
c020474c:	8b 12                	mov    (%edx),%edx
c020474e:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204751:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204755:	0f 85 86 02 00 00    	jne    c02049e1 <.L39+0x3>
				MULTI_LINK ->_1 = &(page_array[page_no]);
c020475b:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204761:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204764:	89 ca                	mov    %ecx,%edx
c0204766:	01 d2                	add    %edx,%edx
c0204768:	01 ca                	add    %ecx,%edx
c020476a:	c1 e2 02             	shl    $0x2,%edx
c020476d:	89 d1                	mov    %edx,%ecx
c020476f:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204775:	8b 12                	mov    (%edx),%edx
c0204777:	01 d9                	add    %ebx,%ecx
c0204779:	89 0a                	mov    %ecx,(%edx)
			break;
c020477b:	e9 61 02 00 00       	jmp    c02049e1 <.L39+0x3>

c0204780 <.L14>:
		case _2:
			header = MULTI_LINK ->_2;
c0204780:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204786:	8b 12                	mov    (%edx),%edx
c0204788:	8b 52 04             	mov    0x4(%edx),%edx
c020478b:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020478e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204792:	0f 85 4c 02 00 00    	jne    c02049e4 <.L39+0x6>
				MULTI_LINK ->_2 = &(page_array[page_no]);
c0204798:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c020479e:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02047a1:	89 ca                	mov    %ecx,%edx
c02047a3:	01 d2                	add    %edx,%edx
c02047a5:	01 ca                	add    %ecx,%edx
c02047a7:	c1 e2 02             	shl    $0x2,%edx
c02047aa:	89 d1                	mov    %edx,%ecx
c02047ac:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047b2:	8b 12                	mov    (%edx),%edx
c02047b4:	01 d9                	add    %ebx,%ecx
c02047b6:	89 4a 04             	mov    %ecx,0x4(%edx)
			break;
c02047b9:	e9 26 02 00 00       	jmp    c02049e4 <.L39+0x6>

c02047be <.L15>:
		case _4:
			header = MULTI_LINK ->_4;
c02047be:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047c4:	8b 12                	mov    (%edx),%edx
c02047c6:	8b 52 08             	mov    0x8(%edx),%edx
c02047c9:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02047cc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02047d0:	0f 85 11 02 00 00    	jne    c02049e7 <.L39+0x9>
				MULTI_LINK ->_4 = &(page_array[page_no]);
c02047d6:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02047dc:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02047df:	89 ca                	mov    %ecx,%edx
c02047e1:	01 d2                	add    %edx,%edx
c02047e3:	01 ca                	add    %ecx,%edx
c02047e5:	c1 e2 02             	shl    $0x2,%edx
c02047e8:	89 d1                	mov    %edx,%ecx
c02047ea:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02047f0:	8b 12                	mov    (%edx),%edx
c02047f2:	01 d9                	add    %ebx,%ecx
c02047f4:	89 4a 08             	mov    %ecx,0x8(%edx)
			break;
c02047f7:	e9 eb 01 00 00       	jmp    c02049e7 <.L39+0x9>

c02047fc <.L16>:
		case _8:
			header = MULTI_LINK ->_8;
c02047fc:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204802:	8b 12                	mov    (%edx),%edx
c0204804:	8b 52 0c             	mov    0xc(%edx),%edx
c0204807:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020480a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020480e:	0f 85 d6 01 00 00    	jne    c02049ea <.L39+0xc>
				MULTI_LINK ->_8 = &(page_array[page_no]);
c0204814:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c020481a:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020481d:	89 ca                	mov    %ecx,%edx
c020481f:	01 d2                	add    %edx,%edx
c0204821:	01 ca                	add    %ecx,%edx
c0204823:	c1 e2 02             	shl    $0x2,%edx
c0204826:	89 d1                	mov    %edx,%ecx
c0204828:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020482e:	8b 12                	mov    (%edx),%edx
c0204830:	01 d9                	add    %ebx,%ecx
c0204832:	89 4a 0c             	mov    %ecx,0xc(%edx)
			break;
c0204835:	e9 b0 01 00 00       	jmp    c02049ea <.L39+0xc>

c020483a <.L17>:
		case _16:
			header = MULTI_LINK ->_16;
c020483a:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204840:	8b 12                	mov    (%edx),%edx
c0204842:	8b 52 10             	mov    0x10(%edx),%edx
c0204845:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204848:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020484c:	0f 85 9b 01 00 00    	jne    c02049ed <.L39+0xf>
				MULTI_LINK ->_16 = &(page_array[page_no]);
c0204852:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204858:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020485b:	89 ca                	mov    %ecx,%edx
c020485d:	01 d2                	add    %edx,%edx
c020485f:	01 ca                	add    %ecx,%edx
c0204861:	c1 e2 02             	shl    $0x2,%edx
c0204864:	89 d1                	mov    %edx,%ecx
c0204866:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020486c:	8b 12                	mov    (%edx),%edx
c020486e:	01 d9                	add    %ebx,%ecx
c0204870:	89 4a 10             	mov    %ecx,0x10(%edx)
			break;
c0204873:	e9 75 01 00 00       	jmp    c02049ed <.L39+0xf>

c0204878 <.L18>:
		case _32:
			header = MULTI_LINK ->_32;
c0204878:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020487e:	8b 12                	mov    (%edx),%edx
c0204880:	8b 52 14             	mov    0x14(%edx),%edx
c0204883:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204886:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c020488a:	0f 85 60 01 00 00    	jne    c02049f0 <.L39+0x12>
				MULTI_LINK ->_32 = &(page_array[page_no]);
c0204890:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204896:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204899:	89 ca                	mov    %ecx,%edx
c020489b:	01 d2                	add    %edx,%edx
c020489d:	01 ca                	add    %ecx,%edx
c020489f:	c1 e2 02             	shl    $0x2,%edx
c02048a2:	89 d1                	mov    %edx,%ecx
c02048a4:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048aa:	8b 12                	mov    (%edx),%edx
c02048ac:	01 d9                	add    %ebx,%ecx
c02048ae:	89 4a 14             	mov    %ecx,0x14(%edx)
			break;
c02048b1:	e9 3a 01 00 00       	jmp    c02049f0 <.L39+0x12>

c02048b6 <.L19>:
		case _64:
			header = MULTI_LINK ->_64;
c02048b6:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048bc:	8b 12                	mov    (%edx),%edx
c02048be:	8b 52 18             	mov    0x18(%edx),%edx
c02048c1:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02048c4:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02048c8:	0f 85 25 01 00 00    	jne    c02049f3 <.L39+0x15>
				MULTI_LINK ->_64 = &(page_array[page_no]);
c02048ce:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02048d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02048d7:	89 ca                	mov    %ecx,%edx
c02048d9:	01 d2                	add    %edx,%edx
c02048db:	01 ca                	add    %ecx,%edx
c02048dd:	c1 e2 02             	shl    $0x2,%edx
c02048e0:	89 d1                	mov    %edx,%ecx
c02048e2:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048e8:	8b 12                	mov    (%edx),%edx
c02048ea:	01 d9                	add    %ebx,%ecx
c02048ec:	89 4a 18             	mov    %ecx,0x18(%edx)
			break;
c02048ef:	e9 ff 00 00 00       	jmp    c02049f3 <.L39+0x15>

c02048f4 <.L20>:
		case _128:
			header = MULTI_LINK ->_128;
c02048f4:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02048fa:	8b 12                	mov    (%edx),%edx
c02048fc:	8b 52 1c             	mov    0x1c(%edx),%edx
c02048ff:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204902:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204906:	0f 85 ea 00 00 00    	jne    c02049f6 <.L39+0x18>
				MULTI_LINK ->_128 = &(page_array[page_no]);
c020490c:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204912:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204915:	89 ca                	mov    %ecx,%edx
c0204917:	01 d2                	add    %edx,%edx
c0204919:	01 ca                	add    %ecx,%edx
c020491b:	c1 e2 02             	shl    $0x2,%edx
c020491e:	89 d1                	mov    %edx,%ecx
c0204920:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204926:	8b 12                	mov    (%edx),%edx
c0204928:	01 d9                	add    %ebx,%ecx
c020492a:	89 4a 1c             	mov    %ecx,0x1c(%edx)
			break;
c020492d:	e9 c4 00 00 00       	jmp    c02049f6 <.L39+0x18>

c0204932 <.L21>:
		case _256:
			header = MULTI_LINK ->_256;
c0204932:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204938:	8b 12                	mov    (%edx),%edx
c020493a:	8b 52 20             	mov    0x20(%edx),%edx
c020493d:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c0204940:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204944:	0f 85 af 00 00 00    	jne    c02049f9 <.L39+0x1b>
				MULTI_LINK ->_256 = &(page_array[page_no]);
c020494a:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c0204950:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0204953:	89 ca                	mov    %ecx,%edx
c0204955:	01 d2                	add    %edx,%edx
c0204957:	01 ca                	add    %ecx,%edx
c0204959:	c1 e2 02             	shl    $0x2,%edx
c020495c:	89 d1                	mov    %edx,%ecx
c020495e:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204964:	8b 12                	mov    (%edx),%edx
c0204966:	01 d9                	add    %ebx,%ecx
c0204968:	89 4a 20             	mov    %ecx,0x20(%edx)
			break;
c020496b:	e9 89 00 00 00       	jmp    c02049f9 <.L39+0x1b>

c0204970 <.L22>:
		case _512:
			header = MULTI_LINK ->_512;
c0204970:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204976:	8b 12                	mov    (%edx),%edx
c0204978:	8b 52 24             	mov    0x24(%edx),%edx
c020497b:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c020497e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204982:	75 78                	jne    c02049fc <.L39+0x1e>
				MULTI_LINK ->_512 = &(page_array[page_no]);
c0204984:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c020498a:	8b 4d 08             	mov    0x8(%ebp),%ecx
c020498d:	89 ca                	mov    %ecx,%edx
c020498f:	01 d2                	add    %edx,%edx
c0204991:	01 ca                	add    %ecx,%edx
c0204993:	c1 e2 02             	shl    $0x2,%edx
c0204996:	89 d1                	mov    %edx,%ecx
c0204998:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c020499e:	8b 12                	mov    (%edx),%edx
c02049a0:	01 d9                	add    %ebx,%ecx
c02049a2:	89 4a 24             	mov    %ecx,0x24(%edx)
			break;
c02049a5:	eb 55                	jmp    c02049fc <.L39+0x1e>

c02049a7 <.L23>:
		case _1024:
			header = MULTI_LINK ->_1024;
c02049a7:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049ad:	8b 12                	mov    (%edx),%edx
c02049af:	8b 52 28             	mov    0x28(%edx),%edx
c02049b2:	89 55 f8             	mov    %edx,-0x8(%ebp)
			if(header==NULL)
c02049b5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c02049b9:	75 44                	jne    c02049ff <.L39+0x21>
				MULTI_LINK ->_1024 = &(page_array[page_no]);
c02049bb:	8b 98 24 f0 ff ff    	mov    -0xfdc(%eax),%ebx
c02049c1:	8b 4d 08             	mov    0x8(%ebp),%ecx
c02049c4:	89 ca                	mov    %ecx,%edx
c02049c6:	01 d2                	add    %edx,%edx
c02049c8:	01 ca                	add    %ecx,%edx
c02049ca:	c1 e2 02             	shl    $0x2,%edx
c02049cd:	89 d1                	mov    %edx,%ecx
c02049cf:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c02049d5:	8b 12                	mov    (%edx),%edx
c02049d7:	01 d9                	add    %ebx,%ecx
c02049d9:	89 4a 28             	mov    %ecx,0x28(%edx)
			break;
c02049dc:	eb 21                	jmp    c02049ff <.L39+0x21>

c02049de <.L39>:
		case _erro:
			break;
c02049de:	90                   	nop
c02049df:	eb 1f                	jmp    c0204a00 <.L39+0x22>
			break;
c02049e1:	90                   	nop
c02049e2:	eb 1c                	jmp    c0204a00 <.L39+0x22>
			break;
c02049e4:	90                   	nop
c02049e5:	eb 19                	jmp    c0204a00 <.L39+0x22>
			break;
c02049e7:	90                   	nop
c02049e8:	eb 16                	jmp    c0204a00 <.L39+0x22>
			break;
c02049ea:	90                   	nop
c02049eb:	eb 13                	jmp    c0204a00 <.L39+0x22>
			break;
c02049ed:	90                   	nop
c02049ee:	eb 10                	jmp    c0204a00 <.L39+0x22>
			break;
c02049f0:	90                   	nop
c02049f1:	eb 0d                	jmp    c0204a00 <.L39+0x22>
			break;
c02049f3:	90                   	nop
c02049f4:	eb 0a                	jmp    c0204a00 <.L39+0x22>
			break;
c02049f6:	90                   	nop
c02049f7:	eb 07                	jmp    c0204a00 <.L39+0x22>
			break;
c02049f9:	90                   	nop
c02049fa:	eb 04                	jmp    c0204a00 <.L39+0x22>
			break;
c02049fc:	90                   	nop
c02049fd:	eb 01                	jmp    c0204a00 <.L39+0x22>
			break;
c02049ff:	90                   	nop
	}
	if(header!=NULL){
c0204a00:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
c0204a04:	74 36                	je     c0204a3c <.L39+0x5e>
		pm_page_t * probe = header;
c0204a06:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0204a09:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;(probe->next)!=NULL;probe = probe->next)
c0204a0c:	eb 09                	jmp    c0204a17 <.L39+0x39>
c0204a0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204a11:	8b 52 04             	mov    0x4(%edx),%edx
c0204a14:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0204a17:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0204a1a:	8b 52 04             	mov    0x4(%edx),%edx
c0204a1d:	85 d2                	test   %edx,%edx
c0204a1f:	75 ed                	jne    c0204a0e <.L39+0x30>
			;
		(probe -> next)=&(page_array[page_no]);
c0204a21:	8b 88 24 f0 ff ff    	mov    -0xfdc(%eax),%ecx
c0204a27:	8b 55 08             	mov    0x8(%ebp),%edx
c0204a2a:	89 d0                	mov    %edx,%eax
c0204a2c:	01 c0                	add    %eax,%eax
c0204a2e:	01 d0                	add    %edx,%eax
c0204a30:	c1 e0 02             	shl    $0x2,%eax
c0204a33:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0204a36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0204a39:	89 50 04             	mov    %edx,0x4(%eax)
	}
}
c0204a3c:	90                   	nop
c0204a3d:	83 c4 10             	add    $0x10,%esp
c0204a40:	5b                   	pop    %ebx
c0204a41:	5d                   	pop    %ebp
c0204a42:	c3                   	ret    

c0204a43 <pop_block>:

//从链表中取出一个块 链表为空返回ERRO_POP_BLOCK
static uint32_t pop_block(page_c_t c){
c0204a43:	55                   	push   %ebp
c0204a44:	89 e5                	mov    %esp,%ebp
c0204a46:	83 ec 10             	sub    $0x10,%esp
c0204a49:	e8 b2 25 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204a4e:	05 b2 35 00 00       	add    $0x35b2,%eax
	pm_page_t * header;
	switch(c){
c0204a53:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0204a57:	0f 87 1e 03 00 00    	ja     c0204d7b <.L66+0x26>
c0204a5d:	8b 55 08             	mov    0x8(%ebp),%edx
c0204a60:	c1 e2 02             	shl    $0x2,%edx
c0204a63:	8b 94 02 80 00 00 00 	mov    0x80(%edx,%eax,1),%edx
c0204a6a:	01 c2                	add    %eax,%edx
c0204a6c:	ff e2                	jmp    *%edx

c0204a6e <.L54>:
		case _1:
			header = MULTI_LINK ->_1;
c0204a6e:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204a74:	8b 12                	mov    (%edx),%edx
c0204a76:	8b 12                	mov    (%edx),%edx
c0204a78:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204a7b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204a7f:	75 0a                	jne    c0204a8b <.L54+0x1d>
				return ERRO_POP_BLOCK;
c0204a81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204a86:	e9 26 03 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204a8b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204a8e:	8b 52 04             	mov    0x4(%edx),%edx
c0204a91:	85 d2                	test   %edx,%edx
c0204a93:	0f 85 c3 02 00 00    	jne    c0204d5c <.L66+0x7>
				MULTI_LINK ->_1 =NULL;
c0204a99:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204a9f:	8b 00                	mov    (%eax),%eax
c0204aa1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				return header->page_no;
c0204aa7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204aaa:	8b 00                	mov    (%eax),%eax
c0204aac:	e9 00 03 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204ab1 <.L56>:
			}
			break;
		case _2:
			header = MULTI_LINK ->_2;
c0204ab1:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204ab7:	8b 12                	mov    (%edx),%edx
c0204ab9:	8b 52 04             	mov    0x4(%edx),%edx
c0204abc:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204abf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ac3:	75 0a                	jne    c0204acf <.L56+0x1e>
				return ERRO_POP_BLOCK;
c0204ac5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204aca:	e9 e2 02 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204acf:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204ad2:	8b 52 04             	mov    0x4(%edx),%edx
c0204ad5:	85 d2                	test   %edx,%edx
c0204ad7:	0f 85 82 02 00 00    	jne    c0204d5f <.L66+0xa>
				MULTI_LINK ->_2 = NULL;
c0204add:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204ae3:	8b 00                	mov    (%eax),%eax
c0204ae5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
				return header->page_no;
c0204aec:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204aef:	8b 00                	mov    (%eax),%eax
c0204af1:	e9 bb 02 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204af6 <.L57>:
			}
			break;
		case _4:
			header = MULTI_LINK ->_4;
c0204af6:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204afc:	8b 12                	mov    (%edx),%edx
c0204afe:	8b 52 08             	mov    0x8(%edx),%edx
c0204b01:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b04:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b08:	75 0a                	jne    c0204b14 <.L57+0x1e>
				return ERRO_POP_BLOCK;
c0204b0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b0f:	e9 9d 02 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204b14:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204b17:	8b 52 04             	mov    0x4(%edx),%edx
c0204b1a:	85 d2                	test   %edx,%edx
c0204b1c:	0f 85 40 02 00 00    	jne    c0204d62 <.L66+0xd>
				MULTI_LINK ->_4 = NULL;
c0204b22:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b28:	8b 00                	mov    (%eax),%eax
c0204b2a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				return header->page_no;
c0204b31:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b34:	8b 00                	mov    (%eax),%eax
c0204b36:	e9 76 02 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204b3b <.L58>:
			}
			break;
		case _8:
			header = MULTI_LINK ->_8;
c0204b3b:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204b41:	8b 12                	mov    (%edx),%edx
c0204b43:	8b 52 0c             	mov    0xc(%edx),%edx
c0204b46:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b49:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b4d:	75 0a                	jne    c0204b59 <.L58+0x1e>
				return ERRO_POP_BLOCK;
c0204b4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b54:	e9 58 02 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204b59:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204b5c:	8b 52 04             	mov    0x4(%edx),%edx
c0204b5f:	85 d2                	test   %edx,%edx
c0204b61:	0f 85 fe 01 00 00    	jne    c0204d65 <.L66+0x10>
				MULTI_LINK ->_8 = NULL;
c0204b67:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204b6d:	8b 00                	mov    (%eax),%eax
c0204b6f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				return header->page_no;
c0204b76:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204b79:	8b 00                	mov    (%eax),%eax
c0204b7b:	e9 31 02 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204b80 <.L59>:
			}
			break;
		case _16:
			header = MULTI_LINK ->_16;
c0204b80:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204b86:	8b 12                	mov    (%edx),%edx
c0204b88:	8b 52 10             	mov    0x10(%edx),%edx
c0204b8b:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204b8e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204b92:	75 0a                	jne    c0204b9e <.L59+0x1e>
				return ERRO_POP_BLOCK;
c0204b94:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204b99:	e9 13 02 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204b9e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204ba1:	8b 52 04             	mov    0x4(%edx),%edx
c0204ba4:	85 d2                	test   %edx,%edx
c0204ba6:	0f 85 bc 01 00 00    	jne    c0204d68 <.L66+0x13>
				MULTI_LINK ->_16 = NULL;
c0204bac:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204bb2:	8b 00                	mov    (%eax),%eax
c0204bb4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
				return header->page_no;
c0204bbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204bbe:	8b 00                	mov    (%eax),%eax
c0204bc0:	e9 ec 01 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204bc5 <.L60>:
			}
			break;
		case _32:
			header = MULTI_LINK ->_32;
c0204bc5:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204bcb:	8b 12                	mov    (%edx),%edx
c0204bcd:	8b 52 14             	mov    0x14(%edx),%edx
c0204bd0:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204bd3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204bd7:	75 0a                	jne    c0204be3 <.L60+0x1e>
				return ERRO_POP_BLOCK;
c0204bd9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204bde:	e9 ce 01 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204be3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204be6:	8b 52 04             	mov    0x4(%edx),%edx
c0204be9:	85 d2                	test   %edx,%edx
c0204beb:	0f 85 7a 01 00 00    	jne    c0204d6b <.L66+0x16>
				MULTI_LINK ->_32 = NULL;
c0204bf1:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204bf7:	8b 00                	mov    (%eax),%eax
c0204bf9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
				return header->page_no;
c0204c00:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c03:	8b 00                	mov    (%eax),%eax
c0204c05:	e9 a7 01 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204c0a <.L61>:
			}
			break;
		case _64:
			header = MULTI_LINK ->_64;
c0204c0a:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c10:	8b 12                	mov    (%edx),%edx
c0204c12:	8b 52 18             	mov    0x18(%edx),%edx
c0204c15:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204c18:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204c1c:	75 0a                	jne    c0204c28 <.L61+0x1e>
				return ERRO_POP_BLOCK;
c0204c1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c23:	e9 89 01 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204c28:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c2b:	8b 52 04             	mov    0x4(%edx),%edx
c0204c2e:	85 d2                	test   %edx,%edx
c0204c30:	0f 85 38 01 00 00    	jne    c0204d6e <.L66+0x19>
				MULTI_LINK ->_64 = NULL;
c0204c36:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204c3c:	8b 00                	mov    (%eax),%eax
c0204c3e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
				return header->page_no;
c0204c45:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c48:	8b 00                	mov    (%eax),%eax
c0204c4a:	e9 62 01 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204c4f <.L62>:
			}
			break;
		case _128:
			header = MULTI_LINK ->_128;
c0204c4f:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c55:	8b 12                	mov    (%edx),%edx
c0204c57:	8b 52 1c             	mov    0x1c(%edx),%edx
c0204c5a:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204c5d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204c61:	75 0a                	jne    c0204c6d <.L62+0x1e>
				return ERRO_POP_BLOCK;
c0204c63:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204c68:	e9 44 01 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204c6d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204c70:	8b 52 04             	mov    0x4(%edx),%edx
c0204c73:	85 d2                	test   %edx,%edx
c0204c75:	0f 85 f6 00 00 00    	jne    c0204d71 <.L66+0x1c>
				MULTI_LINK ->_128 = NULL;
c0204c7b:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204c81:	8b 00                	mov    (%eax),%eax
c0204c83:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
				return header->page_no;
c0204c8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204c8d:	8b 00                	mov    (%eax),%eax
c0204c8f:	e9 1d 01 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204c94 <.L63>:
			}
			break;
		case _256:
			header = MULTI_LINK ->_256;
c0204c94:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204c9a:	8b 12                	mov    (%edx),%edx
c0204c9c:	8b 52 20             	mov    0x20(%edx),%edx
c0204c9f:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204ca2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ca6:	75 0a                	jne    c0204cb2 <.L63+0x1e>
				return ERRO_POP_BLOCK;
c0204ca8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204cad:	e9 ff 00 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204cb2:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204cb5:	8b 52 04             	mov    0x4(%edx),%edx
c0204cb8:	85 d2                	test   %edx,%edx
c0204cba:	0f 85 b4 00 00 00    	jne    c0204d74 <.L66+0x1f>
				MULTI_LINK ->_256 = NULL;
c0204cc0:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204cc6:	8b 00                	mov    (%eax),%eax
c0204cc8:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				return header->page_no;
c0204ccf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204cd2:	8b 00                	mov    (%eax),%eax
c0204cd4:	e9 d8 00 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204cd9 <.L64>:
			}
			break;
		case _512:
			header = MULTI_LINK ->_512;
c0204cd9:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204cdf:	8b 12                	mov    (%edx),%edx
c0204ce1:	8b 52 24             	mov    0x24(%edx),%edx
c0204ce4:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204ce7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ceb:	75 0a                	jne    c0204cf7 <.L64+0x1e>
				return ERRO_POP_BLOCK;
c0204ced:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204cf2:	e9 ba 00 00 00       	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204cf7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204cfa:	8b 52 04             	mov    0x4(%edx),%edx
c0204cfd:	85 d2                	test   %edx,%edx
c0204cff:	75 76                	jne    c0204d77 <.L66+0x22>
				MULTI_LINK ->_512 = NULL;
c0204d01:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d07:	8b 00                	mov    (%eax),%eax
c0204d09:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
				return header->page_no;
c0204d10:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d13:	8b 00                	mov    (%eax),%eax
c0204d15:	e9 97 00 00 00       	jmp    c0204db1 <.L66+0x5c>

c0204d1a <.L65>:
			}
			break;
		case _1024:
			header = MULTI_LINK ->_1024;
c0204d1a:	c7 c2 00 20 29 c0    	mov    $0xc0292000,%edx
c0204d20:	8b 12                	mov    (%edx),%edx
c0204d22:	8b 52 28             	mov    0x28(%edx),%edx
c0204d25:	89 55 fc             	mov    %edx,-0x4(%ebp)
			if(header==NULL)
c0204d28:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204d2c:	75 07                	jne    c0204d35 <.L65+0x1b>
				return ERRO_POP_BLOCK;
c0204d2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d33:	eb 7c                	jmp    c0204db1 <.L66+0x5c>
			if(header->next==NULL){
c0204d35:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0204d38:	8b 52 04             	mov    0x4(%edx),%edx
c0204d3b:	85 d2                	test   %edx,%edx
c0204d3d:	75 3b                	jne    c0204d7a <.L66+0x25>
				MULTI_LINK ->_1024 = NULL;
c0204d3f:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204d45:	8b 00                	mov    (%eax),%eax
c0204d47:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
				return header->page_no;
c0204d4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d51:	8b 00                	mov    (%eax),%eax
c0204d53:	eb 5c                	jmp    c0204db1 <.L66+0x5c>

c0204d55 <.L66>:
			}
			break;
		case _erro:
			return ERRO_POP_BLOCK; 
c0204d55:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204d5a:	eb 55                	jmp    c0204db1 <.L66+0x5c>
			break;
c0204d5c:	90                   	nop
c0204d5d:	eb 1c                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d5f:	90                   	nop
c0204d60:	eb 19                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d62:	90                   	nop
c0204d63:	eb 16                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d65:	90                   	nop
c0204d66:	eb 13                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d68:	90                   	nop
c0204d69:	eb 10                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d6b:	90                   	nop
c0204d6c:	eb 0d                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d6e:	90                   	nop
c0204d6f:	eb 0a                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d71:	90                   	nop
c0204d72:	eb 07                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d74:	90                   	nop
c0204d75:	eb 04                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d77:	90                   	nop
c0204d78:	eb 01                	jmp    c0204d7b <.L66+0x26>
			break;
c0204d7a:	90                   	nop
			break;
	}
	pm_page_t * probe = header;
c0204d7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204d7e:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(;probe->next->next!=NULL;probe = probe->next)
c0204d81:	eb 09                	jmp    c0204d8c <.L66+0x37>
c0204d83:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204d86:	8b 40 04             	mov    0x4(%eax),%eax
c0204d89:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204d8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204d8f:	8b 40 04             	mov    0x4(%eax),%eax
c0204d92:	8b 40 04             	mov    0x4(%eax),%eax
c0204d95:	85 c0                	test   %eax,%eax
c0204d97:	75 ea                	jne    c0204d83 <.L66+0x2e>
		;
	uint32_t return_page_no = probe->next->page_no;
c0204d99:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204d9c:	8b 40 04             	mov    0x4(%eax),%eax
c0204d9f:	8b 00                	mov    (%eax),%eax
c0204da1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	probe->next=NULL;
c0204da4:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204da7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	return return_page_no;
c0204dae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204db1:	c9                   	leave  
c0204db2:	c3                   	ret    

c0204db3 <find_and_pop_block>:
 
//free合并块使用函数
//如果链表中没有 返回ERRO_POP_BLOCK 否则返回对应page_no
static uint32_t find_and_pop_block(uint32_t target_page_no,page_c_t ph){
c0204db3:	55                   	push   %ebp
c0204db4:	89 e5                	mov    %esp,%ebp
c0204db6:	83 ec 10             	sub    $0x10,%esp
c0204db9:	e8 42 22 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0204dbe:	05 42 32 00 00       	add    $0x3242,%eax
	pm_page_t * header;
	switch(ph){
c0204dc3:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
c0204dc7:	0f 87 d3 00 00 00    	ja     c0204ea0 <.L117+0xa>
c0204dcd:	8b 55 0c             	mov    0xc(%ebp),%edx
c0204dd0:	c1 e2 02             	shl    $0x2,%edx
c0204dd3:	8b 94 02 b0 00 00 00 	mov    0xb0(%edx,%eax,1),%edx
c0204dda:	01 c2                	add    %eax,%edx
c0204ddc:	ff e2                	jmp    *%edx

c0204dde <.L105>:
		case _1:
			header = MULTI_LINK -> _1;
c0204dde:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204de4:	8b 00                	mov    (%eax),%eax
c0204de6:	8b 00                	mov    (%eax),%eax
c0204de8:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204deb:	e9 b0 00 00 00       	jmp    c0204ea0 <.L117+0xa>

c0204df0 <.L107>:
		case _2:
			header = MULTI_LINK -> _2;
c0204df0:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204df6:	8b 00                	mov    (%eax),%eax
c0204df8:	8b 40 04             	mov    0x4(%eax),%eax
c0204dfb:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204dfe:	e9 9d 00 00 00       	jmp    c0204ea0 <.L117+0xa>

c0204e03 <.L108>:
		case _4:
			header = MULTI_LINK -> _4;
c0204e03:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e09:	8b 00                	mov    (%eax),%eax
c0204e0b:	8b 40 08             	mov    0x8(%eax),%eax
c0204e0e:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e11:	e9 8a 00 00 00       	jmp    c0204ea0 <.L117+0xa>

c0204e16 <.L109>:
		case _8:
			header = MULTI_LINK -> _8;
c0204e16:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e1c:	8b 00                	mov    (%eax),%eax
c0204e1e:	8b 40 0c             	mov    0xc(%eax),%eax
c0204e21:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e24:	eb 7a                	jmp    c0204ea0 <.L117+0xa>

c0204e26 <.L110>:
		case _16:
			header = MULTI_LINK -> _16;
c0204e26:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e2c:	8b 00                	mov    (%eax),%eax
c0204e2e:	8b 40 10             	mov    0x10(%eax),%eax
c0204e31:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e34:	eb 6a                	jmp    c0204ea0 <.L117+0xa>

c0204e36 <.L111>:
		case _32:
			header = MULTI_LINK -> _32;
c0204e36:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e3c:	8b 00                	mov    (%eax),%eax
c0204e3e:	8b 40 14             	mov    0x14(%eax),%eax
c0204e41:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e44:	eb 5a                	jmp    c0204ea0 <.L117+0xa>

c0204e46 <.L112>:
		case _64:
			header = MULTI_LINK -> _64;
c0204e46:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e4c:	8b 00                	mov    (%eax),%eax
c0204e4e:	8b 40 18             	mov    0x18(%eax),%eax
c0204e51:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e54:	eb 4a                	jmp    c0204ea0 <.L117+0xa>

c0204e56 <.L113>:
		case _128:
			header = MULTI_LINK -> _128;
c0204e56:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e5c:	8b 00                	mov    (%eax),%eax
c0204e5e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0204e61:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e64:	eb 3a                	jmp    c0204ea0 <.L117+0xa>

c0204e66 <.L114>:
		case _256:
			header = MULTI_LINK -> _256;
c0204e66:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e6c:	8b 00                	mov    (%eax),%eax
c0204e6e:	8b 40 20             	mov    0x20(%eax),%eax
c0204e71:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e74:	eb 2a                	jmp    c0204ea0 <.L117+0xa>

c0204e76 <.L115>:
		case _512:
			header = MULTI_LINK -> _512;
c0204e76:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e7c:	8b 00                	mov    (%eax),%eax
c0204e7e:	8b 40 24             	mov    0x24(%eax),%eax
c0204e81:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e84:	eb 1a                	jmp    c0204ea0 <.L117+0xa>

c0204e86 <.L116>:
		case _1024:
			header = MULTI_LINK -> _1024;
c0204e86:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0204e8c:	8b 00                	mov    (%eax),%eax
c0204e8e:	8b 40 28             	mov    0x28(%eax),%eax
c0204e91:	89 45 fc             	mov    %eax,-0x4(%ebp)
			break;
c0204e94:	eb 0a                	jmp    c0204ea0 <.L117+0xa>

c0204e96 <.L117>:
		case _erro:
			return ERRO_POP_BLOCK;
c0204e96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204e9b:	e9 8c 00 00 00       	jmp    c0204f2c <.L117+0x96>
	}
	if(header == NULL)
c0204ea0:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0204ea4:	75 07                	jne    c0204ead <.L117+0x17>
		return ERRO_POP_BLOCK;
c0204ea6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0204eab:	eb 7f                	jmp    c0204f2c <.L117+0x96>
	if(header->next==NULL){
c0204ead:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204eb0:	8b 40 04             	mov    0x4(%eax),%eax
c0204eb3:	85 c0                	test   %eax,%eax
c0204eb5:	75 1a                	jne    c0204ed1 <.L117+0x3b>
		if(header->page_no==target_page_no){
c0204eb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204eba:	8b 00                	mov    (%eax),%eax
c0204ebc:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204ebf:	75 10                	jne    c0204ed1 <.L117+0x3b>
			pop_block(ph);
c0204ec1:	ff 75 0c             	pushl  0xc(%ebp)
c0204ec4:	e8 7a fb ff ff       	call   c0204a43 <pop_block>
c0204ec9:	83 c4 04             	add    $0x4,%esp
			return target_page_no;
c0204ecc:	8b 45 08             	mov    0x8(%ebp),%eax
c0204ecf:	eb 5b                	jmp    c0204f2c <.L117+0x96>
		}
	}
	pm_page_t * probe = header ;
c0204ed1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0204ed4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for(; probe->next!=NULL;probe=probe->next){
c0204ed7:	eb 2a                	jmp    c0204f03 <.L117+0x6d>
		if(probe->next->page_no == target_page_no){
c0204ed9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204edc:	8b 40 04             	mov    0x4(%eax),%eax
c0204edf:	8b 00                	mov    (%eax),%eax
c0204ee1:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204ee4:	75 14                	jne    c0204efa <.L117+0x64>
			probe->next = probe->next->next;
c0204ee6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ee9:	8b 40 04             	mov    0x4(%eax),%eax
c0204eec:	8b 50 04             	mov    0x4(%eax),%edx
c0204eef:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204ef2:	89 50 04             	mov    %edx,0x4(%eax)
			return target_page_no;
c0204ef5:	8b 45 08             	mov    0x8(%ebp),%eax
c0204ef8:	eb 32                	jmp    c0204f2c <.L117+0x96>
	for(; probe->next!=NULL;probe=probe->next){
c0204efa:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204efd:	8b 40 04             	mov    0x4(%eax),%eax
c0204f00:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0204f03:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f06:	8b 40 04             	mov    0x4(%eax),%eax
c0204f09:	85 c0                	test   %eax,%eax
c0204f0b:	75 cc                	jne    c0204ed9 <.L117+0x43>
		}
	}
	if(probe->page_no == target_page_no){
c0204f0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0204f10:	8b 00                	mov    (%eax),%eax
c0204f12:	39 45 08             	cmp    %eax,0x8(%ebp)
c0204f15:	75 10                	jne    c0204f27 <.L117+0x91>
		pop_block(ph);
c0204f17:	ff 75 0c             	pushl  0xc(%ebp)
c0204f1a:	e8 24 fb ff ff       	call   c0204a43 <pop_block>
c0204f1f:	83 c4 04             	add    $0x4,%esp
		return target_page_no;
c0204f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0204f25:	eb 05                	jmp    c0204f2c <.L117+0x96>
	}

	return ERRO_POP_BLOCK;
c0204f27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0204f2c:	c9                   	leave  
c0204f2d:	c3                   	ret    

c0204f2e <get_max_pm_addr>:

//从multi_boot结构体中取出需要管理的地址空间大小 
static uint32_t get_max_pm_addr(){          //qemu默认为128M
c0204f2e:	55                   	push   %ebp
c0204f2f:	89 e5                	mov    %esp,%ebp
c0204f31:	56                   	push   %esi
c0204f32:	53                   	push   %ebx
c0204f33:	83 ec 10             	sub    $0x10,%esp
c0204f36:	e8 c9 20 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0204f3b:	81 c3 c5 30 00 00    	add    $0x30c5,%ebx
	uint32_t max_addr=0;
c0204f41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204f48:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c0204f4e:	8b 00                	mov    (%eax),%eax
c0204f50:	8b 40 30             	mov    0x30(%eax),%eax
c0204f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0204f56:	eb 6a                	jmp    c0204fc2 <get_max_pm_addr+0x94>
		printk("0x%h-0x%h-0x%h-%d\n",pm_entry_cur->base_addr_low,pm_entry_cur->length_low,pm_entry_cur->base_addr_low+pm_entry_cur->length_low,pm_entry_cur->type);
c0204f58:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f5b:	8b 48 14             	mov    0x14(%eax),%ecx
c0204f5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f61:	8b 50 04             	mov    0x4(%eax),%edx
c0204f64:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f67:	8b 40 0c             	mov    0xc(%eax),%eax
c0204f6a:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0204f6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f70:	8b 50 0c             	mov    0xc(%eax),%edx
c0204f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f76:	8b 40 04             	mov    0x4(%eax),%eax
c0204f79:	83 ec 0c             	sub    $0xc,%esp
c0204f7c:	51                   	push   %ecx
c0204f7d:	56                   	push   %esi
c0204f7e:	52                   	push   %edx
c0204f7f:	50                   	push   %eax
c0204f80:	8d 83 e0 00 00 00    	lea    0xe0(%ebx),%eax
c0204f86:	50                   	push   %eax
c0204f87:	e8 ca e8 ff ff       	call   c0203856 <printk>
c0204f8c:	83 c4 20             	add    $0x20,%esp
		if(pm_entry_cur->type==1&&max_addr<pm_entry_cur->base_addr_low+pm_entry_cur->length_low)
c0204f8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f92:	8b 40 14             	mov    0x14(%eax),%eax
c0204f95:	83 f8 01             	cmp    $0x1,%eax
c0204f98:	75 24                	jne    c0204fbe <get_max_pm_addr+0x90>
c0204f9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204f9d:	8b 50 04             	mov    0x4(%eax),%edx
c0204fa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fa3:	8b 40 0c             	mov    0xc(%eax),%eax
c0204fa6:	01 d0                	add    %edx,%eax
c0204fa8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0204fab:	73 11                	jae    c0204fbe <get_max_pm_addr+0x90>
			max_addr=pm_entry_cur->base_addr_low+pm_entry_cur->length_low;		
c0204fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fb0:	8b 50 04             	mov    0x4(%eax),%edx
c0204fb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0204fb6:	8b 40 0c             	mov    0xc(%eax),%eax
c0204fb9:	01 d0                	add    %edx,%eax
c0204fbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(pm_entry_t * pm_entry_cur = mboot_ptr->mmap_addr;pm_entry_cur<mboot_ptr->mmap_addr+mboot_ptr->mmap_length;pm_entry_cur++){
c0204fbe:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
c0204fc2:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c0204fc8:	8b 00                	mov    (%eax),%eax
c0204fca:	8b 50 30             	mov    0x30(%eax),%edx
c0204fcd:	c7 c0 0c 70 20 c0    	mov    $0xc020700c,%eax
c0204fd3:	8b 00                	mov    (%eax),%eax
c0204fd5:	8b 40 2c             	mov    0x2c(%eax),%eax
c0204fd8:	01 d0                	add    %edx,%eax
c0204fda:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0204fdd:	0f 82 75 ff ff ff    	jb     c0204f58 <get_max_pm_addr+0x2a>
	}
	return max_addr;
c0204fe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0204fe6:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0204fe9:	5b                   	pop    %ebx
c0204fea:	5e                   	pop    %esi
c0204feb:	5d                   	pop    %ebp
c0204fec:	c3                   	ret    

c0204fed <pmm_page_init>:

//初始化页描述结构体以及装载链表
static void pmm_page_init(){  //初始化链表结构体并且填充链表
c0204fed:	55                   	push   %ebp
c0204fee:	89 e5                	mov    %esp,%ebp
c0204ff0:	53                   	push   %ebx
c0204ff1:	83 ec 14             	sub    $0x14,%esp
c0204ff4:	e8 0b 20 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0204ff9:	81 c3 07 30 00 00    	add    $0x3007,%ebx
	MULTI_LINK=&multi_link_struct;
c0204fff:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205005:	8d 93 a0 91 08 00    	lea    0x891a0(%ebx),%edx
c020500b:	89 10                	mov    %edx,(%eax)
	MULTI_LINK->_1=NULL;
c020500d:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205013:	8b 00                	mov    (%eax),%eax
c0205015:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	MULTI_LINK->_2=NULL;
c020501b:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205021:	8b 00                	mov    (%eax),%eax
c0205023:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	MULTI_LINK->_4=NULL;
c020502a:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205030:	8b 00                	mov    (%eax),%eax
c0205032:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	MULTI_LINK->_8=NULL;
c0205039:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020503f:	8b 00                	mov    (%eax),%eax
c0205041:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	MULTI_LINK->_16=NULL;
c0205048:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020504e:	8b 00                	mov    (%eax),%eax
c0205050:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	MULTI_LINK->_32=NULL;
c0205057:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020505d:	8b 00                	mov    (%eax),%eax
c020505f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	MULTI_LINK->_64=NULL;
c0205066:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020506c:	8b 00                	mov    (%eax),%eax
c020506e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	MULTI_LINK->_128=NULL;
c0205075:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020507b:	8b 00                	mov    (%eax),%eax
c020507d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	MULTI_LINK->_256=NULL;
c0205084:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020508a:	8b 00                	mov    (%eax),%eax
c020508c:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	MULTI_LINK->_512=NULL;
c0205093:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205099:	8b 00                	mov    (%eax),%eax
c020509b:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	MULTI_LINK->_1024=NULL;
c02050a2:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02050a8:	8b 00                	mov    (%eax),%eax
c02050aa:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	//我们将要余出至多1023页来作为单页分配的一个缓冲区 这个缓冲区是与伙伴算法独立的 便于快速分配单页
	for(int i=0;i<pmm_max_page_no;i++){
c02050b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c02050b8:	eb 51                	jmp    c020510b <pmm_page_init+0x11e>
		page_array[i].page_no = i;
c02050ba:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c02050c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02050c3:	89 d0                	mov    %edx,%eax
c02050c5:	01 c0                	add    %eax,%eax
c02050c7:	01 d0                	add    %edx,%eax
c02050c9:	c1 e0 02             	shl    $0x2,%eax
c02050cc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c02050cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02050d2:	89 02                	mov    %eax,(%edx)
		page_array[i].state = 1;
c02050d4:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c02050da:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02050dd:	89 d0                	mov    %edx,%eax
c02050df:	01 c0                	add    %eax,%eax
c02050e1:	01 d0                	add    %edx,%eax
c02050e3:	c1 e0 02             	shl    $0x2,%eax
c02050e6:	01 c8                	add    %ecx,%eax
c02050e8:	c6 40 08 01          	movb   $0x1,0x8(%eax)
		page_array[i].next = NULL;
c02050ec:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c02050f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02050f5:	89 d0                	mov    %edx,%eax
c02050f7:	01 c0                	add    %eax,%eax
c02050f9:	01 d0                	add    %edx,%eax
c02050fb:	c1 e0 02             	shl    $0x2,%eax
c02050fe:	01 c8                	add    %ecx,%eax
c0205100:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	for(int i=0;i<pmm_max_page_no;i++){
c0205107:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c020510b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020510e:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c0205114:	39 c2                	cmp    %eax,%edx
c0205116:	72 a2                	jb     c02050ba <pmm_page_init+0xcd>
	}
	//装载链表
	append_block(0,_1);    //1页链表
c0205118:	6a 00                	push   $0x0
c020511a:	6a 00                	push   $0x0
c020511c:	e8 dc f5 ff ff       	call   c02046fd <append_block>
c0205121:	83 c4 08             	add    $0x8,%esp
	append_block(1,_1);
c0205124:	6a 00                	push   $0x0
c0205126:	6a 01                	push   $0x1
c0205128:	e8 d0 f5 ff ff       	call   c02046fd <append_block>
c020512d:	83 c4 08             	add    $0x8,%esp

	append_block(2,_2);    //2页链表
c0205130:	6a 01                	push   $0x1
c0205132:	6a 02                	push   $0x2
c0205134:	e8 c4 f5 ff ff       	call   c02046fd <append_block>
c0205139:	83 c4 08             	add    $0x8,%esp

	append_block(4,_4);
c020513c:	6a 02                	push   $0x2
c020513e:	6a 04                	push   $0x4
c0205140:	e8 b8 f5 ff ff       	call   c02046fd <append_block>
c0205145:	83 c4 08             	add    $0x8,%esp

	append_block(8,_8);
c0205148:	6a 03                	push   $0x3
c020514a:	6a 08                	push   $0x8
c020514c:	e8 ac f5 ff ff       	call   c02046fd <append_block>
c0205151:	83 c4 08             	add    $0x8,%esp

	append_block(16,_16);
c0205154:	6a 04                	push   $0x4
c0205156:	6a 10                	push   $0x10
c0205158:	e8 a0 f5 ff ff       	call   c02046fd <append_block>
c020515d:	83 c4 08             	add    $0x8,%esp

	append_block(32,_32);
c0205160:	6a 05                	push   $0x5
c0205162:	6a 20                	push   $0x20
c0205164:	e8 94 f5 ff ff       	call   c02046fd <append_block>
c0205169:	83 c4 08             	add    $0x8,%esp

	append_block(64,_64);
c020516c:	6a 06                	push   $0x6
c020516e:	6a 40                	push   $0x40
c0205170:	e8 88 f5 ff ff       	call   c02046fd <append_block>
c0205175:	83 c4 08             	add    $0x8,%esp

	append_block(128,_128);
c0205178:	6a 07                	push   $0x7
c020517a:	68 80 00 00 00       	push   $0x80
c020517f:	e8 79 f5 ff ff       	call   c02046fd <append_block>
c0205184:	83 c4 08             	add    $0x8,%esp

	append_block(256,_256);
c0205187:	6a 08                	push   $0x8
c0205189:	68 00 01 00 00       	push   $0x100
c020518e:	e8 6a f5 ff ff       	call   c02046fd <append_block>
c0205193:	83 c4 08             	add    $0x8,%esp

	append_block(512,_512);
c0205196:	6a 09                	push   $0x9
c0205198:	68 00 02 00 00       	push   $0x200
c020519d:	e8 5b f5 ff ff       	call   c02046fd <append_block>
c02051a2:	83 c4 08             	add    $0x8,%esp

	append_block(1024,_1024);
c02051a5:	6a 0a                	push   $0xa
c02051a7:	68 00 04 00 00       	push   $0x400
c02051ac:	e8 4c f5 ff ff       	call   c02046fd <append_block>
c02051b1:	83 c4 08             	add    $0x8,%esp


	int temp_page_no=2048;
c02051b4:	c7 45 f0 00 08 00 00 	movl   $0x800,-0x10(%ebp)
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c02051bb:	eb 14                	jmp    c02051d1 <pmm_page_init+0x1e4>
		append_block(temp_page_no,_1024);
c02051bd:	6a 0a                	push   $0xa
c02051bf:	ff 75 f0             	pushl  -0x10(%ebp)
c02051c2:	e8 36 f5 ff ff       	call   c02046fd <append_block>
c02051c7:	83 c4 08             	add    $0x8,%esp
	for(;temp_page_no<(pmm_max_page_no-1024);temp_page_no+=1024){
c02051ca:	81 45 f0 00 04 00 00 	addl   $0x400,-0x10(%ebp)
c02051d1:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c02051d7:	8d 90 00 fc ff ff    	lea    -0x400(%eax),%edx
c02051dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02051e0:	39 c2                	cmp    %eax,%edx
c02051e2:	77 d9                	ja     c02051bd <pmm_page_init+0x1d0>
	}
	singel_page_first_no = temp_page_no;   //将第一个单页缓冲区的编号存放好
c02051e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02051e7:	89 83 dc 91 08 00    	mov    %eax,0x891dc(%ebx)

	printk("we have %d pages for singel page alloc!\n",pmm_max_page_no-temp_page_no);
c02051ed:	8b 93 d8 91 08 00    	mov    0x891d8(%ebx),%edx
c02051f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02051f6:	29 c2                	sub    %eax,%edx
c02051f8:	89 d0                	mov    %edx,%eax
c02051fa:	83 ec 08             	sub    $0x8,%esp
c02051fd:	50                   	push   %eax
c02051fe:	8d 83 f4 00 00 00    	lea    0xf4(%ebx),%eax
c0205204:	50                   	push   %eax
c0205205:	e8 4c e6 ff ff       	call   c0203856 <printk>
c020520a:	83 c4 10             	add    $0x10,%esp
	pm_page_t * temp_single_probe = NULL;
c020520d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c0205214:	eb 57                	jmp    c020526d <pmm_page_init+0x280>
		if(SINGLE_LINK == NULL){
c0205216:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c020521c:	85 c0                	test   %eax,%eax
c020521e:	75 25                	jne    c0205245 <pmm_page_init+0x258>
			SINGLE_LINK=&(page_array[temp_page_no]);
c0205220:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c0205226:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205229:	89 d0                	mov    %edx,%eax
c020522b:	01 c0                	add    %eax,%eax
c020522d:	01 d0                	add    %edx,%eax
c020522f:	c1 e0 02             	shl    $0x2,%eax
c0205232:	01 c8                	add    %ecx,%eax
c0205234:	89 83 cc 91 08 00    	mov    %eax,0x891cc(%ebx)
			temp_single_probe = SINGLE_LINK ;
c020523a:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205240:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0205243:	eb 24                	jmp    c0205269 <pmm_page_init+0x27c>
		}
		else{
			temp_single_probe->next = &(page_array[temp_page_no]);
c0205245:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c020524b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c020524e:	89 d0                	mov    %edx,%eax
c0205250:	01 c0                	add    %eax,%eax
c0205252:	01 d0                	add    %edx,%eax
c0205254:	c1 e0 02             	shl    $0x2,%eax
c0205257:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c020525a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020525d:	89 50 04             	mov    %edx,0x4(%eax)
			temp_single_probe = temp_single_probe -> next;
c0205260:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0205263:	8b 40 04             	mov    0x4(%eax),%eax
c0205266:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for(;temp_page_no<pmm_max_page_no;temp_page_no++){
c0205269:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c020526d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205270:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c0205276:	39 c2                	cmp    %eax,%edx
c0205278:	72 9c                	jb     c0205216 <pmm_page_init+0x229>
		}
	}
}
c020527a:	90                   	nop
c020527b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020527e:	c9                   	leave  
c020527f:	c3                   	ret    

c0205280 <alloc_helper>:





static uint32_t alloc_helper(page_c_t target_ph,page_c_t pop_ph,uint32_t pop_page_no){
c0205280:	55                   	push   %ebp
c0205281:	89 e5                	mov    %esp,%ebp
c0205283:	83 ec 10             	sub    $0x10,%esp
c0205286:	e8 75 1d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020528b:	05 75 2d 00 00       	add    $0x2d75,%eax
	for(;pop_ph!=target_ph;pop_ph--){
c0205290:	eb 2e                	jmp    c02052c0 <alloc_helper+0x40>
		uint32_t append_page_no = pop_page_no+(c_to_uint32(pop_ph)/2);
c0205292:	ff 75 0c             	pushl  0xc(%ebp)
c0205295:	e8 f3 f3 ff ff       	call   c020468d <c_to_uint32>
c020529a:	83 c4 04             	add    $0x4,%esp
c020529d:	d1 e8                	shr    %eax
c020529f:	89 c2                	mov    %eax,%edx
c02052a1:	8b 45 10             	mov    0x10(%ebp),%eax
c02052a4:	01 d0                	add    %edx,%eax
c02052a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
		append_block(append_page_no,pop_page_no-1);
c02052a9:	8b 45 10             	mov    0x10(%ebp),%eax
c02052ac:	8d 50 ff             	lea    -0x1(%eax),%edx
c02052af:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02052b2:	52                   	push   %edx
c02052b3:	50                   	push   %eax
c02052b4:	e8 44 f4 ff ff       	call   c02046fd <append_block>
c02052b9:	83 c4 08             	add    $0x8,%esp
	for(;pop_ph!=target_ph;pop_ph--){
c02052bc:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c02052c0:	8b 45 0c             	mov    0xc(%ebp),%eax
c02052c3:	3b 45 08             	cmp    0x8(%ebp),%eax
c02052c6:	75 ca                	jne    c0205292 <alloc_helper+0x12>
	}
	return pop_page_no;
c02052c8:	8b 45 10             	mov    0x10(%ebp),%eax
}
c02052cb:	c9                   	leave  
c02052cc:	c3                   	ret    

c02052cd <pmm_alloc_pages>:



//伙伴算法多页分配
pm_alloc_t pmm_alloc_pages(uint32_t page_count){
c02052cd:	55                   	push   %ebp
c02052ce:	89 e5                	mov    %esp,%ebp
c02052d0:	83 ec 30             	sub    $0x30,%esp
c02052d3:	e8 28 1d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02052d8:	05 28 2d 00 00       	add    $0x2d28,%eax
	pm_alloc_t return_struct = {0,_erro,0}; 
c02052dd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
c02052e4:	c7 45 dc 0b 00 00 00 	movl   $0xb,-0x24(%ebp)
c02052eb:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
	if (page_count>1024||page_count==0)
c02052ef:	81 7d 0c 00 04 00 00 	cmpl   $0x400,0xc(%ebp)
c02052f6:	77 06                	ja     c02052fe <pmm_alloc_pages+0x31>
c02052f8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c02052fc:	75 19                	jne    c0205317 <pmm_alloc_pages+0x4a>
		return return_struct;    //分配失败
c02052fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0205301:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0205304:	89 10                	mov    %edx,(%eax)
c0205306:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0205309:	89 50 04             	mov    %edx,0x4(%eax)
c020530c:	8b 55 e0             	mov    -0x20(%ebp),%edx
c020530f:	89 50 08             	mov    %edx,0x8(%eax)
c0205312:	e9 ce 00 00 00       	jmp    c02053e5 <pmm_alloc_pages+0x118>
	//来点骚操作
	//获取需要分配的页数
	uint32_t page_count_probe=page_count;
c0205317:	8b 45 0c             	mov    0xc(%ebp),%eax
c020531a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter1 = 0;
c020531d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;page_count_probe!=0 ;counter1++,page_count_probe=page_count_probe>>1)
c0205324:	eb 07                	jmp    c020532d <pmm_alloc_pages+0x60>
c0205326:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c020532a:	d1 6d fc             	shrl   -0x4(%ebp)
c020532d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0205331:	75 f3                	jne    c0205326 <pmm_alloc_pages+0x59>
		;
	uint32_t counter2= counter1-1;
c0205333:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205336:	83 e8 01             	sub    $0x1,%eax
c0205339:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(page_count==(1<<counter2))
c020533c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c020533f:	ba 01 00 00 00       	mov    $0x1,%edx
c0205344:	89 c1                	mov    %eax,%ecx
c0205346:	d3 e2                	shl    %cl,%edx
c0205348:	89 d0                	mov    %edx,%eax
c020534a:	39 45 0c             	cmp    %eax,0xc(%ebp)
c020534d:	75 04                	jne    c0205353 <pmm_alloc_pages+0x86>
		counter1--;
c020534f:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
	//此时的counter1即为pm_c_t枚举的对应值
	page_c_t ph = counter1;
c0205353:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205356:	89 45 f4             	mov    %eax,-0xc(%ebp)
	page_c_t origin_ph = ph;    //存放原始ph
c0205359:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020535c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pop_page_no = ERRO_POP_BLOCK;
c020535f:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
	for(;ph<_erro;ph++){
c0205366:	eb 18                	jmp    c0205380 <pmm_alloc_pages+0xb3>
		pop_page_no = pop_block(ph);
c0205368:	ff 75 f4             	pushl  -0xc(%ebp)
c020536b:	e8 d3 f6 ff ff       	call   c0204a43 <pop_block>
c0205370:	83 c4 04             	add    $0x4,%esp
c0205373:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(pop_page_no!=ERRO_POP_BLOCK)
c0205376:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c020537a:	75 0c                	jne    c0205388 <pmm_alloc_pages+0xbb>
	for(;ph<_erro;ph++){
c020537c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0205380:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
c0205384:	76 e2                	jbe    c0205368 <pmm_alloc_pages+0x9b>
c0205386:	eb 01                	jmp    c0205389 <pmm_alloc_pages+0xbc>
			break;
c0205388:	90                   	nop
	}
	if(pop_page_no==ERRO_POP_BLOCK){
c0205389:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c020538d:	75 16                	jne    c02053a5 <pmm_alloc_pages+0xd8>
		return return_struct;    //分配失败
c020538f:	8b 45 08             	mov    0x8(%ebp),%eax
c0205392:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0205395:	89 10                	mov    %edx,(%eax)
c0205397:	8b 55 dc             	mov    -0x24(%ebp),%edx
c020539a:	89 50 04             	mov    %edx,0x4(%eax)
c020539d:	8b 55 e0             	mov    -0x20(%ebp),%edx
c02053a0:	89 50 08             	mov    %edx,0x8(%eax)
c02053a3:	eb 40                	jmp    c02053e5 <pmm_alloc_pages+0x118>
	}
	else{
		uint32_t target_page_no = alloc_helper(origin_ph,ph,pop_page_no);
c02053a5:	ff 75 f0             	pushl  -0x10(%ebp)
c02053a8:	ff 75 f4             	pushl  -0xc(%ebp)
c02053ab:	ff 75 e8             	pushl  -0x18(%ebp)
c02053ae:	e8 cd fe ff ff       	call   c0205280 <alloc_helper>
c02053b3:	83 c4 0c             	add    $0xc,%esp
c02053b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		return_struct.addr = pmm_page_no_to_addr(target_page_no);
c02053b9:	ff 75 e4             	pushl  -0x1c(%ebp)
c02053bc:	e8 90 f2 ff ff       	call   c0204651 <pmm_page_no_to_addr>
c02053c1:	83 c4 04             	add    $0x4,%esp
c02053c4:	89 45 d8             	mov    %eax,-0x28(%ebp)
		return_struct.state = 1;
c02053c7:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
		return_struct.size = origin_ph;
c02053cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c02053ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
		return return_struct;
c02053d1:	8b 45 08             	mov    0x8(%ebp),%eax
c02053d4:	8b 55 d8             	mov    -0x28(%ebp),%edx
c02053d7:	89 10                	mov    %edx,(%eax)
c02053d9:	8b 55 dc             	mov    -0x24(%ebp),%edx
c02053dc:	89 50 04             	mov    %edx,0x4(%eax)
c02053df:	8b 55 e0             	mov    -0x20(%ebp),%edx
c02053e2:	89 50 08             	mov    %edx,0x8(%eax)
	}
}
c02053e5:	8b 45 08             	mov    0x8(%ebp),%eax
c02053e8:	c9                   	leave  
c02053e9:	c2 04 00             	ret    $0x4

c02053ec <pmm_alloc_one_page>:

//缓冲区及伙伴算法单页分配
//当缓冲区没有页的时候会调用伙伴算法分配一页
pm_alloc_t pmm_alloc_one_page(){
c02053ec:	55                   	push   %ebp
c02053ed:	89 e5                	mov    %esp,%ebp
c02053ef:	83 ec 20             	sub    $0x20,%esp
c02053f2:	e8 09 1c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02053f7:	05 09 2c 00 00       	add    $0x2c09,%eax
	pm_alloc_t return_struct = {0,_erro,0};
c02053fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0205403:	c7 45 f0 0b 00 00 00 	movl   $0xb,-0x10(%ebp)
c020540a:	c6 45 f4 00          	movb   $0x0,-0xc(%ebp)
	if(SINGLE_LINK!=NULL){
c020540e:	8b 90 cc 91 08 00    	mov    0x891cc(%eax),%edx
c0205414:	85 d2                	test   %edx,%edx
c0205416:	0f 84 ac 00 00 00    	je     c02054c8 <pmm_alloc_one_page+0xdc>
		pm_page_t * header = SINGLE_LINK;
c020541c:	8b 90 cc 91 08 00    	mov    0x891cc(%eax),%edx
c0205422:	89 55 f8             	mov    %edx,-0x8(%ebp)
		if(header->next==NULL){
c0205425:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0205428:	8b 52 04             	mov    0x4(%edx),%edx
c020542b:	85 d2                	test   %edx,%edx
c020542d:	75 3c                	jne    c020546b <pmm_alloc_one_page+0x7f>
			SINGLE_LINK = NULL;
c020542f:	c7 80 cc 91 08 00 00 	movl   $0x0,0x891cc(%eax)
c0205436:	00 00 00 
			return_struct.state = 1;
c0205439:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c020543d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(header->page_no);
c0205444:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0205447:	8b 00                	mov    (%eax),%eax
c0205449:	50                   	push   %eax
c020544a:	e8 02 f2 ff ff       	call   c0204651 <pmm_page_no_to_addr>
c020544f:	83 c4 04             	add    $0x4,%esp
c0205452:	89 45 ec             	mov    %eax,-0x14(%ebp)
			return return_struct;
c0205455:	8b 45 08             	mov    0x8(%ebp),%eax
c0205458:	8b 55 ec             	mov    -0x14(%ebp),%edx
c020545b:	89 10                	mov    %edx,(%eax)
c020545d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205460:	89 50 04             	mov    %edx,0x4(%eax)
c0205463:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0205466:	89 50 08             	mov    %edx,0x8(%eax)
c0205469:	eb 6b                	jmp    c02054d6 <pmm_alloc_one_page+0xea>
		}
		else{
			pm_page_t * probe = header;
c020546b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020546e:	89 45 fc             	mov    %eax,-0x4(%ebp)
			for(;probe->next->next!=NULL;probe=probe->next){
c0205471:	eb 09                	jmp    c020547c <pmm_alloc_one_page+0x90>
c0205473:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205476:	8b 40 04             	mov    0x4(%eax),%eax
c0205479:	89 45 fc             	mov    %eax,-0x4(%ebp)
c020547c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020547f:	8b 40 04             	mov    0x4(%eax),%eax
c0205482:	8b 40 04             	mov    0x4(%eax),%eax
c0205485:	85 c0                	test   %eax,%eax
c0205487:	75 ea                	jne    c0205473 <pmm_alloc_one_page+0x87>
				//printk("%d\n",probe->page_no);
				//if(probe->page_no==0){
				//	while(1);
				//}
			}
			return_struct.state = 1;
c0205489:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
			return_struct.size = _1;
c020548d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			return_struct.addr =pmm_page_no_to_addr(probe->next->page_no);
c0205494:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0205497:	8b 40 04             	mov    0x4(%eax),%eax
c020549a:	8b 00                	mov    (%eax),%eax
c020549c:	50                   	push   %eax
c020549d:	e8 af f1 ff ff       	call   c0204651 <pmm_page_no_to_addr>
c02054a2:	83 c4 04             	add    $0x4,%esp
c02054a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
			probe->next = NULL;
c02054a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02054ab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		}
		return return_struct;
c02054b2:	8b 45 08             	mov    0x8(%ebp),%eax
c02054b5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c02054b8:	89 10                	mov    %edx,(%eax)
c02054ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02054bd:	89 50 04             	mov    %edx,0x4(%eax)
c02054c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02054c3:	89 50 08             	mov    %edx,0x8(%eax)
c02054c6:	eb 0e                	jmp    c02054d6 <pmm_alloc_one_page+0xea>
	}
	else{
		return pmm_alloc_pages(1);
c02054c8:	8b 45 08             	mov    0x8(%ebp),%eax
c02054cb:	6a 01                	push   $0x1
c02054cd:	50                   	push   %eax
c02054ce:	e8 fa fd ff ff       	call   c02052cd <pmm_alloc_pages>
c02054d3:	83 c4 04             	add    $0x4,%esp
	}
}
c02054d6:	8b 45 08             	mov    0x8(%ebp),%eax
c02054d9:	c9                   	leave  
c02054da:	c2 04 00             	ret    $0x4

c02054dd <free_helper>:

static void free_helper(uint32_t page_no,page_c_t size){
c02054dd:	55                   	push   %ebp
c02054de:	89 e5                	mov    %esp,%ebp
c02054e0:	53                   	push   %ebx
c02054e1:	83 ec 14             	sub    $0x14,%esp
c02054e4:	e8 1b 1b 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02054e9:	81 c3 17 2b 00 00    	add    $0x2b17,%ebx
	printk("free size : %d\n",c_to_uint32(size));
c02054ef:	ff 75 0c             	pushl  0xc(%ebp)
c02054f2:	e8 96 f1 ff ff       	call   c020468d <c_to_uint32>
c02054f7:	83 c4 04             	add    $0x4,%esp
c02054fa:	83 ec 08             	sub    $0x8,%esp
c02054fd:	50                   	push   %eax
c02054fe:	8d 83 1d 01 00 00    	lea    0x11d(%ebx),%eax
c0205504:	50                   	push   %eax
c0205505:	e8 4c e3 ff ff       	call   c0203856 <printk>
c020550a:	83 c4 10             	add    $0x10,%esp
	uint32_t partner_page_no = get_partner_page_no(page_no,size);
c020550d:	83 ec 08             	sub    $0x8,%esp
c0205510:	ff 75 0c             	pushl  0xc(%ebp)
c0205513:	ff 75 08             	pushl  0x8(%ebp)
c0205516:	e8 96 f1 ff ff       	call   c02046b1 <get_partner_page_no>
c020551b:	83 c4 10             	add    $0x10,%esp
c020551e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(find_and_pop_block(partner_page_no,size)!=ERRO_POP_BLOCK){
c0205521:	83 ec 08             	sub    $0x8,%esp
c0205524:	ff 75 0c             	pushl  0xc(%ebp)
c0205527:	ff 75 f4             	pushl  -0xc(%ebp)
c020552a:	e8 84 f8 ff ff       	call   c0204db3 <find_and_pop_block>
c020552f:	83 c4 10             	add    $0x10,%esp
c0205532:	83 f8 ff             	cmp    $0xffffffff,%eax
c0205535:	74 1f                	je     c0205556 <free_helper+0x79>
		//合并
		free_helper(partner_page_no<page_no?partner_page_no:page_no,size+1);
c0205537:	8b 45 0c             	mov    0xc(%ebp),%eax
c020553a:	8d 50 01             	lea    0x1(%eax),%edx
c020553d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205540:	39 45 08             	cmp    %eax,0x8(%ebp)
c0205543:	0f 46 45 08          	cmovbe 0x8(%ebp),%eax
c0205547:	83 ec 08             	sub    $0x8,%esp
c020554a:	52                   	push   %edx
c020554b:	50                   	push   %eax
c020554c:	e8 8c ff ff ff       	call   c02054dd <free_helper>
c0205551:	83 c4 10             	add    $0x10,%esp
	}
	else{
		append_block(page_no,size);
	}
}
c0205554:	eb 12                	jmp    c0205568 <free_helper+0x8b>
		append_block(page_no,size);
c0205556:	8b 45 08             	mov    0x8(%ebp),%eax
c0205559:	83 ec 08             	sub    $0x8,%esp
c020555c:	ff 75 0c             	pushl  0xc(%ebp)
c020555f:	50                   	push   %eax
c0205560:	e8 98 f1 ff ff       	call   c02046fd <append_block>
c0205565:	83 c4 10             	add    $0x10,%esp
}
c0205568:	90                   	nop
c0205569:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020556c:	c9                   	leave  
c020556d:	c3                   	ret    

c020556e <pmm_free_page>:

//free页 返回bool型（定义在typs.h中） True-成功free False-失败
bool pmm_free_page(pm_alloc_t block_disc){
c020556e:	55                   	push   %ebp
c020556f:	89 e5                	mov    %esp,%ebp
c0205571:	53                   	push   %ebx
c0205572:	83 ec 14             	sub    $0x14,%esp
c0205575:	e8 8a 1a 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020557a:	81 c3 86 2a 00 00    	add    $0x2a86,%ebx
	//检查页是否在页编号范围内
	uint32_t page_no = addr_to_pmm_page_no(block_disc.addr);
c0205580:	8b 45 08             	mov    0x8(%ebp),%eax
c0205583:	50                   	push   %eax
c0205584:	e8 e5 f0 ff ff       	call   c020466e <addr_to_pmm_page_no>
c0205589:	83 c4 04             	add    $0x4,%esp
c020558c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(page_no<pmm_max_page_no){
c020558f:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c0205595:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0205598:	73 7f                	jae    c0205619 <pmm_free_page+0xab>
		if(page_no<singel_page_first_no)
c020559a:	8b 83 dc 91 08 00    	mov    0x891dc(%ebx),%eax
c02055a0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c02055a3:	73 14                	jae    c02055b9 <pmm_free_page+0x4b>
			free_helper(page_no,block_disc.size);
c02055a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c02055a8:	83 ec 08             	sub    $0x8,%esp
c02055ab:	50                   	push   %eax
c02055ac:	ff 75 f0             	pushl  -0x10(%ebp)
c02055af:	e8 29 ff ff ff       	call   c02054dd <free_helper>
c02055b4:	83 c4 10             	add    $0x10,%esp
c02055b7:	eb 59                	jmp    c0205612 <pmm_free_page+0xa4>
		else{
			pm_page_t *probe = SINGLE_LINK;
c02055b9:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c02055bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if(probe==NULL){
c02055c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c02055c6:	75 25                	jne    c02055ed <pmm_free_page+0x7f>
				SINGLE_LINK=&page_array[page_no];
c02055c8:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c02055ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02055d1:	89 d0                	mov    %edx,%eax
c02055d3:	01 c0                	add    %eax,%eax
c02055d5:	01 d0                	add    %edx,%eax
c02055d7:	c1 e0 02             	shl    $0x2,%eax
c02055da:	01 c8                	add    %ecx,%eax
c02055dc:	89 83 cc 91 08 00    	mov    %eax,0x891cc(%ebx)
c02055e2:	eb 2e                	jmp    c0205612 <pmm_free_page+0xa4>
			}
			else{
				for(;probe->next!=NULL;probe=probe->next)
c02055e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02055e7:	8b 40 04             	mov    0x4(%eax),%eax
c02055ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
c02055ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02055f0:	8b 40 04             	mov    0x4(%eax),%eax
c02055f3:	85 c0                	test   %eax,%eax
c02055f5:	75 ed                	jne    c02055e4 <pmm_free_page+0x76>
					;
				probe->next = &page_array[page_no];
c02055f7:	8b 8b 24 f0 ff ff    	mov    -0xfdc(%ebx),%ecx
c02055fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0205600:	89 d0                	mov    %edx,%eax
c0205602:	01 c0                	add    %eax,%eax
c0205604:	01 d0                	add    %edx,%eax
c0205606:	c1 e0 02             	shl    $0x2,%eax
c0205609:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c020560c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c020560f:	89 50 04             	mov    %edx,0x4(%eax)
			}
		}
		return True;
c0205612:	b8 01 00 00 00       	mov    $0x1,%eax
c0205617:	eb 05                	jmp    c020561e <pmm_free_page+0xb0>
	}
	else
		return False;
c0205619:	b8 00 00 00 00       	mov    $0x0,%eax
}
c020561e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205621:	c9                   	leave  
c0205622:	c3                   	ret    

c0205623 <counte_helper>:

static uint32_t counte_helper(pm_page_t * probe){
c0205623:	55                   	push   %ebp
c0205624:	89 e5                	mov    %esp,%ebp
c0205626:	83 ec 10             	sub    $0x10,%esp
c0205629:	e8 d2 19 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c020562e:	05 d2 29 00 00       	add    $0x29d2,%eax
	uint32_t counter = 0;
c0205633:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c020563a:	eb 0d                	jmp    c0205649 <counte_helper+0x26>
		counter++;
c020563c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
	for(;probe!=NULL;probe = probe->next)
c0205640:	8b 45 08             	mov    0x8(%ebp),%eax
c0205643:	8b 40 04             	mov    0x4(%eax),%eax
c0205646:	89 45 08             	mov    %eax,0x8(%ebp)
c0205649:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c020564d:	75 ed                	jne    c020563c <counte_helper+0x19>
	return counter;
c020564f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0205652:	c9                   	leave  
c0205653:	c3                   	ret    

c0205654 <get_block_count>:

uint32_t * get_block_count(){
c0205654:	55                   	push   %ebp
c0205655:	89 e5                	mov    %esp,%ebp
c0205657:	53                   	push   %ebx
c0205658:	e8 a7 19 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020565d:	81 c3 a3 29 00 00    	add    $0x29a3,%ebx
	block_count_array[_1]=counte_helper(MULTI_LINK->_1);
c0205663:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205669:	8b 00                	mov    (%eax),%eax
c020566b:	8b 00                	mov    (%eax),%eax
c020566d:	50                   	push   %eax
c020566e:	e8 b0 ff ff ff       	call   c0205623 <counte_helper>
c0205673:	83 c4 04             	add    $0x4,%esp
c0205676:	89 83 60 91 08 00    	mov    %eax,0x89160(%ebx)
	block_count_array[_2]=counte_helper(MULTI_LINK->_2);
c020567c:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205682:	8b 00                	mov    (%eax),%eax
c0205684:	8b 40 04             	mov    0x4(%eax),%eax
c0205687:	50                   	push   %eax
c0205688:	e8 96 ff ff ff       	call   c0205623 <counte_helper>
c020568d:	83 c4 04             	add    $0x4,%esp
c0205690:	89 83 64 91 08 00    	mov    %eax,0x89164(%ebx)
	block_count_array[_4]=counte_helper(MULTI_LINK->_4);
c0205696:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020569c:	8b 00                	mov    (%eax),%eax
c020569e:	8b 40 08             	mov    0x8(%eax),%eax
c02056a1:	50                   	push   %eax
c02056a2:	e8 7c ff ff ff       	call   c0205623 <counte_helper>
c02056a7:	83 c4 04             	add    $0x4,%esp
c02056aa:	89 83 68 91 08 00    	mov    %eax,0x89168(%ebx)
	block_count_array[_8]=counte_helper(MULTI_LINK->_8);
c02056b0:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056b6:	8b 00                	mov    (%eax),%eax
c02056b8:	8b 40 0c             	mov    0xc(%eax),%eax
c02056bb:	50                   	push   %eax
c02056bc:	e8 62 ff ff ff       	call   c0205623 <counte_helper>
c02056c1:	83 c4 04             	add    $0x4,%esp
c02056c4:	89 83 6c 91 08 00    	mov    %eax,0x8916c(%ebx)
	block_count_array[_16]=counte_helper(MULTI_LINK->_16);
c02056ca:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056d0:	8b 00                	mov    (%eax),%eax
c02056d2:	8b 40 10             	mov    0x10(%eax),%eax
c02056d5:	50                   	push   %eax
c02056d6:	e8 48 ff ff ff       	call   c0205623 <counte_helper>
c02056db:	83 c4 04             	add    $0x4,%esp
c02056de:	89 83 70 91 08 00    	mov    %eax,0x89170(%ebx)
	block_count_array[_32]=counte_helper(MULTI_LINK->_32);
c02056e4:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c02056ea:	8b 00                	mov    (%eax),%eax
c02056ec:	8b 40 14             	mov    0x14(%eax),%eax
c02056ef:	50                   	push   %eax
c02056f0:	e8 2e ff ff ff       	call   c0205623 <counte_helper>
c02056f5:	83 c4 04             	add    $0x4,%esp
c02056f8:	89 83 74 91 08 00    	mov    %eax,0x89174(%ebx)
	block_count_array[_64]=counte_helper(MULTI_LINK->_64);
c02056fe:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205704:	8b 00                	mov    (%eax),%eax
c0205706:	8b 40 18             	mov    0x18(%eax),%eax
c0205709:	50                   	push   %eax
c020570a:	e8 14 ff ff ff       	call   c0205623 <counte_helper>
c020570f:	83 c4 04             	add    $0x4,%esp
c0205712:	89 83 78 91 08 00    	mov    %eax,0x89178(%ebx)
	block_count_array[_128]=counte_helper(MULTI_LINK->_128);
c0205718:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020571e:	8b 00                	mov    (%eax),%eax
c0205720:	8b 40 1c             	mov    0x1c(%eax),%eax
c0205723:	50                   	push   %eax
c0205724:	e8 fa fe ff ff       	call   c0205623 <counte_helper>
c0205729:	83 c4 04             	add    $0x4,%esp
c020572c:	89 83 7c 91 08 00    	mov    %eax,0x8917c(%ebx)
	block_count_array[_256]=counte_helper(MULTI_LINK->_256);
c0205732:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205738:	8b 00                	mov    (%eax),%eax
c020573a:	8b 40 20             	mov    0x20(%eax),%eax
c020573d:	50                   	push   %eax
c020573e:	e8 e0 fe ff ff       	call   c0205623 <counte_helper>
c0205743:	83 c4 04             	add    $0x4,%esp
c0205746:	89 83 80 91 08 00    	mov    %eax,0x89180(%ebx)
	block_count_array[_512]=counte_helper(MULTI_LINK->_512);
c020574c:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c0205752:	8b 00                	mov    (%eax),%eax
c0205754:	8b 40 24             	mov    0x24(%eax),%eax
c0205757:	50                   	push   %eax
c0205758:	e8 c6 fe ff ff       	call   c0205623 <counte_helper>
c020575d:	83 c4 04             	add    $0x4,%esp
c0205760:	89 83 84 91 08 00    	mov    %eax,0x89184(%ebx)
	block_count_array[_1024]=counte_helper(MULTI_LINK->_1024);
c0205766:	c7 c0 00 20 29 c0    	mov    $0xc0292000,%eax
c020576c:	8b 00                	mov    (%eax),%eax
c020576e:	8b 40 28             	mov    0x28(%eax),%eax
c0205771:	50                   	push   %eax
c0205772:	e8 ac fe ff ff       	call   c0205623 <counte_helper>
c0205777:	83 c4 04             	add    $0x4,%esp
c020577a:	89 83 88 91 08 00    	mov    %eax,0x89188(%ebx)
	block_count_array[_erro]=0;
c0205780:	c7 83 8c 91 08 00 00 	movl   $0x0,0x8918c(%ebx)
c0205787:	00 00 00 
	return block_count_array;
c020578a:	8d 83 60 91 08 00    	lea    0x89160(%ebx),%eax
}
c0205790:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205793:	c9                   	leave  
c0205794:	c3                   	ret    

c0205795 <get_single_count>:

uint32_t get_single_count(){
c0205795:	55                   	push   %ebp
c0205796:	89 e5                	mov    %esp,%ebp
c0205798:	83 ec 10             	sub    $0x10,%esp
c020579b:	e8 60 18 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02057a0:	05 60 28 00 00       	add    $0x2860,%eax
	pm_page_t * probe =SINGLE_LINK;
c02057a5:	8b 80 cc 91 08 00    	mov    0x891cc(%eax),%eax
c02057ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t counter = 0;
c02057ae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02057b5:	eb 0d                	jmp    c02057c4 <get_single_count+0x2f>
		counter++;
c02057b7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(;probe!=NULL;probe = probe->next)
c02057bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02057be:	8b 40 04             	mov    0x4(%eax),%eax
c02057c1:	89 45 fc             	mov    %eax,-0x4(%ebp)
c02057c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c02057c8:	75 ed                	jne    c02057b7 <get_single_count+0x22>
	return counter;	
c02057ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c02057cd:	c9                   	leave  
c02057ce:	c3                   	ret    

c02057cf <pmm_show_page_count>:

//打印块使用情况的函数 
//懒得挨个写 用宏来解决
// #表示字符串化 ##表示连接生成符号操作
#define MACRO_PMM_1(number) printk("_"#number":%d blocks\n",block_count_array[_##number])
void pmm_show_page_count(){
c02057cf:	55                   	push   %ebp
c02057d0:	89 e5                	mov    %esp,%ebp
c02057d2:	53                   	push   %ebx
c02057d3:	83 ec 04             	sub    $0x4,%esp
c02057d6:	e8 29 18 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02057db:	81 c3 25 28 00 00    	add    $0x2825,%ebx
	get_block_count();
c02057e1:	e8 6e fe ff ff       	call   c0205654 <get_block_count>
	printk("Partner:\n");
c02057e6:	83 ec 0c             	sub    $0xc,%esp
c02057e9:	8d 83 2d 01 00 00    	lea    0x12d(%ebx),%eax
c02057ef:	50                   	push   %eax
c02057f0:	e8 61 e0 ff ff       	call   c0203856 <printk>
c02057f5:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1);
c02057f8:	8b 83 60 91 08 00    	mov    0x89160(%ebx),%eax
c02057fe:	83 ec 08             	sub    $0x8,%esp
c0205801:	50                   	push   %eax
c0205802:	8d 83 37 01 00 00    	lea    0x137(%ebx),%eax
c0205808:	50                   	push   %eax
c0205809:	e8 48 e0 ff ff       	call   c0203856 <printk>
c020580e:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(2);
c0205811:	8b 83 64 91 08 00    	mov    0x89164(%ebx),%eax
c0205817:	83 ec 08             	sub    $0x8,%esp
c020581a:	50                   	push   %eax
c020581b:	8d 83 45 01 00 00    	lea    0x145(%ebx),%eax
c0205821:	50                   	push   %eax
c0205822:	e8 2f e0 ff ff       	call   c0203856 <printk>
c0205827:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(4);
c020582a:	8b 83 68 91 08 00    	mov    0x89168(%ebx),%eax
c0205830:	83 ec 08             	sub    $0x8,%esp
c0205833:	50                   	push   %eax
c0205834:	8d 83 53 01 00 00    	lea    0x153(%ebx),%eax
c020583a:	50                   	push   %eax
c020583b:	e8 16 e0 ff ff       	call   c0203856 <printk>
c0205840:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(8);
c0205843:	8b 83 6c 91 08 00    	mov    0x8916c(%ebx),%eax
c0205849:	83 ec 08             	sub    $0x8,%esp
c020584c:	50                   	push   %eax
c020584d:	8d 83 61 01 00 00    	lea    0x161(%ebx),%eax
c0205853:	50                   	push   %eax
c0205854:	e8 fd df ff ff       	call   c0203856 <printk>
c0205859:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(16);
c020585c:	8b 83 70 91 08 00    	mov    0x89170(%ebx),%eax
c0205862:	83 ec 08             	sub    $0x8,%esp
c0205865:	50                   	push   %eax
c0205866:	8d 83 6f 01 00 00    	lea    0x16f(%ebx),%eax
c020586c:	50                   	push   %eax
c020586d:	e8 e4 df ff ff       	call   c0203856 <printk>
c0205872:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(32);
c0205875:	8b 83 74 91 08 00    	mov    0x89174(%ebx),%eax
c020587b:	83 ec 08             	sub    $0x8,%esp
c020587e:	50                   	push   %eax
c020587f:	8d 83 7e 01 00 00    	lea    0x17e(%ebx),%eax
c0205885:	50                   	push   %eax
c0205886:	e8 cb df ff ff       	call   c0203856 <printk>
c020588b:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(64);
c020588e:	8b 83 78 91 08 00    	mov    0x89178(%ebx),%eax
c0205894:	83 ec 08             	sub    $0x8,%esp
c0205897:	50                   	push   %eax
c0205898:	8d 83 8d 01 00 00    	lea    0x18d(%ebx),%eax
c020589e:	50                   	push   %eax
c020589f:	e8 b2 df ff ff       	call   c0203856 <printk>
c02058a4:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(128);
c02058a7:	8b 83 7c 91 08 00    	mov    0x8917c(%ebx),%eax
c02058ad:	83 ec 08             	sub    $0x8,%esp
c02058b0:	50                   	push   %eax
c02058b1:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
c02058b7:	50                   	push   %eax
c02058b8:	e8 99 df ff ff       	call   c0203856 <printk>
c02058bd:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(256);
c02058c0:	8b 83 80 91 08 00    	mov    0x89180(%ebx),%eax
c02058c6:	83 ec 08             	sub    $0x8,%esp
c02058c9:	50                   	push   %eax
c02058ca:	8d 83 ac 01 00 00    	lea    0x1ac(%ebx),%eax
c02058d0:	50                   	push   %eax
c02058d1:	e8 80 df ff ff       	call   c0203856 <printk>
c02058d6:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(512);
c02058d9:	8b 83 84 91 08 00    	mov    0x89184(%ebx),%eax
c02058df:	83 ec 08             	sub    $0x8,%esp
c02058e2:	50                   	push   %eax
c02058e3:	8d 83 bc 01 00 00    	lea    0x1bc(%ebx),%eax
c02058e9:	50                   	push   %eax
c02058ea:	e8 67 df ff ff       	call   c0203856 <printk>
c02058ef:	83 c4 10             	add    $0x10,%esp
	MACRO_PMM_1(1024);
c02058f2:	8b 83 88 91 08 00    	mov    0x89188(%ebx),%eax
c02058f8:	83 ec 08             	sub    $0x8,%esp
c02058fb:	50                   	push   %eax
c02058fc:	8d 83 cc 01 00 00    	lea    0x1cc(%ebx),%eax
c0205902:	50                   	push   %eax
c0205903:	e8 4e df ff ff       	call   c0203856 <printk>
c0205908:	83 c4 10             	add    $0x10,%esp
	printk("singel buffer have:%d pages!\n",get_single_count());
c020590b:	e8 85 fe ff ff       	call   c0205795 <get_single_count>
c0205910:	83 ec 08             	sub    $0x8,%esp
c0205913:	50                   	push   %eax
c0205914:	8d 83 dd 01 00 00    	lea    0x1dd(%ebx),%eax
c020591a:	50                   	push   %eax
c020591b:	e8 36 df ff ff       	call   c0203856 <printk>
c0205920:	83 c4 10             	add    $0x10,%esp
}
c0205923:	90                   	nop
c0205924:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205927:	c9                   	leave  
c0205928:	c3                   	ret    

c0205929 <pmm_init>:
//取消此宏定义 将宏定义范围限制在此函数中
#undef MACRO_PMM_1(number)

//为内核entry使用的pmm管理模块初始化函数
void pmm_init(){
c0205929:	55                   	push   %ebp
c020592a:	89 e5                	mov    %esp,%ebp
c020592c:	53                   	push   %ebx
c020592d:	83 ec 04             	sub    $0x4,%esp
c0205930:	e8 cf 16 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205935:	81 c3 cb 26 00 00    	add    $0x26cb,%ebx
	printk("kern_start:0x%h\n",kern_start);
c020593b:	83 ec 08             	sub    $0x8,%esp
c020593e:	c7 c0 00 00 10 00    	mov    $0x100000,%eax
c0205944:	50                   	push   %eax
c0205945:	8d 83 fb 01 00 00    	lea    0x1fb(%ebx),%eax
c020594b:	50                   	push   %eax
c020594c:	e8 05 df ff ff       	call   c0203856 <printk>
c0205951:	83 c4 10             	add    $0x10,%esp
	printk("kern_end:0x%h\n",kern_end);
c0205954:	83 ec 08             	sub    $0x8,%esp
c0205957:	c7 c0 00 d0 29 00    	mov    $0x29d000,%eax
c020595d:	50                   	push   %eax
c020595e:	8d 83 0c 02 00 00    	lea    0x20c(%ebx),%eax
c0205964:	50                   	push   %eax
c0205965:	e8 ec de ff ff       	call   c0203856 <printk>
c020596a:	83 c4 10             	add    $0x10,%esp

	//一定要注意 由于分页必须4k对齐 所以此处的物理页管理必须与虚拟页相同 都要4K对齐
	pmm_page_start = ((((uint32_t)kern_end >> 12))+1)<<12;
c020596d:	c7 c0 00 d0 29 00    	mov    $0x29d000,%eax
c0205973:	c1 e8 0c             	shr    $0xc,%eax
c0205976:	83 c0 01             	add    $0x1,%eax
c0205979:	c1 e0 0c             	shl    $0xc,%eax
c020597c:	89 83 d0 91 08 00    	mov    %eax,0x891d0(%ebx)
	pmm_page_end = (((get_max_pm_addr() >> 12)))<<12;
c0205982:	e8 a7 f5 ff ff       	call   c0204f2e <get_max_pm_addr>
c0205987:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c020598c:	89 83 d4 91 08 00    	mov    %eax,0x891d4(%ebx)
	pmm_max_page_no = ((pmm_page_end - pmm_page_start)>>12);
c0205992:	8b 93 d4 91 08 00    	mov    0x891d4(%ebx),%edx
c0205998:	8b 83 d0 91 08 00    	mov    0x891d0(%ebx),%eax
c020599e:	29 c2                	sub    %eax,%edx
c02059a0:	89 d0                	mov    %edx,%eax
c02059a2:	c1 e8 0c             	shr    $0xc,%eax
c02059a5:	89 83 d8 91 08 00    	mov    %eax,0x891d8(%ebx)
	printk("0x%h\n",pmm_page_start);
c02059ab:	8b 83 d0 91 08 00    	mov    0x891d0(%ebx),%eax
c02059b1:	83 ec 08             	sub    $0x8,%esp
c02059b4:	50                   	push   %eax
c02059b5:	8d 83 1b 02 00 00    	lea    0x21b(%ebx),%eax
c02059bb:	50                   	push   %eax
c02059bc:	e8 95 de ff ff       	call   c0203856 <printk>
c02059c1:	83 c4 10             	add    $0x10,%esp
	printk("0x%h\n",pmm_page_end);
c02059c4:	8b 83 d4 91 08 00    	mov    0x891d4(%ebx),%eax
c02059ca:	83 ec 08             	sub    $0x8,%esp
c02059cd:	50                   	push   %eax
c02059ce:	8d 83 1b 02 00 00    	lea    0x21b(%ebx),%eax
c02059d4:	50                   	push   %eax
c02059d5:	e8 7c de ff ff       	call   c0203856 <printk>
c02059da:	83 c4 10             	add    $0x10,%esp
	printk("%d\n",pmm_max_page_no);
c02059dd:	8b 83 d8 91 08 00    	mov    0x891d8(%ebx),%eax
c02059e3:	83 ec 08             	sub    $0x8,%esp
c02059e6:	50                   	push   %eax
c02059e7:	8d 83 21 02 00 00    	lea    0x221(%ebx),%eax
c02059ed:	50                   	push   %eax
c02059ee:	e8 63 de ff ff       	call   c0203856 <printk>
c02059f3:	83 c4 10             	add    $0x10,%esp
	printk("page0:0x%h\n",pmm_page_no_to_addr(32000));
c02059f6:	83 ec 0c             	sub    $0xc,%esp
c02059f9:	68 00 7d 00 00       	push   $0x7d00
c02059fe:	e8 4e ec ff ff       	call   c0204651 <pmm_page_no_to_addr>
c0205a03:	83 c4 10             	add    $0x10,%esp
c0205a06:	83 ec 08             	sub    $0x8,%esp
c0205a09:	50                   	push   %eax
c0205a0a:	8d 83 25 02 00 00    	lea    0x225(%ebx),%eax
c0205a10:	50                   	push   %eax
c0205a11:	e8 40 de ff ff       	call   c0203856 <printk>
c0205a16:	83 c4 10             	add    $0x10,%esp
	pmm_page_init();
c0205a19:	e8 cf f5 ff ff       	call   c0204fed <pmm_page_init>
	printk("page_no:%d\n",SINGLE_LINK->next->page_no);
c0205a1e:	8b 83 cc 91 08 00    	mov    0x891cc(%ebx),%eax
c0205a24:	8b 40 04             	mov    0x4(%eax),%eax
c0205a27:	8b 00                	mov    (%eax),%eax
c0205a29:	83 ec 08             	sub    $0x8,%esp
c0205a2c:	50                   	push   %eax
c0205a2d:	8d 83 31 02 00 00    	lea    0x231(%ebx),%eax
c0205a33:	50                   	push   %eax
c0205a34:	e8 1d de ff ff       	call   c0203856 <printk>
c0205a39:	83 c4 10             	add    $0x10,%esp
	printk("***%d***",get_partner_page_no(4,_2));
c0205a3c:	83 ec 08             	sub    $0x8,%esp
c0205a3f:	6a 01                	push   $0x1
c0205a41:	6a 04                	push   $0x4
c0205a43:	e8 69 ec ff ff       	call   c02046b1 <get_partner_page_no>
c0205a48:	83 c4 10             	add    $0x10,%esp
c0205a4b:	83 ec 08             	sub    $0x8,%esp
c0205a4e:	50                   	push   %eax
c0205a4f:	8d 83 3d 02 00 00    	lea    0x23d(%ebx),%eax
c0205a55:	50                   	push   %eax
c0205a56:	e8 fb dd ff ff       	call   c0203856 <printk>
c0205a5b:	83 c4 10             	add    $0x10,%esp
c0205a5e:	90                   	nop
c0205a5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205a62:	c9                   	leave  
c0205a63:	c3                   	ret    

c0205a64 <set_int_disc>:
int_server_func_t int_server_func_list[256];
interrupt_discripter_t idt_entries[256];    //中断描述符表 idt_entries为表首指针
lidt_target_t lidt_target;
static uint8_t default_inf=0x8E;
static uint16_t kern_cs=0x08; 
static void set_int_disc(int int_no, uint32_t offset, uint16_t selector, uint8_t inf){
c0205a64:	55                   	push   %ebp
c0205a65:	89 e5                	mov    %esp,%ebp
c0205a67:	53                   	push   %ebx
c0205a68:	83 ec 08             	sub    $0x8,%esp
c0205a6b:	e8 90 15 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205a70:	05 90 25 00 00       	add    $0x2590,%eax
c0205a75:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0205a78:	8b 55 14             	mov    0x14(%ebp),%edx
c0205a7b:	66 89 4d f8          	mov    %cx,-0x8(%ebp)
c0205a7f:	88 55 f4             	mov    %dl,-0xc(%ebp)
	idt_entries[int_no].offset_low=(uint16_t)offset;
c0205a82:	8b 55 0c             	mov    0xc(%ebp),%edx
c0205a85:	89 d3                	mov    %edx,%ebx
c0205a87:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205a8d:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205a90:	66 89 1c ca          	mov    %bx,(%edx,%ecx,8)
	idt_entries[int_no].offset_high=(uint16_t)(offset>>16);
c0205a94:	8b 55 0c             	mov    0xc(%ebp),%edx
c0205a97:	c1 ea 10             	shr    $0x10,%edx
c0205a9a:	89 d3                	mov    %edx,%ebx
c0205a9c:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205aa2:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205aa5:	66 89 5c ca 06       	mov    %bx,0x6(%edx,%ecx,8)
	idt_entries[int_no].selector=selector;
c0205aaa:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205ab0:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205ab3:	0f b7 5d f8          	movzwl -0x8(%ebp),%ebx
c0205ab7:	66 89 5c ca 02       	mov    %bx,0x2(%edx,%ecx,8)
	idt_entries[int_no].inf=inf;
c0205abc:	c7 c2 40 24 29 c0    	mov    $0xc0292440,%edx
c0205ac2:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0205ac5:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0205ac9:	88 5c ca 05          	mov    %bl,0x5(%edx,%ecx,8)
	idt_entries[int_no].default_bit8=0;
c0205acd:	c7 c0 40 24 29 c0    	mov    $0xc0292440,%eax
c0205ad3:	8b 55 08             	mov    0x8(%ebp),%edx
c0205ad6:	c6 44 d0 04 00       	movb   $0x0,0x4(%eax,%edx,8)
}
c0205adb:	90                   	nop
c0205adc:	83 c4 08             	add    $0x8,%esp
c0205adf:	5b                   	pop    %ebx
c0205ae0:	5d                   	pop    %ebp
c0205ae1:	c3                   	ret    

c0205ae2 <timer_init>:
static void timer_init(uint32_t frequency){
c0205ae2:	55                   	push   %ebp
c0205ae3:	89 e5                	mov    %esp,%ebp
c0205ae5:	53                   	push   %ebx
c0205ae6:	83 ec 14             	sub    $0x14,%esp
c0205ae9:	e8 16 15 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205aee:	81 c3 12 25 00 00    	add    $0x2512,%ebx
	// Intel 8253/8254 PIT芯片 I/O端口地址范围是40h~43h
    // 输入频率为 1193180，frequency 即每秒中断次数
    uint32_t divisor = 1193180 / frequency;
c0205af4:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0205af9:	ba 00 00 00 00       	mov    $0x0,%edx
c0205afe:	f7 75 08             	divl   0x8(%ebp)
c0205b01:	89 45 f4             	mov    %eax,-0xc(%ebp)
    // D7 D6 D5 D4 D3 D2 D1 D0
    // 0  0  1  1  0  1  1  0
    // 即就是 36 H
    // 设置 8253/8254 芯片工作在模式 3 下
    outb(0x43, 0x36);
c0205b04:	83 ec 08             	sub    $0x8,%esp
c0205b07:	6a 36                	push   $0x36
c0205b09:	6a 43                	push   $0x43
c0205b0b:	e8 2b dc ff ff       	call   c020373b <outb>
c0205b10:	83 c4 10             	add    $0x10,%esp

    // 拆分低字节和高字节
    uint8_t low = (uint8_t)(divisor & 0xFF);
c0205b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205b16:	88 45 f3             	mov    %al,-0xd(%ebp)
    uint8_t hign = (uint8_t)((divisor >> 8) & 0xFF);
c0205b19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0205b1c:	c1 e8 08             	shr    $0x8,%eax
c0205b1f:	88 45 f2             	mov    %al,-0xe(%ebp)
    
    // 分别写入低字节和高字节
    outb(0x40, low);
c0205b22:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0205b26:	83 ec 08             	sub    $0x8,%esp
c0205b29:	50                   	push   %eax
c0205b2a:	6a 40                	push   $0x40
c0205b2c:	e8 0a dc ff ff       	call   c020373b <outb>
c0205b31:	83 c4 10             	add    $0x10,%esp
    outb(0x40, hign);
c0205b34:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
c0205b38:	83 ec 08             	sub    $0x8,%esp
c0205b3b:	50                   	push   %eax
c0205b3c:	6a 40                	push   $0x40
c0205b3e:	e8 f8 db ff ff       	call   c020373b <outb>
c0205b43:	83 c4 10             	add    $0x10,%esp
}
c0205b46:	90                   	nop
c0205b47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205b4a:	c9                   	leave  
c0205b4b:	c3                   	ret    

c0205b4c <registe_interrupt>:

static void registe_interrupt(int int_no,int_server_func_t target_func){
c0205b4c:	55                   	push   %ebp
c0205b4d:	89 e5                	mov    %esp,%ebp
c0205b4f:	e8 ac 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205b54:	05 ac 24 00 00       	add    $0x24ac,%eax
	int_server_func_list[int_no] = target_func;
c0205b59:	c7 c0 20 20 29 c0    	mov    $0xc0292020,%eax
c0205b5f:	8b 55 08             	mov    0x8(%ebp),%edx
c0205b62:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0205b65:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
}
c0205b68:	90                   	nop
c0205b69:	5d                   	pop    %ebp
c0205b6a:	c3                   	ret    

c0205b6b <default_server_func>:

void default_server_func(void *args){
c0205b6b:	55                   	push   %ebp
c0205b6c:	89 e5                	mov    %esp,%ebp
c0205b6e:	53                   	push   %ebx
c0205b6f:	83 ec 04             	sub    $0x4,%esp
c0205b72:	e8 89 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205b77:	05 89 24 00 00       	add    $0x2489,%eax
	printk("Default Int server function!\n");
c0205b7c:	83 ec 0c             	sub    $0xc,%esp
c0205b7f:	8d 90 46 02 00 00    	lea    0x246(%eax),%edx
c0205b85:	52                   	push   %edx
c0205b86:	89 c3                	mov    %eax,%ebx
c0205b88:	e8 c9 dc ff ff       	call   c0203856 <printk>
c0205b8d:	83 c4 10             	add    $0x10,%esp
}
c0205b90:	90                   	nop
c0205b91:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205b94:	c9                   	leave  
c0205b95:	c3                   	ret    

c0205b96 <timer_server_func>:


extern TCB_t * cur_tcb; 

//时钟中断函数 主要用于线程调度
void timer_server_func(void *args){
c0205b96:	55                   	push   %ebp
c0205b97:	89 e5                	mov    %esp,%ebp
c0205b99:	53                   	push   %ebx
c0205b9a:	83 ec 04             	sub    $0x4,%esp
c0205b9d:	e8 5e 14 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0205ba2:	05 5e 24 00 00       	add    $0x245e,%eax
	if(cur_tcb->time_left!=0){
c0205ba7:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0205bad:	8b 12                	mov    (%edx),%edx
c0205baf:	8b 52 0c             	mov    0xc(%edx),%edx
c0205bb2:	85 d2                	test   %edx,%edx
c0205bb4:	74 24                	je     c0205bda <timer_server_func+0x44>
		(cur_tcb->time_left)--;
c0205bb6:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0205bbc:	8b 12                	mov    (%edx),%edx
c0205bbe:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0205bc1:	83 e9 01             	sub    $0x1,%ecx
c0205bc4:	89 4a 0c             	mov    %ecx,0xc(%edx)
		(cur_tcb->time_counter)++;
c0205bc7:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0205bcd:	8b 00                	mov    (%eax),%eax
c0205bcf:	8b 50 08             	mov    0x8(%eax),%edx
c0205bd2:	83 c2 01             	add    $0x1,%edx
c0205bd5:	89 50 08             	mov    %edx,0x8(%eax)
	}
	else{
		schedule();
	}
}
c0205bd8:	eb 07                	jmp    c0205be1 <timer_server_func+0x4b>
		schedule();
c0205bda:	89 c3                	mov    %eax,%ebx
c0205bdc:	e8 6e 07 00 00       	call   c020634f <schedule>
}
c0205be1:	90                   	nop
c0205be2:	83 c4 04             	add    $0x4,%esp
c0205be5:	5b                   	pop    %ebx
c0205be6:	5d                   	pop    %ebp
c0205be7:	c3                   	ret    

c0205be8 <lost_page_func>:

//cr2 保存引起缺页的线性地址
void get_cr2();
extern uint32_t _CR2;
void lost_page_func(){
c0205be8:	55                   	push   %ebp
c0205be9:	89 e5                	mov    %esp,%ebp
c0205beb:	53                   	push   %ebx
c0205bec:	83 ec 04             	sub    $0x4,%esp
c0205bef:	e8 10 14 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205bf4:	81 c3 0c 24 00 00    	add    $0x240c,%ebx
	get_cr2();
c0205bfa:	e8 4a d6 ff ff       	call   c0203249 <get_cr2>
	printk("INT 14:lost page--0x%h\n",_CR2);
c0205bff:	c7 c0 52 32 20 c0    	mov    $0xc0203252,%eax
c0205c05:	8b 00                	mov    (%eax),%eax
c0205c07:	83 ec 08             	sub    $0x8,%esp
c0205c0a:	50                   	push   %eax
c0205c0b:	8d 83 64 02 00 00    	lea    0x264(%ebx),%eax
c0205c11:	50                   	push   %eax
c0205c12:	e8 3f dc ff ff       	call   c0203856 <printk>
c0205c17:	83 c4 10             	add    $0x10,%esp
}
c0205c1a:	90                   	nop
c0205c1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0205c1e:	c9                   	leave  
c0205c1f:	c3                   	ret    

c0205c20 <idt_init>:
void isr30();
void isr31();

void isr32();

void idt_init(){
c0205c20:	55                   	push   %ebp
c0205c21:	89 e5                	mov    %esp,%ebp
c0205c23:	53                   	push   %ebx
c0205c24:	83 ec 04             	sub    $0x4,%esp
c0205c27:	e8 d8 13 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c0205c2c:	81 c3 d4 23 00 00    	add    $0x23d4,%ebx
	_8259A_init();   //初始化中断控制器
c0205c32:	e8 90 e5 ff ff       	call   c02041c7 <_8259A_init>
	set_int_disc(0,(uint32_t)isr0,kern_cs,default_inf);
c0205c37:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205c3e:	0f b6 d0             	movzbl %al,%edx
c0205c41:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205c48:	0f b7 c0             	movzwl %ax,%eax
c0205c4b:	c7 c1 ef 30 20 c0    	mov    $0xc02030ef,%ecx
c0205c51:	52                   	push   %edx
c0205c52:	50                   	push   %eax
c0205c53:	51                   	push   %ecx
c0205c54:	6a 00                	push   $0x0
c0205c56:	e8 09 fe ff ff       	call   c0205a64 <set_int_disc>
c0205c5b:	83 c4 10             	add    $0x10,%esp
	set_int_disc(1,(uint32_t)isr1,kern_cs,default_inf);
c0205c5e:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205c65:	0f b6 d0             	movzbl %al,%edx
c0205c68:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205c6f:	0f b7 c0             	movzwl %ax,%eax
c0205c72:	c7 c1 f7 30 20 c0    	mov    $0xc02030f7,%ecx
c0205c78:	52                   	push   %edx
c0205c79:	50                   	push   %eax
c0205c7a:	51                   	push   %ecx
c0205c7b:	6a 01                	push   $0x1
c0205c7d:	e8 e2 fd ff ff       	call   c0205a64 <set_int_disc>
c0205c82:	83 c4 10             	add    $0x10,%esp
	set_int_disc(2,(uint32_t)isr2,kern_cs,default_inf);
c0205c85:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205c8c:	0f b6 d0             	movzbl %al,%edx
c0205c8f:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205c96:	0f b7 c0             	movzwl %ax,%eax
c0205c99:	c7 c1 ff 30 20 c0    	mov    $0xc02030ff,%ecx
c0205c9f:	52                   	push   %edx
c0205ca0:	50                   	push   %eax
c0205ca1:	51                   	push   %ecx
c0205ca2:	6a 02                	push   $0x2
c0205ca4:	e8 bb fd ff ff       	call   c0205a64 <set_int_disc>
c0205ca9:	83 c4 10             	add    $0x10,%esp
	set_int_disc(3,(uint32_t)isr3,kern_cs,default_inf);
c0205cac:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205cb3:	0f b6 d0             	movzbl %al,%edx
c0205cb6:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205cbd:	0f b7 c0             	movzwl %ax,%eax
c0205cc0:	c7 c1 07 31 20 c0    	mov    $0xc0203107,%ecx
c0205cc6:	52                   	push   %edx
c0205cc7:	50                   	push   %eax
c0205cc8:	51                   	push   %ecx
c0205cc9:	6a 03                	push   $0x3
c0205ccb:	e8 94 fd ff ff       	call   c0205a64 <set_int_disc>
c0205cd0:	83 c4 10             	add    $0x10,%esp
	set_int_disc(4,(uint32_t)isr4,kern_cs,default_inf);
c0205cd3:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205cda:	0f b6 d0             	movzbl %al,%edx
c0205cdd:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205ce4:	0f b7 c0             	movzwl %ax,%eax
c0205ce7:	c7 c1 0f 31 20 c0    	mov    $0xc020310f,%ecx
c0205ced:	52                   	push   %edx
c0205cee:	50                   	push   %eax
c0205cef:	51                   	push   %ecx
c0205cf0:	6a 04                	push   $0x4
c0205cf2:	e8 6d fd ff ff       	call   c0205a64 <set_int_disc>
c0205cf7:	83 c4 10             	add    $0x10,%esp
	set_int_disc(5,(uint32_t)isr5,kern_cs,default_inf);
c0205cfa:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d01:	0f b6 d0             	movzbl %al,%edx
c0205d04:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d0b:	0f b7 c0             	movzwl %ax,%eax
c0205d0e:	c7 c1 17 31 20 c0    	mov    $0xc0203117,%ecx
c0205d14:	52                   	push   %edx
c0205d15:	50                   	push   %eax
c0205d16:	51                   	push   %ecx
c0205d17:	6a 05                	push   $0x5
c0205d19:	e8 46 fd ff ff       	call   c0205a64 <set_int_disc>
c0205d1e:	83 c4 10             	add    $0x10,%esp
	set_int_disc(6,(uint32_t)isr6,kern_cs,default_inf);
c0205d21:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d28:	0f b6 d0             	movzbl %al,%edx
c0205d2b:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d32:	0f b7 c0             	movzwl %ax,%eax
c0205d35:	c7 c1 1f 31 20 c0    	mov    $0xc020311f,%ecx
c0205d3b:	52                   	push   %edx
c0205d3c:	50                   	push   %eax
c0205d3d:	51                   	push   %ecx
c0205d3e:	6a 06                	push   $0x6
c0205d40:	e8 1f fd ff ff       	call   c0205a64 <set_int_disc>
c0205d45:	83 c4 10             	add    $0x10,%esp
	set_int_disc(7,(uint32_t)isr7,kern_cs,default_inf);
c0205d48:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d4f:	0f b6 d0             	movzbl %al,%edx
c0205d52:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d59:	0f b7 c0             	movzwl %ax,%eax
c0205d5c:	c7 c1 2a 31 20 c0    	mov    $0xc020312a,%ecx
c0205d62:	52                   	push   %edx
c0205d63:	50                   	push   %eax
c0205d64:	51                   	push   %ecx
c0205d65:	6a 07                	push   $0x7
c0205d67:	e8 f8 fc ff ff       	call   c0205a64 <set_int_disc>
c0205d6c:	83 c4 10             	add    $0x10,%esp
	set_int_disc(8,(uint32_t)isr8,kern_cs,default_inf);
c0205d6f:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d76:	0f b6 d0             	movzbl %al,%edx
c0205d79:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205d80:	0f b7 c0             	movzwl %ax,%eax
c0205d83:	c7 c1 35 31 20 c0    	mov    $0xc0203135,%ecx
c0205d89:	52                   	push   %edx
c0205d8a:	50                   	push   %eax
c0205d8b:	51                   	push   %ecx
c0205d8c:	6a 08                	push   $0x8
c0205d8e:	e8 d1 fc ff ff       	call   c0205a64 <set_int_disc>
c0205d93:	83 c4 10             	add    $0x10,%esp
	set_int_disc(9,(uint32_t)isr9,kern_cs,default_inf);
c0205d96:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205d9d:	0f b6 d0             	movzbl %al,%edx
c0205da0:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205da7:	0f b7 c0             	movzwl %ax,%eax
c0205daa:	c7 c1 3f 31 20 c0    	mov    $0xc020313f,%ecx
c0205db0:	52                   	push   %edx
c0205db1:	50                   	push   %eax
c0205db2:	51                   	push   %ecx
c0205db3:	6a 09                	push   $0x9
c0205db5:	e8 aa fc ff ff       	call   c0205a64 <set_int_disc>
c0205dba:	83 c4 10             	add    $0x10,%esp
	set_int_disc(10,(uint32_t)isr10,kern_cs,default_inf);
c0205dbd:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205dc4:	0f b6 d0             	movzbl %al,%edx
c0205dc7:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205dce:	0f b7 c0             	movzwl %ax,%eax
c0205dd1:	c7 c1 4a 31 20 c0    	mov    $0xc020314a,%ecx
c0205dd7:	52                   	push   %edx
c0205dd8:	50                   	push   %eax
c0205dd9:	51                   	push   %ecx
c0205dda:	6a 0a                	push   $0xa
c0205ddc:	e8 83 fc ff ff       	call   c0205a64 <set_int_disc>
c0205de1:	83 c4 10             	add    $0x10,%esp
	set_int_disc(11,(uint32_t)isr11,kern_cs,default_inf);
c0205de4:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205deb:	0f b6 d0             	movzbl %al,%edx
c0205dee:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205df5:	0f b7 c0             	movzwl %ax,%eax
c0205df8:	c7 c1 54 31 20 c0    	mov    $0xc0203154,%ecx
c0205dfe:	52                   	push   %edx
c0205dff:	50                   	push   %eax
c0205e00:	51                   	push   %ecx
c0205e01:	6a 0b                	push   $0xb
c0205e03:	e8 5c fc ff ff       	call   c0205a64 <set_int_disc>
c0205e08:	83 c4 10             	add    $0x10,%esp
	set_int_disc(12,(uint32_t)isr12,kern_cs,default_inf);
c0205e0b:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e12:	0f b6 d0             	movzbl %al,%edx
c0205e15:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e1c:	0f b7 c0             	movzwl %ax,%eax
c0205e1f:	c7 c1 5e 31 20 c0    	mov    $0xc020315e,%ecx
c0205e25:	52                   	push   %edx
c0205e26:	50                   	push   %eax
c0205e27:	51                   	push   %ecx
c0205e28:	6a 0c                	push   $0xc
c0205e2a:	e8 35 fc ff ff       	call   c0205a64 <set_int_disc>
c0205e2f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(13,(uint32_t)isr13,kern_cs,default_inf);
c0205e32:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e39:	0f b6 d0             	movzbl %al,%edx
c0205e3c:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e43:	0f b7 c0             	movzwl %ax,%eax
c0205e46:	c7 c1 68 31 20 c0    	mov    $0xc0203168,%ecx
c0205e4c:	52                   	push   %edx
c0205e4d:	50                   	push   %eax
c0205e4e:	51                   	push   %ecx
c0205e4f:	6a 0d                	push   $0xd
c0205e51:	e8 0e fc ff ff       	call   c0205a64 <set_int_disc>
c0205e56:	83 c4 10             	add    $0x10,%esp
	set_int_disc(14,(uint32_t)isr14,kern_cs,default_inf);
c0205e59:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e60:	0f b6 d0             	movzbl %al,%edx
c0205e63:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e6a:	0f b7 c0             	movzwl %ax,%eax
c0205e6d:	c7 c1 72 31 20 c0    	mov    $0xc0203172,%ecx
c0205e73:	52                   	push   %edx
c0205e74:	50                   	push   %eax
c0205e75:	51                   	push   %ecx
c0205e76:	6a 0e                	push   $0xe
c0205e78:	e8 e7 fb ff ff       	call   c0205a64 <set_int_disc>
c0205e7d:	83 c4 10             	add    $0x10,%esp
	set_int_disc(15,(uint32_t)isr15,kern_cs,default_inf);
c0205e80:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205e87:	0f b6 d0             	movzbl %al,%edx
c0205e8a:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205e91:	0f b7 c0             	movzwl %ax,%eax
c0205e94:	c7 c1 7c 31 20 c0    	mov    $0xc020317c,%ecx
c0205e9a:	52                   	push   %edx
c0205e9b:	50                   	push   %eax
c0205e9c:	51                   	push   %ecx
c0205e9d:	6a 0f                	push   $0xf
c0205e9f:	e8 c0 fb ff ff       	call   c0205a64 <set_int_disc>
c0205ea4:	83 c4 10             	add    $0x10,%esp
	set_int_disc(16,(uint32_t)isr16,kern_cs,default_inf);
c0205ea7:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205eae:	0f b6 d0             	movzbl %al,%edx
c0205eb1:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205eb8:	0f b7 c0             	movzwl %ax,%eax
c0205ebb:	c7 c1 87 31 20 c0    	mov    $0xc0203187,%ecx
c0205ec1:	52                   	push   %edx
c0205ec2:	50                   	push   %eax
c0205ec3:	51                   	push   %ecx
c0205ec4:	6a 10                	push   $0x10
c0205ec6:	e8 99 fb ff ff       	call   c0205a64 <set_int_disc>
c0205ecb:	83 c4 10             	add    $0x10,%esp
	set_int_disc(17,(uint32_t)isr17,kern_cs,default_inf);
c0205ece:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205ed5:	0f b6 d0             	movzbl %al,%edx
c0205ed8:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205edf:	0f b7 c0             	movzwl %ax,%eax
c0205ee2:	c7 c1 92 31 20 c0    	mov    $0xc0203192,%ecx
c0205ee8:	52                   	push   %edx
c0205ee9:	50                   	push   %eax
c0205eea:	51                   	push   %ecx
c0205eeb:	6a 11                	push   $0x11
c0205eed:	e8 72 fb ff ff       	call   c0205a64 <set_int_disc>
c0205ef2:	83 c4 10             	add    $0x10,%esp
	set_int_disc(18,(uint32_t)isr18,kern_cs,default_inf);
c0205ef5:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205efc:	0f b6 d0             	movzbl %al,%edx
c0205eff:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f06:	0f b7 c0             	movzwl %ax,%eax
c0205f09:	c7 c1 9c 31 20 c0    	mov    $0xc020319c,%ecx
c0205f0f:	52                   	push   %edx
c0205f10:	50                   	push   %eax
c0205f11:	51                   	push   %ecx
c0205f12:	6a 12                	push   $0x12
c0205f14:	e8 4b fb ff ff       	call   c0205a64 <set_int_disc>
c0205f19:	83 c4 10             	add    $0x10,%esp
	set_int_disc(19,(uint32_t)isr19,kern_cs,default_inf);
c0205f1c:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f23:	0f b6 d0             	movzbl %al,%edx
c0205f26:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f2d:	0f b7 c0             	movzwl %ax,%eax
c0205f30:	c7 c1 a7 31 20 c0    	mov    $0xc02031a7,%ecx
c0205f36:	52                   	push   %edx
c0205f37:	50                   	push   %eax
c0205f38:	51                   	push   %ecx
c0205f39:	6a 13                	push   $0x13
c0205f3b:	e8 24 fb ff ff       	call   c0205a64 <set_int_disc>
c0205f40:	83 c4 10             	add    $0x10,%esp
	set_int_disc(20,(uint32_t)isr20,kern_cs,default_inf);
c0205f43:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f4a:	0f b6 d0             	movzbl %al,%edx
c0205f4d:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f54:	0f b7 c0             	movzwl %ax,%eax
c0205f57:	c7 c1 b2 31 20 c0    	mov    $0xc02031b2,%ecx
c0205f5d:	52                   	push   %edx
c0205f5e:	50                   	push   %eax
c0205f5f:	51                   	push   %ecx
c0205f60:	6a 14                	push   $0x14
c0205f62:	e8 fd fa ff ff       	call   c0205a64 <set_int_disc>
c0205f67:	83 c4 10             	add    $0x10,%esp
	set_int_disc(21,(uint32_t)isr21,kern_cs,default_inf);
c0205f6a:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f71:	0f b6 d0             	movzbl %al,%edx
c0205f74:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205f7b:	0f b7 c0             	movzwl %ax,%eax
c0205f7e:	c7 c1 bd 31 20 c0    	mov    $0xc02031bd,%ecx
c0205f84:	52                   	push   %edx
c0205f85:	50                   	push   %eax
c0205f86:	51                   	push   %ecx
c0205f87:	6a 15                	push   $0x15
c0205f89:	e8 d6 fa ff ff       	call   c0205a64 <set_int_disc>
c0205f8e:	83 c4 10             	add    $0x10,%esp
	set_int_disc(22,(uint32_t)isr22,kern_cs,default_inf);
c0205f91:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205f98:	0f b6 d0             	movzbl %al,%edx
c0205f9b:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205fa2:	0f b7 c0             	movzwl %ax,%eax
c0205fa5:	c7 c1 c8 31 20 c0    	mov    $0xc02031c8,%ecx
c0205fab:	52                   	push   %edx
c0205fac:	50                   	push   %eax
c0205fad:	51                   	push   %ecx
c0205fae:	6a 16                	push   $0x16
c0205fb0:	e8 af fa ff ff       	call   c0205a64 <set_int_disc>
c0205fb5:	83 c4 10             	add    $0x10,%esp
	set_int_disc(23,(uint32_t)isr23,kern_cs,default_inf);
c0205fb8:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205fbf:	0f b6 d0             	movzbl %al,%edx
c0205fc2:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205fc9:	0f b7 c0             	movzwl %ax,%eax
c0205fcc:	c7 c1 d3 31 20 c0    	mov    $0xc02031d3,%ecx
c0205fd2:	52                   	push   %edx
c0205fd3:	50                   	push   %eax
c0205fd4:	51                   	push   %ecx
c0205fd5:	6a 17                	push   $0x17
c0205fd7:	e8 88 fa ff ff       	call   c0205a64 <set_int_disc>
c0205fdc:	83 c4 10             	add    $0x10,%esp
	set_int_disc(24,(uint32_t)isr24,kern_cs,default_inf);
c0205fdf:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0205fe6:	0f b6 d0             	movzbl %al,%edx
c0205fe9:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0205ff0:	0f b7 c0             	movzwl %ax,%eax
c0205ff3:	c7 c1 de 31 20 c0    	mov    $0xc02031de,%ecx
c0205ff9:	52                   	push   %edx
c0205ffa:	50                   	push   %eax
c0205ffb:	51                   	push   %ecx
c0205ffc:	6a 18                	push   $0x18
c0205ffe:	e8 61 fa ff ff       	call   c0205a64 <set_int_disc>
c0206003:	83 c4 10             	add    $0x10,%esp
	set_int_disc(25,(uint32_t)isr25,kern_cs,default_inf);
c0206006:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c020600d:	0f b6 d0             	movzbl %al,%edx
c0206010:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206017:	0f b7 c0             	movzwl %ax,%eax
c020601a:	c7 c1 e9 31 20 c0    	mov    $0xc02031e9,%ecx
c0206020:	52                   	push   %edx
c0206021:	50                   	push   %eax
c0206022:	51                   	push   %ecx
c0206023:	6a 19                	push   $0x19
c0206025:	e8 3a fa ff ff       	call   c0205a64 <set_int_disc>
c020602a:	83 c4 10             	add    $0x10,%esp
	set_int_disc(26,(uint32_t)isr26,kern_cs,default_inf);
c020602d:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206034:	0f b6 d0             	movzbl %al,%edx
c0206037:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c020603e:	0f b7 c0             	movzwl %ax,%eax
c0206041:	c7 c1 f4 31 20 c0    	mov    $0xc02031f4,%ecx
c0206047:	52                   	push   %edx
c0206048:	50                   	push   %eax
c0206049:	51                   	push   %ecx
c020604a:	6a 1a                	push   $0x1a
c020604c:	e8 13 fa ff ff       	call   c0205a64 <set_int_disc>
c0206051:	83 c4 10             	add    $0x10,%esp
	set_int_disc(27,(uint32_t)isr27,kern_cs,default_inf);
c0206054:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c020605b:	0f b6 d0             	movzbl %al,%edx
c020605e:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206065:	0f b7 c0             	movzwl %ax,%eax
c0206068:	c7 c1 ff 31 20 c0    	mov    $0xc02031ff,%ecx
c020606e:	52                   	push   %edx
c020606f:	50                   	push   %eax
c0206070:	51                   	push   %ecx
c0206071:	6a 1b                	push   $0x1b
c0206073:	e8 ec f9 ff ff       	call   c0205a64 <set_int_disc>
c0206078:	83 c4 10             	add    $0x10,%esp
	set_int_disc(28,(uint32_t)isr28,kern_cs,default_inf);
c020607b:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c0206082:	0f b6 d0             	movzbl %al,%edx
c0206085:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c020608c:	0f b7 c0             	movzwl %ax,%eax
c020608f:	c7 c1 0a 32 20 c0    	mov    $0xc020320a,%ecx
c0206095:	52                   	push   %edx
c0206096:	50                   	push   %eax
c0206097:	51                   	push   %ecx
c0206098:	6a 1c                	push   $0x1c
c020609a:	e8 c5 f9 ff ff       	call   c0205a64 <set_int_disc>
c020609f:	83 c4 10             	add    $0x10,%esp
	set_int_disc(29,(uint32_t)isr29,kern_cs,default_inf);
c02060a2:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c02060a9:	0f b6 d0             	movzbl %al,%edx
c02060ac:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c02060b3:	0f b7 c0             	movzwl %ax,%eax
c02060b6:	c7 c1 15 32 20 c0    	mov    $0xc0203215,%ecx
c02060bc:	52                   	push   %edx
c02060bd:	50                   	push   %eax
c02060be:	51                   	push   %ecx
c02060bf:	6a 1d                	push   $0x1d
c02060c1:	e8 9e f9 ff ff       	call   c0205a64 <set_int_disc>
c02060c6:	83 c4 10             	add    $0x10,%esp
	set_int_disc(30,(uint32_t)isr30,kern_cs,default_inf);
c02060c9:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c02060d0:	0f b6 d0             	movzbl %al,%edx
c02060d3:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c02060da:	0f b7 c0             	movzwl %ax,%eax
c02060dd:	c7 c1 20 32 20 c0    	mov    $0xc0203220,%ecx
c02060e3:	52                   	push   %edx
c02060e4:	50                   	push   %eax
c02060e5:	51                   	push   %ecx
c02060e6:	6a 1e                	push   $0x1e
c02060e8:	e8 77 f9 ff ff       	call   c0205a64 <set_int_disc>
c02060ed:	83 c4 10             	add    $0x10,%esp
	set_int_disc(31,(uint32_t)isr31,kern_cs,default_inf);
c02060f0:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c02060f7:	0f b6 d0             	movzbl %al,%edx
c02060fa:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206101:	0f b7 c0             	movzwl %ax,%eax
c0206104:	c7 c1 2b 32 20 c0    	mov    $0xc020322b,%ecx
c020610a:	52                   	push   %edx
c020610b:	50                   	push   %eax
c020610c:	51                   	push   %ecx
c020610d:	6a 1f                	push   $0x1f
c020610f:	e8 50 f9 ff ff       	call   c0205a64 <set_int_disc>
c0206114:	83 c4 10             	add    $0x10,%esp
	set_int_disc(32,(uint32_t)isr32,kern_cs,default_inf);
c0206117:	0f b6 83 28 f0 ff ff 	movzbl -0xfd8(%ebx),%eax
c020611e:	0f b6 d0             	movzbl %al,%edx
c0206121:	0f b7 83 2a f0 ff ff 	movzwl -0xfd6(%ebx),%eax
c0206128:	0f b7 c0             	movzwl %ax,%eax
c020612b:	c7 c1 36 32 20 c0    	mov    $0xc0203236,%ecx
c0206131:	52                   	push   %edx
c0206132:	50                   	push   %eax
c0206133:	51                   	push   %ecx
c0206134:	6a 20                	push   $0x20
c0206136:	e8 29 f9 ff ff       	call   c0205a64 <set_int_disc>
c020613b:	83 c4 10             	add    $0x10,%esp
	//registe_interrupt(32,timer_server_func);
	registe_interrupt(14,lost_page_func);
c020613e:	83 ec 08             	sub    $0x8,%esp
c0206141:	8d 83 e8 db ff ff    	lea    -0x2418(%ebx),%eax
c0206147:	50                   	push   %eax
c0206148:	6a 0e                	push   $0xe
c020614a:	e8 fd f9 ff ff       	call   c0205b4c <registe_interrupt>
c020614f:	83 c4 10             	add    $0x10,%esp
	lidt_target.limit = sizeof(interrupt_discripter_t)*256;
c0206152:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c0206158:	66 c7 00 00 08       	movw   $0x800,(%eax)
	lidt_target.base = (uint32_t)&idt_entries;
c020615d:	c7 c0 40 24 29 c0    	mov    $0xc0292440,%eax
c0206163:	89 c2                	mov    %eax,%edx
c0206165:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c020616b:	89 50 02             	mov    %edx,0x2(%eax)
	timer_init(1000);        
c020616e:	83 ec 0c             	sub    $0xc,%esp
c0206171:	68 e8 03 00 00       	push   $0x3e8
c0206176:	e8 67 f9 ff ff       	call   c0205ae2 <timer_init>
c020617b:	83 c4 10             	add    $0x10,%esp
	load_idt((uint32_t)&lidt_target);
c020617e:	c7 c0 20 24 29 c0    	mov    $0xc0292420,%eax
c0206184:	83 ec 0c             	sub    $0xc,%esp
c0206187:	50                   	push   %eax
c0206188:	e8 b4 d0 ff ff       	call   c0203241 <load_idt>
c020618d:	83 c4 10             	add    $0x10,%esp
}
c0206190:	90                   	nop
c0206191:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206194:	c9                   	leave  
c0206195:	c3                   	ret    

c0206196 <int_func_route>:
void int_func_route(int int_no,void * args){
c0206196:	55                   	push   %ebp
c0206197:	89 e5                	mov    %esp,%ebp
c0206199:	83 ec 08             	sub    $0x8,%esp
c020619c:	e8 5f 0e 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02061a1:	05 5f 1e 00 00       	add    $0x1e5f,%eax
	int_server_func_list[int_no](args);
c02061a6:	c7 c0 20 20 29 c0    	mov    $0xc0292020,%eax
c02061ac:	8b 55 08             	mov    0x8(%ebp),%edx
c02061af:	8b 04 90             	mov    (%eax,%edx,4),%eax
c02061b2:	83 ec 0c             	sub    $0xc,%esp
c02061b5:	ff 75 0c             	pushl  0xc(%ebp)
c02061b8:	ff d0                	call   *%eax
c02061ba:	83 c4 10             	add    $0x10,%esp
}
c02061bd:	90                   	nop
c02061be:	c9                   	leave  
c02061bf:	c3                   	ret    

c02061c0 <threads_init>:
#include "printk.h"
#define TIME_CONT  2 //默认时间片计数
TCB_t main_TCB;    //主线程TCB
TCB_t* cur_tcb;

void threads_init(){
c02061c0:	55                   	push   %ebp
c02061c1:	89 e5                	mov    %esp,%ebp
c02061c3:	83 ec 10             	sub    $0x10,%esp
c02061c6:	e8 35 0e 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02061cb:	05 35 1e 00 00       	add    $0x1e35,%eax
	TCB_t *tcb_buffer_addr = &main_TCB;
c02061d0:	c7 c2 60 2c 29 c0    	mov    $0xc0292c60,%edx
c02061d6:	89 55 fc             	mov    %edx,-0x4(%ebp)
	tcb_buffer_addr->tid = 0;        //主线程的编号为0  
c02061d9:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02061dc:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
	tcb_buffer_addr->time_counter=0;
c02061e3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02061e6:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	tcb_buffer_addr->time_left=TIME_CONT;
c02061ed:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02061f0:	c7 42 0c 02 00 00 00 	movl   $0x2,0xc(%edx)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c02061f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c02061fa:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	tcb_buffer_addr->page_counte=0;   //主线程不会被回收内存 所以可以任意赋值
c0206201:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206204:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	tcb_buffer_addr->page_addr=0;
c020620b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c020620e:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	tcb_buffer_addr->next = tcb_buffer_addr;
c0206215:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206218:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c020621b:	89 4a 10             	mov    %ecx,0x10(%edx)
	tcb_buffer_addr->kern_stack_top=0;
c020621e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206221:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	cur_tcb = tcb_buffer_addr;
c0206227:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020622d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0206230:	89 10                	mov    %edx,(%eax)
}
c0206232:	90                   	nop
c0206233:	c9                   	leave  
c0206234:	c3                   	ret    

c0206235 <create_TCB>:

uint32_t create_TCB(uint32_t tid,uint32_t page_addr,uint32_t page_counte){
c0206235:	55                   	push   %ebp
c0206236:	89 e5                	mov    %esp,%ebp
c0206238:	83 ec 10             	sub    $0x10,%esp
c020623b:	e8 c0 0d 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206240:	05 c0 1d 00 00       	add    $0x1dc0,%eax
	TCB_t * tcb_buffer_addr = (TCB_t*)page_addr;
c0206245:	8b 45 0c             	mov    0xc(%ebp),%eax
c0206248:	89 45 fc             	mov    %eax,-0x4(%ebp)
	tcb_buffer_addr->tid = tid;         
c020624b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020624e:	8b 55 08             	mov    0x8(%ebp),%edx
c0206251:	89 50 14             	mov    %edx,0x14(%eax)
	tcb_buffer_addr->time_counter=0;
c0206254:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206257:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	tcb_buffer_addr->time_left=TIME_CONT;
c020625e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206261:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	tcb_buffer_addr->task_status = TASK_RUNNING;
c0206268:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020626b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	tcb_buffer_addr->page_counte=page_counte; 
c0206272:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206275:	8b 55 10             	mov    0x10(%ebp),%edx
c0206278:	89 50 18             	mov    %edx,0x18(%eax)
	tcb_buffer_addr->page_addr=page_addr;
c020627b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c020627e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0206281:	89 50 1c             	mov    %edx,0x1c(%eax)
	tcb_buffer_addr->kern_stack_top=page_addr+page_counte*4096;
c0206284:	8b 45 10             	mov    0x10(%ebp),%eax
c0206287:	c1 e0 0c             	shl    $0xc,%eax
c020628a:	89 c2                	mov    %eax,%edx
c020628c:	8b 45 0c             	mov    0xc(%ebp),%eax
c020628f:	01 d0                	add    %edx,%eax
c0206291:	89 c2                	mov    %eax,%edx
c0206293:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206296:	89 10                	mov    %edx,(%eax)
	return page_addr;
c0206298:	8b 45 0c             	mov    0xc(%ebp),%eax
}
c020629b:	c9                   	leave  
c020629c:	c3                   	ret    

c020629d <create_thread>:

void create_thread(uint32_t tid,thread_function *func,void *args,uint32_t addr,uint32_t page_counte){	
c020629d:	55                   	push   %ebp
c020629e:	89 e5                	mov    %esp,%ebp
c02062a0:	53                   	push   %ebx
c02062a1:	83 ec 10             	sub    $0x10,%esp
c02062a4:	e8 5b 0d 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02062a9:	81 c3 57 1d 00 00    	add    $0x1d57,%ebx
	asm volatile("cli");  //由于创建过程会使用到共享的数据 不使用锁的话会造成临界区错误 所以我们在此处关闭中断
c02062af:	fa                   	cli    
	TCB_t * new_tcb = create_TCB(tid,addr,page_counte);
c02062b0:	ff 75 18             	pushl  0x18(%ebp)
c02062b3:	ff 75 14             	pushl  0x14(%ebp)
c02062b6:	ff 75 08             	pushl  0x8(%ebp)
c02062b9:	e8 77 ff ff ff       	call   c0206235 <create_TCB>
c02062be:	83 c4 0c             	add    $0xc,%esp
c02062c1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	TCB_t * temp_next = cur_tcb->next;
c02062c4:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02062ca:	8b 00                	mov    (%eax),%eax
c02062cc:	8b 40 10             	mov    0x10(%eax),%eax
c02062cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cur_tcb->next = new_tcb;
c02062d2:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02062d8:	8b 00                	mov    (%eax),%eax
c02062da:	8b 55 f8             	mov    -0x8(%ebp),%edx
c02062dd:	89 50 10             	mov    %edx,0x10(%eax)
	new_tcb->next = temp_next;
c02062e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02062e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
c02062e6:	89 50 10             	mov    %edx,0x10(%eax)
	*(--new_tcb->kern_stack_top)=args;     //压入初始化的参数与线程执行函数
c02062e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02062ec:	8b 00                	mov    (%eax),%eax
c02062ee:	8d 50 fc             	lea    -0x4(%eax),%edx
c02062f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02062f4:	89 10                	mov    %edx,(%eax)
c02062f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
c02062f9:	8b 00                	mov    (%eax),%eax
c02062fb:	8b 55 10             	mov    0x10(%ebp),%edx
c02062fe:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=exit;
c0206300:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206303:	8b 00                	mov    (%eax),%eax
c0206305:	8d 50 fc             	lea    -0x4(%eax),%edx
c0206308:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020630b:	89 10                	mov    %edx,(%eax)
c020630d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206310:	8b 00                	mov    (%eax),%eax
c0206312:	8d 93 50 e4 ff ff    	lea    -0x1bb0(%ebx),%edx
c0206318:	89 10                	mov    %edx,(%eax)
	*(--new_tcb->kern_stack_top)=func;
c020631a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020631d:	8b 00                	mov    (%eax),%eax
c020631f:	8d 50 fc             	lea    -0x4(%eax),%edx
c0206322:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206325:	89 10                	mov    %edx,(%eax)
c0206327:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020632a:	8b 00                	mov    (%eax),%eax
c020632c:	8b 55 0c             	mov    0xc(%ebp),%edx
c020632f:	89 10                	mov    %edx,(%eax)
	new_tcb->context.eflags = 0x200;
c0206331:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206334:	c7 40 38 00 02 00 00 	movl   $0x200,0x38(%eax)
	new_tcb->context.esp =new_tcb->kern_stack_top;
c020633b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c020633e:	8b 00                	mov    (%eax),%eax
c0206340:	89 c2                	mov    %eax,%edx
c0206342:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0206345:	89 50 3c             	mov    %edx,0x3c(%eax)
	asm volatile("sti");	
c0206348:	fb                   	sti    
}
c0206349:	90                   	nop
c020634a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020634d:	c9                   	leave  
c020634e:	c3                   	ret    

c020634f <schedule>:

void schedule(){      //调度函数  检测时间片为0时调用此函数
c020634f:	55                   	push   %ebp
c0206350:	89 e5                	mov    %esp,%ebp
c0206352:	53                   	push   %ebx
c0206353:	83 ec 14             	sub    $0x14,%esp
c0206356:	e8 a9 0c 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020635b:	81 c3 a5 1c 00 00    	add    $0x1ca5,%ebx
	if(cur_tcb->next==cur_tcb){
c0206361:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206367:	8b 00                	mov    (%eax),%eax
c0206369:	8b 50 10             	mov    0x10(%eax),%edx
c020636c:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206372:	8b 00                	mov    (%eax),%eax
c0206374:	39 c2                	cmp    %eax,%edx
c0206376:	75 11                	jne    c0206389 <schedule+0x3a>
		cur_tcb->time_left = TIME_CONT;    //如果只有一个线程 就再次给此线程添加时间片
c0206378:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020637e:	8b 00                	mov    (%eax),%eax
c0206380:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
		return ;
c0206387:	eb 4c                	jmp    c02063d5 <schedule+0x86>
	}
	TCB_t *now = cur_tcb;
c0206389:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020638f:	8b 00                	mov    (%eax),%eax
c0206391:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0206394:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020639a:	8b 00                	mov    (%eax),%eax
c020639c:	8b 40 10             	mov    0x10(%eax),%eax
c020639f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c02063a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02063a5:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	cur_tcb = next_tcb;
c02063ac:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c02063b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c02063b5:	89 10                	mov    %edx,(%eax)
	get_esp();      //有一个隐藏bug 需要call刷新寄存器
c02063b7:	e8 a4 ce ff ff       	call   c0203260 <get_esp>
	switch_to(&(now->context),&(next_tcb->context));      
c02063bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02063bf:	8d 50 20             	lea    0x20(%eax),%edx
c02063c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02063c5:	83 c0 20             	add    $0x20,%eax
c02063c8:	83 ec 08             	sub    $0x8,%esp
c02063cb:	52                   	push   %edx
c02063cc:	50                   	push   %eax
c02063cd:	e8 94 ce ff ff       	call   c0203266 <switch_to>
c02063d2:	83 c4 10             	add    $0x10,%esp
}
c02063d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02063d8:	c9                   	leave  
c02063d9:	c3                   	ret    

c02063da <remove_thread>:

void remove_thread(){
c02063da:	55                   	push   %ebp
c02063db:	89 e5                	mov    %esp,%ebp
c02063dd:	53                   	push   %ebx
c02063de:	83 ec 14             	sub    $0x14,%esp
c02063e1:	e8 1a 0c 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02063e6:	05 1a 1c 00 00       	add    $0x1c1a,%eax
	asm volatile("cli");
c02063eb:	fa                   	cli    
	if(cur_tcb->tid==0)
c02063ec:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c02063f2:	8b 12                	mov    (%edx),%edx
c02063f4:	8b 52 14             	mov    0x14(%edx),%edx
c02063f7:	85 d2                	test   %edx,%edx
c02063f9:	75 16                	jne    c0206411 <remove_thread+0x37>
		printk("ERRO:main thread can`t use function exit\n");
c02063fb:	83 ec 0c             	sub    $0xc,%esp
c02063fe:	8d 90 7c 02 00 00    	lea    0x27c(%eax),%edx
c0206404:	52                   	push   %edx
c0206405:	89 c3                	mov    %eax,%ebx
c0206407:	e8 4a d4 ff ff       	call   c0203856 <printk>
c020640c:	83 c4 10             	add    $0x10,%esp
		TCB_t *temp = cur_tcb;
		for(;temp->next!=cur_tcb;temp=temp->next)
			;
		temp->next = cur_tcb->next;
	}
}
c020640f:	eb 39                	jmp    c020644a <remove_thread+0x70>
		TCB_t *temp = cur_tcb;
c0206411:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0206417:	8b 12                	mov    (%edx),%edx
c0206419:	89 55 f4             	mov    %edx,-0xc(%ebp)
		for(;temp->next!=cur_tcb;temp=temp->next)
c020641c:	eb 09                	jmp    c0206427 <remove_thread+0x4d>
c020641e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0206421:	8b 52 10             	mov    0x10(%edx),%edx
c0206424:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0206427:	8b 55 f4             	mov    -0xc(%ebp),%edx
c020642a:	8b 4a 10             	mov    0x10(%edx),%ecx
c020642d:	c7 c2 40 2c 29 c0    	mov    $0xc0292c40,%edx
c0206433:	8b 12                	mov    (%edx),%edx
c0206435:	39 d1                	cmp    %edx,%ecx
c0206437:	75 e5                	jne    c020641e <remove_thread+0x44>
		temp->next = cur_tcb->next;
c0206439:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020643f:	8b 00                	mov    (%eax),%eax
c0206441:	8b 50 10             	mov    0x10(%eax),%edx
c0206444:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206447:	89 50 10             	mov    %edx,0x10(%eax)
}
c020644a:	90                   	nop
c020644b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c020644e:	c9                   	leave  
c020644f:	c3                   	ret    

c0206450 <exit>:

void exit(){
c0206450:	55                   	push   %ebp
c0206451:	89 e5                	mov    %esp,%ebp
c0206453:	53                   	push   %ebx
c0206454:	83 ec 14             	sub    $0x14,%esp
c0206457:	e8 a8 0b 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020645c:	81 c3 a4 1b 00 00    	add    $0x1ba4,%ebx
	remove_thread();
c0206462:	e8 73 ff ff ff       	call   c02063da <remove_thread>
	TCB_t *now = cur_tcb;
c0206467:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020646d:	8b 00                	mov    (%eax),%eax
c020646f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	TCB_t *next_tcb = cur_tcb->next;
c0206472:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206478:	8b 00                	mov    (%eax),%eax
c020647a:	8b 40 10             	mov    0x10(%eax),%eax
c020647d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	next_tcb->time_left = TIME_CONT;
c0206480:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0206483:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	cur_tcb = cur_tcb->next;
c020648a:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c0206490:	8b 00                	mov    (%eax),%eax
c0206492:	8b 50 10             	mov    0x10(%eax),%edx
c0206495:	c7 c0 40 2c 29 c0    	mov    $0xc0292c40,%eax
c020649b:	89 10                	mov    %edx,(%eax)
	switch_to(&(now->context),&(next_tcb->context));
c020649d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02064a0:	8d 50 20             	lea    0x20(%eax),%edx
c02064a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c02064a6:	83 c0 20             	add    $0x20,%eax
c02064a9:	83 ec 08             	sub    $0x8,%esp
c02064ac:	52                   	push   %edx
c02064ad:	50                   	push   %eax
c02064ae:	e8 b3 cd ff ff       	call   c0203266 <switch_to>
c02064b3:	83 c4 10             	add    $0x10,%esp
	//注意 暂时没有回收此线程页
}
c02064b6:	90                   	nop
c02064b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02064ba:	c9                   	leave  
c02064bb:	c3                   	ret    

c02064bc <get_kern_used_page_count>:
//内核已使用的页数量(1MB以下也是已使用的部分)

bitmap kern_vmm_pool;


static int get_kern_used_page_count(){
c02064bc:	55                   	push   %ebp
c02064bd:	89 e5                	mov    %esp,%ebp
c02064bf:	83 ec 10             	sub    $0x10,%esp
c02064c2:	e8 39 0b 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02064c7:	05 39 1b 00 00       	add    $0x1b39,%eax
    uint32_t size_bytes = kern_end-0;
c02064cc:	c7 c0 00 d0 29 00    	mov    $0x29d000,%eax
c02064d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return (size_bytes+PAGE_SIZE-1)/PAGE_SIZE;     //向上取整
c02064d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c02064d8:	05 ff 0f 00 00       	add    $0xfff,%eax
c02064dd:	c1 e8 0c             	shr    $0xc,%eax
}
c02064e0:	c9                   	leave  
c02064e1:	c3                   	ret    

c02064e2 <kern_vmm_init>:

//初始化内核虚拟空间
//预分配已使用内核空间
static void kern_vmm_init(){    
c02064e2:	55                   	push   %ebp
c02064e3:	89 e5                	mov    %esp,%ebp
c02064e5:	53                   	push   %ebx
c02064e6:	83 ec 24             	sub    $0x24,%esp
c02064e9:	e8 16 0b 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02064ee:	81 c3 12 1b 00 00    	add    $0x1b12,%ebx
    kern_vmm_pool.target_addr_header = 0xC0000000;   //内核空间起始地址
c02064f4:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02064fa:	c7 40 08 00 00 00 c0 	movl   $0xc0000000,0x8(%eax)
    kern_vmm_pool.length = 0x8000;     //总共1GB空间
c0206501:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c0206507:	c7 40 04 00 80 00 00 	movl   $0x8000,0x4(%eax)
    kern_vmm_pool.vaddr_header = kern_bitmap;
c020650e:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c0206514:	8b 10                	mov    (%eax),%edx
c0206516:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020651c:	89 10                	mov    %edx,(%eax)

    bitmap_init_mem(kern_vmm_pool);
c020651e:	83 ec 04             	sub    $0x4,%esp
c0206521:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c0206527:	ff 70 08             	pushl  0x8(%eax)
c020652a:	ff 70 04             	pushl  0x4(%eax)
c020652d:	ff 30                	pushl  (%eax)
c020652f:	e8 8f dd ff ff       	call   c02042c3 <bitmap_init_mem>
c0206534:	83 c4 10             	add    $0x10,%esp
    int page_used = get_kern_used_page_count();
c0206537:	e8 80 ff ff ff       	call   c02064bc <get_kern_used_page_count>
c020653c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(page_used>1024){
c020653f:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
c0206546:	7e 14                	jle    c020655c <kern_vmm_init+0x7a>
        printk("\nERRO!don`t have enough vm page for kernel when init!\n");
c0206548:	83 ec 0c             	sub    $0xc,%esp
c020654b:	8d 83 a8 02 00 00    	lea    0x2a8(%ebx),%eax
c0206551:	50                   	push   %eax
c0206552:	e8 ff d2 ff ff       	call   c0203856 <printk>
c0206557:	83 c4 10             	add    $0x10,%esp
        while (True){
c020655a:	eb fe                	jmp    c020655a <kern_vmm_init+0x78>
            //内核暂停
        }
    }
    for(int i = 0; i<page_used ;i++){
c020655c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0206563:	eb 20                	jmp    c0206585 <kern_vmm_init+0xa3>
        uint32_t rem = bitmap_alloc(kern_vmm_pool); //将内核空间在内存池中置为繁忙   此处可做性能优化
c0206565:	83 ec 04             	sub    $0x4,%esp
c0206568:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020656e:	ff 70 08             	pushl  0x8(%eax)
c0206571:	ff 70 04             	pushl  0x4(%eax)
c0206574:	ff 30                	pushl  (%eax)
c0206576:	e8 0f df ff ff       	call   c020448a <bitmap_alloc>
c020657b:	83 c4 10             	add    $0x10,%esp
c020657e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(int i = 0; i<page_used ;i++){
c0206581:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0206585:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206588:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c020658b:	7c d8                	jl     c0206565 <kern_vmm_init+0x83>
    }    
    //将内核虚拟内存管理页（最后1024页）在内存池中置为繁忙
    //1024页占用128字节 所以要将bitmap最后128字节清零
    int temp_cnt =0;
c020658d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c0206594:	c7 c0 08 70 20 c0    	mov    $0xc0207008,%eax
c020659a:	8b 00                	mov    (%eax),%eax
c020659c:	05 ff 7f 00 00       	add    $0x7fff,%eax
c02065a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
c02065a4:	eb 0e                	jmp    c02065b4 <kern_vmm_init+0xd2>
        *((byte*)probe) = 0;
c02065a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c02065a9:	c6 00 00             	movb   $0x0,(%eax)
    for( uint32_t probe = kern_bitmap+0x8000-1;temp_cnt<128;temp_cnt++,probe--){
c02065ac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c02065b0:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
c02065b4:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
c02065b8:	7e ec                	jle    c02065a6 <kern_vmm_init+0xc4>
    }
}
c02065ba:	90                   	nop
c02065bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02065be:	c9                   	leave  
c02065bf:	c3                   	ret    

c02065c0 <vmm_init>:

void vmm_init(){
c02065c0:	55                   	push   %ebp
c02065c1:	89 e5                	mov    %esp,%ebp
c02065c3:	83 ec 08             	sub    $0x8,%esp
c02065c6:	e8 35 0a 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02065cb:	05 35 1a 00 00       	add    $0x1a35,%eax
       kern_vmm_init(); 
c02065d0:	e8 0d ff ff ff       	call   c02064e2 <kern_vmm_init>
}
c02065d5:	90                   	nop
c02065d6:	c9                   	leave  
c02065d7:	c3                   	ret    

c02065d8 <vmm_get_page_vaddr_by_target>:

static uint32_t vmm_get_page_vaddr_by_target(uint32_t target){
c02065d8:	55                   	push   %ebp
c02065d9:	89 e5                	mov    %esp,%ebp
c02065db:	83 ec 10             	sub    $0x10,%esp
c02065de:	e8 1d 0a 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02065e3:	05 1d 1a 00 00       	add    $0x1a1d,%eax
    target = target&0xFFFFF000;
c02065e8:	81 65 08 00 f0 ff ff 	andl   $0xfffff000,0x8(%ebp)
    uint32_t addr_high10 = 0x3FF<<22;     //高10位
c02065ef:	c7 45 fc 00 00 c0 ff 	movl   $0xffc00000,-0x4(%ebp)
    uint32_t addr_middle10 = (target>>10) & 0x003FF000;//中间10位为target高10位
c02065f6:	8b 45 08             	mov    0x8(%ebp),%eax
c02065f9:	c1 e8 0a             	shr    $0xa,%eax
c02065fc:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0206601:	89 45 f8             	mov    %eax,-0x8(%ebp)
    uint32_t addr_low12 = ((target>>12)&0x3FF)*4;//低12位为target中间10位×4
c0206604:	8b 45 08             	mov    0x8(%ebp),%eax
c0206607:	c1 e8 0c             	shr    $0xc,%eax
c020660a:	25 ff 03 00 00       	and    $0x3ff,%eax
c020660f:	c1 e0 02             	shl    $0x2,%eax
c0206612:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr_high10|addr_middle10|addr_low12;
c0206615:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0206618:	0b 45 f8             	or     -0x8(%ebp),%eax
c020661b:	0b 45 f4             	or     -0xc(%ebp),%eax
}
c020661e:	c9                   	leave  
c020661f:	c3                   	ret    

c0206620 <vmm_kern_alloc_one_page>:
//修改页表时的地址结构：
//      1111111111_xxxxxxxxxx_xxxxxxxxxx
//前十位为1表示页目录表最后一项 指向页目录表起始地址
// 中间十位表示在1024项页目录表中的索引
//最后12位表示在页表中的索引（每张页表1024项 共4096B 也就是12位可表达的最大范围）
uint32_t vmm_kern_alloc_one_page(uint32_t target){
c0206620:	55                   	push   %ebp
c0206621:	89 e5                	mov    %esp,%ebp
c0206623:	53                   	push   %ebx
c0206624:	83 ec 24             	sub    $0x24,%esp
c0206627:	e8 d8 09 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c020662c:	81 c3 d4 19 00 00    	add    $0x19d4,%ebx
    uint32_t vaddr_get=bitmap_alloc_one_page(kern_vmm_pool,target);
c0206632:	ff 75 08             	pushl  0x8(%ebp)
c0206635:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c020663b:	ff 70 08             	pushl  0x8(%eax)
c020663e:	ff 70 04             	pushl  0x4(%eax)
c0206641:	ff 30                	pushl  (%eax)
c0206643:	e8 ba dc ff ff       	call   c0204302 <bitmap_alloc_one_page>
c0206648:	83 c4 10             	add    $0x10,%esp
c020664b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c020664e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0206652:	75 19                	jne    c020666d <vmm_kern_alloc_one_page+0x4d>
        printk("1\n");
c0206654:	83 ec 0c             	sub    $0xc,%esp
c0206657:	8d 83 df 02 00 00    	lea    0x2df(%ebx),%eax
c020665d:	50                   	push   %eax
c020665e:	e8 f3 d1 ff ff       	call   c0203856 <printk>
c0206663:	83 c4 10             	add    $0x10,%esp
        return VMM_ALLOC_ERRO;
c0206666:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020666b:	eb 59                	jmp    c02066c6 <vmm_kern_alloc_one_page+0xa6>
    }            
    else{
        uint32_t page_desc_vaddr = vmm_get_page_vaddr_by_target(target);
c020666d:	83 ec 0c             	sub    $0xc,%esp
c0206670:	ff 75 08             	pushl  0x8(%ebp)
c0206673:	e8 60 ff ff ff       	call   c02065d8 <vmm_get_page_vaddr_by_target>
c0206678:	83 c4 10             	add    $0x10,%esp
c020667b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        pm_alloc_t phy_page = pmm_alloc_one_page();
c020667e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0206681:	83 ec 0c             	sub    $0xc,%esp
c0206684:	50                   	push   %eax
c0206685:	e8 62 ed ff ff       	call   c02053ec <pmm_alloc_one_page>
c020668a:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c020668d:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0206691:	84 c0                	test   %al,%al
c0206693:	75 19                	jne    c02066ae <vmm_kern_alloc_one_page+0x8e>
            //没有可用的物理页
        printk("2\n"); 
c0206695:	83 ec 0c             	sub    $0xc,%esp
c0206698:	8d 83 e2 02 00 00    	lea    0x2e2(%ebx),%eax
c020669e:	50                   	push   %eax
c020669f:	e8 b2 d1 ff ff       	call   c0203856 <printk>
c02066a4:	83 c4 10             	add    $0x10,%esp
            return VMM_ALLOC_ERRO;
c02066a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c02066ac:	eb 18                	jmp    c02066c6 <vmm_kern_alloc_one_page+0xa6>
        }
        //修改页表
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c02066ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c02066b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c02066b6:	89 c2                	mov    %eax,%edx
c02066b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c02066bb:	81 c2 03 01 00 00    	add    $0x103,%edx
c02066c1:	89 10                	mov    %edx,(%eax)
        return target;
c02066c3:	8b 45 08             	mov    0x8(%ebp),%eax
    }
    
}
c02066c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02066c9:	c9                   	leave  
c02066ca:	c3                   	ret    

c02066cb <vmm_kern_alloc>:

uint32_t vmm_kern_alloc(){
c02066cb:	55                   	push   %ebp
c02066cc:	89 e5                	mov    %esp,%ebp
c02066ce:	53                   	push   %ebx
c02066cf:	83 ec 24             	sub    $0x24,%esp
c02066d2:	e8 2d 09 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02066d7:	81 c3 29 19 00 00    	add    $0x1929,%ebx
    uint32_t target = bitmap_alloc(kern_vmm_pool);
c02066dd:	83 ec 04             	sub    $0x4,%esp
c02066e0:	c7 c0 a0 2c 29 c0    	mov    $0xc0292ca0,%eax
c02066e6:	ff 70 08             	pushl  0x8(%eax)
c02066e9:	ff 70 04             	pushl  0x4(%eax)
c02066ec:	ff 30                	pushl  (%eax)
c02066ee:	e8 97 dd ff ff       	call   c020448a <bitmap_alloc>
c02066f3:	83 c4 10             	add    $0x10,%esp
c02066f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (target == BITMAP_RETURN_ERRO){
c02066f9:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c02066fd:	75 07                	jne    c0206706 <vmm_kern_alloc+0x3b>
        return VMM_ALLOC_ERRO;
c02066ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0206704:	eb 7e                	jmp    c0206784 <vmm_kern_alloc+0xb9>
    }
    uint32_t vaddr_get = target;
c0206706:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0206709:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(vaddr_get == BITMAP_RETURN_ERRO){
c020670c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0206710:	75 19                	jne    c020672b <vmm_kern_alloc+0x60>
        printk("1\n");
c0206712:	83 ec 0c             	sub    $0xc,%esp
c0206715:	8d 83 df 02 00 00    	lea    0x2df(%ebx),%eax
c020671b:	50                   	push   %eax
c020671c:	e8 35 d1 ff ff       	call   c0203856 <printk>
c0206721:	83 c4 10             	add    $0x10,%esp
        return VMM_ALLOC_ERRO;
c0206724:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0206729:	eb 59                	jmp    c0206784 <vmm_kern_alloc+0xb9>
    }            
    else{
        uint32_t page_desc_vaddr = vmm_get_page_vaddr_by_target(target);
c020672b:	83 ec 0c             	sub    $0xc,%esp
c020672e:	ff 75 f4             	pushl  -0xc(%ebp)
c0206731:	e8 a2 fe ff ff       	call   c02065d8 <vmm_get_page_vaddr_by_target>
c0206736:	83 c4 10             	add    $0x10,%esp
c0206739:	89 45 ec             	mov    %eax,-0x14(%ebp)
        pm_alloc_t phy_page = pmm_alloc_one_page();
c020673c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c020673f:	83 ec 0c             	sub    $0xc,%esp
c0206742:	50                   	push   %eax
c0206743:	e8 a4 ec ff ff       	call   c02053ec <pmm_alloc_one_page>
c0206748:	83 c4 0c             	add    $0xc,%esp
        if(phy_page.state == 0){
c020674b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c020674f:	84 c0                	test   %al,%al
c0206751:	75 19                	jne    c020676c <vmm_kern_alloc+0xa1>
            //没有可用的物理页
        printk("2\n"); 
c0206753:	83 ec 0c             	sub    $0xc,%esp
c0206756:	8d 83 e2 02 00 00    	lea    0x2e2(%ebx),%eax
c020675c:	50                   	push   %eax
c020675d:	e8 f4 d0 ff ff       	call   c0203856 <printk>
c0206762:	83 c4 10             	add    $0x10,%esp
            return VMM_ALLOC_ERRO;
c0206765:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c020676a:	eb 18                	jmp    c0206784 <vmm_kern_alloc+0xb9>
        }
        //修改页表
        *((uint32_t*)page_desc_vaddr) = (phy_page.addr&0xFFFFF000)+PAGE_DESC_RW_W+PAGE_DESC_US_S+PAGE_DESC_G+PAGE_DESC_P;
c020676c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c020676f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0206774:	89 c2                	mov    %eax,%edx
c0206776:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0206779:	81 c2 03 01 00 00    	add    $0x103,%edx
c020677f:	89 10                	mov    %edx,(%eax)
        return target;
c0206781:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0206784:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0206787:	c9                   	leave  
c0206788:	c3                   	ret    

c0206789 <vmm_kern_release_one_page>:

void vmm_kern_release_one_page(uint32_t target){
c0206789:	55                   	push   %ebp
c020678a:	89 e5                	mov    %esp,%ebp
c020678c:	e8 6f 08 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c0206791:	05 6f 18 00 00       	add    $0x186f,%eax

}
c0206796:	90                   	nop
c0206797:	5d                   	pop    %ebp
c0206798:	c3                   	ret    

c0206799 <user_vmm_init>:

static void user_vmm_init(){
c0206799:	55                   	push   %ebp
c020679a:	89 e5                	mov    %esp,%ebp
c020679c:	e8 5f 08 00 00       	call   c0207000 <__x86.get_pc_thunk.ax>
c02067a1:	05 5f 18 00 00       	add    $0x185f,%eax

}
c02067a6:	90                   	nop
c02067a7:	5d                   	pop    %ebp
c02067a8:	c3                   	ret    

c02067a9 <vmm_test>:

void vmm_test(){
c02067a9:	55                   	push   %ebp
c02067aa:	89 e5                	mov    %esp,%ebp
c02067ac:	53                   	push   %ebx
c02067ad:	83 ec 14             	sub    $0x14,%esp
c02067b0:	e8 4f 08 00 00       	call   c0207004 <__x86.get_pc_thunk.bx>
c02067b5:	81 c3 4b 18 00 00    	add    $0x184b,%ebx
    vmm_init();
c02067bb:	e8 00 fe ff ff       	call   c02065c0 <vmm_init>
    uint32_t re = vmm_kern_alloc();
c02067c0:	e8 06 ff ff ff       	call   c02066cb <vmm_kern_alloc>
c02067c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    printk("get:0x%h\n",re);
c02067c8:	83 ec 08             	sub    $0x8,%esp
c02067cb:	ff 75 f4             	pushl  -0xc(%ebp)
c02067ce:	8d 83 e5 02 00 00    	lea    0x2e5(%ebx),%eax
c02067d4:	50                   	push   %eax
c02067d5:	e8 7c d0 ff ff       	call   c0203856 <printk>
c02067da:	83 c4 10             	add    $0x10,%esp
c02067dd:	90                   	nop
c02067de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c02067e1:	c9                   	leave  
c02067e2:	c3                   	ret    
c02067e3:	66 90                	xchg   %ax,%ax
c02067e5:	66 90                	xchg   %ax,%ax
c02067e7:	66 90                	xchg   %ax,%ax
c02067e9:	66 90                	xchg   %ax,%ax
c02067eb:	66 90                	xchg   %ax,%ax
c02067ed:	66 90                	xchg   %ax,%ax
c02067ef:	66 90                	xchg   %ax,%ax
c02067f1:	66 90                	xchg   %ax,%ax
c02067f3:	66 90                	xchg   %ax,%ax
c02067f5:	66 90                	xchg   %ax,%ax
c02067f7:	66 90                	xchg   %ax,%ax
c02067f9:	66 90                	xchg   %ax,%ax
c02067fb:	66 90                	xchg   %ax,%ax
c02067fd:	66 90                	xchg   %ax,%ax
c02067ff:	66 90                	xchg   %ax,%ax
c0206801:	66 90                	xchg   %ax,%ax
c0206803:	66 90                	xchg   %ax,%ax
c0206805:	66 90                	xchg   %ax,%ax
c0206807:	66 90                	xchg   %ax,%ax
c0206809:	66 90                	xchg   %ax,%ax
c020680b:	66 90                	xchg   %ax,%ax
c020680d:	66 90                	xchg   %ax,%ax
c020680f:	66 90                	xchg   %ax,%ax
c0206811:	66 90                	xchg   %ax,%ax
c0206813:	66 90                	xchg   %ax,%ax
c0206815:	66 90                	xchg   %ax,%ax
c0206817:	66 90                	xchg   %ax,%ax
c0206819:	66 90                	xchg   %ax,%ax
c020681b:	66 90                	xchg   %ax,%ax
c020681d:	66 90                	xchg   %ax,%ax
c020681f:	66 90                	xchg   %ax,%ax
c0206821:	66 90                	xchg   %ax,%ax
c0206823:	66 90                	xchg   %ax,%ax
c0206825:	66 90                	xchg   %ax,%ax
c0206827:	66 90                	xchg   %ax,%ax
c0206829:	66 90                	xchg   %ax,%ax
c020682b:	66 90                	xchg   %ax,%ax
c020682d:	66 90                	xchg   %ax,%ax
c020682f:	66 90                	xchg   %ax,%ax
c0206831:	66 90                	xchg   %ax,%ax
c0206833:	66 90                	xchg   %ax,%ax
c0206835:	66 90                	xchg   %ax,%ax
c0206837:	66 90                	xchg   %ax,%ax
c0206839:	66 90                	xchg   %ax,%ax
c020683b:	66 90                	xchg   %ax,%ax
c020683d:	66 90                	xchg   %ax,%ax
c020683f:	66 90                	xchg   %ax,%ax
c0206841:	66 90                	xchg   %ax,%ax
c0206843:	66 90                	xchg   %ax,%ax
c0206845:	66 90                	xchg   %ax,%ax
c0206847:	66 90                	xchg   %ax,%ax
c0206849:	66 90                	xchg   %ax,%ax
c020684b:	66 90                	xchg   %ax,%ax
c020684d:	66 90                	xchg   %ax,%ax
c020684f:	66 90                	xchg   %ax,%ax
c0206851:	66 90                	xchg   %ax,%ax
c0206853:	66 90                	xchg   %ax,%ax
c0206855:	66 90                	xchg   %ax,%ax
c0206857:	66 90                	xchg   %ax,%ax
c0206859:	66 90                	xchg   %ax,%ax
c020685b:	66 90                	xchg   %ax,%ax
c020685d:	66 90                	xchg   %ax,%ax
c020685f:	66 90                	xchg   %ax,%ax
c0206861:	66 90                	xchg   %ax,%ax
c0206863:	66 90                	xchg   %ax,%ax
c0206865:	66 90                	xchg   %ax,%ax
c0206867:	66 90                	xchg   %ax,%ax
c0206869:	66 90                	xchg   %ax,%ax
c020686b:	66 90                	xchg   %ax,%ax
c020686d:	66 90                	xchg   %ax,%ax
c020686f:	66 90                	xchg   %ax,%ax
c0206871:	66 90                	xchg   %ax,%ax
c0206873:	66 90                	xchg   %ax,%ax
c0206875:	66 90                	xchg   %ax,%ax
c0206877:	66 90                	xchg   %ax,%ax
c0206879:	66 90                	xchg   %ax,%ax
c020687b:	66 90                	xchg   %ax,%ax
c020687d:	66 90                	xchg   %ax,%ax
c020687f:	66 90                	xchg   %ax,%ax
c0206881:	66 90                	xchg   %ax,%ax
c0206883:	66 90                	xchg   %ax,%ax
c0206885:	66 90                	xchg   %ax,%ax
c0206887:	66 90                	xchg   %ax,%ax
c0206889:	66 90                	xchg   %ax,%ax
c020688b:	66 90                	xchg   %ax,%ax
c020688d:	66 90                	xchg   %ax,%ax
c020688f:	66 90                	xchg   %ax,%ax
c0206891:	66 90                	xchg   %ax,%ax
c0206893:	66 90                	xchg   %ax,%ax
c0206895:	66 90                	xchg   %ax,%ax
c0206897:	66 90                	xchg   %ax,%ax
c0206899:	66 90                	xchg   %ax,%ax
c020689b:	66 90                	xchg   %ax,%ax
c020689d:	66 90                	xchg   %ax,%ax
c020689f:	66 90                	xchg   %ax,%ax
c02068a1:	66 90                	xchg   %ax,%ax
c02068a3:	66 90                	xchg   %ax,%ax
c02068a5:	66 90                	xchg   %ax,%ax
c02068a7:	66 90                	xchg   %ax,%ax
c02068a9:	66 90                	xchg   %ax,%ax
c02068ab:	66 90                	xchg   %ax,%ax
c02068ad:	66 90                	xchg   %ax,%ax
c02068af:	66 90                	xchg   %ax,%ax
c02068b1:	66 90                	xchg   %ax,%ax
c02068b3:	66 90                	xchg   %ax,%ax
c02068b5:	66 90                	xchg   %ax,%ax
c02068b7:	66 90                	xchg   %ax,%ax
c02068b9:	66 90                	xchg   %ax,%ax
c02068bb:	66 90                	xchg   %ax,%ax
c02068bd:	66 90                	xchg   %ax,%ax
c02068bf:	66 90                	xchg   %ax,%ax
c02068c1:	66 90                	xchg   %ax,%ax
c02068c3:	66 90                	xchg   %ax,%ax
c02068c5:	66 90                	xchg   %ax,%ax
c02068c7:	66 90                	xchg   %ax,%ax
c02068c9:	66 90                	xchg   %ax,%ax
c02068cb:	66 90                	xchg   %ax,%ax
c02068cd:	66 90                	xchg   %ax,%ax
c02068cf:	66 90                	xchg   %ax,%ax
c02068d1:	66 90                	xchg   %ax,%ax
c02068d3:	66 90                	xchg   %ax,%ax
c02068d5:	66 90                	xchg   %ax,%ax
c02068d7:	66 90                	xchg   %ax,%ax
c02068d9:	66 90                	xchg   %ax,%ax
c02068db:	66 90                	xchg   %ax,%ax
c02068dd:	66 90                	xchg   %ax,%ax
c02068df:	66 90                	xchg   %ax,%ax
c02068e1:	66 90                	xchg   %ax,%ax
c02068e3:	66 90                	xchg   %ax,%ax
c02068e5:	66 90                	xchg   %ax,%ax
c02068e7:	66 90                	xchg   %ax,%ax
c02068e9:	66 90                	xchg   %ax,%ax
c02068eb:	66 90                	xchg   %ax,%ax
c02068ed:	66 90                	xchg   %ax,%ax
c02068ef:	66 90                	xchg   %ax,%ax
c02068f1:	66 90                	xchg   %ax,%ax
c02068f3:	66 90                	xchg   %ax,%ax
c02068f5:	66 90                	xchg   %ax,%ax
c02068f7:	66 90                	xchg   %ax,%ax
c02068f9:	66 90                	xchg   %ax,%ax
c02068fb:	66 90                	xchg   %ax,%ax
c02068fd:	66 90                	xchg   %ax,%ax
c02068ff:	66 90                	xchg   %ax,%ax
c0206901:	66 90                	xchg   %ax,%ax
c0206903:	66 90                	xchg   %ax,%ax
c0206905:	66 90                	xchg   %ax,%ax
c0206907:	66 90                	xchg   %ax,%ax
c0206909:	66 90                	xchg   %ax,%ax
c020690b:	66 90                	xchg   %ax,%ax
c020690d:	66 90                	xchg   %ax,%ax
c020690f:	66 90                	xchg   %ax,%ax
c0206911:	66 90                	xchg   %ax,%ax
c0206913:	66 90                	xchg   %ax,%ax
c0206915:	66 90                	xchg   %ax,%ax
c0206917:	66 90                	xchg   %ax,%ax
c0206919:	66 90                	xchg   %ax,%ax
c020691b:	66 90                	xchg   %ax,%ax
c020691d:	66 90                	xchg   %ax,%ax
c020691f:	66 90                	xchg   %ax,%ax
c0206921:	66 90                	xchg   %ax,%ax
c0206923:	66 90                	xchg   %ax,%ax
c0206925:	66 90                	xchg   %ax,%ax
c0206927:	66 90                	xchg   %ax,%ax
c0206929:	66 90                	xchg   %ax,%ax
c020692b:	66 90                	xchg   %ax,%ax
c020692d:	66 90                	xchg   %ax,%ax
c020692f:	66 90                	xchg   %ax,%ax
c0206931:	66 90                	xchg   %ax,%ax
c0206933:	66 90                	xchg   %ax,%ax
c0206935:	66 90                	xchg   %ax,%ax
c0206937:	66 90                	xchg   %ax,%ax
c0206939:	66 90                	xchg   %ax,%ax
c020693b:	66 90                	xchg   %ax,%ax
c020693d:	66 90                	xchg   %ax,%ax
c020693f:	66 90                	xchg   %ax,%ax
c0206941:	66 90                	xchg   %ax,%ax
c0206943:	66 90                	xchg   %ax,%ax
c0206945:	66 90                	xchg   %ax,%ax
c0206947:	66 90                	xchg   %ax,%ax
c0206949:	66 90                	xchg   %ax,%ax
c020694b:	66 90                	xchg   %ax,%ax
c020694d:	66 90                	xchg   %ax,%ax
c020694f:	66 90                	xchg   %ax,%ax
c0206951:	66 90                	xchg   %ax,%ax
c0206953:	66 90                	xchg   %ax,%ax
c0206955:	66 90                	xchg   %ax,%ax
c0206957:	66 90                	xchg   %ax,%ax
c0206959:	66 90                	xchg   %ax,%ax
c020695b:	66 90                	xchg   %ax,%ax
c020695d:	66 90                	xchg   %ax,%ax
c020695f:	66 90                	xchg   %ax,%ax
c0206961:	66 90                	xchg   %ax,%ax
c0206963:	66 90                	xchg   %ax,%ax
c0206965:	66 90                	xchg   %ax,%ax
c0206967:	66 90                	xchg   %ax,%ax
c0206969:	66 90                	xchg   %ax,%ax
c020696b:	66 90                	xchg   %ax,%ax
c020696d:	66 90                	xchg   %ax,%ax
c020696f:	66 90                	xchg   %ax,%ax
c0206971:	66 90                	xchg   %ax,%ax
c0206973:	66 90                	xchg   %ax,%ax
c0206975:	66 90                	xchg   %ax,%ax
c0206977:	66 90                	xchg   %ax,%ax
c0206979:	66 90                	xchg   %ax,%ax
c020697b:	66 90                	xchg   %ax,%ax
c020697d:	66 90                	xchg   %ax,%ax
c020697f:	66 90                	xchg   %ax,%ax
c0206981:	66 90                	xchg   %ax,%ax
c0206983:	66 90                	xchg   %ax,%ax
c0206985:	66 90                	xchg   %ax,%ax
c0206987:	66 90                	xchg   %ax,%ax
c0206989:	66 90                	xchg   %ax,%ax
c020698b:	66 90                	xchg   %ax,%ax
c020698d:	66 90                	xchg   %ax,%ax
c020698f:	66 90                	xchg   %ax,%ax
c0206991:	66 90                	xchg   %ax,%ax
c0206993:	66 90                	xchg   %ax,%ax
c0206995:	66 90                	xchg   %ax,%ax
c0206997:	66 90                	xchg   %ax,%ax
c0206999:	66 90                	xchg   %ax,%ax
c020699b:	66 90                	xchg   %ax,%ax
c020699d:	66 90                	xchg   %ax,%ax
c020699f:	66 90                	xchg   %ax,%ax
c02069a1:	66 90                	xchg   %ax,%ax
c02069a3:	66 90                	xchg   %ax,%ax
c02069a5:	66 90                	xchg   %ax,%ax
c02069a7:	66 90                	xchg   %ax,%ax
c02069a9:	66 90                	xchg   %ax,%ax
c02069ab:	66 90                	xchg   %ax,%ax
c02069ad:	66 90                	xchg   %ax,%ax
c02069af:	66 90                	xchg   %ax,%ax
c02069b1:	66 90                	xchg   %ax,%ax
c02069b3:	66 90                	xchg   %ax,%ax
c02069b5:	66 90                	xchg   %ax,%ax
c02069b7:	66 90                	xchg   %ax,%ax
c02069b9:	66 90                	xchg   %ax,%ax
c02069bb:	66 90                	xchg   %ax,%ax
c02069bd:	66 90                	xchg   %ax,%ax
c02069bf:	66 90                	xchg   %ax,%ax
c02069c1:	66 90                	xchg   %ax,%ax
c02069c3:	66 90                	xchg   %ax,%ax
c02069c5:	66 90                	xchg   %ax,%ax
c02069c7:	66 90                	xchg   %ax,%ax
c02069c9:	66 90                	xchg   %ax,%ax
c02069cb:	66 90                	xchg   %ax,%ax
c02069cd:	66 90                	xchg   %ax,%ax
c02069cf:	66 90                	xchg   %ax,%ax
c02069d1:	66 90                	xchg   %ax,%ax
c02069d3:	66 90                	xchg   %ax,%ax
c02069d5:	66 90                	xchg   %ax,%ax
c02069d7:	66 90                	xchg   %ax,%ax
c02069d9:	66 90                	xchg   %ax,%ax
c02069db:	66 90                	xchg   %ax,%ax
c02069dd:	66 90                	xchg   %ax,%ax
c02069df:	66 90                	xchg   %ax,%ax
c02069e1:	66 90                	xchg   %ax,%ax
c02069e3:	66 90                	xchg   %ax,%ax
c02069e5:	66 90                	xchg   %ax,%ax
c02069e7:	66 90                	xchg   %ax,%ax
c02069e9:	66 90                	xchg   %ax,%ax
c02069eb:	66 90                	xchg   %ax,%ax
c02069ed:	66 90                	xchg   %ax,%ax
c02069ef:	66 90                	xchg   %ax,%ax
c02069f1:	66 90                	xchg   %ax,%ax
c02069f3:	66 90                	xchg   %ax,%ax
c02069f5:	66 90                	xchg   %ax,%ax
c02069f7:	66 90                	xchg   %ax,%ax
c02069f9:	66 90                	xchg   %ax,%ax
c02069fb:	66 90                	xchg   %ax,%ax
c02069fd:	66 90                	xchg   %ax,%ax
c02069ff:	66 90                	xchg   %ax,%ax
c0206a01:	66 90                	xchg   %ax,%ax
c0206a03:	66 90                	xchg   %ax,%ax
c0206a05:	66 90                	xchg   %ax,%ax
c0206a07:	66 90                	xchg   %ax,%ax
c0206a09:	66 90                	xchg   %ax,%ax
c0206a0b:	66 90                	xchg   %ax,%ax
c0206a0d:	66 90                	xchg   %ax,%ax
c0206a0f:	66 90                	xchg   %ax,%ax
c0206a11:	66 90                	xchg   %ax,%ax
c0206a13:	66 90                	xchg   %ax,%ax
c0206a15:	66 90                	xchg   %ax,%ax
c0206a17:	66 90                	xchg   %ax,%ax
c0206a19:	66 90                	xchg   %ax,%ax
c0206a1b:	66 90                	xchg   %ax,%ax
c0206a1d:	66 90                	xchg   %ax,%ax
c0206a1f:	66 90                	xchg   %ax,%ax
c0206a21:	66 90                	xchg   %ax,%ax
c0206a23:	66 90                	xchg   %ax,%ax
c0206a25:	66 90                	xchg   %ax,%ax
c0206a27:	66 90                	xchg   %ax,%ax
c0206a29:	66 90                	xchg   %ax,%ax
c0206a2b:	66 90                	xchg   %ax,%ax
c0206a2d:	66 90                	xchg   %ax,%ax
c0206a2f:	66 90                	xchg   %ax,%ax
c0206a31:	66 90                	xchg   %ax,%ax
c0206a33:	66 90                	xchg   %ax,%ax
c0206a35:	66 90                	xchg   %ax,%ax
c0206a37:	66 90                	xchg   %ax,%ax
c0206a39:	66 90                	xchg   %ax,%ax
c0206a3b:	66 90                	xchg   %ax,%ax
c0206a3d:	66 90                	xchg   %ax,%ax
c0206a3f:	66 90                	xchg   %ax,%ax
c0206a41:	66 90                	xchg   %ax,%ax
c0206a43:	66 90                	xchg   %ax,%ax
c0206a45:	66 90                	xchg   %ax,%ax
c0206a47:	66 90                	xchg   %ax,%ax
c0206a49:	66 90                	xchg   %ax,%ax
c0206a4b:	66 90                	xchg   %ax,%ax
c0206a4d:	66 90                	xchg   %ax,%ax
c0206a4f:	66 90                	xchg   %ax,%ax
c0206a51:	66 90                	xchg   %ax,%ax
c0206a53:	66 90                	xchg   %ax,%ax
c0206a55:	66 90                	xchg   %ax,%ax
c0206a57:	66 90                	xchg   %ax,%ax
c0206a59:	66 90                	xchg   %ax,%ax
c0206a5b:	66 90                	xchg   %ax,%ax
c0206a5d:	66 90                	xchg   %ax,%ax
c0206a5f:	66 90                	xchg   %ax,%ax
c0206a61:	66 90                	xchg   %ax,%ax
c0206a63:	66 90                	xchg   %ax,%ax
c0206a65:	66 90                	xchg   %ax,%ax
c0206a67:	66 90                	xchg   %ax,%ax
c0206a69:	66 90                	xchg   %ax,%ax
c0206a6b:	66 90                	xchg   %ax,%ax
c0206a6d:	66 90                	xchg   %ax,%ax
c0206a6f:	66 90                	xchg   %ax,%ax
c0206a71:	66 90                	xchg   %ax,%ax
c0206a73:	66 90                	xchg   %ax,%ax
c0206a75:	66 90                	xchg   %ax,%ax
c0206a77:	66 90                	xchg   %ax,%ax
c0206a79:	66 90                	xchg   %ax,%ax
c0206a7b:	66 90                	xchg   %ax,%ax
c0206a7d:	66 90                	xchg   %ax,%ax
c0206a7f:	66 90                	xchg   %ax,%ax
c0206a81:	66 90                	xchg   %ax,%ax
c0206a83:	66 90                	xchg   %ax,%ax
c0206a85:	66 90                	xchg   %ax,%ax
c0206a87:	66 90                	xchg   %ax,%ax
c0206a89:	66 90                	xchg   %ax,%ax
c0206a8b:	66 90                	xchg   %ax,%ax
c0206a8d:	66 90                	xchg   %ax,%ax
c0206a8f:	66 90                	xchg   %ax,%ax
c0206a91:	66 90                	xchg   %ax,%ax
c0206a93:	66 90                	xchg   %ax,%ax
c0206a95:	66 90                	xchg   %ax,%ax
c0206a97:	66 90                	xchg   %ax,%ax
c0206a99:	66 90                	xchg   %ax,%ax
c0206a9b:	66 90                	xchg   %ax,%ax
c0206a9d:	66 90                	xchg   %ax,%ax
c0206a9f:	66 90                	xchg   %ax,%ax
c0206aa1:	66 90                	xchg   %ax,%ax
c0206aa3:	66 90                	xchg   %ax,%ax
c0206aa5:	66 90                	xchg   %ax,%ax
c0206aa7:	66 90                	xchg   %ax,%ax
c0206aa9:	66 90                	xchg   %ax,%ax
c0206aab:	66 90                	xchg   %ax,%ax
c0206aad:	66 90                	xchg   %ax,%ax
c0206aaf:	66 90                	xchg   %ax,%ax
c0206ab1:	66 90                	xchg   %ax,%ax
c0206ab3:	66 90                	xchg   %ax,%ax
c0206ab5:	66 90                	xchg   %ax,%ax
c0206ab7:	66 90                	xchg   %ax,%ax
c0206ab9:	66 90                	xchg   %ax,%ax
c0206abb:	66 90                	xchg   %ax,%ax
c0206abd:	66 90                	xchg   %ax,%ax
c0206abf:	66 90                	xchg   %ax,%ax
c0206ac1:	66 90                	xchg   %ax,%ax
c0206ac3:	66 90                	xchg   %ax,%ax
c0206ac5:	66 90                	xchg   %ax,%ax
c0206ac7:	66 90                	xchg   %ax,%ax
c0206ac9:	66 90                	xchg   %ax,%ax
c0206acb:	66 90                	xchg   %ax,%ax
c0206acd:	66 90                	xchg   %ax,%ax
c0206acf:	66 90                	xchg   %ax,%ax
c0206ad1:	66 90                	xchg   %ax,%ax
c0206ad3:	66 90                	xchg   %ax,%ax
c0206ad5:	66 90                	xchg   %ax,%ax
c0206ad7:	66 90                	xchg   %ax,%ax
c0206ad9:	66 90                	xchg   %ax,%ax
c0206adb:	66 90                	xchg   %ax,%ax
c0206add:	66 90                	xchg   %ax,%ax
c0206adf:	66 90                	xchg   %ax,%ax
c0206ae1:	66 90                	xchg   %ax,%ax
c0206ae3:	66 90                	xchg   %ax,%ax
c0206ae5:	66 90                	xchg   %ax,%ax
c0206ae7:	66 90                	xchg   %ax,%ax
c0206ae9:	66 90                	xchg   %ax,%ax
c0206aeb:	66 90                	xchg   %ax,%ax
c0206aed:	66 90                	xchg   %ax,%ax
c0206aef:	66 90                	xchg   %ax,%ax
c0206af1:	66 90                	xchg   %ax,%ax
c0206af3:	66 90                	xchg   %ax,%ax
c0206af5:	66 90                	xchg   %ax,%ax
c0206af7:	66 90                	xchg   %ax,%ax
c0206af9:	66 90                	xchg   %ax,%ax
c0206afb:	66 90                	xchg   %ax,%ax
c0206afd:	66 90                	xchg   %ax,%ax
c0206aff:	66 90                	xchg   %ax,%ax
c0206b01:	66 90                	xchg   %ax,%ax
c0206b03:	66 90                	xchg   %ax,%ax
c0206b05:	66 90                	xchg   %ax,%ax
c0206b07:	66 90                	xchg   %ax,%ax
c0206b09:	66 90                	xchg   %ax,%ax
c0206b0b:	66 90                	xchg   %ax,%ax
c0206b0d:	66 90                	xchg   %ax,%ax
c0206b0f:	66 90                	xchg   %ax,%ax
c0206b11:	66 90                	xchg   %ax,%ax
c0206b13:	66 90                	xchg   %ax,%ax
c0206b15:	66 90                	xchg   %ax,%ax
c0206b17:	66 90                	xchg   %ax,%ax
c0206b19:	66 90                	xchg   %ax,%ax
c0206b1b:	66 90                	xchg   %ax,%ax
c0206b1d:	66 90                	xchg   %ax,%ax
c0206b1f:	66 90                	xchg   %ax,%ax
c0206b21:	66 90                	xchg   %ax,%ax
c0206b23:	66 90                	xchg   %ax,%ax
c0206b25:	66 90                	xchg   %ax,%ax
c0206b27:	66 90                	xchg   %ax,%ax
c0206b29:	66 90                	xchg   %ax,%ax
c0206b2b:	66 90                	xchg   %ax,%ax
c0206b2d:	66 90                	xchg   %ax,%ax
c0206b2f:	66 90                	xchg   %ax,%ax
c0206b31:	66 90                	xchg   %ax,%ax
c0206b33:	66 90                	xchg   %ax,%ax
c0206b35:	66 90                	xchg   %ax,%ax
c0206b37:	66 90                	xchg   %ax,%ax
c0206b39:	66 90                	xchg   %ax,%ax
c0206b3b:	66 90                	xchg   %ax,%ax
c0206b3d:	66 90                	xchg   %ax,%ax
c0206b3f:	66 90                	xchg   %ax,%ax
c0206b41:	66 90                	xchg   %ax,%ax
c0206b43:	66 90                	xchg   %ax,%ax
c0206b45:	66 90                	xchg   %ax,%ax
c0206b47:	66 90                	xchg   %ax,%ax
c0206b49:	66 90                	xchg   %ax,%ax
c0206b4b:	66 90                	xchg   %ax,%ax
c0206b4d:	66 90                	xchg   %ax,%ax
c0206b4f:	66 90                	xchg   %ax,%ax
c0206b51:	66 90                	xchg   %ax,%ax
c0206b53:	66 90                	xchg   %ax,%ax
c0206b55:	66 90                	xchg   %ax,%ax
c0206b57:	66 90                	xchg   %ax,%ax
c0206b59:	66 90                	xchg   %ax,%ax
c0206b5b:	66 90                	xchg   %ax,%ax
c0206b5d:	66 90                	xchg   %ax,%ax
c0206b5f:	66 90                	xchg   %ax,%ax
c0206b61:	66 90                	xchg   %ax,%ax
c0206b63:	66 90                	xchg   %ax,%ax
c0206b65:	66 90                	xchg   %ax,%ax
c0206b67:	66 90                	xchg   %ax,%ax
c0206b69:	66 90                	xchg   %ax,%ax
c0206b6b:	66 90                	xchg   %ax,%ax
c0206b6d:	66 90                	xchg   %ax,%ax
c0206b6f:	66 90                	xchg   %ax,%ax
c0206b71:	66 90                	xchg   %ax,%ax
c0206b73:	66 90                	xchg   %ax,%ax
c0206b75:	66 90                	xchg   %ax,%ax
c0206b77:	66 90                	xchg   %ax,%ax
c0206b79:	66 90                	xchg   %ax,%ax
c0206b7b:	66 90                	xchg   %ax,%ax
c0206b7d:	66 90                	xchg   %ax,%ax
c0206b7f:	66 90                	xchg   %ax,%ax
c0206b81:	66 90                	xchg   %ax,%ax
c0206b83:	66 90                	xchg   %ax,%ax
c0206b85:	66 90                	xchg   %ax,%ax
c0206b87:	66 90                	xchg   %ax,%ax
c0206b89:	66 90                	xchg   %ax,%ax
c0206b8b:	66 90                	xchg   %ax,%ax
c0206b8d:	66 90                	xchg   %ax,%ax
c0206b8f:	66 90                	xchg   %ax,%ax
c0206b91:	66 90                	xchg   %ax,%ax
c0206b93:	66 90                	xchg   %ax,%ax
c0206b95:	66 90                	xchg   %ax,%ax
c0206b97:	66 90                	xchg   %ax,%ax
c0206b99:	66 90                	xchg   %ax,%ax
c0206b9b:	66 90                	xchg   %ax,%ax
c0206b9d:	66 90                	xchg   %ax,%ax
c0206b9f:	66 90                	xchg   %ax,%ax
c0206ba1:	66 90                	xchg   %ax,%ax
c0206ba3:	66 90                	xchg   %ax,%ax
c0206ba5:	66 90                	xchg   %ax,%ax
c0206ba7:	66 90                	xchg   %ax,%ax
c0206ba9:	66 90                	xchg   %ax,%ax
c0206bab:	66 90                	xchg   %ax,%ax
c0206bad:	66 90                	xchg   %ax,%ax
c0206baf:	66 90                	xchg   %ax,%ax
c0206bb1:	66 90                	xchg   %ax,%ax
c0206bb3:	66 90                	xchg   %ax,%ax
c0206bb5:	66 90                	xchg   %ax,%ax
c0206bb7:	66 90                	xchg   %ax,%ax
c0206bb9:	66 90                	xchg   %ax,%ax
c0206bbb:	66 90                	xchg   %ax,%ax
c0206bbd:	66 90                	xchg   %ax,%ax
c0206bbf:	66 90                	xchg   %ax,%ax
c0206bc1:	66 90                	xchg   %ax,%ax
c0206bc3:	66 90                	xchg   %ax,%ax
c0206bc5:	66 90                	xchg   %ax,%ax
c0206bc7:	66 90                	xchg   %ax,%ax
c0206bc9:	66 90                	xchg   %ax,%ax
c0206bcb:	66 90                	xchg   %ax,%ax
c0206bcd:	66 90                	xchg   %ax,%ax
c0206bcf:	66 90                	xchg   %ax,%ax
c0206bd1:	66 90                	xchg   %ax,%ax
c0206bd3:	66 90                	xchg   %ax,%ax
c0206bd5:	66 90                	xchg   %ax,%ax
c0206bd7:	66 90                	xchg   %ax,%ax
c0206bd9:	66 90                	xchg   %ax,%ax
c0206bdb:	66 90                	xchg   %ax,%ax
c0206bdd:	66 90                	xchg   %ax,%ax
c0206bdf:	66 90                	xchg   %ax,%ax
c0206be1:	66 90                	xchg   %ax,%ax
c0206be3:	66 90                	xchg   %ax,%ax
c0206be5:	66 90                	xchg   %ax,%ax
c0206be7:	66 90                	xchg   %ax,%ax
c0206be9:	66 90                	xchg   %ax,%ax
c0206beb:	66 90                	xchg   %ax,%ax
c0206bed:	66 90                	xchg   %ax,%ax
c0206bef:	66 90                	xchg   %ax,%ax
c0206bf1:	66 90                	xchg   %ax,%ax
c0206bf3:	66 90                	xchg   %ax,%ax
c0206bf5:	66 90                	xchg   %ax,%ax
c0206bf7:	66 90                	xchg   %ax,%ax
c0206bf9:	66 90                	xchg   %ax,%ax
c0206bfb:	66 90                	xchg   %ax,%ax
c0206bfd:	66 90                	xchg   %ax,%ax
c0206bff:	66 90                	xchg   %ax,%ax
c0206c01:	66 90                	xchg   %ax,%ax
c0206c03:	66 90                	xchg   %ax,%ax
c0206c05:	66 90                	xchg   %ax,%ax
c0206c07:	66 90                	xchg   %ax,%ax
c0206c09:	66 90                	xchg   %ax,%ax
c0206c0b:	66 90                	xchg   %ax,%ax
c0206c0d:	66 90                	xchg   %ax,%ax
c0206c0f:	66 90                	xchg   %ax,%ax
c0206c11:	66 90                	xchg   %ax,%ax
c0206c13:	66 90                	xchg   %ax,%ax
c0206c15:	66 90                	xchg   %ax,%ax
c0206c17:	66 90                	xchg   %ax,%ax
c0206c19:	66 90                	xchg   %ax,%ax
c0206c1b:	66 90                	xchg   %ax,%ax
c0206c1d:	66 90                	xchg   %ax,%ax
c0206c1f:	66 90                	xchg   %ax,%ax
c0206c21:	66 90                	xchg   %ax,%ax
c0206c23:	66 90                	xchg   %ax,%ax
c0206c25:	66 90                	xchg   %ax,%ax
c0206c27:	66 90                	xchg   %ax,%ax
c0206c29:	66 90                	xchg   %ax,%ax
c0206c2b:	66 90                	xchg   %ax,%ax
c0206c2d:	66 90                	xchg   %ax,%ax
c0206c2f:	66 90                	xchg   %ax,%ax
c0206c31:	66 90                	xchg   %ax,%ax
c0206c33:	66 90                	xchg   %ax,%ax
c0206c35:	66 90                	xchg   %ax,%ax
c0206c37:	66 90                	xchg   %ax,%ax
c0206c39:	66 90                	xchg   %ax,%ax
c0206c3b:	66 90                	xchg   %ax,%ax
c0206c3d:	66 90                	xchg   %ax,%ax
c0206c3f:	66 90                	xchg   %ax,%ax
c0206c41:	66 90                	xchg   %ax,%ax
c0206c43:	66 90                	xchg   %ax,%ax
c0206c45:	66 90                	xchg   %ax,%ax
c0206c47:	66 90                	xchg   %ax,%ax
c0206c49:	66 90                	xchg   %ax,%ax
c0206c4b:	66 90                	xchg   %ax,%ax
c0206c4d:	66 90                	xchg   %ax,%ax
c0206c4f:	66 90                	xchg   %ax,%ax
c0206c51:	66 90                	xchg   %ax,%ax
c0206c53:	66 90                	xchg   %ax,%ax
c0206c55:	66 90                	xchg   %ax,%ax
c0206c57:	66 90                	xchg   %ax,%ax
c0206c59:	66 90                	xchg   %ax,%ax
c0206c5b:	66 90                	xchg   %ax,%ax
c0206c5d:	66 90                	xchg   %ax,%ax
c0206c5f:	66 90                	xchg   %ax,%ax
c0206c61:	66 90                	xchg   %ax,%ax
c0206c63:	66 90                	xchg   %ax,%ax
c0206c65:	66 90                	xchg   %ax,%ax
c0206c67:	66 90                	xchg   %ax,%ax
c0206c69:	66 90                	xchg   %ax,%ax
c0206c6b:	66 90                	xchg   %ax,%ax
c0206c6d:	66 90                	xchg   %ax,%ax
c0206c6f:	66 90                	xchg   %ax,%ax
c0206c71:	66 90                	xchg   %ax,%ax
c0206c73:	66 90                	xchg   %ax,%ax
c0206c75:	66 90                	xchg   %ax,%ax
c0206c77:	66 90                	xchg   %ax,%ax
c0206c79:	66 90                	xchg   %ax,%ax
c0206c7b:	66 90                	xchg   %ax,%ax
c0206c7d:	66 90                	xchg   %ax,%ax
c0206c7f:	66 90                	xchg   %ax,%ax
c0206c81:	66 90                	xchg   %ax,%ax
c0206c83:	66 90                	xchg   %ax,%ax
c0206c85:	66 90                	xchg   %ax,%ax
c0206c87:	66 90                	xchg   %ax,%ax
c0206c89:	66 90                	xchg   %ax,%ax
c0206c8b:	66 90                	xchg   %ax,%ax
c0206c8d:	66 90                	xchg   %ax,%ax
c0206c8f:	66 90                	xchg   %ax,%ax
c0206c91:	66 90                	xchg   %ax,%ax
c0206c93:	66 90                	xchg   %ax,%ax
c0206c95:	66 90                	xchg   %ax,%ax
c0206c97:	66 90                	xchg   %ax,%ax
c0206c99:	66 90                	xchg   %ax,%ax
c0206c9b:	66 90                	xchg   %ax,%ax
c0206c9d:	66 90                	xchg   %ax,%ax
c0206c9f:	66 90                	xchg   %ax,%ax
c0206ca1:	66 90                	xchg   %ax,%ax
c0206ca3:	66 90                	xchg   %ax,%ax
c0206ca5:	66 90                	xchg   %ax,%ax
c0206ca7:	66 90                	xchg   %ax,%ax
c0206ca9:	66 90                	xchg   %ax,%ax
c0206cab:	66 90                	xchg   %ax,%ax
c0206cad:	66 90                	xchg   %ax,%ax
c0206caf:	66 90                	xchg   %ax,%ax
c0206cb1:	66 90                	xchg   %ax,%ax
c0206cb3:	66 90                	xchg   %ax,%ax
c0206cb5:	66 90                	xchg   %ax,%ax
c0206cb7:	66 90                	xchg   %ax,%ax
c0206cb9:	66 90                	xchg   %ax,%ax
c0206cbb:	66 90                	xchg   %ax,%ax
c0206cbd:	66 90                	xchg   %ax,%ax
c0206cbf:	66 90                	xchg   %ax,%ax
c0206cc1:	66 90                	xchg   %ax,%ax
c0206cc3:	66 90                	xchg   %ax,%ax
c0206cc5:	66 90                	xchg   %ax,%ax
c0206cc7:	66 90                	xchg   %ax,%ax
c0206cc9:	66 90                	xchg   %ax,%ax
c0206ccb:	66 90                	xchg   %ax,%ax
c0206ccd:	66 90                	xchg   %ax,%ax
c0206ccf:	66 90                	xchg   %ax,%ax
c0206cd1:	66 90                	xchg   %ax,%ax
c0206cd3:	66 90                	xchg   %ax,%ax
c0206cd5:	66 90                	xchg   %ax,%ax
c0206cd7:	66 90                	xchg   %ax,%ax
c0206cd9:	66 90                	xchg   %ax,%ax
c0206cdb:	66 90                	xchg   %ax,%ax
c0206cdd:	66 90                	xchg   %ax,%ax
c0206cdf:	66 90                	xchg   %ax,%ax
c0206ce1:	66 90                	xchg   %ax,%ax
c0206ce3:	66 90                	xchg   %ax,%ax
c0206ce5:	66 90                	xchg   %ax,%ax
c0206ce7:	66 90                	xchg   %ax,%ax
c0206ce9:	66 90                	xchg   %ax,%ax
c0206ceb:	66 90                	xchg   %ax,%ax
c0206ced:	66 90                	xchg   %ax,%ax
c0206cef:	66 90                	xchg   %ax,%ax
c0206cf1:	66 90                	xchg   %ax,%ax
c0206cf3:	66 90                	xchg   %ax,%ax
c0206cf5:	66 90                	xchg   %ax,%ax
c0206cf7:	66 90                	xchg   %ax,%ax
c0206cf9:	66 90                	xchg   %ax,%ax
c0206cfb:	66 90                	xchg   %ax,%ax
c0206cfd:	66 90                	xchg   %ax,%ax
c0206cff:	66 90                	xchg   %ax,%ax
c0206d01:	66 90                	xchg   %ax,%ax
c0206d03:	66 90                	xchg   %ax,%ax
c0206d05:	66 90                	xchg   %ax,%ax
c0206d07:	66 90                	xchg   %ax,%ax
c0206d09:	66 90                	xchg   %ax,%ax
c0206d0b:	66 90                	xchg   %ax,%ax
c0206d0d:	66 90                	xchg   %ax,%ax
c0206d0f:	66 90                	xchg   %ax,%ax
c0206d11:	66 90                	xchg   %ax,%ax
c0206d13:	66 90                	xchg   %ax,%ax
c0206d15:	66 90                	xchg   %ax,%ax
c0206d17:	66 90                	xchg   %ax,%ax
c0206d19:	66 90                	xchg   %ax,%ax
c0206d1b:	66 90                	xchg   %ax,%ax
c0206d1d:	66 90                	xchg   %ax,%ax
c0206d1f:	66 90                	xchg   %ax,%ax
c0206d21:	66 90                	xchg   %ax,%ax
c0206d23:	66 90                	xchg   %ax,%ax
c0206d25:	66 90                	xchg   %ax,%ax
c0206d27:	66 90                	xchg   %ax,%ax
c0206d29:	66 90                	xchg   %ax,%ax
c0206d2b:	66 90                	xchg   %ax,%ax
c0206d2d:	66 90                	xchg   %ax,%ax
c0206d2f:	66 90                	xchg   %ax,%ax
c0206d31:	66 90                	xchg   %ax,%ax
c0206d33:	66 90                	xchg   %ax,%ax
c0206d35:	66 90                	xchg   %ax,%ax
c0206d37:	66 90                	xchg   %ax,%ax
c0206d39:	66 90                	xchg   %ax,%ax
c0206d3b:	66 90                	xchg   %ax,%ax
c0206d3d:	66 90                	xchg   %ax,%ax
c0206d3f:	66 90                	xchg   %ax,%ax
c0206d41:	66 90                	xchg   %ax,%ax
c0206d43:	66 90                	xchg   %ax,%ax
c0206d45:	66 90                	xchg   %ax,%ax
c0206d47:	66 90                	xchg   %ax,%ax
c0206d49:	66 90                	xchg   %ax,%ax
c0206d4b:	66 90                	xchg   %ax,%ax
c0206d4d:	66 90                	xchg   %ax,%ax
c0206d4f:	66 90                	xchg   %ax,%ax
c0206d51:	66 90                	xchg   %ax,%ax
c0206d53:	66 90                	xchg   %ax,%ax
c0206d55:	66 90                	xchg   %ax,%ax
c0206d57:	66 90                	xchg   %ax,%ax
c0206d59:	66 90                	xchg   %ax,%ax
c0206d5b:	66 90                	xchg   %ax,%ax
c0206d5d:	66 90                	xchg   %ax,%ax
c0206d5f:	66 90                	xchg   %ax,%ax
c0206d61:	66 90                	xchg   %ax,%ax
c0206d63:	66 90                	xchg   %ax,%ax
c0206d65:	66 90                	xchg   %ax,%ax
c0206d67:	66 90                	xchg   %ax,%ax
c0206d69:	66 90                	xchg   %ax,%ax
c0206d6b:	66 90                	xchg   %ax,%ax
c0206d6d:	66 90                	xchg   %ax,%ax
c0206d6f:	66 90                	xchg   %ax,%ax
c0206d71:	66 90                	xchg   %ax,%ax
c0206d73:	66 90                	xchg   %ax,%ax
c0206d75:	66 90                	xchg   %ax,%ax
c0206d77:	66 90                	xchg   %ax,%ax
c0206d79:	66 90                	xchg   %ax,%ax
c0206d7b:	66 90                	xchg   %ax,%ax
c0206d7d:	66 90                	xchg   %ax,%ax
c0206d7f:	66 90                	xchg   %ax,%ax
c0206d81:	66 90                	xchg   %ax,%ax
c0206d83:	66 90                	xchg   %ax,%ax
c0206d85:	66 90                	xchg   %ax,%ax
c0206d87:	66 90                	xchg   %ax,%ax
c0206d89:	66 90                	xchg   %ax,%ax
c0206d8b:	66 90                	xchg   %ax,%ax
c0206d8d:	66 90                	xchg   %ax,%ax
c0206d8f:	66 90                	xchg   %ax,%ax
c0206d91:	66 90                	xchg   %ax,%ax
c0206d93:	66 90                	xchg   %ax,%ax
c0206d95:	66 90                	xchg   %ax,%ax
c0206d97:	66 90                	xchg   %ax,%ax
c0206d99:	66 90                	xchg   %ax,%ax
c0206d9b:	66 90                	xchg   %ax,%ax
c0206d9d:	66 90                	xchg   %ax,%ax
c0206d9f:	66 90                	xchg   %ax,%ax
c0206da1:	66 90                	xchg   %ax,%ax
c0206da3:	66 90                	xchg   %ax,%ax
c0206da5:	66 90                	xchg   %ax,%ax
c0206da7:	66 90                	xchg   %ax,%ax
c0206da9:	66 90                	xchg   %ax,%ax
c0206dab:	66 90                	xchg   %ax,%ax
c0206dad:	66 90                	xchg   %ax,%ax
c0206daf:	66 90                	xchg   %ax,%ax
c0206db1:	66 90                	xchg   %ax,%ax
c0206db3:	66 90                	xchg   %ax,%ax
c0206db5:	66 90                	xchg   %ax,%ax
c0206db7:	66 90                	xchg   %ax,%ax
c0206db9:	66 90                	xchg   %ax,%ax
c0206dbb:	66 90                	xchg   %ax,%ax
c0206dbd:	66 90                	xchg   %ax,%ax
c0206dbf:	66 90                	xchg   %ax,%ax
c0206dc1:	66 90                	xchg   %ax,%ax
c0206dc3:	66 90                	xchg   %ax,%ax
c0206dc5:	66 90                	xchg   %ax,%ax
c0206dc7:	66 90                	xchg   %ax,%ax
c0206dc9:	66 90                	xchg   %ax,%ax
c0206dcb:	66 90                	xchg   %ax,%ax
c0206dcd:	66 90                	xchg   %ax,%ax
c0206dcf:	66 90                	xchg   %ax,%ax
c0206dd1:	66 90                	xchg   %ax,%ax
c0206dd3:	66 90                	xchg   %ax,%ax
c0206dd5:	66 90                	xchg   %ax,%ax
c0206dd7:	66 90                	xchg   %ax,%ax
c0206dd9:	66 90                	xchg   %ax,%ax
c0206ddb:	66 90                	xchg   %ax,%ax
c0206ddd:	66 90                	xchg   %ax,%ax
c0206ddf:	66 90                	xchg   %ax,%ax
c0206de1:	66 90                	xchg   %ax,%ax
c0206de3:	66 90                	xchg   %ax,%ax
c0206de5:	66 90                	xchg   %ax,%ax
c0206de7:	66 90                	xchg   %ax,%ax
c0206de9:	66 90                	xchg   %ax,%ax
c0206deb:	66 90                	xchg   %ax,%ax
c0206ded:	66 90                	xchg   %ax,%ax
c0206def:	66 90                	xchg   %ax,%ax
c0206df1:	66 90                	xchg   %ax,%ax
c0206df3:	66 90                	xchg   %ax,%ax
c0206df5:	66 90                	xchg   %ax,%ax
c0206df7:	66 90                	xchg   %ax,%ax
c0206df9:	66 90                	xchg   %ax,%ax
c0206dfb:	66 90                	xchg   %ax,%ax
c0206dfd:	66 90                	xchg   %ax,%ax
c0206dff:	66 90                	xchg   %ax,%ax
c0206e01:	66 90                	xchg   %ax,%ax
c0206e03:	66 90                	xchg   %ax,%ax
c0206e05:	66 90                	xchg   %ax,%ax
c0206e07:	66 90                	xchg   %ax,%ax
c0206e09:	66 90                	xchg   %ax,%ax
c0206e0b:	66 90                	xchg   %ax,%ax
c0206e0d:	66 90                	xchg   %ax,%ax
c0206e0f:	66 90                	xchg   %ax,%ax
c0206e11:	66 90                	xchg   %ax,%ax
c0206e13:	66 90                	xchg   %ax,%ax
c0206e15:	66 90                	xchg   %ax,%ax
c0206e17:	66 90                	xchg   %ax,%ax
c0206e19:	66 90                	xchg   %ax,%ax
c0206e1b:	66 90                	xchg   %ax,%ax
c0206e1d:	66 90                	xchg   %ax,%ax
c0206e1f:	66 90                	xchg   %ax,%ax
c0206e21:	66 90                	xchg   %ax,%ax
c0206e23:	66 90                	xchg   %ax,%ax
c0206e25:	66 90                	xchg   %ax,%ax
c0206e27:	66 90                	xchg   %ax,%ax
c0206e29:	66 90                	xchg   %ax,%ax
c0206e2b:	66 90                	xchg   %ax,%ax
c0206e2d:	66 90                	xchg   %ax,%ax
c0206e2f:	66 90                	xchg   %ax,%ax
c0206e31:	66 90                	xchg   %ax,%ax
c0206e33:	66 90                	xchg   %ax,%ax
c0206e35:	66 90                	xchg   %ax,%ax
c0206e37:	66 90                	xchg   %ax,%ax
c0206e39:	66 90                	xchg   %ax,%ax
c0206e3b:	66 90                	xchg   %ax,%ax
c0206e3d:	66 90                	xchg   %ax,%ax
c0206e3f:	66 90                	xchg   %ax,%ax
c0206e41:	66 90                	xchg   %ax,%ax
c0206e43:	66 90                	xchg   %ax,%ax
c0206e45:	66 90                	xchg   %ax,%ax
c0206e47:	66 90                	xchg   %ax,%ax
c0206e49:	66 90                	xchg   %ax,%ax
c0206e4b:	66 90                	xchg   %ax,%ax
c0206e4d:	66 90                	xchg   %ax,%ax
c0206e4f:	66 90                	xchg   %ax,%ax
c0206e51:	66 90                	xchg   %ax,%ax
c0206e53:	66 90                	xchg   %ax,%ax
c0206e55:	66 90                	xchg   %ax,%ax
c0206e57:	66 90                	xchg   %ax,%ax
c0206e59:	66 90                	xchg   %ax,%ax
c0206e5b:	66 90                	xchg   %ax,%ax
c0206e5d:	66 90                	xchg   %ax,%ax
c0206e5f:	66 90                	xchg   %ax,%ax
c0206e61:	66 90                	xchg   %ax,%ax
c0206e63:	66 90                	xchg   %ax,%ax
c0206e65:	66 90                	xchg   %ax,%ax
c0206e67:	66 90                	xchg   %ax,%ax
c0206e69:	66 90                	xchg   %ax,%ax
c0206e6b:	66 90                	xchg   %ax,%ax
c0206e6d:	66 90                	xchg   %ax,%ax
c0206e6f:	66 90                	xchg   %ax,%ax
c0206e71:	66 90                	xchg   %ax,%ax
c0206e73:	66 90                	xchg   %ax,%ax
c0206e75:	66 90                	xchg   %ax,%ax
c0206e77:	66 90                	xchg   %ax,%ax
c0206e79:	66 90                	xchg   %ax,%ax
c0206e7b:	66 90                	xchg   %ax,%ax
c0206e7d:	66 90                	xchg   %ax,%ax
c0206e7f:	66 90                	xchg   %ax,%ax
c0206e81:	66 90                	xchg   %ax,%ax
c0206e83:	66 90                	xchg   %ax,%ax
c0206e85:	66 90                	xchg   %ax,%ax
c0206e87:	66 90                	xchg   %ax,%ax
c0206e89:	66 90                	xchg   %ax,%ax
c0206e8b:	66 90                	xchg   %ax,%ax
c0206e8d:	66 90                	xchg   %ax,%ax
c0206e8f:	66 90                	xchg   %ax,%ax
c0206e91:	66 90                	xchg   %ax,%ax
c0206e93:	66 90                	xchg   %ax,%ax
c0206e95:	66 90                	xchg   %ax,%ax
c0206e97:	66 90                	xchg   %ax,%ax
c0206e99:	66 90                	xchg   %ax,%ax
c0206e9b:	66 90                	xchg   %ax,%ax
c0206e9d:	66 90                	xchg   %ax,%ax
c0206e9f:	66 90                	xchg   %ax,%ax
c0206ea1:	66 90                	xchg   %ax,%ax
c0206ea3:	66 90                	xchg   %ax,%ax
c0206ea5:	66 90                	xchg   %ax,%ax
c0206ea7:	66 90                	xchg   %ax,%ax
c0206ea9:	66 90                	xchg   %ax,%ax
c0206eab:	66 90                	xchg   %ax,%ax
c0206ead:	66 90                	xchg   %ax,%ax
c0206eaf:	66 90                	xchg   %ax,%ax
c0206eb1:	66 90                	xchg   %ax,%ax
c0206eb3:	66 90                	xchg   %ax,%ax
c0206eb5:	66 90                	xchg   %ax,%ax
c0206eb7:	66 90                	xchg   %ax,%ax
c0206eb9:	66 90                	xchg   %ax,%ax
c0206ebb:	66 90                	xchg   %ax,%ax
c0206ebd:	66 90                	xchg   %ax,%ax
c0206ebf:	66 90                	xchg   %ax,%ax
c0206ec1:	66 90                	xchg   %ax,%ax
c0206ec3:	66 90                	xchg   %ax,%ax
c0206ec5:	66 90                	xchg   %ax,%ax
c0206ec7:	66 90                	xchg   %ax,%ax
c0206ec9:	66 90                	xchg   %ax,%ax
c0206ecb:	66 90                	xchg   %ax,%ax
c0206ecd:	66 90                	xchg   %ax,%ax
c0206ecf:	66 90                	xchg   %ax,%ax
c0206ed1:	66 90                	xchg   %ax,%ax
c0206ed3:	66 90                	xchg   %ax,%ax
c0206ed5:	66 90                	xchg   %ax,%ax
c0206ed7:	66 90                	xchg   %ax,%ax
c0206ed9:	66 90                	xchg   %ax,%ax
c0206edb:	66 90                	xchg   %ax,%ax
c0206edd:	66 90                	xchg   %ax,%ax
c0206edf:	66 90                	xchg   %ax,%ax
c0206ee1:	66 90                	xchg   %ax,%ax
c0206ee3:	66 90                	xchg   %ax,%ax
c0206ee5:	66 90                	xchg   %ax,%ax
c0206ee7:	66 90                	xchg   %ax,%ax
c0206ee9:	66 90                	xchg   %ax,%ax
c0206eeb:	66 90                	xchg   %ax,%ax
c0206eed:	66 90                	xchg   %ax,%ax
c0206eef:	66 90                	xchg   %ax,%ax
c0206ef1:	66 90                	xchg   %ax,%ax
c0206ef3:	66 90                	xchg   %ax,%ax
c0206ef5:	66 90                	xchg   %ax,%ax
c0206ef7:	66 90                	xchg   %ax,%ax
c0206ef9:	66 90                	xchg   %ax,%ax
c0206efb:	66 90                	xchg   %ax,%ax
c0206efd:	66 90                	xchg   %ax,%ax
c0206eff:	66 90                	xchg   %ax,%ax
c0206f01:	66 90                	xchg   %ax,%ax
c0206f03:	66 90                	xchg   %ax,%ax
c0206f05:	66 90                	xchg   %ax,%ax
c0206f07:	66 90                	xchg   %ax,%ax
c0206f09:	66 90                	xchg   %ax,%ax
c0206f0b:	66 90                	xchg   %ax,%ax
c0206f0d:	66 90                	xchg   %ax,%ax
c0206f0f:	66 90                	xchg   %ax,%ax
c0206f11:	66 90                	xchg   %ax,%ax
c0206f13:	66 90                	xchg   %ax,%ax
c0206f15:	66 90                	xchg   %ax,%ax
c0206f17:	66 90                	xchg   %ax,%ax
c0206f19:	66 90                	xchg   %ax,%ax
c0206f1b:	66 90                	xchg   %ax,%ax
c0206f1d:	66 90                	xchg   %ax,%ax
c0206f1f:	66 90                	xchg   %ax,%ax
c0206f21:	66 90                	xchg   %ax,%ax
c0206f23:	66 90                	xchg   %ax,%ax
c0206f25:	66 90                	xchg   %ax,%ax
c0206f27:	66 90                	xchg   %ax,%ax
c0206f29:	66 90                	xchg   %ax,%ax
c0206f2b:	66 90                	xchg   %ax,%ax
c0206f2d:	66 90                	xchg   %ax,%ax
c0206f2f:	66 90                	xchg   %ax,%ax
c0206f31:	66 90                	xchg   %ax,%ax
c0206f33:	66 90                	xchg   %ax,%ax
c0206f35:	66 90                	xchg   %ax,%ax
c0206f37:	66 90                	xchg   %ax,%ax
c0206f39:	66 90                	xchg   %ax,%ax
c0206f3b:	66 90                	xchg   %ax,%ax
c0206f3d:	66 90                	xchg   %ax,%ax
c0206f3f:	66 90                	xchg   %ax,%ax
c0206f41:	66 90                	xchg   %ax,%ax
c0206f43:	66 90                	xchg   %ax,%ax
c0206f45:	66 90                	xchg   %ax,%ax
c0206f47:	66 90                	xchg   %ax,%ax
c0206f49:	66 90                	xchg   %ax,%ax
c0206f4b:	66 90                	xchg   %ax,%ax
c0206f4d:	66 90                	xchg   %ax,%ax
c0206f4f:	66 90                	xchg   %ax,%ax
c0206f51:	66 90                	xchg   %ax,%ax
c0206f53:	66 90                	xchg   %ax,%ax
c0206f55:	66 90                	xchg   %ax,%ax
c0206f57:	66 90                	xchg   %ax,%ax
c0206f59:	66 90                	xchg   %ax,%ax
c0206f5b:	66 90                	xchg   %ax,%ax
c0206f5d:	66 90                	xchg   %ax,%ax
c0206f5f:	66 90                	xchg   %ax,%ax
c0206f61:	66 90                	xchg   %ax,%ax
c0206f63:	66 90                	xchg   %ax,%ax
c0206f65:	66 90                	xchg   %ax,%ax
c0206f67:	66 90                	xchg   %ax,%ax
c0206f69:	66 90                	xchg   %ax,%ax
c0206f6b:	66 90                	xchg   %ax,%ax
c0206f6d:	66 90                	xchg   %ax,%ax
c0206f6f:	66 90                	xchg   %ax,%ax
c0206f71:	66 90                	xchg   %ax,%ax
c0206f73:	66 90                	xchg   %ax,%ax
c0206f75:	66 90                	xchg   %ax,%ax
c0206f77:	66 90                	xchg   %ax,%ax
c0206f79:	66 90                	xchg   %ax,%ax
c0206f7b:	66 90                	xchg   %ax,%ax
c0206f7d:	66 90                	xchg   %ax,%ax
c0206f7f:	66 90                	xchg   %ax,%ax
c0206f81:	66 90                	xchg   %ax,%ax
c0206f83:	66 90                	xchg   %ax,%ax
c0206f85:	66 90                	xchg   %ax,%ax
c0206f87:	66 90                	xchg   %ax,%ax
c0206f89:	66 90                	xchg   %ax,%ax
c0206f8b:	66 90                	xchg   %ax,%ax
c0206f8d:	66 90                	xchg   %ax,%ax
c0206f8f:	66 90                	xchg   %ax,%ax
c0206f91:	66 90                	xchg   %ax,%ax
c0206f93:	66 90                	xchg   %ax,%ax
c0206f95:	66 90                	xchg   %ax,%ax
c0206f97:	66 90                	xchg   %ax,%ax
c0206f99:	66 90                	xchg   %ax,%ax
c0206f9b:	66 90                	xchg   %ax,%ax
c0206f9d:	66 90                	xchg   %ax,%ax
c0206f9f:	66 90                	xchg   %ax,%ax
c0206fa1:	66 90                	xchg   %ax,%ax
c0206fa3:	66 90                	xchg   %ax,%ax
c0206fa5:	66 90                	xchg   %ax,%ax
c0206fa7:	66 90                	xchg   %ax,%ax
c0206fa9:	66 90                	xchg   %ax,%ax
c0206fab:	66 90                	xchg   %ax,%ax
c0206fad:	66 90                	xchg   %ax,%ax
c0206faf:	66 90                	xchg   %ax,%ax
c0206fb1:	66 90                	xchg   %ax,%ax
c0206fb3:	66 90                	xchg   %ax,%ax
c0206fb5:	66 90                	xchg   %ax,%ax
c0206fb7:	66 90                	xchg   %ax,%ax
c0206fb9:	66 90                	xchg   %ax,%ax
c0206fbb:	66 90                	xchg   %ax,%ax
c0206fbd:	66 90                	xchg   %ax,%ax
c0206fbf:	66 90                	xchg   %ax,%ax
c0206fc1:	66 90                	xchg   %ax,%ax
c0206fc3:	66 90                	xchg   %ax,%ax
c0206fc5:	66 90                	xchg   %ax,%ax
c0206fc7:	66 90                	xchg   %ax,%ax
c0206fc9:	66 90                	xchg   %ax,%ax
c0206fcb:	66 90                	xchg   %ax,%ax
c0206fcd:	66 90                	xchg   %ax,%ax
c0206fcf:	66 90                	xchg   %ax,%ax
c0206fd1:	66 90                	xchg   %ax,%ax
c0206fd3:	66 90                	xchg   %ax,%ax
c0206fd5:	66 90                	xchg   %ax,%ax
c0206fd7:	66 90                	xchg   %ax,%ax
c0206fd9:	66 90                	xchg   %ax,%ax
c0206fdb:	66 90                	xchg   %ax,%ax
c0206fdd:	66 90                	xchg   %ax,%ax
c0206fdf:	66 90                	xchg   %ax,%ax
c0206fe1:	66 90                	xchg   %ax,%ax
c0206fe3:	66 90                	xchg   %ax,%ax
c0206fe5:	66 90                	xchg   %ax,%ax
c0206fe7:	66 90                	xchg   %ax,%ax
c0206fe9:	66 90                	xchg   %ax,%ax
c0206feb:	66 90                	xchg   %ax,%ax
c0206fed:	66 90                	xchg   %ax,%ax
c0206fef:	66 90                	xchg   %ax,%ax
c0206ff1:	66 90                	xchg   %ax,%ax
c0206ff3:	66 90                	xchg   %ax,%ax
c0206ff5:	66 90                	xchg   %ax,%ax
c0206ff7:	66 90                	xchg   %ax,%ax
c0206ff9:	66 90                	xchg   %ax,%ax
c0206ffb:	66 90                	xchg   %ax,%ax
c0206ffd:	66 90                	xchg   %ax,%ax
c0206fff:	90                   	nop

Disassembly of section .text.__x86.get_pc_thunk.ax:

c0207000 <__x86.get_pc_thunk.ax>:
c0207000:	8b 04 24             	mov    (%esp),%eax
c0207003:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bx:

c0207004 <__x86.get_pc_thunk.bx>:
c0207004:	8b 1c 24             	mov    (%esp),%ebx
c0207007:	c3                   	ret    
